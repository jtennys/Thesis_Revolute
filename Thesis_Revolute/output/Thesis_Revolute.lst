0000: 80 7F    JMP   0x0080
0002: 30       HALT  
0003: 30       HALT  

FILE: .\boot.asm
                                   (0117) ; Generated by PSoC Designer 5.0.985.0
                                   (0118) ;
                                   (0119) ;@Id: boot.tpl#884 @
0004: 30       HALT                (0120) ;=============================================================================
0005: 30       HALT  
0006: 30       HALT  
0007: 30       HALT  
                                   (0121) ;  FILENAME:   boot.asm
                                   (0122) ;  VERSION:    1.00
                                   (0123) ;  DATE:       05 March 2009
0008: 7E       RETI                (0124) ;
0009: 30       HALT  
000A: 30       HALT  
000B: 30       HALT  
                                   (0125) ;  DESCRIPTION:
                                   (0126) ;  M8C Boot Code for CY8C28xxx microcontroller devices.
                                   (0127) ;
000C: 7E       RETI                (0128) ;  Copyright (C) Cypress Semiconductors 2009. All rights reserved.
000D: 30       HALT  
000E: 30       HALT  
000F: 30       HALT  
                                   (0129) ;
                                   (0130) ; NOTES:
                                   (0131) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
0010: 7E       RETI                (0132) ; the project's root directory to create BOOT.ASM. Any changes made to
0011: 30       HALT  
0012: 30       HALT  
0013: 30       HALT  
                                   (0133) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                   (0134) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                   (0135) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
0014: 7E       RETI                (0136) ; are not accidentally modified.
0015: 30       HALT  
0016: 30       HALT  
0017: 30       HALT  
                                   (0137) ;
                                   (0138) ;=============================================================================
                                   (0139) 
0018: 7E       RETI                (0140) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
0019: 30       HALT  
001A: 30       HALT  
001B: 30       HALT  
                                   (0141) include "m8c.inc"			;Part specific file
                                   (0142) include "m8ssc.inc"			;Part specific file
                                   (0143) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
001C: 7E       RETI                (0144) 
001D: 30       HALT  
001E: 30       HALT  
001F: 30       HALT  
                                   (0145) ;--------------------------------------
                                   (0146) ; Export Declarations
                                   (0147) ;--------------------------------------
0020: 7E       RETI                (0148) 
0021: 30       HALT  
0022: 30       HALT  
0023: 30       HALT  
                                   (0149) export __Start
                                   (0150) IF	(TOOLCHAIN & HITECH)
0024: 7D 31 96 LJMP  Dispatch_INTERRUPT_9(0151) ELSE
0027: 7E       RETI                (0152) export __bss_start
                                   (0153) export __data_start
                                   (0154) export __idata_start
0028: 7D 31 00 LJMP  Dispatch_INTERRUPT_10(0155) export __func_lit_start
002B: 7E       RETI                (0156) export __text_start
                                   (0157) ENDIF
                                   (0158) export  _bGetPowerSetting
002C: 7D 31 6C LJMP  Dispatch_INTERRUPT_11(0159) export   bGetPowerSetting	
002F: 7E       RETI                (0160) 
                                   (0161) 
                                   (0162) ;--------------------------------------
                                   (0163) ; Optimization flags
0030: 7E       RETI                (0164) ;--------------------------------------
0031: 30       HALT  
0032: 30       HALT  
0033: 30       HALT  
                                   (0165) ;
                                   (0166) ; To change the value of these flags, modify the file boot.tpl, not
                                   (0167) ; boot.asm. See the notes in the banner comment at the beginning of
0034: 7E       RETI                (0168) ; this file.
0035: 30       HALT  
0036: 30       HALT  
0037: 30       HALT  
                                   (0169) 
                                   (0170) ; Optimization for Assembly language (only) projects and C-language projects
0038: 7D 15 5D LJMP  0x155D        (0171) ; that do not depend on the C compiler to initialize the values of RAM variables.
003B: 7E       RETI                (0172) ;   Set to 1: Support for C Run-time Environment initialization
                                   (0173) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                   (0174) ;
003C: 7D 14 04 LJMP  0x1404        (0175) IF	(TOOLCHAIN & HITECH)
003F: 7E       RETI                (0176) ; The C compiler will customize the startup code - it's not required here
                                   (0177) 
                                   (0178) C_LANGUAGE_SUPPORT:              equ 0
                                   (0179) ELSE
0040: 7E       RETI                (0180) C_LANGUAGE_SUPPORT:              equ 1
0041: 30       HALT  
0042: 30       HALT  
0043: 30       HALT  
                                   (0181) ENDIF
                                   (0182) 
                                   (0183) 
0044: 7E       RETI                (0184) ; The following equate is required for proper operation. Reseting its value
0045: 30       HALT  
0046: 30       HALT  
0047: 30       HALT  
                                   (0185) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
                                   (0186) ; selected.  If the designer chooses to not wait then stabilization of the ECO
                                   (0187) ; and PLL_Lock must take place within user code. See the family data sheet for
0048: 7E       RETI                (0188) ; the requirements of starting the ECO and PLL lock mode.
0049: 30       HALT  
004A: 30       HALT  
004B: 30       HALT  
                                   (0189) ;
                                   (0190) ;   Set to 1: Wait for XTAL (& PLL if selected) to stabilize before
                                   (0191) ;                invoking main
004C: 7E       RETI                (0192) ;   Set to 0: Boot code does not wait; clock may not have stabilized by
004D: 30       HALT  
004E: 30       HALT  
004F: 30       HALT  
0050: 30       HALT  
0051: 30       HALT  
0052: 30       HALT  
0053: 30       HALT  
0054: 30       HALT  
0055: 30       HALT  
0056: 30       HALT  
0057: 30       HALT  
0058: 30       HALT  
0059: 30       HALT  
005A: 30       HALT  
005B: 30       HALT  
005C: 30       HALT  
005D: 30       HALT  
005E: 30       HALT  
005F: 30       HALT  
                                   (0193) ;               the time code in main starts executing.
                                   (0194) ;
                                   (0195) WAIT_FOR_32K:                    equ 1
0060: 7E       RETI                (0196) 
0061: 30       HALT  
0062: 30       HALT  
0063: 30       HALT  
                                   (0197) 
                                   (0198) 
                                   (0199) ; For historical reasons, by default the boot code uses an lcall instruction
0064: 7E       RETI                (0200) ; to invoke the user's _main code. If _main executes a return instruction,
0065: 30       HALT  
0066: 30       HALT  
0067: 30       HALT  
                                   (0201) ; boot provides an infinite loop. By changing the following equate from zero
                                   (0202) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                   (0203) ; bytes on the stack which are otherwise required for the return address. If
0068: 7E       RETI                (0204) ; this option is enabled, _main must not return. (Beginning with the 4.2
0069: 30       HALT  
006A: 30       HALT  
006B: 30       HALT  
                                   (0205) ; release, the C compiler automatically places an infinite loop at the end
                                   (0206) ; of main, rather than a return instruction.)
                                   (0207) ;
006C: 7E       RETI                (0208) ENABLE_LJMP_TO_MAIN:             equ 0
006D: 30       HALT  
006E: 30       HALT  
006F: 30       HALT  
                                   (0209) 
                                   (0210) 
                                   (0211) ;-----------------------------------------------------------------------------
0070: 7E       RETI                (0212) ; Interrupt Vector Table
0071: 30       HALT  
0072: 30       HALT  
0073: 30       HALT  
                                   (0213) ;-----------------------------------------------------------------------------
                                   (0214) ;
                                   (0215) ; Interrupt vector table entries are 4 bytes long.  Each one contains
0074: 7E       RETI                (0216) ; a jump instruction to an ISR (Interrupt Service Routine), although
0075: 30       HALT  
0076: 30       HALT  
0077: 30       HALT  
0078: 30       HALT  
0079: 30       HALT  
007A: 30       HALT  
007B: 30       HALT  
                                   (0217) ; very short ISRs could be encoded within the table itself. Normally,
                                   (0218) ; vector jump targets are modified automatically according to the user
                                   (0219) ; modules selected. This occurs when the 'Generate Application' opera-
007C: 7E       RETI                (0220) ; tion is run causing PSoC Designer to create boot.asm and the other
007D: 30       HALT  
007E: 30       HALT  
007F: 30       HALT  
                                   (0221) ; configuration files. If you need to hard code a vector, update the
                                   (0222) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                   (0223) ; of this file.
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) 
                                   (0226)     AREA TOP (ROM, ABS, CON)
                                   (0227) 
                                   (0228)     org   0                        ;Reset Interrupt Vector
                                   (0229) IF	(TOOLCHAIN & HITECH)
                                   (0230) ;   jmp   __Start                  ;C compiler fills in this vector
                                   (0231) ELSE
                                   (0232)     jmp   __Start                  ;First instruction executed following a Reset
                                   (0233) ENDIF
                                   (0234) 
                                   (0235)     org   04h                      ;Supply Monitor Interrupt Vector
                                   (0236)     halt                           ;Stop execution if power falls too low
                                   (0237) 
                                   (0238)     org   08h                      ;Analog Column 0 / Decimator 0 Interrupt Vector
                                   (0239)     // call	void_handler
0080: 71 10    OR    F,16          (0240)     reti
0082: 62 E3 87 MOV   REG[227],135  (0241) 
0085: 70 EF    AND   F,239         (0242)     org   0Ch                      ;Analog Column 1 / Decimator 1 Interrupt Vector
                                   (0243)     // call	void_handler
                                   (0244)     reti
                                   (0245) 
                                   (0246)     org   10h                      ;Analog Column 2 / Decimator 2 Interrupt Vector
                                   (0247)     // call	void_handler
                                   (0248)     reti
                                   (0249) 
                                   (0250)     org   14h                      ;Analog Column 3 / Decimator 3 Interrupt Vector
0087: 41 FE FB AND   REG[254],251  (0251)     // call	void_handler
                                   (0252)     reti
                                   (0253)     
                                   (0254)     org   18h                      ;VC3 Interrupt Vector
                                   (0255)     // call	void_handler
                                   (0256)     reti
                                   (0257) 
                                   (0258)     org   1Ch                      ;GPIO Interrupt Vector
                                   (0259)     // call	void_handler
                                   (0260)     reti
008A: 50 80    MOV   A,128         (0261) 
008C: 4E       SWAP  SP,A          (0262)     org   20h                      ;PSoC Block DBC00 Interrupt Vector
                                   (0263)     // call	void_handler
                                   (0264)     reti
                                   (0265) 
                                   (0266)     org   24h                      ;PSoC Block DBC01 Interrupt Vector
                                   (0267)     ljmp	Dispatch_INTERRUPT_9
                                   (0268)     reti
                                   (0269) 
                                   (0270)     org   28h                      ;PSoC Block DCC02 Interrupt Vector
                                   (0271)     ljmp	Dispatch_INTERRUPT_10
                                   (0272)     reti
                                   (0273) 
                                   (0274)     org   2Ch                      ;PSoC Block DCC03 Interrupt Vector
                                   (0275)     ljmp	Dispatch_INTERRUPT_11
                                   (0276)     reti
                                   (0277)     
                                   (0278)     org   30h                      ;PSoC Block DBC10 Interrupt Vector
                                   (0279)     // call	void_handler
                                   (0280)     reti
                                   (0281) 
                                   (0282)     org   34h                      ;PSoC Block DBC11 Interrupt Vector
                                   (0283)     // call	void_handler
                                   (0284)     reti
                                   (0285) 
                                   (0286)     org   38h                      ;PSoC Block DCC12 Interrupt Vector
                                   (0287)     ljmp	_HELLO_3_ISR
                                   (0288)     reti
                                   (0289) 
                                   (0290)     org   3Ch                      ;PSoC Block DCC13 Interrupt Vector
                                   (0291)     ljmp	_HELLO_4_ISR
                                   (0292)     reti
                                   (0293) 
008D: 55 F8 00 MOV   [248],0       (0294) 	org   40h                      ;PSoC Block DBC20 Interrupt Vector
0090: 55 F9 00 MOV   [249],0       (0295)     // call	void_handler
                                   (0296)     reti
                                   (0297) 	
                                   (0298) 	org   44h                      ;PSoC Block DBC21 Interrupt Vector
                                   (0299)     // call	void_handler
                                   (0300)     reti
                                   (0301) 	
                                   (0302) 	org   48h                      ;PSoC Block DCC22 Interrupt Vector
                                   (0303)     // call	void_handler
                                   (0304)     reti
                                   (0305) 	
                                   (0306) 	org   4Ch                      ;PSoC Block DCC23 Interrupt Vector
                                   (0307)     // call	void_handler
                                   (0308)     reti
                                   (0309) 	 
                                   (0310)     org   60h                      ;PSoC I2C0 Interrupt Vector
                                   (0311)     // call	void_handler
                                   (0312)     reti
                                   (0313) 
                                   (0314) 	org   64h                      ;PSoC I2C1 Interrupt Vector
                                   (0315)     // call	void_handler
                                   (0316)     reti
                                   (0317) 	
0093: 71 10    OR    F,16          (0318) 	org   68h                      ;PSoC SARADC Interrupt Vector
0095: 62 E0 02 MOV   REG[224],2    (0319)     // call	void_handler
0098: 70 EF    AND   F,239         (0320)     reti
009A: 62 E3 38 MOV   REG[227],56   (0321) 	
                                   (0322) 	org   6Ch                      ;PSoC RTC Interrupt Vector
                                   (0323)     // call	void_handler
                                   (0324)     reti
                                   (0325) 	
                                   (0326) 	org   70h                      ;Analog Column 4 Interrupt Vector
                                   (0327)     // call	void_handler
                                   (0328)     reti
                                   (0329) 	
                                   (0330) 	org   74h                      ;Analog Column 5 Interrupt Vector
                                   (0331)     // call	void_handler
                                   (0332)     reti
                                   (0333) 	
                                   (0334)     org   7Ch                      ;Sleep Timer Interrupt Vector
                                   (0335)     // call	void_handler
                                   (0336)     reti
                                   (0337) 
                                   (0338) ;-----------------------------------------------------------------------------
                                   (0339) ;  Start of Execution.
                                   (0340) ;-----------------------------------------------------------------------------
                                   (0341) ;  The Supervisory ROM SWBootReset function has already completed the
                                   (0342) ;  calibrate1 process, loading trim values for 5 volt operation.
                                   (0343) ;
                                   (0344) 
                                   (0345) IF	(TOOLCHAIN & HITECH)
                                   (0346)  	AREA PD_startup(CODE, REL, CON)
                                   (0347) ELSE
                                   (0348)     org 80h
                                   (0349) ENDIF
                                   (0350) __Start:
                                   (0351) 
009D: 62 71 05 MOV   REG[113],5    (0352)     ; initialize SMP values for voltage stabilization, if required,
00A0: 62 72 05 MOV   REG[114],5    (0353)     ; leaving power-on reset (POR) level at the default (low) level, at
00A3: 62 73 05 MOV   REG[115],5    (0354)     ; least for now. 
00A6: 62 74 05 MOV   REG[116],5    (0355)     ;
                                   (0356)     M8C_SetBank1
                                   (0357)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
                                   (0358)     M8C_SetBank0
                                   (0359) 
                                   (0360) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                   (0361)     M8C_EnableWatchDog
                                   (0362) ENDIF
                                   (0363) 
                                   (0364) IF ( SELECT_32K )
                                   (0365)     or   reg[CPU_SCR1],  CPU_SCR1_ECO_ALLOWED  ; ECO will be used in this project
                                   (0366) ELSE
                                   (0367)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                   (0368) ENDIF
                                   (0369) 
                                   (0370)     ;---------------------------
                                   (0371)     ; Set up the Temporary stack
                                   (0372)     ;---------------------------
                                   (0373)     ; A temporary stack is set up for the SSC instructions.
                                   (0374)     ; The real stack start will be assigned later.
                                   (0375)     ;
                                   (0376) _stack_start:          equ 80h
                                   (0377)     mov   A, _stack_start          ; Set top of stack to end of used RAM
                                   (0378)     swap  SP, A                    ; This is only temporary if going to LMM
                                   (0379) 
                                   (0380)     ;------------------------
                                   (0381)     ; Set Power-related Trim 
                                   (0382)     ;------------------------
                                   (0383) 
00A9: 62 D1 03 MOV   REG[209],3    (0384) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
00AC: 50 00    MOV   A,0           (0385)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
00AE: 4E       SWAP  SP,A          (0386)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
00AF: 62 D3 03 MOV   REG[211],3    (0387)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
00B2: 62 D0 00 MOV   REG[208],0    (0388) ELSE
00B5: 62 D5 00 MOV   REG[213],0    (0389) 	IF ( AGND_BYPASS )
00B8: 62 D4 00 MOV   REG[212],0    (0390)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0391)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                   (0392)     ; bit in the write-only BDG_TR register. Recalculate the register
00BB: 71 C0    OR    F,192         (0393)     ; value using the proper trim values.
                                   (0394)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0395)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                   (0396)   ENDIF
                                   (0397)  ENDIF
                                   (0398) ENDIF ; 5.0 V Operation
                                   (0399) 
                                   (0400) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                   (0401)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                   (0402)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                   (0403)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                   (0404)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                   (0405)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                   (0406)  ENDIF
                                   (0407) ENDIF ; 3.3 Volt Operation
                                   (0408) 
                                   (0409) 
                                   (0410)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
00BD: 7C 06 92 LCALL 0x0692        (0411)     mov  [bSSC_KEYSP], 0
00C0: 70 EF    AND   F,239         (0412) 
                                   (0413)     ;---------------------------------------
                                   (0414)     ; Initialize Crystal Oscillator and PLL
                                   (0415)     ;---------------------------------------
                                   (0416) IF ( SELECT_32K & WAIT_FOR_32K )
                                   (0417)     ; If the user has requested the External Crystal Oscillator (ECO) then turn it
                                   (0418)     ; on and wait for it to stabilize and the system to switch over to it. The PLL
                                   (0419)     ; is left off.  The SleepTimer period is set to 1 sec to time the wait for
                                   (0420)     ; the ECO to stabilize.
                                   (0421)     ;
                                   (0422)     M8C_SetBank1
                                   (0423)     mov   reg[OSC_CR0], (SELECT_32K_JUST | OSC_CR0_SLEEP_1Hz | OSC_CR0_CPU_12MHz)
                                   (0424)     M8C_SetBank0
                                   (0425)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get a full second
                                   (0426)     or    reg[INT_MSK0], INT_MSK0_SLEEP   ; Enable latching of SleepTimer interrupt
                                   (0427)     mov   reg[INT_VC],   0                ; Clear all pending interrupts
                                   (0428) .WaitFor1s:
                                   (0429)     tst   reg[INT_CLR0], INT_MSK0_SLEEP   ; Test the SleepTimer Interrupt Status
                                   (0430)     jz   .WaitFor1s                       ; Interrupt will latch but will not dispatch
                                   (0431)                                           ;  since interrupts are not globally enabled
                                   (0432) ELSE ; !( SELECT_32K & WAIT_FOR_32K )
                                   (0433)     ; Either no ECO, or waiting for stable clock is to be done in main
                                   (0434)     M8C_SetBank1
                                   (0435)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
                                   (0436)     M8C_SetBank0
                                   (0437)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                   (0438) 
                                   (0439) ENDIF ;( SELECT_32K & WAIT_FOR_32K )
                                   (0440) 
                                   (0441) IF ( PLL_MODE )
                                   (0442)     ; Crystal is now fully operational (assuming WAIT_FOR_32K was enabled).
                                   (0443)     ; Now start up PLL if selected, and wait 16 msec for it to stabilize.
00C2: 62 D0 00 MOV   REG[208],0    (0444)     ;
                                   (0445)     M8C_SetBank1
                                   (0446)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_3MHz)
                                   (0447)     M8C_SetBank0
                                   (0448)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get full period
                                   (0449)     mov   reg[INT_VC], 0                  ; Clear all pending interrupts
                                   (0450) 
00C5: 50 06    MOV   A,6           (0451) .WaitFor16ms:
00C7: 57 90    MOV   X,144         (0452)     tst   reg[INT_CLR0],INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
00C9: 08       PUSH  A             (0453)     jz   .WaitFor16ms
00CA: 28       ROMX                (0454)     M8C_SetBank1                          ; continue boot at CPU Speed of SYSCLK/2
00CB: 53 CC    MOV   [__r0],A      (0455)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_12MHz)
00CD: 18       POP   A             (0456)     M8C_SetBank0
00CE: 75       INC   X             (0457) 
00CF: 09 00    ADC   A,0           (0458) IF      ( WAIT_FOR_32K )
00D1: 28       ROMX                (0459) ELSE ; !( WAIT_FOR_32K )
00D2: 4B       SWAP  A,X           (0460)     ; Option settings (PLL-Yes, ECO-No) are incompatible - force a syntax error
00D3: 51 CC    MOV   A,[204]       (0461)     ERROR_PSoC Disabling WAIT_FOR_32K requires that the PLL_Lock must be enabled in user code.
                                   (0462) ENDIF ;(WAIT_FOR_32K)
00D5: 80 04    JMP   0x00DA        (0463) ENDIF ;(PLL_MODE)
                                   (0464) 
                                   (0465)     ;------------------------
                                   (0466)     ; Close CT leakage path.
                                   (0467)     ;------------------------
                                   (0468)     mov   reg[0x71], 05h
                                   (0469)     mov   reg[0x72], 05h
                                   (0470)     mov   reg[0x73], 05h
                                   (0471)     mov   reg[0x74], 05h
                                   (0472) 
                                   (0473) 
                                   (0474) 
                                   (0475) IF	(TOOLCHAIN & HITECH)
                                   (0476)     ;---------------------------------------------
                                   (0477)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                   (0478)     ;---------------------------------------------
                                   (0479) 	global		__Lstackps
                                   (0480) 	mov     a,low __Lstackps
00D7: 75       INC   X             (0481) 	swap    a,sp
00D8: 09 00    ADC   A,0           (0482) 
                                   (0483) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                   (0484)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                   (0485)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                   (0486)     RAM_SETPAGE_CUR 0
00DA: 62 E3 00 MOV   REG[227],0    (0487)     RAM_SETPAGE_MVW 0
00DD: 08       PUSH  A             (0488)     RAM_SETPAGE_MVR 0
00DE: 28       ROMX                (0489)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
00DF: 60 D5    MOV   REG[213],A    (0490)       or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
00E1: 74       INC   A             (0491)     ELSE
00E2: A0 4B    JZ    0x012E        (0492)       or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
00E4: 18       POP   A             (0493)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
00E5: 75       INC   X             (0494) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
00E6: 09 00    ADC   A,0           (0495) ELSE
00E8: 08       PUSH  A             (0496)     ;---------------------------------------------
00E9: 28       ROMX                (0497)     ; ImageCraft Enter the Large Memory Model, if applicable
00EA: 53 CC    MOV   [__r0],A      (0498)     ;---------------------------------------------
00EC: 18       POP   A             (0499) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00ED: 75       INC   X             (0500)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
00EE: 09 00    ADC   A,0           (0501)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
00F0: 08       PUSH  A             (0502)     swap  A, SP
00F1: 28       ROMX                (0503)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
00F2: A0 1C    JZ    0x010F        (0504)     RAM_SETPAGE_CUR 0
00F4: 53 CB    MOV   [__r1],A      (0505)     RAM_SETPAGE_MVW 0
00F6: 18       POP   A             (0506)     RAM_SETPAGE_MVR 0
                                   (0507) 
                                   (0508)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                   (0509)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                   (0510)   ELSE
                                   (0511)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                   (0512)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                   (0513) ELSE
00F7: 75       INC   X             (0514)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
00F8: 09 00    ADC   A,0           (0515)     swap  SP, A
00FA: 08       PUSH  A             (0516) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
00FB: 28       ROMX                (0517) ENDIF ;	TOOLCHAIN
00FC: 3F CC    MVI   [__r0],A      (0518) 
00FE: 47 CC FF TST   [204],255     (0519)     ;-------------------------
0101: B0 06    JNZ   0x0108        (0520)     ; Load Base Configuration
0103: 5D D5    MOV   A,REG[213]    (0521)     ;-------------------------
0105: 74       INC   A             (0522)     ; Load global parameter settings and load the user modules in the
0106: 60 D5    MOV   REG[213],A    (0523)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                   (0524)     ; to minimize start up time; (2) We may still need to play with the
0108: 18       POP   A             (0525)     ; Sleep Timer.
0109: 7A CB    DEC   [__r1]        (0526)     ;
010B: BF EB    JNZ   0x00F7        (0527)     lcall LoadConfigInit
010D: 8F C9    JMP   0x00D7        (0528)     M8C_SetBank0
                                   (0529) 
                                   (0530)     ;-----------------------------------
010F: 18       POP   A             (0531)     ; Initialize C Run-Time Environment
0110: 75       INC   X             (0532)     ;-----------------------------------
0111: 09 00    ADC   A,0           (0533) IF ( C_LANGUAGE_SUPPORT )
0113: 08       PUSH  A             (0534) IF ( SYSTEM_SMALL_MEMORY_MODEL )
0114: 28       ROMX                (0535)     mov  A,0                           ; clear the 'bss' segment to zero
0115: 53 CB    MOV   [__r1],A      (0536)     mov  [__r0],<__bss_start
0117: 50 00    MOV   A,0           (0537) BssLoop:
                                   (0538)     cmp  [__r0],<__bss_end
                                   (0539)     jz   BssDone
                                   (0540)     mvi  [__r0],A
                                   (0541)     jmp  BssLoop
                                   (0542) BssDone:
0119: 3F CC    MVI   [__r0],A      (0543)     mov  A,>__idata_start              ; copy idata to data segment
011B: 47 CC FF TST   [204],255     (0544)     mov  X,<__idata_start
011E: B0 08    JNZ   0x0127        (0545)     mov  [__r0],<__data_start
0120: 5D D5    MOV   A,REG[213]    (0546) IDataLoop:
0122: 74       INC   A             (0547)     cmp  [__r0],<__data_end
0123: 60 D5    MOV   REG[213],A    (0548)     jz   C_RTE_Done
0125: 50 00    MOV   A,0           (0549)     push A
                                   (0550)     romx
0127: 7A CB    DEC   [__r1]        (0551)     mvi  [__r0],A
0129: BF EF    JNZ   0x0119        (0552)     pop  A
012B: 18       POP   A             (0553)     inc  X
012C: 8F AA    JMP   0x00D7        (0554)     adc  A,0
                                   (0555)     jmp  IDataLoop
                                   (0556) 
012E: 18       POP   A             (0557) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                   (0558) 
                                   (0559) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                   (0560)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                   (0561)                                        ; to use the Virtual Register page.
                                   (0562) 
                                   (0563)     ; Dereference the constant (flash) pointer pXIData to access the start
                                   (0564)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                   (0565)     ; text segment and may have been relocated by the Code Compressor.
                                   (0566)     ;
                                   (0567)     mov   A, >__pXIData                ; Get the address of the flash
                                   (0568)     mov   X, <__pXIData                ;   pointer to the xidata area.
                                   (0569)     push  A
                                   (0570)     romx                               ; get the MSB of xidata's address
                                   (0571)     mov   [__r0], A
                                   (0572)     pop   A
                                   (0573)     inc   X
                                   (0574)     adc   A, 0
                                   (0575)     romx                               ; get the LSB of xidata's address
                                   (0576)     swap  A, X
                                   (0577)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                   (0578)                                        ;   XIData structure list in flash
                                   (0579)     jmp   .AccessStruct
                                   (0580) 
                                   (0581)     ; Unpack one element in the xidata "structure list" that specifies the
                                   (0582)     ; values of C variables. Each structure contains 3 member elements.
                                   (0583)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                   (0584)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                   (0585)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                   (0586)     ; contains 0xFF. There are two formats for the struct depending on the
                                   (0587)     ; value in the second member element, an unsigned byte:
                                   (0588)     ; (1) If the value of the second element is non-zero, it represents
                                   (0589)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                   (0590)     ; third member of the struct is an array of bytes of length 'size' and
                                   (0591)     ; the bytes are copied to the block of RAM.
                                   (0592)     ; (2) If the value of the second element is zero, the block of RAM is
                                   (0593)     ; to be cleared to zero. In this case, the third member of the struct
                                   (0594)     ; is an unsigned byte containing the number of bytes to clear.
                                   (0595) 
                                   (0596) .AccessNextStructLoop:
                                   (0597)     inc   X                            ; pXIData++
                                   (0598)     adc   A, 0
                                   (0599) .AccessStruct:                         ; Entry point for first block
                                   (0600)     ;
                                   (0601)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                   (0602)     ;
                                   (0603)     M8C_ClearWDT                       ; Clear the watchdog for long inits
                                   (0604)     push  A
                                   (0605)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
                                   (0606)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
                                   (0607)     inc   A                            ; End of Struct List? (MSB==0xFF?)
                                   (0608)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
                                   (0609)     pop   A                            ; restore pXIData to [A,X]
                                   (0610)     inc   X                            ; pXIData++
                                   (0611)     adc   A, 0
012F: 71 10    OR    F,16          (0612)     push  A
                                   (0613)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
                                   (0614)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
                                   (0615)     pop   A                            ; restore pXIData to [A,X]
                                   (0616)     inc   X                            ; pXIData++ (point to size)
                                   (0617)     adc   A, 0
                                   (0618)     push  A
                                   (0619)     romx                               ; Get the size (CPU.A <- *pXIData)
0131: 43 E3 20 OR    REG[227],32   (0620)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
                                   (0621)     mov   [__r1], A                    ;             else downcount in __r1
                                   (0622)     pop   A                            ; restore pXIData to [A,X]
                                   (0623) 
                                   (0624) .CopyNextByteLoop:
0134: 70 EF    AND   F,239         (0625)     ; For each byte in the structure's array member, copy from flash to RAM.
                                   (0626)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                   (0627)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                   (0628)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                   (0629)     ;
                                   (0630)     inc   X                            ; pXIData++ (point to next data byte)
                                   (0631)     adc   A, 0
                                   (0632)     push  A
                                   (0633)     romx                               ; Get the data value (CPU.A <- *pXIData)
0136: 62 E0 00 MOV   REG[224],0    (0634)     mvi   [__r0], A                    ; Transfer the data to RAM
                                   (0635)     tst   [__r0], 0xff                 ; Check for page crossing
                                   (0636)     jnz   .CopyLoopTail                ;   No crossing, keep going
                                   (0637)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
0139: 71 10    OR    F,16          (0638)     inc   A
013B: 62 E0 03 MOV   REG[224],3    (0639)     mov   reg[ MVW_PP], A
013E: 43 E2 00 OR    REG[226],0    (0640) .CopyLoopTail:
0141: 70 EF    AND   F,239         (0641)     pop   A                            ; restore pXIData to [A,X]
                                   (0642)     dec   [__r1]                       ; End of this array in flash?
                                   (0643)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
                                   (0644)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                   (0645) 
                                   (0646) .ClearRAMBlockToZero:
0143: 62 E2 00 MOV   REG[226],0    (0647)     pop   A                            ; restore pXIData to [A,X]
                                   (0648)     inc   X                            ; pXIData++ (point to next data byte)
                                   (0649)     adc   A, 0
                                   (0650)     push  A
                                   (0651)     romx                               ; Get the run length (CPU.A <- *pXIData)
                                   (0652)     mov   [__r1], A                    ; Initialize downcounter
                                   (0653)     mov   A, 0                         ; Initialize source data
                                   (0654) 
0146: 7C 20 4C LCALL _main         (0655) .ClearRAMBlockLoop:
                                   (0656)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
0149: 8F FF    JMP   0x0149        (0657)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                   (0658)     ;
                                   (0659)     mvi   [__r0], A                    ; Clear a byte
                                   (0660)     tst   [__r0], 0xff                 ; Check for page crossing
                                   (0661)     jnz   .ClearLoopTail               ;   No crossing, keep going
                                   (0662)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
                                   (0663)     inc   A
                                   (0664)     mov   reg[ MVW_PP], A
                                   (0665)     mov   A, 0                         ; Restore the zero used for clearing
                                   (0666) .ClearLoopTail:
                                   (0667)     dec   [__r1]                       ; Was this the last byte?
                                   (0668)     jnz   .ClearRAMBlockLoop           ;   No,  continue
                                   (0669)     pop   A                            ;   Yes, restore pXIData to [A,X] and
                                   (0670)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                   (0671) 
                                   (0672) .C_RTE_WrapUp:
014B: 50 10    MOV   A,16          (0673)     pop   A                            ; balance stack
                                   (0674) 
0530: 71 10    OR    F,16          (0675) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL

FILE: lib\psocconfigtbl.asm
0532: 62 00 1E MOV   REG[0],30     (0812) ; Generated by PSoC Designer 5.0.985.0
0535: 62 01 E1 MOV   REG[1],225    (0813) ;
0538: 70 EF    AND   F,239         (0814) include "m8c.inc"
053A: 62 03 E0 MOV   REG[3],224    (0815) ;  Personalization tables 
053D: 62 02 1F MOV   REG[2],31     (0816) export LoadConfigTBL_waiting_Bank1
0540: 71 10    OR    F,16          (0817) export LoadConfigTBL_waiting_Bank0
0542: 62 02 00 MOV   REG[2],0      (0818) export LoadConfigTBL_waiting_Ordered
0545: 62 03 00 MOV   REG[3],0      (0819) export UnloadConfigTBL_waiting_Bank1
0548: 70 EF    AND   F,239         (0820) export UnloadConfigTBL_waiting_Bank0
054A: 62 01 00 MOV   REG[1],0      (0821) export ReloadConfigTBL_waiting_Bank1
054D: 71 10    OR    F,16          (0822) export ReloadConfigTBL_waiting_Bank0
054F: 62 04 00 MOV   REG[4],0      (0823) export LoadConfigTBL_hello_Bank1
0552: 62 05 FF MOV   REG[5],255    (0824) export LoadConfigTBL_hello_Bank0
0555: 70 EF    AND   F,239         (0825) export UnloadConfigTBL_hello_Bank1
0557: 62 07 FF MOV   REG[7],255    (0826) export UnloadConfigTBL_hello_Bank0
055A: 62 06 00 MOV   REG[6],0      (0827) export LoadConfigTBL_initial_Bank1
055D: 71 10    OR    F,16          (0828) export LoadConfigTBL_initial_Bank0
055F: 62 06 00 MOV   REG[6],0      (0829) export UnloadConfigTBL_initial_Bank1
0562: 62 07 00 MOV   REG[7],0      (0830) export UnloadConfigTBL_initial_Bank0
0565: 70 EF    AND   F,239         (0831) export LoadConfigTBL_my_response_Bank1
0567: 62 05 00 MOV   REG[5],0      (0832) export LoadConfigTBL_my_response_Bank0
056A: 71 10    OR    F,16          (0833) export UnloadConfigTBL_my_response_Bank1
056C: 62 08 00 MOV   REG[8],0      (0834) export UnloadConfigTBL_my_response_Bank0
056F: 62 09 FF MOV   REG[9],255    (0835) export LoadConfigTBL_response1_Bank1
0572: 70 EF    AND   F,239         (0836) export LoadConfigTBL_response1_Bank0
0574: 62 0B FF MOV   REG[11],255   (0837) export UnloadConfigTBL_response1_Bank1
0577: 62 0A 00 MOV   REG[10],0     (0838) export UnloadConfigTBL_response1_Bank0
057A: 71 10    OR    F,16          (0839) export LoadConfigTBL_response2_Bank1
057C: 62 0A 00 MOV   REG[10],0     (0840) export LoadConfigTBL_response2_Bank0
057F: 62 0B 00 MOV   REG[11],0     (0841) export UnloadConfigTBL_response2_Bank1
0582: 70 EF    AND   F,239         (0842) export UnloadConfigTBL_response2_Bank0
0584: 62 09 00 MOV   REG[9],0      (0843) export LoadConfigTBL_response3_Bank1
0587: 71 10    OR    F,16          (0844) export LoadConfigTBL_response3_Bank0
0589: 62 0C 00 MOV   REG[12],0     (0845) export UnloadConfigTBL_response3_Bank1
058C: 62 0D 00 MOV   REG[13],0     (0846) export UnloadConfigTBL_response3_Bank0
058F: 70 EF    AND   F,239         (0847) export LoadConfigTBL_response4_Bank1
0591: 62 0F 00 MOV   REG[15],0     (0848) export LoadConfigTBL_response4_Bank0
0594: 62 0E 00 MOV   REG[14],0     (0849) export UnloadConfigTBL_response4_Bank1
0597: 71 10    OR    F,16          (0850) export UnloadConfigTBL_response4_Bank0
0599: 62 0E 00 MOV   REG[14],0     (0851) export LoadConfigTBL_servo_transmit_Bank1
059C: 62 0F 00 MOV   REG[15],0     (0852) export LoadConfigTBL_servo_transmit_Bank0
059F: 70 EF    AND   F,239         (0853) export UnloadConfigTBL_servo_transmit_Bank1
05A1: 62 0D 00 MOV   REG[13],0     (0854) export UnloadConfigTBL_servo_transmit_Bank0
05A4: 71 10    OR    F,16          (0855) export UnloadConfigTBL_Total_Bank1
05A6: 62 10 00 MOV   REG[16],0     (0856) export UnloadConfigTBL_Total_Bank0
05A9: 62 11 00 MOV   REG[17],0     (0857) AREA lit(rom, rel)
05AC: 70 EF    AND   F,239         (0858) LoadConfigTBL_hello_Bank0:
05AE: 62 13 00 MOV   REG[19],0     (0859) ;  Instance name HELLO_1, User Module RX8
05B1: 62 12 00 MOV   REG[18],0     (0860) ;       Instance name HELLO_1, Block Name RX8(DCC02)
05B4: 71 10    OR    F,16          (0861) 	db		2bh, 00h		;HELLO_1_CONTROL_REG  (DCC02CR0)
05B6: 62 12 00 MOV   REG[18],0     (0862) 	db		29h, 00h		;HELLO_1_(DCC02DR1)
05B9: 62 13 00 MOV   REG[19],0     (0863) 	db		2ah, 00h		;HELLO_1_RX_BUFFER_REG(DCC02DR2)
05BC: 70 EF    AND   F,239         (0864) ;  Instance name HELLO_2, User Module RX8
05BE: 62 11 00 MOV   REG[17],0     (0865) ;       Instance name HELLO_2, Block Name RX8(DCC03)
05C1: 62 15 00 MOV   REG[21],0     (0866) 	db		2fh, 00h		;HELLO_2_CONTROL_REG  (DCC03CR0)
05C4: 62 16 00 MOV   REG[22],0     (0867) 	db		2dh, 00h		;HELLO_2_(DCC03DR1)
05C7: 62 17 00 MOV   REG[23],0     (0868) 	db		2eh, 00h		;HELLO_2_RX_BUFFER_REG(DCC03DR2)
05CA: 71 10    OR    F,16          (0869) ;  Instance name HELLO_3, User Module RX8
05CC: 62 15 00 MOV   REG[21],0     (0870) ;       Instance name HELLO_3, Block Name RX8(DCC12)
05CF: 62 14 00 MOV   REG[20],0     (0871) 	db		3bh, 00h		;HELLO_3_CONTROL_REG  (DCC12CR0)
05D2: 62 16 00 MOV   REG[22],0     (0872) 	db		39h, 00h		;HELLO_3_(DCC12DR1)
05D5: 62 17 00 MOV   REG[23],0     (0873) 	db		3ah, 00h		;HELLO_3_RX_BUFFER_REG(DCC12DR2)
0692: 62 D0 00 MOV   REG[208],0    (0874) ;  Instance name HELLO_4, User Module RX8

FILE: lib\psocconfig.asm
0695: 55 04 00 MOV   [4],0         (0098) ; Generated by PSoC Designer 5.0.985.0
0698: 55 05 00 MOV   [5],0         (0099) ;
                                   (0100) INCLUDE "PSoCDynamic.inc"
069B: 7C 06 A2 LCALL 0x06A2        (0101) ;==========================================================================
069E: 7C 05 30 LCALL 0x0530        (0102) ;  PSoCConfig.asm
                                   (0103) ;  @PSOC_VERSION
                                   (0104) ;
                                   (0105) ;  Version: 0.85
06A1: 7F       RET                 (0106) ;  Revised: June 22, 2004
                                   (0107) ;  Copyright Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0108) ;
                                   (0109) ;  This file is generated by the Device Editor on Application Generation.
                                   (0110) ;  It contains code which loads the configuration data table generated in
                                   (0111) ;  the file PSoCConfigTBL.asm
                                   (0112) ;
                                   (0113) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0114) ;  Edits to this file will not be preserved.
                                   (0115) ;==========================================================================
                                   (0116) ;
                                   (0117) include "m8c.inc"
                                   (0118) include "memory.inc"
                                   (0119) include "GlobalParams.inc"
                                   (0120) 
                                   (0121) export LoadConfigInit
                                   (0122) export _LoadConfigInit
                                   (0123) export LoadConfig_waiting
                                   (0124) export _LoadConfig_waiting
                                   (0125) export UnloadConfig_waiting
                                   (0126) export _UnloadConfig_waiting
                                   (0127) export ReloadConfig_waiting
                                   (0128) export _ReloadConfig_waiting
                                   (0129) export LoadConfig_hello
06A2: 71 10    OR    F,16          (0130) export _LoadConfig_hello
                                   (0131) export UnloadConfig_hello
06A4: 10       PUSH  X             (0132) export _UnloadConfig_hello
06A5: 70 EF    AND   F,239         (0133) export LoadConfig_initial
06A7: 50 00    MOV   A,0           (0134) export _LoadConfig_initial
06A9: 67       ASR   A             (0135) export UnloadConfig_initial
                                   (0136) export _UnloadConfig_initial
06AA: 50 04    MOV   A,4           (0137) export LoadConfig_my_response
06AC: 57 28    MOV   X,40          (0138) export _LoadConfig_my_response
06AE: 7C 0C 0E LCALL 0x0C0E        (0139) export UnloadConfig_my_response
                                   (0140) export _UnloadConfig_my_response
06B1: 50 01    MOV   A,1           (0141) export LoadConfig_response1
06B3: 67       ASR   A             (0142) export _LoadConfig_response1
                                   (0143) export UnloadConfig_response1
06B4: 50 04    MOV   A,4           (0144) export _UnloadConfig_response1
06B6: 57 97    MOV   X,151         (0145) export LoadConfig_response2
06B8: 7C 0C 0E LCALL 0x0C0E        (0146) export _LoadConfig_response2
                                   (0147) export UnloadConfig_response2
06BB: 62 D0 00 MOV   REG[208],0    (0148) export _UnloadConfig_response2
                                   (0149) export LoadConfig_response3
06BE: 2E 04 01 OR    [4],1         (0150) export _LoadConfig_response3
06C1: 70 EF    AND   F,239         (0151) export UnloadConfig_response3
06C3: 20       POP   X             (0152) export _UnloadConfig_response3
                                   (0153) export LoadConfig_response4
                                   (0154) export _LoadConfig_response4
06C4: 7F       RET                 (0155) export UnloadConfig_response4
                                   (0156) export _UnloadConfig_response4
                                   (0157) export LoadConfig_servo_transmit
                                   (0158) export _LoadConfig_servo_transmit
                                   (0159) export UnloadConfig_servo_transmit
                                   (0160) export _UnloadConfig_servo_transmit
                                   (0161) export UnloadConfig_Total
                                   (0162) export _UnloadConfig_Total
                                   (0163) export ACTIVE_CONFIG_STATUS
                                   (0164) 
                                   (0165) export NO_SHADOW
                                   (0166) export _NO_SHADOW
                                   (0167) 
                                   (0168) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                   (0169) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                   (0170) 
                                   (0171) AREA psoc_config(rom, rel)
                                   (0172) 
                                   (0173) ;---------------------------------------------------------------------------
                                   (0174) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                   (0175) ;                  parameters handled by boot code, like CPU speed). This
                                   (0176) ;                  function can be called from user code, but typically it
                                   (0177) ;                  is only called from boot.
                                   (0178) ;
                                   (0179) ;       INPUTS: None.
06C5: 10       PUSH  X             (0180) ;      RETURNS: Nothing.
06C6: 70 EF    AND   F,239         (0181) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
06C8: 50 00    MOV   A,0           (0182) ;               In the large memory model currently only the page
06CA: 67       ASR   A             (0183) ;               pointer registers listed below are modified.  This does
                                   (0184) ;               not guarantee that in future implementations of this
06CB: 50 05    MOV   A,5           (0185) ;               function other page pointer registers will not be
06CD: 57 D9    MOV   X,217         (0186) ;               modified.
06CF: 7C 0C 0E LCALL 0x0C0E        (0187) ;          
                                   (0188) ;               Page Pointer Registers Modified: 
06D2: 50 01    MOV   A,1           (0189) ;               CUR_PP
06D4: 67       ASR   A             (0190) ;
                                   (0191) _LoadConfigInit:
06D5: 50 05    MOV   A,5           (0192)  LoadConfigInit:
06D7: 57 E6    MOV   X,230         (0193)     RAM_PROLOGUE RAM_USE_CLASS_4
06D9: 7C 0C 0E LCALL 0x0C0E        (0194)     RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0195) 	mov		[ACTIVE_CONFIG_STATUS], 0
                                   (0196) 	mov		[ACTIVE_CONFIG_STATUS+1], 0
06DC: 62 D0 00 MOV   REG[208],0    (0197) 
06DF: 2E 04 01 OR    [4],1         (0198) 	lcall	LoadConfig_waiting
06E2: 70 EF    AND   F,239         (0199) 	lcall	LoadConfigTBL_waiting_Ordered
06E4: 20       POP   X             (0200) 
                                   (0201) 
                                   (0202)     RAM_EPILOGUE RAM_USE_CLASS_4
06E5: 7F       RET                 (0203)     ret
                                   (0204) 
                                   (0205) ;---------------------------------------------------------------------------
                                   (0206) ; Load Configuration waiting
                                   (0207) ;
                                   (0208) ;    Load configuration registers for waiting.
                                   (0209) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0210) ;
                                   (0211) ;       INPUTS: None.
                                   (0212) ;      RETURNS: Nothing.
                                   (0213) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0214) ;               modified as may the Page Pointer registers!
                                   (0215) ;               In the large memory model currently only the page
                                   (0216) ;               pointer registers listed below are modified.  This does
                                   (0217) ;               not guarantee that in future implementations of this
                                   (0218) ;               function other page pointer registers will not be
                                   (0219) ;               modified.
                                   (0220) ;          
                                   (0221) ;               Page Pointer Registers Modified: 
                                   (0222) ;               CUR_PP
                                   (0223) ;
                                   (0224) _LoadConfig_waiting:
                                   (0225)  LoadConfig_waiting:
                                   (0226)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0227) 	M8C_SetBank1
                                   (0228) 
06E6: 10       PUSH  X             (0229) 	push	x
06E7: 70 EF    AND   F,239         (0230)     M8C_SetBank0                    ; Force bank 0
06E9: 50 00    MOV   A,0           (0231)     mov     a, 0                    ; Specify bank 0
06EB: 67       ASR   A             (0232)     asr     a                       ; Store in carry flag
                                   (0233)                                     ; Load bank 0 table:
06EC: 50 05    MOV   A,5           (0234)     mov     A, >LoadConfigTBL_waiting_Bank0
06EE: 57 F7    MOV   X,247         (0235)     mov     X, <LoadConfigTBL_waiting_Bank0
06F0: 7C 0C 0E LCALL 0x0C0E        (0236)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0237) 
06F3: 50 01    MOV   A,1           (0238)     mov     a, 1                    ; Specify bank 1
06F5: 67       ASR   A             (0239)     asr     a                       ; Store in carry flag
                                   (0240)                                     ; Load bank 1 table:
06F6: 50 05    MOV   A,5           (0241)     mov     A, >LoadConfigTBL_waiting_Bank1
06F8: 57 FC    MOV   X,252         (0242)     mov     X, <LoadConfigTBL_waiting_Bank1
06FA: 7C 0C 0E LCALL 0x0C0E        (0243)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0244) 
06FD: 70 EF    AND   F,239         (0245) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0246) ; set config active bit
06FF: 62 D0 00 MOV   REG[208],0    (0247) 	or		[ACTIVE_CONFIG_STATUS+waiting_ADDR_OFF], waiting_BIT
0702: 26 04 FE AND   [4],254       (0248)     M8C_SetBank0                    ; Force return to bank 0
0705: 70 EF    AND   F,239         (0249) 	pop		x
0707: 20       POP   X             (0250) 
                                   (0251)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0252)     ret
0708: 7F       RET                 (0253) 
                                   (0254) ;---------------------------------------------------------------------------
                                   (0255) ; Reload Configuration waiting
                                   (0256) ;
                                   (0257) ;    Reload configuration registers for waiting.
                                   (0258) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0259) ;
                                   (0260) ;       INPUTS: None.
                                   (0261) ;      RETURNS: Nothing.
                                   (0262) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0263) ;               modified as may the Page Pointer registers!
                                   (0264) ;               In the large memory model currently only the page
                                   (0265) ;               pointer registers listed below are modified.  This does
                                   (0266) ;               not guarantee that in future implementations of this
                                   (0267) ;               function other page pointer registers will not be
                                   (0268) ;               modified.
                                   (0269) ;          
                                   (0270) ;               Page Pointer Registers Modified: 
                                   (0271) ;               CUR_PP
                                   (0272) ;
                                   (0273) _ReloadConfig_waiting:
                                   (0274)  ReloadConfig_waiting:
                                   (0275)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0276) 
0709: 71 10    OR    F,16          (0277) 	push	x
                                   (0278)     M8C_SetBank0                    ; Force bank 0
070B: 41 00 E1 AND   REG[0],225    (0279)     mov     a, 0                    ; Specify bank 0
                                   (0280)     asr     a                       ; Store in carry flag
070E: 41 01 E1 AND   REG[1],225    (0281)                                     ; Bank 0 table address:
0711: 43 01 1E OR    REG[1],30     (0282)     mov     A, >ReloadConfigTBL_waiting_Bank0
                                   (0283)     mov     X, <ReloadConfigTBL_waiting_Bank0
0714: 70 EF    AND   F,239         (0284)     lcall   LoadConfig              ; Reload the bank 0 values
0716: 41 03 FE AND   REG[3],254    (0285) 
0719: 43 03 01 OR    REG[3],1      (0286)     mov     a, 1                    ; Specify bank 1
                                   (0287)     asr     a                       ; Store in carry flag
071C: 41 02 FE AND   REG[2],254    (0288)                                     ; Bank 1 table address:
                                   (0289)     mov     A, >ReloadConfigTBL_waiting_Bank1
071F: 41 B3 F0 AND   REG[179],240  (0290)     mov     X, <ReloadConfigTBL_waiting_Bank1
0722: 43 B3 03 OR    REG[179],3    (0291)     lcall   LoadConfig              ; Reload the bank 1 values
                                   (0292) 
0725: 41 B4 F0 AND   REG[180],240  (0293) ; set config active bit
0728: 43 B4 03 OR    REG[180],3    (0294) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0295) 	or		[ACTIVE_CONFIG_STATUS+waiting_ADDR_OFF], waiting_BIT
072B: 41 B5 ED AND   REG[181],237  (0296)     M8C_SetBank0                    ; Force return to bank 0
                                   (0297) 	pop		x
072E: 41 B6 EE AND   REG[182],238  (0298) 
                                   (0299)     RAM_EPILOGUE RAM_USE_CLASS_4
0731: 41 B8 3F AND   REG[184],63   (0300)     ret
                                   (0301) 
0734: 10       PUSH  X             (0302) ;---------------------------------------------------------------------------
0735: 70 EF    AND   F,239         (0303) ; Unload Configuration waiting
0737: 50 00    MOV   A,0           (0304) ;
0739: 67       ASR   A             (0305) ;    Reset configuration registers for waiting
                                   (0306) ;    to their values as initially configured.
073A: 50 01    MOV   A,1           (0307) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
073C: 57 90    MOV   X,144         (0308) ;
073E: 7C 0C 0E LCALL 0x0C0E        (0309) ;       INPUTS: None.
                                   (0310) ;      RETURNS: Nothing.
0741: 50 01    MOV   A,1           (0311) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0743: 67       ASR   A             (0312) ;               modified as may the Page Pointer registers!
                                   (0313) ;               In the large memory model currently only the page
0744: 50 01    MOV   A,1           (0314) ;               pointer registers listed below are modified.  This does
0746: 57 B5    MOV   X,181         (0315) ;               not guarantee that in future implementations of this
0748: 7C 0C 0E LCALL 0x0C0E        (0316) ;               function other page pointer registers will not be
                                   (0317) ;               modified.
074B: 62 D0 00 MOV   REG[208],0    (0318) ;          
                                   (0319) ;               Page Pointer Registers Modified: 
074E: 2E 04 02 OR    [4],2         (0320) ;               CUR_PP
0751: 70 EF    AND   F,239         (0321) ;
0753: 20       POP   X             (0322) _UnloadConfig_waiting:
                                   (0323)  UnloadConfig_waiting:
                                   (0324)     RAM_PROLOGUE RAM_USE_CLASS_4
0754: 7F       RET                 (0325) 
                                   (0326) 	push	x
                                   (0327)     M8C_SetBank0                    ; Force bank 0
                                   (0328)     mov     a, 0                    ; Specify bank 0
                                   (0329)     asr     a                       ; Store in carry flag
                                   (0330)                                     ; Bank 0 table address:
                                   (0331)     mov     A, >UnloadConfigTBL_waiting_Bank0
                                   (0332)     mov     X, <UnloadConfigTBL_waiting_Bank0
                                   (0333)     lcall   LoadConfig              ; Unload the bank 0 values
                                   (0334) 
                                   (0335)     mov     a, 1                    ; Specify bank 1
                                   (0336)     asr     a                       ; Store in carry flag
                                   (0337)                                     ; Bank 1 table address:
                                   (0338)     mov     A, >UnloadConfigTBL_waiting_Bank1
                                   (0339)     mov     X, <UnloadConfigTBL_waiting_Bank1
                                   (0340)     lcall   LoadConfig              ; Unload the bank 1 values
                                   (0341) 
                                   (0342) 	M8C_SetBank0
                                   (0343) ; clear config active bit
                                   (0344) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0345) 	and		[ACTIVE_CONFIG_STATUS+waiting_ADDR_OFF], ~waiting_BIT
                                   (0346)     M8C_SetBank0                    ; Force return to bank 0
                                   (0347) 	pop		x
                                   (0348) 
                                   (0349)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0350)     ret
0755: 10       PUSH  X             (0351) 
0756: 70 EF    AND   F,239         (0352) ;---------------------------------------------------------------------------
0758: 50 00    MOV   A,0           (0353) ; Load Configuration hello
075A: 67       ASR   A             (0354) ;
                                   (0355) ;    Load configuration registers for hello.
075B: 50 01    MOV   A,1           (0356) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
075D: 57 E6    MOV   X,230         (0357) ;
075F: 7C 0C 0E LCALL 0x0C0E        (0358) ;       INPUTS: None.
                                   (0359) ;      RETURNS: Nothing.
0762: 50 01    MOV   A,1           (0360) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0764: 67       ASR   A             (0361) ;               modified as may the Page Pointer registers!
                                   (0362) ;               In the large memory model currently only the page
0765: 50 01    MOV   A,1           (0363) ;               pointer registers listed below are modified.  This does
0767: 57 F3    MOV   X,243         (0364) ;               not guarantee that in future implementations of this
0769: 7C 0C 0E LCALL 0x0C0E        (0365) ;               function other page pointer registers will not be
                                   (0366) ;               modified.
076C: 70 EF    AND   F,239         (0367) ;          
                                   (0368) ;               Page Pointer Registers Modified: 
076E: 41 B3 F0 AND   REG[179],240  (0369) ;               CUR_PP
0771: 43 B3 05 OR    REG[179],5    (0370) ;
                                   (0371) _LoadConfig_hello:
0774: 41 B4 F0 AND   REG[180],240  (0372)  LoadConfig_hello:
0777: 43 B4 05 OR    REG[180],5    (0373)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0374) 	M8C_SetBank1
077A: 41 B5 ED AND   REG[181],237  (0375) ; writing Port_0_DriveMode_0 register
077D: 43 B5 12 OR    REG[181],18   (0376) 	and		reg[ 0h], ~1eh
                                   (0377) ; writing Port_0_DriveMode_1 register
0780: 41 B6 EE AND   REG[182],238  (0378) 	and		reg[ 1h], ~1eh
0783: 43 B6 11 OR    REG[182],17   (0379) 	or		reg[ 1h], 1eh
                                   (0380) ; writing Port_0_DriveMode_2 register
0786: 41 B8 3F AND   REG[184],63   (0381) 	M8C_SetBank0
0789: 43 B8 40 OR    REG[184],64   (0382) 	and		reg[ 3h], ~ 1h
                                   (0383) 	or		reg[ 3h],  1h
078C: 41 02 FE AND   REG[2],254    (0384) ; writing Port_0_GlobalSelect register
078F: 43 02 01 OR    REG[2],1      (0385) 	and		reg[ 2h], ~ 1h
                                   (0386) ; writing Row_0_LogicSelect_0 register
0792: 41 03 FE AND   REG[3],254    (0387) 	and		reg[b3h], ~ fh
                                   (0388) 	or		reg[b3h],  3h
0795: 71 10    OR    F,16          (0389) ; writing Row_0_LogicSelect_1 register
0797: 41 01 E1 AND   REG[1],225    (0390) 	and		reg[b4h], ~ fh
                                   (0391) 	or		reg[b4h],  3h
079A: 41 00 E1 AND   REG[0],225    (0392) ; writing Row_0_OutputDrive_0 register
079D: 43 00 1E OR    REG[0],30     (0393) 	and		reg[b5h], ~12h
07A0: 70 EF    AND   F,239         (0394) ; writing Row_0_OutputDrive_1 register
                                   (0395) 	and		reg[b6h], ~11h
07A2: 62 D0 00 MOV   REG[208],0    (0396) ; writing Row_1_InputMux register
07A5: 26 04 FD AND   [4],253       (0397) 	and		reg[b8h], ~c0h
07A8: 70 EF    AND   F,239         (0398) 
07AA: 20       POP   X             (0399) 	push	x
                                   (0400)     M8C_SetBank0                    ; Force bank 0
                                   (0401)     mov     a, 0                    ; Specify bank 0
07AB: 7F       RET                 (0402)     asr     a                       ; Store in carry flag
                                   (0403)                                     ; Load bank 0 table:
                                   (0404)     mov     A, >LoadConfigTBL_hello_Bank0
                                   (0405)     mov     X, <LoadConfigTBL_hello_Bank0
                                   (0406)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0407) 
                                   (0408)     mov     a, 1                    ; Specify bank 1
                                   (0409)     asr     a                       ; Store in carry flag
                                   (0410)                                     ; Load bank 1 table:
                                   (0411)     mov     A, >LoadConfigTBL_hello_Bank1
                                   (0412)     mov     X, <LoadConfigTBL_hello_Bank1
                                   (0413)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0414) 
                                   (0415) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0416) ; set config active bit
                                   (0417) 	or		[ACTIVE_CONFIG_STATUS+hello_ADDR_OFF], hello_BIT
                                   (0418)     M8C_SetBank0                    ; Force return to bank 0
                                   (0419) 	pop		x
                                   (0420) 
                                   (0421)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0422)     ret
                                   (0423) 
                                   (0424) ;---------------------------------------------------------------------------
                                   (0425) ; Unload Configuration hello
07AC: 71 10    OR    F,16          (0426) ;
                                   (0427) ;    Reset configuration registers for hello
07AE: 41 00 E1 AND   REG[0],225    (0428) ;    to their values as initially configured.
                                   (0429) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
07B1: 41 01 E1 AND   REG[1],225    (0430) ;
07B4: 43 01 1E OR    REG[1],30     (0431) ;       INPUTS: None.
                                   (0432) ;      RETURNS: Nothing.
07B7: 70 EF    AND   F,239         (0433) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
07B9: 41 03 E1 AND   REG[3],225    (0434) ;               modified as may the Page Pointer registers!
07BC: 43 03 1E OR    REG[3],30     (0435) ;               In the large memory model currently only the page
                                   (0436) ;               pointer registers listed below are modified.  This does
07BF: 41 02 E1 AND   REG[2],225    (0437) ;               not guarantee that in future implementations of this
                                   (0438) ;               function other page pointer registers will not be
07C2: 41 B3 F0 AND   REG[179],240  (0439) ;               modified.
07C5: 43 B3 03 OR    REG[179],3    (0440) ;          
                                   (0441) ;               Page Pointer Registers Modified: 
07C8: 41 B4 F0 AND   REG[180],240  (0442) ;               CUR_PP
07CB: 43 B4 03 OR    REG[180],3    (0443) ;
                                   (0444) _UnloadConfig_hello:
07CE: 41 B5 ED AND   REG[181],237  (0445)  UnloadConfig_hello:
                                   (0446)     RAM_PROLOGUE RAM_USE_CLASS_4
07D1: 41 B6 EE AND   REG[182],238  (0447) 
                                   (0448) 	push	x
07D4: 10       PUSH  X             (0449)     M8C_SetBank0                    ; Force bank 0
07D5: 70 EF    AND   F,239         (0450)     mov     a, 0                    ; Specify bank 0
07D7: 50 00    MOV   A,0           (0451)     asr     a                       ; Store in carry flag
07D9: 67       ASR   A             (0452)                                     ; Bank 0 table address:
                                   (0453)     mov     A, >UnloadConfigTBL_hello_Bank0
07DA: 50 02    MOV   A,2           (0454)     mov     X, <UnloadConfigTBL_hello_Bank0
07DC: 57 25    MOV   X,37          (0455)     lcall   LoadConfig              ; Unload the bank 0 values
07DE: 7C 0C 0E LCALL 0x0C0E        (0456) 
                                   (0457)     mov     a, 1                    ; Specify bank 1
07E1: 50 01    MOV   A,1           (0458)     asr     a                       ; Store in carry flag
07E3: 67       ASR   A             (0459)                                     ; Bank 1 table address:
                                   (0460)     mov     A, >UnloadConfigTBL_hello_Bank1
07E4: 50 02    MOV   A,2           (0461)     mov     X, <UnloadConfigTBL_hello_Bank1
07E6: 57 38    MOV   X,56          (0462)     lcall   LoadConfig              ; Unload the bank 1 values
07E8: 7C 0C 0E LCALL 0x0C0E        (0463) 
                                   (0464) 	M8C_SetBank0
07EB: 62 D0 00 MOV   REG[208],0    (0465) ; writing Row_0_LogicSelect_0 register
                                   (0466) 	and		reg[b3h], ~ fh
07EE: 2E 04 04 OR    [4],4         (0467) 	or		reg[b3h],  5h
07F1: 70 EF    AND   F,239         (0468) ; writing Row_0_LogicSelect_1 register
07F3: 20       POP   X             (0469) 	and		reg[b4h], ~ fh
                                   (0470) 	or		reg[b4h],  5h
                                   (0471) ; writing Row_0_OutputDrive_0 register
07F4: 7F       RET                 (0472) 	and		reg[b5h], ~12h
                                   (0473) 	or		reg[b5h], 12h
                                   (0474) ; writing Row_0_OutputDrive_1 register
                                   (0475) 	and		reg[b6h], ~11h
                                   (0476) 	or		reg[b6h], 11h
                                   (0477) ; writing Row_1_InputMux register
                                   (0478) 	and		reg[b8h], ~c0h
                                   (0479) 	or		reg[b8h], 40h
                                   (0480) ; writing Port_0_GlobalSelect register
                                   (0481) 	and		reg[ 2h], ~ 1h
                                   (0482) 	or		reg[ 2h],  1h
                                   (0483) ; writing Port_0_DriveMode_2 register
                                   (0484) 	and		reg[ 3h], ~ 1h
                                   (0485) ; writing Port_0_DriveMode_1 register
                                   (0486) 	M8C_SetBank1
                                   (0487) 	and		reg[ 1h], ~1eh
                                   (0488) ; writing Port_0_DriveMode_0 register
                                   (0489) 	and		reg[ 0h], ~1eh
                                   (0490) 	or		reg[ 0h], 1eh
                                   (0491) 	M8C_SetBank0
                                   (0492) ; clear config active bit
                                   (0493) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0494) 	and		[ACTIVE_CONFIG_STATUS+hello_ADDR_OFF], ~hello_BIT
                                   (0495)     M8C_SetBank0                    ; Force return to bank 0
                                   (0496) 	pop		x
                                   (0497) 
07F5: 10       PUSH  X             (0498)     RAM_EPILOGUE RAM_USE_CLASS_4
07F6: 70 EF    AND   F,239         (0499)     ret
07F8: 50 00    MOV   A,0           (0500) 
07FA: 67       ASR   A             (0501) ;---------------------------------------------------------------------------
                                   (0502) ; Load Configuration initial
07FB: 50 02    MOV   A,2           (0503) ;
07FD: 57 51    MOV   X,81          (0504) ;    Load configuration registers for initial.
07FF: 7C 0C 0E LCALL 0x0C0E        (0505) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0506) ;
0802: 50 01    MOV   A,1           (0507) ;       INPUTS: None.
0804: 67       ASR   A             (0508) ;      RETURNS: Nothing.
                                   (0509) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0805: 50 02    MOV   A,2           (0510) ;               modified as may the Page Pointer registers!
0807: 57 58    MOV   X,88          (0511) ;               In the large memory model currently only the page
0809: 7C 0C 0E LCALL 0x0C0E        (0512) ;               pointer registers listed below are modified.  This does
                                   (0513) ;               not guarantee that in future implementations of this
080C: 70 EF    AND   F,239         (0514) ;               function other page pointer registers will not be
                                   (0515) ;               modified.
080E: 41 B3 F0 AND   REG[179],240  (0516) ;          
0811: 43 B3 05 OR    REG[179],5    (0517) ;               Page Pointer Registers Modified: 
                                   (0518) ;               CUR_PP
0814: 41 B4 F0 AND   REG[180],240  (0519) ;
0817: 43 B4 05 OR    REG[180],5    (0520) _LoadConfig_initial:
                                   (0521)  LoadConfig_initial:
081A: 41 B5 ED AND   REG[181],237  (0522)     RAM_PROLOGUE RAM_USE_CLASS_4
081D: 43 B5 12 OR    REG[181],18   (0523) 	M8C_SetBank1
                                   (0524) ; writing Port_0_DriveMode_0 register
0820: 41 B6 EE AND   REG[182],238  (0525) 	and		reg[ 0h], ~1eh
0823: 43 B6 11 OR    REG[182],17   (0526) ; writing Port_0_DriveMode_1 register
                                   (0527) 	and		reg[ 1h], ~1eh
0826: 41 02 E1 AND   REG[2],225    (0528) 	or		reg[ 1h], 1eh
0829: 43 02 1E OR    REG[2],30     (0529) ; writing Port_0_DriveMode_2 register
                                   (0530) 	M8C_SetBank0
082C: 41 03 E1 AND   REG[3],225    (0531) 	and		reg[ 3h], ~1eh
                                   (0532) 	or		reg[ 3h], 1eh
082F: 71 10    OR    F,16          (0533) ; writing Port_0_GlobalSelect register
0831: 41 01 E1 AND   REG[1],225    (0534) 	and		reg[ 2h], ~1eh
                                   (0535) ; writing Row_0_LogicSelect_0 register
0834: 41 00 E1 AND   REG[0],225    (0536) 	and		reg[b3h], ~ fh
0837: 43 00 1E OR    REG[0],30     (0537) 	or		reg[b3h],  3h
083A: 70 EF    AND   F,239         (0538) ; writing Row_0_LogicSelect_1 register
                                   (0539) 	and		reg[b4h], ~ fh
083C: 62 D0 00 MOV   REG[208],0    (0540) 	or		reg[b4h],  3h
083F: 26 04 FB AND   [4],251       (0541) ; writing Row_0_OutputDrive_0 register
0842: 70 EF    AND   F,239         (0542) 	and		reg[b5h], ~12h
0844: 20       POP   X             (0543) ; writing Row_0_OutputDrive_1 register
                                   (0544) 	and		reg[b6h], ~11h
                                   (0545) 
0845: 7F       RET                 (0546) 	push	x
                                   (0547)     M8C_SetBank0                    ; Force bank 0
                                   (0548)     mov     a, 0                    ; Specify bank 0
                                   (0549)     asr     a                       ; Store in carry flag
                                   (0550)                                     ; Load bank 0 table:
                                   (0551)     mov     A, >LoadConfigTBL_initial_Bank0
                                   (0552)     mov     X, <LoadConfigTBL_initial_Bank0
                                   (0553)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0554) 
                                   (0555)     mov     a, 1                    ; Specify bank 1
                                   (0556)     asr     a                       ; Store in carry flag
                                   (0557)                                     ; Load bank 1 table:
                                   (0558)     mov     A, >LoadConfigTBL_initial_Bank1
                                   (0559)     mov     X, <LoadConfigTBL_initial_Bank1
                                   (0560)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0561) 
                                   (0562) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0563) ; set config active bit
                                   (0564) 	or		[ACTIVE_CONFIG_STATUS+initial_ADDR_OFF], initial_BIT
                                   (0565)     M8C_SetBank0                    ; Force return to bank 0
                                   (0566) 	pop		x
                                   (0567) 
                                   (0568)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0569)     ret
0846: 71 10    OR    F,16          (0570) 
                                   (0571) ;---------------------------------------------------------------------------
0848: 41 00 FE AND   REG[0],254    (0572) ; Unload Configuration initial
084B: 43 00 01 OR    REG[0],1      (0573) ;
                                   (0574) ;    Reset configuration registers for initial
084E: 41 01 FE AND   REG[1],254    (0575) ;    to their values as initially configured.
                                   (0576) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0851: 70 EF    AND   F,239         (0577) ;
0853: 41 B5 FE AND   REG[181],254  (0578) ;       INPUTS: None.
0856: 43 B5 01 OR    REG[181],1    (0579) ;      RETURNS: Nothing.
                                   (0580) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0859: 10       PUSH  X             (0581) ;               modified as may the Page Pointer registers!
085A: 70 EF    AND   F,239         (0582) ;               In the large memory model currently only the page
085C: 50 00    MOV   A,0           (0583) ;               pointer registers listed below are modified.  This does
085E: 67       ASR   A             (0584) ;               not guarantee that in future implementations of this
                                   (0585) ;               function other page pointer registers will not be
085F: 50 02    MOV   A,2           (0586) ;               modified.
0861: 57 72    MOV   X,114         (0587) ;          
0863: 7C 0C 0E LCALL 0x0C0E        (0588) ;               Page Pointer Registers Modified: 
                                   (0589) ;               CUR_PP
0866: 50 01    MOV   A,1           (0590) ;
0868: 67       ASR   A             (0591) _UnloadConfig_initial:
                                   (0592)  UnloadConfig_initial:
0869: 50 02    MOV   A,2           (0593)     RAM_PROLOGUE RAM_USE_CLASS_4
086B: 57 8B    MOV   X,139         (0594) 
086D: 7C 0C 0E LCALL 0x0C0E        (0595) 	push	x
                                   (0596)     M8C_SetBank0                    ; Force bank 0
0870: 62 D0 00 MOV   REG[208],0    (0597)     mov     a, 0                    ; Specify bank 0
                                   (0598)     asr     a                       ; Store in carry flag
0873: 2E 04 08 OR    [4],8         (0599)                                     ; Bank 0 table address:
0876: 70 EF    AND   F,239         (0600)     mov     A, >UnloadConfigTBL_initial_Bank0
0878: 20       POP   X             (0601)     mov     X, <UnloadConfigTBL_initial_Bank0
                                   (0602)     lcall   LoadConfig              ; Unload the bank 0 values
                                   (0603) 
0879: 7F       RET                 (0604)     mov     a, 1                    ; Specify bank 1
                                   (0605)     asr     a                       ; Store in carry flag
                                   (0606)                                     ; Bank 1 table address:
                                   (0607)     mov     A, >UnloadConfigTBL_initial_Bank1
                                   (0608)     mov     X, <UnloadConfigTBL_initial_Bank1
                                   (0609)     lcall   LoadConfig              ; Unload the bank 1 values
                                   (0610) 
                                   (0611) 	M8C_SetBank0
                                   (0612) ; writing Row_0_LogicSelect_0 register
                                   (0613) 	and		reg[b3h], ~ fh
                                   (0614) 	or		reg[b3h],  5h
                                   (0615) ; writing Row_0_LogicSelect_1 register
                                   (0616) 	and		reg[b4h], ~ fh
                                   (0617) 	or		reg[b4h],  5h
                                   (0618) ; writing Row_0_OutputDrive_0 register
                                   (0619) 	and		reg[b5h], ~12h
                                   (0620) 	or		reg[b5h], 12h
                                   (0621) ; writing Row_0_OutputDrive_1 register
                                   (0622) 	and		reg[b6h], ~11h
                                   (0623) 	or		reg[b6h], 11h
                                   (0624) ; writing Port_0_GlobalSelect register
                                   (0625) 	and		reg[ 2h], ~1eh
                                   (0626) 	or		reg[ 2h], 1eh
                                   (0627) ; writing Port_0_DriveMode_2 register
                                   (0628) 	and		reg[ 3h], ~1eh
                                   (0629) ; writing Port_0_DriveMode_1 register
087A: 10       PUSH  X             (0630) 	M8C_SetBank1
087B: 70 EF    AND   F,239         (0631) 	and		reg[ 1h], ~1eh
087D: 50 00    MOV   A,0           (0632) ; writing Port_0_DriveMode_0 register
087F: 67       ASR   A             (0633) 	and		reg[ 0h], ~1eh
                                   (0634) 	or		reg[ 0h], 1eh
0880: 50 02    MOV   A,2           (0635) 	M8C_SetBank0
0882: 57 AC    MOV   X,172         (0636) ; clear config active bit
0884: 7C 0C 0E LCALL 0x0C0E        (0637) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0638) 	and		[ACTIVE_CONFIG_STATUS+initial_ADDR_OFF], ~initial_BIT
0887: 50 01    MOV   A,1           (0639)     M8C_SetBank0                    ; Force return to bank 0
0889: 67       ASR   A             (0640) 	pop		x
                                   (0641) 
088A: 50 02    MOV   A,2           (0642)     RAM_EPILOGUE RAM_USE_CLASS_4
088C: 57 B5    MOV   X,181         (0643)     ret
088E: 7C 0C 0E LCALL 0x0C0E        (0644) 
                                   (0645) ;---------------------------------------------------------------------------
0891: 70 EF    AND   F,239         (0646) ; Load Configuration my_response
                                   (0647) ;
0893: 41 B5 FE AND   REG[181],254  (0648) ;    Load configuration registers for my_response.
                                   (0649) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0896: 71 10    OR    F,16          (0650) ;
0898: 41 01 FE AND   REG[1],254    (0651) ;       INPUTS: None.
089B: 43 01 01 OR    REG[1],1      (0652) ;      RETURNS: Nothing.
                                   (0653) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
089E: 41 00 FE AND   REG[0],254    (0654) ;               modified as may the Page Pointer registers!
08A1: 70 EF    AND   F,239         (0655) ;               In the large memory model currently only the page
                                   (0656) ;               pointer registers listed below are modified.  This does
08A3: 62 D0 00 MOV   REG[208],0    (0657) ;               not guarantee that in future implementations of this
08A6: 26 04 F7 AND   [4],247       (0658) ;               function other page pointer registers will not be
08A9: 70 EF    AND   F,239         (0659) ;               modified.
08AB: 20       POP   X             (0660) ;          
                                   (0661) ;               Page Pointer Registers Modified: 
                                   (0662) ;               CUR_PP
08AC: 7F       RET                 (0663) ;
                                   (0664) _LoadConfig_my_response:
                                   (0665)  LoadConfig_my_response:
                                   (0666)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0667) 	M8C_SetBank1
                                   (0668) ; writing Port_0_DriveMode_0 register
                                   (0669) 	and		reg[ 0h], ~ 1h
                                   (0670) 	or		reg[ 0h],  1h
                                   (0671) ; writing Port_0_DriveMode_1 register
                                   (0672) 	and		reg[ 1h], ~ 1h
                                   (0673) ; writing Row_0_OutputDrive_0 register
                                   (0674) 	M8C_SetBank0
                                   (0675) 	and		reg[b5h], ~ 1h
                                   (0676) 	or		reg[b5h],  1h
                                   (0677) 
                                   (0678) 	push	x
                                   (0679)     M8C_SetBank0                    ; Force bank 0
                                   (0680)     mov     a, 0                    ; Specify bank 0
                                   (0681)     asr     a                       ; Store in carry flag
                                   (0682)                                     ; Load bank 0 table:
                                   (0683)     mov     A, >LoadConfigTBL_my_response_Bank0
                                   (0684)     mov     X, <LoadConfigTBL_my_response_Bank0
                                   (0685)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0686) 
08AD: 71 10    OR    F,16          (0687)     mov     a, 1                    ; Specify bank 1
                                   (0688)     asr     a                       ; Store in carry flag
08AF: 41 00 E0 AND   REG[0],224    (0689)                                     ; Load bank 1 table:
08B2: 43 00 01 OR    REG[0],1      (0690)     mov     A, >LoadConfigTBL_my_response_Bank1
                                   (0691)     mov     X, <LoadConfigTBL_my_response_Bank1
08B5: 41 01 E0 AND   REG[1],224    (0692)     lcall   LoadConfig              ; Load the bank 1 values
08B8: 43 01 1E OR    REG[1],30     (0693) 
                                   (0694) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
08BB: 70 EF    AND   F,239         (0695) ; set config active bit
08BD: 41 03 E3 AND   REG[3],227    (0696) 	or		[ACTIVE_CONFIG_STATUS+my_response_ADDR_OFF], my_response_BIT
08C0: 43 03 1C OR    REG[3],28     (0697)     M8C_SetBank0                    ; Force return to bank 0
                                   (0698) 	pop		x
08C3: 41 02 E3 AND   REG[2],227    (0699) 
                                   (0700)     RAM_EPILOGUE RAM_USE_CLASS_4
08C6: 41 B3 F0 AND   REG[179],240  (0701)     ret
08C9: 43 B3 03 OR    REG[179],3    (0702) 
                                   (0703) ;---------------------------------------------------------------------------
08CC: 41 B4 F0 AND   REG[180],240  (0704) ; Unload Configuration my_response
08CF: 43 B4 03 OR    REG[180],3    (0705) ;
                                   (0706) ;    Reset configuration registers for my_response
08D2: 41 B5 EC AND   REG[181],236  (0707) ;    to their values as initially configured.
08D5: 43 B5 01 OR    REG[181],1    (0708) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0709) ;
08D8: 41 B6 EE AND   REG[182],238  (0710) ;       INPUTS: None.
                                   (0711) ;      RETURNS: Nothing.
08DB: 10       PUSH  X             (0712) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
08DC: 70 EF    AND   F,239         (0713) ;               modified as may the Page Pointer registers!
08DE: 50 00    MOV   A,0           (0714) ;               In the large memory model currently only the page
08E0: 67       ASR   A             (0715) ;               pointer registers listed below are modified.  This does
                                   (0716) ;               not guarantee that in future implementations of this
08E1: 50 02    MOV   A,2           (0717) ;               function other page pointer registers will not be
08E3: 57 D7    MOV   X,215         (0718) ;               modified.
08E5: 7C 0C 0E LCALL 0x0C0E        (0719) ;          
                                   (0720) ;               Page Pointer Registers Modified: 
08E8: 50 01    MOV   A,1           (0721) ;               CUR_PP
08EA: 67       ASR   A             (0722) ;
                                   (0723) _UnloadConfig_my_response:
08EB: 50 02    MOV   A,2           (0724)  UnloadConfig_my_response:
08ED: 57 EA    MOV   X,234         (0725)     RAM_PROLOGUE RAM_USE_CLASS_4
08EF: 7C 0C 0E LCALL 0x0C0E        (0726) 
                                   (0727) 	push	x
08F2: 62 D0 00 MOV   REG[208],0    (0728)     M8C_SetBank0                    ; Force bank 0
                                   (0729)     mov     a, 0                    ; Specify bank 0
08F5: 2E 04 10 OR    [4],16        (0730)     asr     a                       ; Store in carry flag
08F8: 70 EF    AND   F,239         (0731)                                     ; Bank 0 table address:
08FA: 20       POP   X             (0732)     mov     A, >UnloadConfigTBL_my_response_Bank0
                                   (0733)     mov     X, <UnloadConfigTBL_my_response_Bank0
                                   (0734)     lcall   LoadConfig              ; Unload the bank 0 values
08FB: 7F       RET                 (0735) 
                                   (0736)     mov     a, 1                    ; Specify bank 1
                                   (0737)     asr     a                       ; Store in carry flag
                                   (0738)                                     ; Bank 1 table address:
                                   (0739)     mov     A, >UnloadConfigTBL_my_response_Bank1
                                   (0740)     mov     X, <UnloadConfigTBL_my_response_Bank1
                                   (0741)     lcall   LoadConfig              ; Unload the bank 1 values
                                   (0742) 
                                   (0743) 	M8C_SetBank0
                                   (0744) ; writing Row_0_OutputDrive_0 register
                                   (0745) 	and		reg[b5h], ~ 1h
                                   (0746) ; writing Port_0_DriveMode_1 register
                                   (0747) 	M8C_SetBank1
                                   (0748) 	and		reg[ 1h], ~ 1h
                                   (0749) 	or		reg[ 1h],  1h
                                   (0750) ; writing Port_0_DriveMode_0 register
                                   (0751) 	and		reg[ 0h], ~ 1h
                                   (0752) 	M8C_SetBank0
                                   (0753) ; clear config active bit
                                   (0754) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0755) 	and		[ACTIVE_CONFIG_STATUS+my_response_ADDR_OFF], ~my_response_BIT
                                   (0756)     M8C_SetBank0                    ; Force return to bank 0
                                   (0757) 	pop		x
                                   (0758) 
                                   (0759)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0760)     ret
08FC: 10       PUSH  X             (0761) 
08FD: 70 EF    AND   F,239         (0762) ;---------------------------------------------------------------------------
08FF: 50 00    MOV   A,0           (0763) ; Load Configuration response1
0901: 67       ASR   A             (0764) ;
                                   (0765) ;    Load configuration registers for response1.
0902: 50 03    MOV   A,3           (0766) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0904: 57 03    MOV   X,3           (0767) ;
0906: 7C 0C 0E LCALL 0x0C0E        (0768) ;       INPUTS: None.
                                   (0769) ;      RETURNS: Nothing.
0909: 50 01    MOV   A,1           (0770) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
090B: 67       ASR   A             (0771) ;               modified as may the Page Pointer registers!
                                   (0772) ;               In the large memory model currently only the page
090C: 50 03    MOV   A,3           (0773) ;               pointer registers listed below are modified.  This does
090E: 57 0A    MOV   X,10          (0774) ;               not guarantee that in future implementations of this
0910: 7C 0C 0E LCALL 0x0C0E        (0775) ;               function other page pointer registers will not be
                                   (0776) ;               modified.
0913: 70 EF    AND   F,239         (0777) ;          
                                   (0778) ;               Page Pointer Registers Modified: 
0915: 41 B3 F0 AND   REG[179],240  (0779) ;               CUR_PP
0918: 43 B3 05 OR    REG[179],5    (0780) ;
                                   (0781) _LoadConfig_response1:
091B: 41 B4 F0 AND   REG[180],240  (0782)  LoadConfig_response1:
091E: 43 B4 05 OR    REG[180],5    (0783)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0784) 	M8C_SetBank1
0921: 41 B5 EC AND   REG[181],236  (0785) ; writing Port_0_DriveMode_0 register
0924: 43 B5 12 OR    REG[181],18   (0786) 	and		reg[ 0h], ~1fh
                                   (0787) 	or		reg[ 0h],  1h
0927: 41 B6 EE AND   REG[182],238  (0788) ; writing Port_0_DriveMode_1 register
092A: 43 B6 11 OR    REG[182],17   (0789) 	and		reg[ 1h], ~1fh
                                   (0790) 	or		reg[ 1h], 1eh
092D: 41 02 E3 AND   REG[2],227    (0791) ; writing Port_0_DriveMode_2 register
0930: 43 02 1C OR    REG[2],28     (0792) 	M8C_SetBank0
                                   (0793) 	and		reg[ 3h], ~1ch
0933: 41 03 E3 AND   REG[3],227    (0794) 	or		reg[ 3h], 1ch
                                   (0795) ; writing Port_0_GlobalSelect register
0936: 71 10    OR    F,16          (0796) 	and		reg[ 2h], ~1ch
0938: 41 01 E0 AND   REG[1],224    (0797) ; writing Row_0_LogicSelect_0 register
093B: 43 01 01 OR    REG[1],1      (0798) 	and		reg[b3h], ~ fh
                                   (0799) 	or		reg[b3h],  3h
093E: 41 00 E0 AND   REG[0],224    (0800) ; writing Row_0_LogicSelect_1 register
0941: 43 00 1E OR    REG[0],30     (0801) 	and		reg[b4h], ~ fh
0944: 70 EF    AND   F,239         (0802) 	or		reg[b4h],  3h
                                   (0803) ; writing Row_0_OutputDrive_0 register
0946: 62 D0 00 MOV   REG[208],0    (0804) 	and		reg[b5h], ~13h
0949: 26 04 EF AND   [4],239       (0805) 	or		reg[b5h],  1h
094C: 70 EF    AND   F,239         (0806) ; writing Row_0_OutputDrive_1 register
094E: 20       POP   X             (0807) 	and		reg[b6h], ~11h
                                   (0808) 
                                   (0809) 	push	x
094F: 7F       RET                 (0810)     M8C_SetBank0                    ; Force bank 0
                                   (0811)     mov     a, 0                    ; Specify bank 0
                                   (0812)     asr     a                       ; Store in carry flag
                                   (0813)                                     ; Load bank 0 table:
                                   (0814)     mov     A, >LoadConfigTBL_response1_Bank0
                                   (0815)     mov     X, <LoadConfigTBL_response1_Bank0
                                   (0816)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0817) 
                                   (0818)     mov     a, 1                    ; Specify bank 1
                                   (0819)     asr     a                       ; Store in carry flag
                                   (0820)                                     ; Load bank 1 table:
                                   (0821)     mov     A, >LoadConfigTBL_response1_Bank1
                                   (0822)     mov     X, <LoadConfigTBL_response1_Bank1
                                   (0823)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0824) 
                                   (0825) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0826) ; set config active bit
                                   (0827) 	or		[ACTIVE_CONFIG_STATUS+response1_ADDR_OFF], response1_BIT
                                   (0828)     M8C_SetBank0                    ; Force return to bank 0
                                   (0829) 	pop		x
                                   (0830) 
                                   (0831)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0832)     ret
                                   (0833) 
0950: 71 10    OR    F,16          (0834) ;---------------------------------------------------------------------------
                                   (0835) ; Unload Configuration response1
0952: 41 00 E0 AND   REG[0],224    (0836) ;
0955: 43 00 01 OR    REG[0],1      (0837) ;    Reset configuration registers for response1
                                   (0838) ;    to their values as initially configured.
0958: 41 01 E0 AND   REG[1],224    (0839) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
095B: 43 01 1E OR    REG[1],30     (0840) ;
                                   (0841) ;       INPUTS: None.
095E: 70 EF    AND   F,239         (0842) ;      RETURNS: Nothing.
0960: 41 03 E5 AND   REG[3],229    (0843) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0963: 43 03 1A OR    REG[3],26     (0844) ;               modified as may the Page Pointer registers!
                                   (0845) ;               In the large memory model currently only the page
0966: 41 02 E5 AND   REG[2],229    (0846) ;               pointer registers listed below are modified.  This does
                                   (0847) ;               not guarantee that in future implementations of this
0969: 41 B3 F0 AND   REG[179],240  (0848) ;               function other page pointer registers will not be
096C: 43 B3 03 OR    REG[179],3    (0849) ;               modified.
                                   (0850) ;          
096F: 41 B4 F0 AND   REG[180],240  (0851) ;               Page Pointer Registers Modified: 
0972: 43 B4 03 OR    REG[180],3    (0852) ;               CUR_PP
                                   (0853) ;
0975: 41 B5 EC AND   REG[181],236  (0854) _UnloadConfig_response1:
0978: 43 B5 01 OR    REG[181],1    (0855)  UnloadConfig_response1:
                                   (0856)     RAM_PROLOGUE RAM_USE_CLASS_4
097B: 41 B6 EE AND   REG[182],238  (0857) 
                                   (0858) 	push	x
097E: 10       PUSH  X             (0859)     M8C_SetBank0                    ; Force bank 0
097F: 70 EF    AND   F,239         (0860)     mov     a, 0                    ; Specify bank 0
0981: 50 00    MOV   A,0           (0861)     asr     a                       ; Store in carry flag
0983: 67       ASR   A             (0862)                                     ; Bank 0 table address:
                                   (0863)     mov     A, >UnloadConfigTBL_response1_Bank0
0984: 50 03    MOV   A,3           (0864)     mov     X, <UnloadConfigTBL_response1_Bank0
0986: 57 24    MOV   X,36          (0865)     lcall   LoadConfig              ; Unload the bank 0 values
0988: 7C 0C 0E LCALL 0x0C0E        (0866) 
                                   (0867)     mov     a, 1                    ; Specify bank 1
098B: 50 01    MOV   A,1           (0868)     asr     a                       ; Store in carry flag
098D: 67       ASR   A             (0869)                                     ; Bank 1 table address:
                                   (0870)     mov     A, >UnloadConfigTBL_response1_Bank1
098E: 50 03    MOV   A,3           (0871)     mov     X, <UnloadConfigTBL_response1_Bank1
0990: 57 37    MOV   X,55          (0872)     lcall   LoadConfig              ; Unload the bank 1 values
0992: 7C 0C 0E LCALL 0x0C0E        (0873) 
                                   (0874) 	M8C_SetBank0
0995: 62 D0 00 MOV   REG[208],0    (0875) ; writing Row_0_LogicSelect_0 register
                                   (0876) 	and		reg[b3h], ~ fh
0998: 2E 04 20 OR    [4],32        (0877) 	or		reg[b3h],  5h
099B: 70 EF    AND   F,239         (0878) ; writing Row_0_LogicSelect_1 register
099D: 20       POP   X             (0879) 	and		reg[b4h], ~ fh
                                   (0880) 	or		reg[b4h],  5h
                                   (0881) ; writing Row_0_OutputDrive_0 register
099E: 7F       RET                 (0882) 	and		reg[b5h], ~13h
                                   (0883) 	or		reg[b5h], 12h
                                   (0884) ; writing Row_0_OutputDrive_1 register
                                   (0885) 	and		reg[b6h], ~11h
                                   (0886) 	or		reg[b6h], 11h
                                   (0887) ; writing Port_0_GlobalSelect register
                                   (0888) 	and		reg[ 2h], ~1ch
                                   (0889) 	or		reg[ 2h], 1ch
                                   (0890) ; writing Port_0_DriveMode_2 register
                                   (0891) 	and		reg[ 3h], ~1ch
                                   (0892) ; writing Port_0_DriveMode_1 register
                                   (0893) 	M8C_SetBank1
                                   (0894) 	and		reg[ 1h], ~1fh
                                   (0895) 	or		reg[ 1h],  1h
                                   (0896) ; writing Port_0_DriveMode_0 register
                                   (0897) 	and		reg[ 0h], ~1fh
                                   (0898) 	or		reg[ 0h], 1eh
                                   (0899) 	M8C_SetBank0
                                   (0900) ; clear config active bit
                                   (0901) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0902) 	and		[ACTIVE_CONFIG_STATUS+response1_ADDR_OFF], ~response1_BIT
                                   (0903)     M8C_SetBank0                    ; Force return to bank 0
                                   (0904) 	pop		x
                                   (0905) 
                                   (0906)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0907)     ret
099F: 10       PUSH  X             (0908) 
09A0: 70 EF    AND   F,239         (0909) ;---------------------------------------------------------------------------
09A2: 50 00    MOV   A,0           (0910) ; Load Configuration response2
09A4: 67       ASR   A             (0911) ;
                                   (0912) ;    Load configuration registers for response2.
09A5: 50 03    MOV   A,3           (0913) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
09A7: 57 50    MOV   X,80          (0914) ;
09A9: 7C 0C 0E LCALL 0x0C0E        (0915) ;       INPUTS: None.
                                   (0916) ;      RETURNS: Nothing.
09AC: 50 01    MOV   A,1           (0917) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
09AE: 67       ASR   A             (0918) ;               modified as may the Page Pointer registers!
                                   (0919) ;               In the large memory model currently only the page
09AF: 50 03    MOV   A,3           (0920) ;               pointer registers listed below are modified.  This does
09B1: 57 57    MOV   X,87          (0921) ;               not guarantee that in future implementations of this
09B3: 7C 0C 0E LCALL 0x0C0E        (0922) ;               function other page pointer registers will not be
                                   (0923) ;               modified.
09B6: 70 EF    AND   F,239         (0924) ;          
                                   (0925) ;               Page Pointer Registers Modified: 
09B8: 41 B3 F0 AND   REG[179],240  (0926) ;               CUR_PP
09BB: 43 B3 05 OR    REG[179],5    (0927) ;
                                   (0928) _LoadConfig_response2:
09BE: 41 B4 F0 AND   REG[180],240  (0929)  LoadConfig_response2:
09C1: 43 B4 05 OR    REG[180],5    (0930)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0931) 	M8C_SetBank1
09C4: 41 B5 EC AND   REG[181],236  (0932) ; writing Port_0_DriveMode_0 register
09C7: 43 B5 12 OR    REG[181],18   (0933) 	and		reg[ 0h], ~1fh
                                   (0934) 	or		reg[ 0h],  1h
09CA: 41 B6 EE AND   REG[182],238  (0935) ; writing Port_0_DriveMode_1 register
09CD: 43 B6 11 OR    REG[182],17   (0936) 	and		reg[ 1h], ~1fh
                                   (0937) 	or		reg[ 1h], 1eh
09D0: 41 02 E5 AND   REG[2],229    (0938) ; writing Port_0_DriveMode_2 register
09D3: 43 02 1A OR    REG[2],26     (0939) 	M8C_SetBank0
                                   (0940) 	and		reg[ 3h], ~1ah
09D6: 41 03 E5 AND   REG[3],229    (0941) 	or		reg[ 3h], 1ah
                                   (0942) ; writing Port_0_GlobalSelect register
09D9: 71 10    OR    F,16          (0943) 	and		reg[ 2h], ~1ah
09DB: 41 01 E0 AND   REG[1],224    (0944) ; writing Row_0_LogicSelect_0 register
09DE: 43 01 01 OR    REG[1],1      (0945) 	and		reg[b3h], ~ fh
                                   (0946) 	or		reg[b3h],  3h
09E1: 41 00 E0 AND   REG[0],224    (0947) ; writing Row_0_LogicSelect_1 register
09E4: 43 00 1E OR    REG[0],30     (0948) 	and		reg[b4h], ~ fh
09E7: 70 EF    AND   F,239         (0949) 	or		reg[b4h],  3h
                                   (0950) ; writing Row_0_OutputDrive_0 register
09E9: 62 D0 00 MOV   REG[208],0    (0951) 	and		reg[b5h], ~13h
09EC: 26 04 DF AND   [4],223       (0952) 	or		reg[b5h],  1h
09EF: 70 EF    AND   F,239         (0953) ; writing Row_0_OutputDrive_1 register
09F1: 20       POP   X             (0954) 	and		reg[b6h], ~11h
                                   (0955) 
                                   (0956) 	push	x
09F2: 7F       RET                 (0957)     M8C_SetBank0                    ; Force bank 0
                                   (0958)     mov     a, 0                    ; Specify bank 0
                                   (0959)     asr     a                       ; Store in carry flag
                                   (0960)                                     ; Load bank 0 table:
                                   (0961)     mov     A, >LoadConfigTBL_response2_Bank0
                                   (0962)     mov     X, <LoadConfigTBL_response2_Bank0
                                   (0963)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0964) 
                                   (0965)     mov     a, 1                    ; Specify bank 1
                                   (0966)     asr     a                       ; Store in carry flag
                                   (0967)                                     ; Load bank 1 table:
                                   (0968)     mov     A, >LoadConfigTBL_response2_Bank1
                                   (0969)     mov     X, <LoadConfigTBL_response2_Bank1
                                   (0970)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0971) 
                                   (0972) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0973) ; set config active bit
                                   (0974) 	or		[ACTIVE_CONFIG_STATUS+response2_ADDR_OFF], response2_BIT
                                   (0975)     M8C_SetBank0                    ; Force return to bank 0
                                   (0976) 	pop		x
                                   (0977) 
                                   (0978)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0979)     ret
                                   (0980) 
09F3: 71 10    OR    F,16          (0981) ;---------------------------------------------------------------------------
                                   (0982) ; Unload Configuration response2
09F5: 41 00 E0 AND   REG[0],224    (0983) ;
09F8: 43 00 01 OR    REG[0],1      (0984) ;    Reset configuration registers for response2
                                   (0985) ;    to their values as initially configured.
09FB: 41 01 E0 AND   REG[1],224    (0986) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
09FE: 43 01 1E OR    REG[1],30     (0987) ;
                                   (0988) ;       INPUTS: None.
0A01: 70 EF    AND   F,239         (0989) ;      RETURNS: Nothing.
0A03: 41 03 E9 AND   REG[3],233    (0990) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0A06: 43 03 16 OR    REG[3],22     (0991) ;               modified as may the Page Pointer registers!
                                   (0992) ;               In the large memory model currently only the page
0A09: 41 02 E9 AND   REG[2],233    (0993) ;               pointer registers listed below are modified.  This does
                                   (0994) ;               not guarantee that in future implementations of this
0A0C: 41 B3 F0 AND   REG[179],240  (0995) ;               function other page pointer registers will not be
0A0F: 43 B3 03 OR    REG[179],3    (0996) ;               modified.
                                   (0997) ;          
0A12: 41 B4 F0 AND   REG[180],240  (0998) ;               Page Pointer Registers Modified: 
0A15: 43 B4 03 OR    REG[180],3    (0999) ;               CUR_PP
                                   (1000) ;
0A18: 41 B5 EC AND   REG[181],236  (1001) _UnloadConfig_response2:
0A1B: 43 B5 01 OR    REG[181],1    (1002)  UnloadConfig_response2:
                                   (1003)     RAM_PROLOGUE RAM_USE_CLASS_4
0A1E: 41 B6 EE AND   REG[182],238  (1004) 
                                   (1005) 	push	x
0A21: 10       PUSH  X             (1006)     M8C_SetBank0                    ; Force bank 0
0A22: 70 EF    AND   F,239         (1007)     mov     a, 0                    ; Specify bank 0
0A24: 50 00    MOV   A,0           (1008)     asr     a                       ; Store in carry flag
0A26: 67       ASR   A             (1009)                                     ; Bank 0 table address:
                                   (1010)     mov     A, >UnloadConfigTBL_response2_Bank0
0A27: 50 03    MOV   A,3           (1011)     mov     X, <UnloadConfigTBL_response2_Bank0
0A29: 57 71    MOV   X,113         (1012)     lcall   LoadConfig              ; Unload the bank 0 values
0A2B: 7C 0C 0E LCALL 0x0C0E        (1013) 
                                   (1014)     mov     a, 1                    ; Specify bank 1
0A2E: 50 01    MOV   A,1           (1015)     asr     a                       ; Store in carry flag
0A30: 67       ASR   A             (1016)                                     ; Bank 1 table address:
                                   (1017)     mov     A, >UnloadConfigTBL_response2_Bank1
0A31: 50 03    MOV   A,3           (1018)     mov     X, <UnloadConfigTBL_response2_Bank1
0A33: 57 84    MOV   X,132         (1019)     lcall   LoadConfig              ; Unload the bank 1 values
0A35: 7C 0C 0E LCALL 0x0C0E        (1020) 
                                   (1021) 	M8C_SetBank0
0A38: 62 D0 00 MOV   REG[208],0    (1022) ; writing Row_0_LogicSelect_0 register
                                   (1023) 	and		reg[b3h], ~ fh
0A3B: 2E 04 40 OR    [4],64        (1024) 	or		reg[b3h],  5h
0A3E: 70 EF    AND   F,239         (1025) ; writing Row_0_LogicSelect_1 register
0A40: 20       POP   X             (1026) 	and		reg[b4h], ~ fh
                                   (1027) 	or		reg[b4h],  5h
                                   (1028) ; writing Row_0_OutputDrive_0 register
0A41: 7F       RET                 (1029) 	and		reg[b5h], ~13h
                                   (1030) 	or		reg[b5h], 12h
                                   (1031) ; writing Row_0_OutputDrive_1 register
                                   (1032) 	and		reg[b6h], ~11h
                                   (1033) 	or		reg[b6h], 11h
                                   (1034) ; writing Port_0_GlobalSelect register
                                   (1035) 	and		reg[ 2h], ~1ah
                                   (1036) 	or		reg[ 2h], 1ah
                                   (1037) ; writing Port_0_DriveMode_2 register
                                   (1038) 	and		reg[ 3h], ~1ah
                                   (1039) ; writing Port_0_DriveMode_1 register
                                   (1040) 	M8C_SetBank1
                                   (1041) 	and		reg[ 1h], ~1fh
                                   (1042) 	or		reg[ 1h],  1h
                                   (1043) ; writing Port_0_DriveMode_0 register
                                   (1044) 	and		reg[ 0h], ~1fh
                                   (1045) 	or		reg[ 0h], 1eh
                                   (1046) 	M8C_SetBank0
                                   (1047) ; clear config active bit
                                   (1048) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1049) 	and		[ACTIVE_CONFIG_STATUS+response2_ADDR_OFF], ~response2_BIT
                                   (1050)     M8C_SetBank0                    ; Force return to bank 0
                                   (1051) 	pop		x
                                   (1052) 
                                   (1053)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1054)     ret
0A42: 10       PUSH  X             (1055) 
0A43: 70 EF    AND   F,239         (1056) ;---------------------------------------------------------------------------
0A45: 50 00    MOV   A,0           (1057) ; Load Configuration response3
0A47: 67       ASR   A             (1058) ;
                                   (1059) ;    Load configuration registers for response3.
0A48: 50 03    MOV   A,3           (1060) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0A4A: 57 9D    MOV   X,157         (1061) ;
0A4C: 7C 0C 0E LCALL 0x0C0E        (1062) ;       INPUTS: None.
                                   (1063) ;      RETURNS: Nothing.
0A4F: 50 01    MOV   A,1           (1064) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0A51: 67       ASR   A             (1065) ;               modified as may the Page Pointer registers!
                                   (1066) ;               In the large memory model currently only the page
0A52: 50 03    MOV   A,3           (1067) ;               pointer registers listed below are modified.  This does
0A54: 57 A4    MOV   X,164         (1068) ;               not guarantee that in future implementations of this
0A56: 7C 0C 0E LCALL 0x0C0E        (1069) ;               function other page pointer registers will not be
                                   (1070) ;               modified.
0A59: 70 EF    AND   F,239         (1071) ;          
                                   (1072) ;               Page Pointer Registers Modified: 
0A5B: 41 B3 F0 AND   REG[179],240  (1073) ;               CUR_PP
0A5E: 43 B3 05 OR    REG[179],5    (1074) ;
                                   (1075) _LoadConfig_response3:
0A61: 41 B4 F0 AND   REG[180],240  (1076)  LoadConfig_response3:
0A64: 43 B4 05 OR    REG[180],5    (1077)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1078) 	M8C_SetBank1
0A67: 41 B5 EC AND   REG[181],236  (1079) ; writing Port_0_DriveMode_0 register
0A6A: 43 B5 12 OR    REG[181],18   (1080) 	and		reg[ 0h], ~1fh
                                   (1081) 	or		reg[ 0h],  1h
0A6D: 41 B6 EE AND   REG[182],238  (1082) ; writing Port_0_DriveMode_1 register
0A70: 43 B6 11 OR    REG[182],17   (1083) 	and		reg[ 1h], ~1fh
                                   (1084) 	or		reg[ 1h], 1eh
0A73: 41 02 E9 AND   REG[2],233    (1085) ; writing Port_0_DriveMode_2 register
0A76: 43 02 16 OR    REG[2],22     (1086) 	M8C_SetBank0
                                   (1087) 	and		reg[ 3h], ~16h
0A79: 41 03 E9 AND   REG[3],233    (1088) 	or		reg[ 3h], 16h
                                   (1089) ; writing Port_0_GlobalSelect register
0A7C: 71 10    OR    F,16          (1090) 	and		reg[ 2h], ~16h
0A7E: 41 01 E0 AND   REG[1],224    (1091) ; writing Row_0_LogicSelect_0 register
0A81: 43 01 01 OR    REG[1],1      (1092) 	and		reg[b3h], ~ fh
                                   (1093) 	or		reg[b3h],  3h
0A84: 41 00 E0 AND   REG[0],224    (1094) ; writing Row_0_LogicSelect_1 register
0A87: 43 00 1E OR    REG[0],30     (1095) 	and		reg[b4h], ~ fh
0A8A: 70 EF    AND   F,239         (1096) 	or		reg[b4h],  3h
                                   (1097) ; writing Row_0_OutputDrive_0 register
0A8C: 62 D0 00 MOV   REG[208],0    (1098) 	and		reg[b5h], ~13h
0A8F: 26 04 BF AND   [4],191       (1099) 	or		reg[b5h],  1h
0A92: 70 EF    AND   F,239         (1100) ; writing Row_0_OutputDrive_1 register
0A94: 20       POP   X             (1101) 	and		reg[b6h], ~11h
                                   (1102) 
                                   (1103) 	push	x
0A95: 7F       RET                 (1104)     M8C_SetBank0                    ; Force bank 0
                                   (1105)     mov     a, 0                    ; Specify bank 0
                                   (1106)     asr     a                       ; Store in carry flag
                                   (1107)                                     ; Load bank 0 table:
                                   (1108)     mov     A, >LoadConfigTBL_response3_Bank0
                                   (1109)     mov     X, <LoadConfigTBL_response3_Bank0
                                   (1110)     lcall   LoadConfig              ; Load the bank 0 values
                                   (1111) 
                                   (1112)     mov     a, 1                    ; Specify bank 1
                                   (1113)     asr     a                       ; Store in carry flag
                                   (1114)                                     ; Load bank 1 table:
                                   (1115)     mov     A, >LoadConfigTBL_response3_Bank1
                                   (1116)     mov     X, <LoadConfigTBL_response3_Bank1
                                   (1117)     lcall   LoadConfig              ; Load the bank 1 values
                                   (1118) 
                                   (1119) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1120) ; set config active bit
                                   (1121) 	or		[ACTIVE_CONFIG_STATUS+response3_ADDR_OFF], response3_BIT
                                   (1122)     M8C_SetBank0                    ; Force return to bank 0
                                   (1123) 	pop		x
                                   (1124) 
                                   (1125)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1126)     ret
                                   (1127) 
0A96: 71 10    OR    F,16          (1128) ;---------------------------------------------------------------------------
                                   (1129) ; Unload Configuration response3
0A98: 41 00 E0 AND   REG[0],224    (1130) ;
0A9B: 43 00 01 OR    REG[0],1      (1131) ;    Reset configuration registers for response3
                                   (1132) ;    to their values as initially configured.
0A9E: 41 01 E0 AND   REG[1],224    (1133) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0AA1: 43 01 1E OR    REG[1],30     (1134) ;
                                   (1135) ;       INPUTS: None.
0AA4: 70 EF    AND   F,239         (1136) ;      RETURNS: Nothing.
0AA6: 41 03 F1 AND   REG[3],241    (1137) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0AA9: 43 03 0E OR    REG[3],14     (1138) ;               modified as may the Page Pointer registers!
                                   (1139) ;               In the large memory model currently only the page
0AAC: 41 02 F1 AND   REG[2],241    (1140) ;               pointer registers listed below are modified.  This does
                                   (1141) ;               not guarantee that in future implementations of this
0AAF: 41 B0 FC AND   REG[176],252  (1142) ;               function other page pointer registers will not be
0AB2: 43 B0 01 OR    REG[176],1    (1143) ;               modified.
                                   (1144) ;          
0AB5: 41 B3 F0 AND   REG[179],240  (1145) ;               Page Pointer Registers Modified: 
0AB8: 43 B3 03 OR    REG[179],3    (1146) ;               CUR_PP
                                   (1147) ;
0ABB: 41 B4 F0 AND   REG[180],240  (1148) _UnloadConfig_response3:
0ABE: 43 B4 03 OR    REG[180],3    (1149)  UnloadConfig_response3:
                                   (1150)     RAM_PROLOGUE RAM_USE_CLASS_4
0AC1: 41 B5 EC AND   REG[181],236  (1151) 
0AC4: 43 B5 01 OR    REG[181],1    (1152) 	push	x
                                   (1153)     M8C_SetBank0                    ; Force bank 0
0AC7: 41 B6 EE AND   REG[182],238  (1154)     mov     a, 0                    ; Specify bank 0
                                   (1155)     asr     a                       ; Store in carry flag
0ACA: 10       PUSH  X             (1156)                                     ; Bank 0 table address:
0ACB: 70 EF    AND   F,239         (1157)     mov     A, >UnloadConfigTBL_response3_Bank0
0ACD: 50 00    MOV   A,0           (1158)     mov     X, <UnloadConfigTBL_response3_Bank0
0ACF: 67       ASR   A             (1159)     lcall   LoadConfig              ; Unload the bank 0 values
                                   (1160) 
0AD0: 50 03    MOV   A,3           (1161)     mov     a, 1                    ; Specify bank 1
0AD2: 57 BE    MOV   X,190         (1162)     asr     a                       ; Store in carry flag
0AD4: 7C 0C 0E LCALL 0x0C0E        (1163)                                     ; Bank 1 table address:
                                   (1164)     mov     A, >UnloadConfigTBL_response3_Bank1
0AD7: 50 01    MOV   A,1           (1165)     mov     X, <UnloadConfigTBL_response3_Bank1
0AD9: 67       ASR   A             (1166)     lcall   LoadConfig              ; Unload the bank 1 values
                                   (1167) 
0ADA: 50 03    MOV   A,3           (1168) 	M8C_SetBank0
0ADC: 57 D1    MOV   X,209         (1169) ; writing Row_0_LogicSelect_0 register
0ADE: 7C 0C 0E LCALL 0x0C0E        (1170) 	and		reg[b3h], ~ fh
                                   (1171) 	or		reg[b3h],  5h
0AE1: 62 D0 00 MOV   REG[208],0    (1172) ; writing Row_0_LogicSelect_1 register
                                   (1173) 	and		reg[b4h], ~ fh
0AE4: 2E 04 80 OR    [4],128       (1174) 	or		reg[b4h],  5h
0AE7: 70 EF    AND   F,239         (1175) ; writing Row_0_OutputDrive_0 register
0AE9: 20       POP   X             (1176) 	and		reg[b5h], ~13h
                                   (1177) 	or		reg[b5h], 12h
                                   (1178) ; writing Row_0_OutputDrive_1 register
0AEA: 7F       RET                 (1179) 	and		reg[b6h], ~11h
                                   (1180) 	or		reg[b6h], 11h
                                   (1181) ; writing Port_0_GlobalSelect register
                                   (1182) 	and		reg[ 2h], ~16h
                                   (1183) 	or		reg[ 2h], 16h
                                   (1184) ; writing Port_0_DriveMode_2 register
                                   (1185) 	and		reg[ 3h], ~16h
                                   (1186) ; writing Port_0_DriveMode_1 register
                                   (1187) 	M8C_SetBank1
                                   (1188) 	and		reg[ 1h], ~1fh
                                   (1189) 	or		reg[ 1h],  1h
                                   (1190) ; writing Port_0_DriveMode_0 register
                                   (1191) 	and		reg[ 0h], ~1fh
                                   (1192) 	or		reg[ 0h], 1eh
                                   (1193) 	M8C_SetBank0
                                   (1194) ; clear config active bit
                                   (1195) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1196) 	and		[ACTIVE_CONFIG_STATUS+response3_ADDR_OFF], ~response3_BIT
                                   (1197)     M8C_SetBank0                    ; Force return to bank 0
                                   (1198) 	pop		x
                                   (1199) 
                                   (1200)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1201)     ret
                                   (1202) 
                                   (1203) ;---------------------------------------------------------------------------
                                   (1204) ; Load Configuration response4
0AEB: 10       PUSH  X             (1205) ;
0AEC: 70 EF    AND   F,239         (1206) ;    Load configuration registers for response4.
0AEE: 50 00    MOV   A,0           (1207) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0AF0: 67       ASR   A             (1208) ;
                                   (1209) ;       INPUTS: None.
0AF1: 50 03    MOV   A,3           (1210) ;      RETURNS: Nothing.
0AF3: 57 EA    MOV   X,234         (1211) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0AF5: 7C 0C 0E LCALL 0x0C0E        (1212) ;               modified as may the Page Pointer registers!
                                   (1213) ;               In the large memory model currently only the page
0AF8: 50 01    MOV   A,1           (1214) ;               pointer registers listed below are modified.  This does
0AFA: 67       ASR   A             (1215) ;               not guarantee that in future implementations of this
                                   (1216) ;               function other page pointer registers will not be
0AFB: 50 03    MOV   A,3           (1217) ;               modified.
0AFD: 57 F1    MOV   X,241         (1218) ;          
0AFF: 7C 0C 0E LCALL 0x0C0E        (1219) ;               Page Pointer Registers Modified: 
                                   (1220) ;               CUR_PP
0B02: 70 EF    AND   F,239         (1221) ;
                                   (1222) _LoadConfig_response4:
0B04: 41 B0 FC AND   REG[176],252  (1223)  LoadConfig_response4:
                                   (1224)     RAM_PROLOGUE RAM_USE_CLASS_4
0B07: 41 B3 F0 AND   REG[179],240  (1225) 	M8C_SetBank1
0B0A: 43 B3 05 OR    REG[179],5    (1226) ; writing Port_0_DriveMode_0 register
                                   (1227) 	and		reg[ 0h], ~1fh
0B0D: 41 B4 F0 AND   REG[180],240  (1228) 	or		reg[ 0h],  1h
0B10: 43 B4 05 OR    REG[180],5    (1229) ; writing Port_0_DriveMode_1 register
                                   (1230) 	and		reg[ 1h], ~1fh
0B13: 41 B5 EC AND   REG[181],236  (1231) 	or		reg[ 1h], 1eh
0B16: 43 B5 12 OR    REG[181],18   (1232) ; writing Port_0_DriveMode_2 register
                                   (1233) 	M8C_SetBank0
0B19: 41 B6 EE AND   REG[182],238  (1234) 	and		reg[ 3h], ~ eh
0B1C: 43 B6 11 OR    REG[182],17   (1235) 	or		reg[ 3h],  eh
                                   (1236) ; writing Port_0_GlobalSelect register
0B1F: 41 02 F1 AND   REG[2],241    (1237) 	and		reg[ 2h], ~ eh
0B22: 43 02 0E OR    REG[2],14     (1238) ; writing Row_0_InputMux register
                                   (1239) 	and		reg[b0h], ~ 3h
0B25: 41 03 F1 AND   REG[3],241    (1240) 	or		reg[b0h],  1h
                                   (1241) ; writing Row_0_LogicSelect_0 register
0B28: 71 10    OR    F,16          (1242) 	and		reg[b3h], ~ fh
0B2A: 41 01 E0 AND   REG[1],224    (1243) 	or		reg[b3h],  3h
0B2D: 43 01 01 OR    REG[1],1      (1244) ; writing Row_0_LogicSelect_1 register
                                   (1245) 	and		reg[b4h], ~ fh
0B30: 41 00 E0 AND   REG[0],224    (1246) 	or		reg[b4h],  3h
0B33: 43 00 1E OR    REG[0],30     (1247) ; writing Row_0_OutputDrive_0 register
0B36: 70 EF    AND   F,239         (1248) 	and		reg[b5h], ~13h
                                   (1249) 	or		reg[b5h],  1h
0B38: 62 D0 00 MOV   REG[208],0    (1250) ; writing Row_0_OutputDrive_1 register
0B3B: 26 04 7F AND   [4],127       (1251) 	and		reg[b6h], ~11h
0B3E: 70 EF    AND   F,239         (1252) 
0B40: 20       POP   X             (1253) 	push	x
                                   (1254)     M8C_SetBank0                    ; Force bank 0
                                   (1255)     mov     a, 0                    ; Specify bank 0
0B41: 7F       RET                 (1256)     asr     a                       ; Store in carry flag
                                   (1257)                                     ; Load bank 0 table:
                                   (1258)     mov     A, >LoadConfigTBL_response4_Bank0
                                   (1259)     mov     X, <LoadConfigTBL_response4_Bank0
                                   (1260)     lcall   LoadConfig              ; Load the bank 0 values
                                   (1261) 
                                   (1262)     mov     a, 1                    ; Specify bank 1
                                   (1263)     asr     a                       ; Store in carry flag
                                   (1264)                                     ; Load bank 1 table:
                                   (1265)     mov     A, >LoadConfigTBL_response4_Bank1
                                   (1266)     mov     X, <LoadConfigTBL_response4_Bank1
                                   (1267)     lcall   LoadConfig              ; Load the bank 1 values
                                   (1268) 
                                   (1269) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1270) ; set config active bit
                                   (1271) 	or		[ACTIVE_CONFIG_STATUS+response4_ADDR_OFF], response4_BIT
                                   (1272)     M8C_SetBank0                    ; Force return to bank 0
                                   (1273) 	pop		x
                                   (1274) 
                                   (1275)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1276)     ret
                                   (1277) 
                                   (1278) ;---------------------------------------------------------------------------
                                   (1279) ; Unload Configuration response4
0B42: 71 10    OR    F,16          (1280) ;
                                   (1281) ;    Reset configuration registers for response4
0B44: 41 00 E0 AND   REG[0],224    (1282) ;    to their values as initially configured.
0B47: 43 00 01 OR    REG[0],1      (1283) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (1284) ;
0B4A: 41 01 E0 AND   REG[1],224    (1285) ;       INPUTS: None.
0B4D: 43 01 1E OR    REG[1],30     (1286) ;      RETURNS: Nothing.
                                   (1287) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0B50: 70 EF    AND   F,239         (1288) ;               modified as may the Page Pointer registers!
0B52: 41 03 E1 AND   REG[3],225    (1289) ;               In the large memory model currently only the page
0B55: 43 03 1E OR    REG[3],30     (1290) ;               pointer registers listed below are modified.  This does
                                   (1291) ;               not guarantee that in future implementations of this
0B58: 41 02 E1 AND   REG[2],225    (1292) ;               function other page pointer registers will not be
                                   (1293) ;               modified.
0B5B: 41 B3 F0 AND   REG[179],240  (1294) ;          
0B5E: 43 B3 03 OR    REG[179],3    (1295) ;               Page Pointer Registers Modified: 
                                   (1296) ;               CUR_PP
0B61: 41 B4 F0 AND   REG[180],240  (1297) ;
0B64: 43 B4 03 OR    REG[180],3    (1298) _UnloadConfig_response4:
                                   (1299)  UnloadConfig_response4:
0B67: 41 B5 EC AND   REG[181],236  (1300)     RAM_PROLOGUE RAM_USE_CLASS_4
0B6A: 43 B5 01 OR    REG[181],1    (1301) 
                                   (1302) 	push	x
0B6D: 41 B6 EE AND   REG[182],238  (1303)     M8C_SetBank0                    ; Force bank 0
                                   (1304)     mov     a, 0                    ; Specify bank 0
0B70: 10       PUSH  X             (1305)     asr     a                       ; Store in carry flag
0B71: 70 EF    AND   F,239         (1306)                                     ; Bank 0 table address:
0B73: 50 00    MOV   A,0           (1307)     mov     A, >UnloadConfigTBL_response4_Bank0
0B75: 67       ASR   A             (1308)     mov     X, <UnloadConfigTBL_response4_Bank0
                                   (1309)     lcall   LoadConfig              ; Unload the bank 0 values
0B76: 50 04    MOV   A,4           (1310) 
0B78: 57 0B    MOV   X,11          (1311)     mov     a, 1                    ; Specify bank 1
0B7A: 7C 0C 0E LCALL 0x0C0E        (1312)     asr     a                       ; Store in carry flag
                                   (1313)                                     ; Bank 1 table address:
0B7D: 50 01    MOV   A,1           (1314)     mov     A, >UnloadConfigTBL_response4_Bank1
0B7F: 67       ASR   A             (1315)     mov     X, <UnloadConfigTBL_response4_Bank1
                                   (1316)     lcall   LoadConfig              ; Unload the bank 1 values
0B80: 50 04    MOV   A,4           (1317) 
0B82: 57 12    MOV   X,18          (1318) 	M8C_SetBank0
0B84: 7C 0C 0E LCALL 0x0C0E        (1319) ; writing Row_0_InputMux register
                                   (1320) 	and		reg[b0h], ~ 3h
0B87: 62 D0 00 MOV   REG[208],0    (1321) ; writing Row_0_LogicSelect_0 register
                                   (1322) 	and		reg[b3h], ~ fh
0B8A: 2E 05 01 OR    [5],1         (1323) 	or		reg[b3h],  5h
0B8D: 70 EF    AND   F,239         (1324) ; writing Row_0_LogicSelect_1 register
0B8F: 20       POP   X             (1325) 	and		reg[b4h], ~ fh
                                   (1326) 	or		reg[b4h],  5h
                                   (1327) ; writing Row_0_OutputDrive_0 register
0B90: 7F       RET                 (1328) 	and		reg[b5h], ~13h
                                   (1329) 	or		reg[b5h], 12h
                                   (1330) ; writing Row_0_OutputDrive_1 register
                                   (1331) 	and		reg[b6h], ~11h
                                   (1332) 	or		reg[b6h], 11h
                                   (1333) ; writing Port_0_GlobalSelect register
                                   (1334) 	and		reg[ 2h], ~ eh
                                   (1335) 	or		reg[ 2h],  eh
                                   (1336) ; writing Port_0_DriveMode_2 register
                                   (1337) 	and		reg[ 3h], ~ eh
                                   (1338) ; writing Port_0_DriveMode_1 register
                                   (1339) 	M8C_SetBank1
                                   (1340) 	and		reg[ 1h], ~1fh
                                   (1341) 	or		reg[ 1h],  1h
                                   (1342) ; writing Port_0_DriveMode_0 register
                                   (1343) 	and		reg[ 0h], ~1fh
                                   (1344) 	or		reg[ 0h], 1eh
                                   (1345) 	M8C_SetBank0
                                   (1346) ; clear config active bit
                                   (1347) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1348) 	and		[ACTIVE_CONFIG_STATUS+response4_ADDR_OFF], ~response4_BIT
                                   (1349)     M8C_SetBank0                    ; Force return to bank 0
                                   (1350) 	pop		x
                                   (1351) 
                                   (1352)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1353)     ret
0B91: 10       PUSH  X             (1354) 
0B92: 70 EF    AND   F,239         (1355) ;---------------------------------------------------------------------------
0B94: 50 00    MOV   A,0           (1356) ; Load Configuration servo_transmit
0B96: 67       ASR   A             (1357) ;
                                   (1358) ;    Load configuration registers for servo_transmit.
0B97: 50 04    MOV   A,4           (1359) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0B99: 57 1B    MOV   X,27          (1360) ;
0B9B: 7C 0C 0E LCALL 0x0C0E        (1361) ;       INPUTS: None.
                                   (1362) ;      RETURNS: Nothing.
0B9E: 50 01    MOV   A,1           (1363) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0BA0: 67       ASR   A             (1364) ;               modified as may the Page Pointer registers!
                                   (1365) ;               In the large memory model currently only the page
0BA1: 50 04    MOV   A,4           (1366) ;               pointer registers listed below are modified.  This does
0BA3: 57 1E    MOV   X,30          (1367) ;               not guarantee that in future implementations of this
0BA5: 7C 0C 0E LCALL 0x0C0E        (1368) ;               function other page pointer registers will not be
                                   (1369) ;               modified.
0BA8: 70 EF    AND   F,239         (1370) ;          
                                   (1371) ;               Page Pointer Registers Modified: 
0BAA: 41 B3 F0 AND   REG[179],240  (1372) ;               CUR_PP
0BAD: 43 B3 05 OR    REG[179],5    (1373) ;
                                   (1374) _LoadConfig_servo_transmit:
0BB0: 41 B4 F0 AND   REG[180],240  (1375)  LoadConfig_servo_transmit:
0BB3: 43 B4 05 OR    REG[180],5    (1376)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1377) 	M8C_SetBank1
0BB6: 41 B5 EC AND   REG[181],236  (1378) ; writing Port_0_DriveMode_0 register
0BB9: 43 B5 12 OR    REG[181],18   (1379) 	and		reg[ 0h], ~1fh
                                   (1380) 	or		reg[ 0h],  1h
0BBC: 41 B6 EE AND   REG[182],238  (1381) ; writing Port_0_DriveMode_1 register
0BBF: 43 B6 11 OR    REG[182],17   (1382) 	and		reg[ 1h], ~1fh
                                   (1383) 	or		reg[ 1h], 1eh
0BC2: 41 02 E1 AND   REG[2],225    (1384) ; writing Port_0_DriveMode_2 register
0BC5: 43 02 1E OR    REG[2],30     (1385) 	M8C_SetBank0
                                   (1386) 	and		reg[ 3h], ~1eh
0BC8: 41 03 E1 AND   REG[3],225    (1387) 	or		reg[ 3h], 1eh
                                   (1388) ; writing Port_0_GlobalSelect register
0BCB: 71 10    OR    F,16          (1389) 	and		reg[ 2h], ~1eh
0BCD: 41 01 E0 AND   REG[1],224    (1390) ; writing Row_0_LogicSelect_0 register
0BD0: 43 01 01 OR    REG[1],1      (1391) 	and		reg[b3h], ~ fh
                                   (1392) 	or		reg[b3h],  3h
0BD3: 41 00 E0 AND   REG[0],224    (1393) ; writing Row_0_LogicSelect_1 register
0BD6: 43 00 1E OR    REG[0],30     (1394) 	and		reg[b4h], ~ fh
0BD9: 70 EF    AND   F,239         (1395) 	or		reg[b4h],  3h
                                   (1396) ; writing Row_0_OutputDrive_0 register
0BDB: 62 D0 00 MOV   REG[208],0    (1397) 	and		reg[b5h], ~13h
0BDE: 26 05 FE AND   [5],254       (1398) 	or		reg[b5h],  1h
0BE1: 70 EF    AND   F,239         (1399) ; writing Row_0_OutputDrive_1 register
0BE3: 20       POP   X             (1400) 	and		reg[b6h], ~11h
                                   (1401) 
                                   (1402) 	push	x
0BE4: 7F       RET                 (1403)     M8C_SetBank0                    ; Force bank 0
                                   (1404)     mov     a, 0                    ; Specify bank 0
                                   (1405)     asr     a                       ; Store in carry flag
                                   (1406)                                     ; Load bank 0 table:
                                   (1407)     mov     A, >LoadConfigTBL_servo_transmit_Bank0
                                   (1408)     mov     X, <LoadConfigTBL_servo_transmit_Bank0
                                   (1409)     lcall   LoadConfig              ; Load the bank 0 values
                                   (1410) 
                                   (1411)     mov     a, 1                    ; Specify bank 1
                                   (1412)     asr     a                       ; Store in carry flag
                                   (1413)                                     ; Load bank 1 table:
                                   (1414)     mov     A, >LoadConfigTBL_servo_transmit_Bank1
                                   (1415)     mov     X, <LoadConfigTBL_servo_transmit_Bank1
                                   (1416)     lcall   LoadConfig              ; Load the bank 1 values
                                   (1417) 
                                   (1418) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1419) ; set config active bit
                                   (1420) 	or		[ACTIVE_CONFIG_STATUS+servo_transmit_ADDR_OFF], servo_transmit_BIT
                                   (1421)     M8C_SetBank0                    ; Force return to bank 0
                                   (1422) 	pop		x
                                   (1423) 
                                   (1424)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1425)     ret
                                   (1426) 
                                   (1427) ;---------------------------------------------------------------------------
                                   (1428) ; Unload Configuration servo_transmit
0BE5: 10       PUSH  X             (1429) ;
0BE6: 70 EF    AND   F,239         (1430) ;    Reset configuration registers for servo_transmit
0BE8: 50 00    MOV   A,0           (1431) ;    to their values as initially configured.
0BEA: 67       ASR   A             (1432) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (1433) ;
0BEB: 50 06    MOV   A,6           (1434) ;       INPUTS: None.
0BED: 57 0E    MOV   X,14          (1435) ;      RETURNS: Nothing.
0BEF: 7C 0C 0E LCALL 0x0C0E        (1436) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (1437) ;               modified as may the Page Pointer registers!
0BF2: 50 01    MOV   A,1           (1438) ;               In the large memory model currently only the page
0BF4: 67       ASR   A             (1439) ;               pointer registers listed below are modified.  This does
                                   (1440) ;               not guarantee that in future implementations of this
0BF5: 50 06    MOV   A,6           (1441) ;               function other page pointer registers will not be
0BF7: 57 2F    MOV   X,47          (1442) ;               modified.
0BF9: 7C 0C 0E LCALL 0x0C0E        (1443) ;          
                                   (1444) ;               Page Pointer Registers Modified: 
0BFC: 70 EF    AND   F,239         (1445) ;               CUR_PP
                                   (1446) ;
0BFE: 62 D0 00 MOV   REG[208],0    (1447) _UnloadConfig_servo_transmit:
0C01: 55 04 00 MOV   [4],0         (1448)  UnloadConfig_servo_transmit:
0C04: 62 D0 00 MOV   REG[208],0    (1449)     RAM_PROLOGUE RAM_USE_CLASS_4
0C07: 55 05 00 MOV   [5],0         (1450) 
0C0A: 70 EF    AND   F,239         (1451) 	push	x
0C0C: 20       POP   X             (1452)     M8C_SetBank0                    ; Force bank 0
                                   (1453)     mov     a, 0                    ; Specify bank 0
                                   (1454)     asr     a                       ; Store in carry flag
0C0D: 7F       RET                 (1455)                                     ; Bank 0 table address:
                                   (1456)     mov     A, >UnloadConfigTBL_servo_transmit_Bank0
                                   (1457)     mov     X, <UnloadConfigTBL_servo_transmit_Bank0
                                   (1458)     lcall   LoadConfig              ; Unload the bank 0 values
                                   (1459) 
                                   (1460)     mov     a, 1                    ; Specify bank 1
                                   (1461)     asr     a                       ; Store in carry flag
                                   (1462)                                     ; Bank 1 table address:
                                   (1463)     mov     A, >UnloadConfigTBL_servo_transmit_Bank1
                                   (1464)     mov     X, <UnloadConfigTBL_servo_transmit_Bank1
                                   (1465)     lcall   LoadConfig              ; Unload the bank 1 values
                                   (1466) 
                                   (1467) 	M8C_SetBank0
                                   (1468) ; writing Row_0_LogicSelect_0 register
                                   (1469) 	and		reg[b3h], ~ fh
                                   (1470) 	or		reg[b3h],  5h
                                   (1471) ; writing Row_0_LogicSelect_1 register
                                   (1472) 	and		reg[b4h], ~ fh
                                   (1473) 	or		reg[b4h],  5h
                                   (1474) ; writing Row_0_OutputDrive_0 register
                                   (1475) 	and		reg[b5h], ~13h
                                   (1476) 	or		reg[b5h], 12h
0C0E: 38 02    ADD   SP,2          (1477) ; writing Row_0_OutputDrive_1 register
0C10: 10       PUSH  X             (1478) 	and		reg[b6h], ~11h
0C11: 08       PUSH  A             (1479) 	or		reg[b6h], 11h
0C12: 4F       MOV   X,SP          (1480) ; writing Port_0_GlobalSelect register
0C13: 56 FC 00 MOV   [X-4],0       (1481) 	and		reg[ 2h], ~1eh
0C16: D0 04    JNC   0x0C1B        (1482) 	or		reg[ 2h], 1eh
0C18: 56 FC 01 MOV   [X-4],1       (1483) ; writing Port_0_DriveMode_2 register
                                   (1484) 	and		reg[ 3h], ~1eh
0C1B: 18       POP   A             (1485) ; writing Port_0_DriveMode_1 register
0C1C: 20       POP   X             (1486) 	M8C_SetBank1
                                   (1487) 	and		reg[ 1h], ~1fh
                                   (1488) 	or		reg[ 1h],  1h
0C1D: 70 EF    AND   F,239         (1489) ; writing Port_0_DriveMode_0 register
0C1F: 62 E3 00 MOV   REG[227],0    (1490) 	and		reg[ 0h], ~1fh
0C22: 10       PUSH  X             (1491) 	or		reg[ 0h], 1eh
0C23: 08       PUSH  A             (1492) 	M8C_SetBank0
0C24: 28       ROMX                (1493) ; clear config active bit
0C25: 39 FF    CMP   A,255         (1494) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
0C27: A0 1F    JZ    0x0C47        (1495) 	and		[ACTIVE_CONFIG_STATUS+servo_transmit_ADDR_OFF], ~servo_transmit_BIT
0C29: 4F       MOV   X,SP          (1496)     M8C_SetBank0                    ; Force return to bank 0
0C2A: 48 FC 01 TST   [X-4],1       (1497) 	pop		x
0C2D: A0 03    JZ    0x0C31        (1498) 
0C2F: 71 10    OR    F,16          (1499)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1500)     ret
0C31: 54 FD    MOV   [X-3],A       (1501) 
0C33: 18       POP   A             (1502) ;---------------------------------------------------------------------------
0C34: 20       POP   X             (1503) ; Unload Configuration Total
0C35: 75       INC   X             (1504) ;
0C36: 09 00    ADC   A,0           (1505) ;    Reset configuration registers for Total
0C38: 10       PUSH  X             (1506) ;    to their values as initially configured.
0C39: 08       PUSH  A             (1507) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0C3A: 28       ROMX                (1508) ;
0C3B: 4F       MOV   X,SP          (1509) ;       INPUTS: None.
0C3C: 59 FD    MOV   X,[X-3]       (1510) ;      RETURNS: Nothing.
0C3E: 61 00    MOV   REG[X+0],A    (1511) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0C40: 18       POP   A             (1512) ;               modified as may the Page Pointer registers!
0C41: 20       POP   X             (1513) ;               In the large memory model currently only the page
0C42: 75       INC   X             (1514) ;               pointer registers listed below are modified.  This does
0C43: 09 00    ADC   A,0           (1515) ;               not guarantee that in future implementations of this
0C45: 8F D7    JMP   0x0C1D        (1516) ;               function other page pointer registers will not be
                                   (1517) ;               modified.
0C47: 38 FC    ADD   SP,252        (1518) ;          
0C49: 70 3F    AND   F,63
0C4B: 71 C0    OR    F,192         (1519) ;               Page Pointer Registers Modified: 
0C4E: 08       PUSH  A             (1520) ;               CUR_PP

FILE: lib\wait_recvint.asm
0C4F: 10       PUSH  X             (0104) ;;*****************************************************************************
0C50: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: WAIT_RECVINT.asm
0C52: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
0C53: 58 01    MOV   X,[1]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
0C55: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
0C57: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
0C58: 21 08    AND   A,8           (0114) ;;*****************************************************************************
0C5A: B0 04    JNZ   0x0C5F        (0115) 
0C5C: 18       POP   A             (0116) include "m8c.inc"
0C5D: 80 5E    JMP   0x0CBC        (0117) include "memory.inc"
                                   (0118) include "WAIT_RECV.inc"
                                   (0119) 
                                   (0120) 
0C5F: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
0C60: 21 E0    AND   A,224         (0124) export  _WAIT_RECV_ISR
0C62: A0 12    JZ    0x0C75        (0125) 
                                   (0126) 
0C64: 2C 00    OR    [0],A         (0127) IF (WAIT_RECV_RXBUF_ENABLE)
                                   (0128) export  WAIT_RECV_aRxBuffer
0C66: 49 2A 00 TST   REG[42],0     (0129) export _WAIT_RECV_aRxBuffer
                                   (0130) export  WAIT_RECV_bRxCnt
0C69: 21 20    AND   A,32          (0131) export _WAIT_RECV_bRxCnt
0C6B: A0 50    JZ    0x0CBC        (0132) export  WAIT_RECV_fStatus
                                   (0133) export _WAIT_RECV_fStatus
                                   (0134) ENDIF
                                   (0135) 
0C6D: 41 2B FE AND   REG[43],254   (0136) 
0C70: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
0C73: 80 48    JMP   0x0CBC        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (WAIT_RECV_RXBUF_ENABLE)
0C75: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  WAIT_RECV_fStatus:
                                   (0144) _WAIT_RECV_fStatus:      BLK  1
0C77: 47 00 01 TST   [0],1         (0145)  WAIT_RECV_bRxCnt:
0C7A: B0 41    JNZ   0x0CBC        (0146) _WAIT_RECV_bRxCnt:       BLK  1
                                   (0147) AREA WAIT_RECV_RAM(RAM,REL,CON)
0C7C: 39 00    CMP   A,0           (0148)  WAIT_RECV_aRxBuffer:    
0C7E: B0 14    JNZ   0x0C93        (0149) _WAIT_RECV_aRxBuffer:    BLK WAIT_RECV_RX_BUFFER_SIZE
0C80: 2E 00 01 OR    [0],1         (0150) ENDIF
                                   (0151) 
0C83: 62 D3 00 MOV   REG[211],0    (0152) 
0C86: 70 3F    AND   F,63
0C88: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
0C8A: 56 68 00 MOV   [X+104],0     (0154) 
0C8D: 70 3F    AND   F,63
0C8F: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
0C91: 80 2A    JMP   0x0CBC        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
0C93: 3C 01 0F CMP   [1],15        (0167) ;------------------------
0C96: C0 14    JC    0x0CAB        (0168) 
0C98: 2E 00 10 OR    [0],16        (0169) 
                                   (0170) ;------------------------
0C9B: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
0C9E: 70 3F    AND   F,63
0CA0: 71 80    OR    F,128         (0172) ;------------------------
0CA2: 56 68 00 MOV   [X+104],0     (0173) 
0CA5: 70 3F    AND   F,63
0CA7: 71 00    OR    F,0           (0174) 
0CA9: 80 12    JMP   0x0CBC        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
0CAB: 75       INC   X             (0179) 
0CAC: 5A 01    MOV   [1],X         (0180) 
0CAE: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
0CAF: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
0CB2: 70 3F    AND   F,63
0CB4: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _WAIT_RECV_ISR
0CB6: 54 68    MOV   [X+104],A     (0185) ;
0CB8: 70 3F    AND   F,63
0CBA: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
0CBC: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
0CBD: 60 D3    MOV   REG[211],A    (0191) _WAIT_RECV_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
0CBF: 20       POP   X             (0195)    ; Insert your custom code below this banner
0CC0: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
0CC2: 43 E1 04 OR    REG[225],4    (0201)    ; Insert your custom code above this banner

FILE: lib\wait_recv.asm
                                   (0121) ;;*****************************************************************************
0CC5: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: WAIT_RECV.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "WAIT_RECV.inc"
0CC6: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
0CC9: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   WAIT_RECV_EnableInt
                                   (0155) export  _WAIT_RECV_EnableInt
                                   (0156) export   WAIT_RECV_DisableInt
                                   (0157) export  _WAIT_RECV_DisableInt
                                   (0158) export   WAIT_RECV_Start
                                   (0159) export  _WAIT_RECV_Start
                                   (0160) export   WAIT_RECV_Stop
                                   (0161) export  _WAIT_RECV_Stop
                                   (0162) export   WAIT_RECV_bReadRxData
                                   (0163) export  _WAIT_RECV_bReadRxData
                                   (0164) export   WAIT_RECV_bReadRxStatus
                                   (0165) export  _WAIT_RECV_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bWAIT_RECV_ReadRxData
                                   (0170) export _bWAIT_RECV_ReadRxData
                                   (0171) export  bWAIT_RECV_ReadRxStatus
                                   (0172) export _bWAIT_RECV_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  WAIT_RECV_cGetChar
0CCA: 29 01    OR    A,1           (0179) export _WAIT_RECV_cGetChar
0CCC: 60 2B    MOV   REG[43],A     (0180) export  WAIT_RECV_cReadChar
                                   (0181) export _WAIT_RECV_cReadChar
0CCE: 7F       RET                 (0182) export  WAIT_RECV_iReadChar
                                   (0183) export _WAIT_RECV_iReadChar
                                   (0184) 
                                   (0185) IF (WAIT_RECV_RXBUF_ENABLE)
                                   (0186) export  WAIT_RECV_CmdReset
                                   (0187) export _WAIT_RECV_CmdReset
                                   (0188) export  WAIT_RECV_bCmdCheck
                                   (0189) export _WAIT_RECV_bCmdCheck
                                   (0190) export  WAIT_RECV_bCmdLength
                                   (0191) export _WAIT_RECV_bCmdLength
                                   (0192) export  WAIT_RECV_bErrCheck
                                   (0193) export _WAIT_RECV_bErrCheck
                                   (0194) 
                                   (0195) export  WAIT_RECV_szGetParam
                                   (0196) export _WAIT_RECV_szGetParam
                                   (0197) export  WAIT_RECV_szGetRestOfParams
                                   (0198) export _WAIT_RECV_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA WAIT_RECV_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
0CCF: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
0CD2: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: WAIT_RECV_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  WAIT_RECV_EnableInt:
                                   (0238) _WAIT_RECV_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
0CD3: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask WAIT_RECV_INT_REG, WAIT_RECV_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
0CD5: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: WAIT_RECV_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  WAIT_RECV_DisableInt:
                                   (0267) _WAIT_RECV_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask WAIT_RECV_INT_REG, WAIT_RECV_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
0CD6: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
0CD8: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: WAIT_RECV_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  WAIT_RECV_Start:
                                   (0297) _WAIT_RECV_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[WAIT_RECV_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: WAIT_RECV_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
0CD9: 49 2B 08 TST   REG[43],8     (0311) ;
0CDC: AF FC    JZ    0x0CD9        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
0CDE: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
0CE0: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  WAIT_RECV_Stop:
                                   (0326) _WAIT_RECV_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[WAIT_RECV_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: WAIT_RECV_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
0CE1: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
0CE3: 08       PUSH  A             (0347) ;
0CE4: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
0CE6: B0 04    JNZ   0x0CEB        (0349) ;    The A and X registers may be modified by this or future implementations
0CE8: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
0CE9: 80 0B    JMP   0x0CF5        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
0CEB: 5D 2A    MOV   A,REG[42]     (0354) ;
0CED: 4B       SWAP  A,X           (0355)  WAIT_RECV_bReadRxData:
                                   (0356) _WAIT_RECV_bReadRxData:
0CEE: 18       POP   A             (0357)  bWAIT_RECV_ReadRxData:
0CEF: 21 A0    AND   A,160         (0358) _bWAIT_RECV_ReadRxData:
0CF1: B0 03    JNZ   0x0CF5        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
0CF3: 4B       SWAP  A,X           (0360)    mov A, REG[WAIT_RECV_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
0CF4: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
0CF5: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: WAIT_RECV_bReadRxStatus
                                   (0368) ;
0CF7: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  WAIT_RECV_bReadRxStatus:
                                   (0388) _WAIT_RECV_bReadRxStatus:
                                   (0389)  bWAIT_RECV_ReadRxStatus:
                                   (0390) _bWAIT_RECV_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[WAIT_RECV_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: WAIT_RECV_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
0CF8: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
0CFA: 21 E8    AND   A,232         (0408) ;
0CFC: 08       PUSH  A             (0409) ;  ARGUMENTS:
0CFD: 21 08    AND   A,8           (0410) ;      none
0CFF: B0 07    JNZ   0x0D07        (0411) ;
0D01: 18       POP   A             (0412) ;  RETURNS:
0D02: 29 01    OR    A,1           (0413) ;     char that is returned from UART
0D04: 4B       SWAP  A,X           (0414) ;
0D05: 80 07    JMP   0x0D0D        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
0D07: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
0D08: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
0D0A: 4B       SWAP  A,X           (0420) ;    functions.
0D0B: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
0D0D: 7F       RET                 (0426)  WAIT_RECV_cGetChar:
                                   (0427) _WAIT_RECV_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[WAIT_RECV_CONTROL_REG],WAIT_RECV_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[WAIT_RECV_RX_BUFFER_REG]           ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: WAIT_RECV_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  WAIT_RECV_cReadChar:
                                   (0463) _WAIT_RECV_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[WAIT_RECV_CONTROL_REG]                       ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,WAIT_RECV_RX_COMPLETE                            ; Check if a character is ready
0D0E: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
0D11: 55 68 00 MOV   [104],0       (0470)    pop  A
0D14: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
0D17: 55 E5 00 MOV   [ID+1],0      (0472) 
0D1A: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
0D1D: 55 01 00 MOV   [1],0         (0474)    mov  A,REG[WAIT_RECV_RX_BUFFER_REG]                     ; Read data first, then
0D20: 26 00 00 AND   [0],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
0D23: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(WAIT_RECV_RX_PARITY_ERROR | WAIT_RECV_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_WAIT_RECV_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: WAIT_RECV_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
0D24: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
0D27: 51 00    MOV   A,[0]         (0511) ;        0x40CC    Overrun Error
0D29: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
0D2B: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  WAIT_RECV_iReadChar:
                                   (0523) _WAIT_RECV_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[WAIT_RECV_CONTROL_REG]                       ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(WAIT_RECV_RX_ERROR|WAIT_RECV_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,WAIT_RECV_RX_COMPLETE                            ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,WAIT_RECV_RX_NO_DATA                             ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_WAIT_RECV_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,WAIT_RECV_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[WAIT_RECV_RX_BUFFER_REG]                     ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_WAIT_RECV_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (WAIT_RECV_RXBUF_ENABLE)
                                   (0552) .SECTION
0D2C: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
0D2F: 51 00    MOV   A,[0]         (0554) ;-----------------------------------------------------------------------------
0D31: 21 F0    AND   A,240         (0555) ;
0D33: 26 00 0F AND   [0],15        (0556) ;     Command Buffer commands
                                   (0557) ;
0D36: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: WAIT_RECV_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  WAIT_RECV_CmdReset:
0D37: 62 D0 00 MOV   REG[208],0    (0587) _WAIT_RECV_CmdReset:
0D3A: 51 01    MOV   A,[1]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >WAIT_RECV_aRxBuffer
0D3C: 7F       RET                 (0590)    mov [WAIT_RECV_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >WAIT_RECV_bRxCnt
                                   (0594)    mov [WAIT_RECV_bRxCnt], 0x00
                                   (0595)    and [WAIT_RECV_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: WAIT_RECV_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  WAIT_RECV_bCmdCheck:
                                   (0628) _WAIT_RECV_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >WAIT_RECV_fStatus
                                   (0631)    mov A,  [WAIT_RECV_fStatus]
                                   (0632)    and A, WAIT_RECV_RX_BUF_CMDTERM               ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: WAIT_RECV_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
0D3D: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
0D3F: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
0D42: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
0D45: 50 68    MOV   A,104         (0648) ;     BYTE  fStatus - Status of command receive buffer.
0D47: 02 E5    ADD   A,[ID+1]      (0649) ;                     Returns non-zero value in A if command is valid.
0D49: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
0D4A: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
0D4C: B0 04    JNZ   0x0D51        (0653) ;           0x10 => Software Buffer OverRun
0D4E: 10       PUSH  X             (0654) ;
0D4F: 80 33    JMP   0x0D83        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
0D51: 39 00    CMP   A,0           (0660) ;    functions.
0D53: B0 11    JNZ   0x0D65        (0661) ;          
0D55: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
0D56: 76 E5    INC   [ID+1]        (0663) ;          CUR_PP
0D58: 52 00    MOV   A,[X+0]       (0664) ;
0D5A: 3C E5 0F CMP   [ID+1],15     (0665) ;     Error Status is clear when read.
0D5D: BF F3    JNZ   0x0D51        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
0D5F: 10       PUSH  X             (0669) ;
                                   (0670)  WAIT_RECV_bErrCheck:
0D60: 56 00 00 MOV   [X+0],0       (0671) _WAIT_RECV_bErrCheck:
0D63: 80 1F    JMP   0x0D83        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >WAIT_RECV_fStatus
                                   (0674)    mov A,  [WAIT_RECV_fStatus]
0D65: 10       PUSH  X             (0675)    and A, WAIT_RECV_RX_BUF_ERROR                 ; Mask off Error status
                                   (0676)    and [WAIT_RECV_fStatus], ~WAIT_RECV_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
0D66: 75       INC   X             (0679) .ENDSECTION
0D67: 76 E5    INC   [ID+1]        (0680) 
0D69: 3C E5 0F CMP   [ID+1],15     (0681) .SECTION
0D6C: AF F3    JZ    0x0D60        (0682) ;-----------------------------------------------------------------------------
0D6E: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: WAIT_RECV_bCmdLength
0D70: A0 12    JZ    0x0D83        (0684) ;
0D72: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
0D74: BF F1    JNZ   0x0D66        (0686) ;     Get length of command string
                                   (0687) ;
0D76: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
0D79: 76 E5    INC   [ID+1]        (0689) ;     none.
0D7B: 3C E5 0F CMP   [ID+1],15     (0690) ;
0D7E: B0 04    JNZ   0x0D83        (0691) ;  RETURNS:
0D80: 55 E5 0F MOV   [ID+1],15     (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
0D83: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
0D84: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
0D85: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
0D88: B0 0B    JNZ   0x0D94        (0699) ;    functions.
0D8A: 20       POP   X             (0700) ;          
0D8B: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
0D8D: 50 00    MOV   A,0           (0702) ;          CUR_PP
0D8F: 70 3F    AND   F,63
0D91: 71 C0    OR    F,192         (0703) ;
                                   (0704)  WAIT_RECV_bCmdLength:
0D93: 7F       RET                 (0705) _WAIT_RECV_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >WAIT_RECV_bRxCnt
0D94: 20       POP   X             (0708)    mov A,  [WAIT_RECV_bRxCnt]
0D95: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
0D97: 70 3F    AND   F,63
0D99: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
0D9B: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: WAIT_RECV_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
0D9C: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
0D9F: 50 68    MOV   A,104         (0744) ;     each lexically distinct element into a null-terminated string by replacing
0DA1: 02 E5    ADD   A,[ID+1]      (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
0DA3: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
0DA4: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     WAIT_RECV_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, WAIT_RECV_szGetParam, is
0DA8: 43 E1 08 OR    REG[225],8    (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\tx_23.asm
                                   (0109) ;;*****************************************************************************
0DAB: 7F       RET                 (0110) ;;*****************************************************************************
                                   (0111) ;;  FILENAME: TX_23.asm
                                   (0112) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:51
                                   (0113) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0114) ;;
                                   (0115) ;;  DESCRIPTION: TX8 User Module software implementation file
                                   (0116) ;;               for 22/24/25/26/27xxx PSoc family of devices.
                                   (0117) ;;
                                   (0118) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0119) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0120) ;;        This means it is the caller's responsibility to preserve any values
                                   (0121) ;;        in the X and A registers that are still needed after the API functions
                                   (0122) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0123) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0124) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0125) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0126) ;;-----------------------------------------------------------------------------
                                   (0127) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0128) ;;*****************************************************************************
                                   (0129) ;;*****************************************************************************
                                   (0130) 
                                   (0131) ;-----------------------------------------------
                                   (0132) ; include instance specific register definitions
                                   (0133) ;-----------------------------------------------
                                   (0134) include "m8c.inc"
                                   (0135) include "memory.inc"
                                   (0136) include "TX_23.inc"
0DAC: 41 E1 F7 AND   REG[225],247  (0137) 
                                   (0138) area UserModules (ROM, REL)
0DAF: 7F       RET                 (0139) ;-----------------------------------------------
                                   (0140) ;  Global Symbols
                                   (0141) ;-----------------------------------------------
                                   (0142) export   TX_23_SetTxIntMode
                                   (0143) export  _TX_23_SetTxIntMode
                                   (0144) export   TX_23_EnableInt
                                   (0145) export  _TX_23_EnableInt
                                   (0146) export   TX_23_DisableInt
                                   (0147) export  _TX_23_DisableInt
                                   (0148) export   TX_23_Start
                                   (0149) export  _TX_23_Start
                                   (0150) export   TX_23_Stop
                                   (0151) export  _TX_23_Stop
                                   (0152) export   TX_23_SendData
                                   (0153) export  _TX_23_SendData
                                   (0154) export   TX_23_bReadTxStatus
                                   (0155) export  _TX_23_bReadTxStatus
                                   (0156) 
                                   (0157) // Old labels, will be removed in future release
                                   (0158) // Do Not Use.
                                   (0159) export   bTX_23_ReadTxStatus
                                   (0160) export  _bTX_23_ReadTxStatus
                                   (0161) 
                                   (0162) ;-----------------------------------------------
                                   (0163) ;  High Level TX functions
                                   (0164) ;-----------------------------------------------
                                   (0165) export  TX_23_PutSHexByte
                                   (0166) export _TX_23_PutSHexByte
                                   (0167) export  TX_23_PutSHexInt
                                   (0168) export _TX_23_PutSHexInt
                                   (0169) 
0DB0: 71 10    OR    F,16          (0170) export  TX_23_CPutString
0DB2: 21 01    AND   A,1           (0171) export _TX_23_CPutString
0DB4: A0 07    JZ    0x0DBC        (0172) export  TX_23_PutString
0DB6: 43 2C 10 OR    REG[44],16    (0173) export _TX_23_PutString
0DB9: 70 EF    AND   F,239         (0174) export  TX_23_PutChar
                                   (0175) export _TX_23_PutChar
0DBB: 7F       RET                 (0176) export  TX_23_Write
                                   (0177) export _TX_23_Write
                                   (0178) export  TX_23_CWrite
0DBC: 41 2C EF AND   REG[44],239   (0179) export _TX_23_CWrite
0DBF: 70 EF    AND   F,239         (0180) export  TX_23_PutCRLF
                                   (0181) export _TX_23_PutCRLF 
0DC1: 7F       RET                 (0182) 
                                   (0183) ;-----------------------------------------------
                                   (0184) ;  EQUATES
                                   (0185) ;-----------------------------------------------
                                   (0186) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0187) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                   (0188) 
                                   (0189) AREA UserModules (ROM, REL)
                                   (0190) 
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: TX_23_EnableInt
                                   (0194) ;
                                   (0195) ;  DESCRIPTION:
                                   (0196) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                   (0197) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0198) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0199) ;
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201) ;
                                   (0202) ;  ARGUMENTS: none
                                   (0203) ;
                                   (0204) ;  RETURNS: none
                                   (0205) ;
                                   (0206) ;  SIDE EFFECTS:
                                   (0207) ;    The A and X registers may be modified by this or future implementations
                                   (0208) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0210) ;    responsibility to perserve their values across calls to fastcall16 
0DC2: 29 01    OR    A,1           (0211) ;    functions.
0DC4: 60 2F    MOV   REG[47],A     (0212) ;
                                   (0213)  TX_23_EnableInt:
0DC6: 7F       RET                 (0214) _TX_23_EnableInt:
                                   (0215)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0216)    M8C_EnableIntMask  TX_23_INT_REG, TX_23_bINT_MASK
                                   (0217)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0218)    ret
                                   (0219) .ENDSECTION
                                   (0220) 
                                   (0221) .SECTION
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) ;  FUNCTION NAME: TX_23_DisableInt
                                   (0224) ;
                                   (0225) ;  DESCRIPTION:
                                   (0226) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                   (0227) ;     associated with this User Module.
                                   (0228) ;
                                   (0229) ;-----------------------------------------------------------------------------
                                   (0230) ;
                                   (0231) ;  ARGUMENTS:  none
                                   (0232) ;
                                   (0233) ;  RETURNS:  none
                                   (0234) ;
                                   (0235) ;  SIDE EFFECTS:
                                   (0236) ;    The A and X registers may be modified by this or future implementations
                                   (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0239) ;    responsibility to perserve their values across calls to fastcall16 
0DC7: 41 2F FE AND   REG[47],254   (0240) ;    functions.
                                   (0241) ;
0DCA: 7F       RET                 (0242)  TX_23_DisableInt:
                                   (0243) _TX_23_DisableInt:
                                   (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0245)    M8C_DisableIntMask TX_23_INT_REG, TX_23_bINT_MASK
                                   (0246)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0247)    ret
                                   (0248) .ENDSECTION
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: TX_23_SetTxIntMode(BYTE bTxIntMode)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0256) ;
                                   (0257) ;  ARGUMENTS:
                                   (0258) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0259) ;        Passed in the A register
                                   (0260) ;
                                   (0261) ;  RETURNS:
                                   (0262) ;     none.
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    The A and X registers may be modified by this or future implementations
                                   (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0268) ;    responsibility to perserve their values across calls to fastcall16 
0DCB: 60 2D    MOV   REG[45],A     (0269) ;    functions.
                                   (0270) ;
0DCD: 7F       RET                 (0271) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0272) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0273) ;     on TX register empty or TX transmit complete
                                   (0274) ;
                                   (0275)  TX_23_SetTxIntMode:
                                   (0276) _TX_23_SetTxIntMode:
                                   (0277)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0278)    M8C_SetBank1
                                   (0279)    and   A, TX_23_INT_MODE_TX_COMPLETE
                                   (0280)    jz    .SetModeRegEmpty
                                   (0281)    or    REG[TX_23_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0282)    M8C_SetBank0
                                   (0283)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0284)    ret
                                   (0285) 
                                   (0286) .SetModeRegEmpty:
                                   (0287)    and   REG[TX_23_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0288)    M8C_SetBank0
                                   (0289)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0290)    ret
                                   (0291) .ENDSECTION
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_23_Start(BYTE bParity)
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0299) ;     The transmitter will begin transmitting if a byte has been written into the
                                   (0300) ;     transmit buffer.
0DCE: 5D 2F    MOV   A,REG[47]     (0301) ;
                                   (0302) ;-----------------------------------------------------------------------------
0DD0: 7F       RET                 (0303) ;
0DD1: 30       HALT  
0DD2: 31 32    XOR   A,50
0DD4: 33 34    XOR   A,[X+52]
0DD6: 35 36    XOR   [X+54],A
0DD8: 37 38 39 XOR   [X+56],57
0DDB: 41 42 43 AND   REG[66],67
0DDE: 44 45 46 OR    REG[X+69],70
                                   (0304) ;  ARGUMENTS:
                                   (0305) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                   (0306) ;
                                   (0307) ;  RETURNS:  none
                                   (0308) ;
                                   (0309) ;  SIDE EFFECTS:
                                   (0310) ;    The A and X registers may be modified by this or future implementations
                                   (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0314) ;    functions.
                                   (0315) ;
                                   (0316)  TX_23_Start:
                                   (0317) _TX_23_Start:
                                   (0318)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0319)    or    A, bfCONTROL_REG_START_BIT
                                   (0320)    mov   REG[TX_23_CONTROL_REG], A
                                   (0321)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0322)    ret
                                   (0323) .ENDSECTION
                                   (0324) 
                                   (0325) .SECTION
                                   (0326) ;-----------------------------------------------------------------------------
                                   (0327) ;  FUNCTION NAME: TX_23_Stop
                                   (0328) ;
                                   (0329) ;  DESCRIPTION:
                                   (0330) ;     Disables TX8 operation.
                                   (0331) ;
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:  none
0DE1: 08       PUSH  A             (0335) ;
0DE2: 67       ASR   A             (0336) ;  RETURNS:  none
0DE3: 67       ASR   A             (0337) ;
0DE4: 67       ASR   A             (0338) ;  SIDE EFFECTS:
0DE5: 67       ASR   A             (0339) ;    The A and X registers may be modified by this or future implementations
0DE6: 21 0F    AND   A,15          (0340) ;    of this function.  The same is true for all RAM page pointer registers in
0DE8: FF E7    INDEX 0x0DD1        (0341) ;    the Large Memory Model.  When necessary, it is the calling function's
0DEA: 90 0F    CALL  0x0DFB        (0342) ;    responsibility to perserve their values across calls to fastcall16 
0DEC: 18       POP   A             (0343) ;    functions.
0DED: 21 0F    AND   A,15          (0344) ;
0DEF: FF E0    INDEX 0x0DD1        (0345)  TX_23_Stop:
0DF1: 90 08    CALL  0x0DFB        (0346) _TX_23_Stop:
                                   (0347)    RAM_PROLOGUE RAM_USE_CLASS_1
0DF3: 7F       RET                 (0348)    and   REG[TX_23_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0349)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0350)    ret
                                   (0351) .ENDSECTION
                                   (0352) 
                                   (0353) .SECTION
                                   (0354) ;-----------------------------------------------------------------------------
                                   (0355) ;  FUNCTION NAME: TX_23_SendData
                                   (0356) ;
                                   (0357) ;  DESCRIPTION:
                                   (0358) ;     Sends one byte through serial port.
                                   (0359) ;
                                   (0360) ;-----------------------------------------------------------------------------
                                   (0361) ;
                                   (0362) ;  ARGUMENTS:
                                   (0363) ;     BYTE  TxData - data to transmit.
                                   (0364) ;
                                   (0365) ;  RETURNS:
                                   (0366) ;
                                   (0367) ;  SIDE EFFECTS:
                                   (0368) ;    The A and X registers may be modified by this or future implementations
                                   (0369) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0370) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0371) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0372) ;    functions.
                                   (0373) ;
                                   (0374)  TX_23_SendData:
                                   (0375) _TX_23_SendData:
0DF4: 4B       SWAP  A,X           (0376)    RAM_PROLOGUE RAM_USE_CLASS_1
0DF5: 9F EA    CALL  0x0DE1        (0377)    mov REG[TX_23_TX_BUFFER_REG], A
0DF7: 5B       MOV   A,X           (0378)    RAM_EPILOGUE RAM_USE_CLASS_1
0DF8: 9F E7    CALL  0x0DE1        (0379)    ret
                                   (0380) .ENDSECTION
0DFA: 7F       RET                 (0381) 
0DFB: 49 2F 10 TST   REG[47],16
                                   (0382) .SECTION
                                   (0383) ;-----------------------------------------------------------------------------
                                   (0384) ;  FUNCTION NAME: TX_23_bReadTxStatus
                                   (0385) ;
                                   (0386) ;  DESCRIPTION:
                                   (0387) ;     Reads the Tx Status bits in the Control/Status register.
                                   (0388) ;
                                   (0389) ;-----------------------------------------------------------------------------
                                   (0390) ;
                                   (0391) ;  ARGUMENTS:
                                   (0392) ;
                                   (0393) ;  RETURNS:
                                   (0394) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                   (0395) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;
                                   (0404)  TX_23_bReadTxStatus:
                                   (0405) _TX_23_bReadTxStatus:
                                   (0406)  bTX_23_ReadTxStatus:
                                   (0407) _bTX_23_ReadTxStatus:
                                   (0408)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0409)    mov A,  REG[TX_23_CONTROL_REG]
                                   (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0411)    ret
                                   (0412) 
                                   (0413) .ENDSECTION
                                   (0414) 
                                   (0415) ;-----------------------------------------------------------------------------
0DFE: AF FC    JZ    0x0DFB        (0416) ;  FUNCTION NAME: TX_23_PutSHexByte
0E00: 60 2D    MOV   REG[45],A
                                   (0417) ;
0E02: 7F       RET                 (0418) ;  DESCRIPTION:
                                   (0419) ;     Print a byte in Hex (two characters) to the UART Tx
                                   (0420) ;
                                   (0421) ;  ARGUMENTS:
                                   (0422) ;     A  => (BYTE) Data/char to be printed
                                   (0423) ;
                                   (0424) ;  RETURNS:
                                   (0425) ;     none.
                                   (0426) ;
                                   (0427) ;  SIDE EFFECTS:
                                   (0428) ;    The A and X registers may be modified by this or future implementations
                                   (0429) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0430) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0431) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0432) ;    functions.
                                   (0433) ;
                                   (0434) .LITERAL
                                   (0435) TX_23_HEX_STR:
                                   (0436)      DS    "0123456789ABCDEF"
                                   (0437) .ENDLITERAL
                                   (0438) 
                                   (0439) .SECTION
                                   (0440)  TX_23_PutSHexByte:
                                   (0441) _TX_23_PutSHexByte:
                                   (0442)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0443)     push  A                            ; Save lower nibble
                                   (0444)     asr   A                            ; Shift high nibble to right
                                   (0445)     asr   A
                                   (0446)     asr   A
                                   (0447)     asr   A
                                   (0448)     and   A,0Fh                        ; Mask off nibble
                                   (0449)     index TX_23_HEX_STR                ; Get Hex value
                                   (0450)     call  TX_23_PutChar                ; Write data to screen
                                   (0451)     pop   A                            ; Restore value
                                   (0452)     and   A,0Fh                        ; Mask off lower nibble
                                   (0453)     index TX_23_HEX_STR                ; Get Hex value
                                   (0454)     call  TX_23_PutChar                ; Write data to screen
                                   (0455)     RAM_EPILOGUE RAM_USE_CLASS_1
0E03: 70 BF    AND   F,191         (0456)     ret
0E05: 60 D3    MOV   REG[211],A    (0457) .ENDSECTION
                                   (0458) 
0E07: 52 00    MOV   A,[X+0]       (0459) .SECTION
0E09: A0 06    JZ    0x0E10        (0460) ;-----------------------------------------------------------------------------
0E0B: 9F EE    CALL  0x0DFB        (0461) ;  FUNCTION NAME: TX_23_PutSHexInt
0E0D: 75       INC   X             (0462) ;
0E0E: 8F F8    JMP   0x0E07        (0463) ;  DESCRIPTION:
0E10: 70 3F    AND   F,63
                                   (0464) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0465) ;
0E12: 71 C0    OR    F,192         (0466) ;  ARGUMENTS:
0E14: 7F       RET                 (0467) ;     Pointer to string
                                   (0468) ;     A  => ASB of Int
                                   (0469) ;     X  => MSB of Int
                                   (0470) ;
                                   (0471) ;  RETURNS:
                                   (0472) ;     none.
                                   (0473) ;
                                   (0474) ;  SIDE EFFECTS:
                                   (0475) ;    The A and X registers may be modified by this or future implementations
                                   (0476) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0477) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0478) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0479) ;    functions.
                                   (0480) ;
                                   (0481)  TX_23_PutSHexInt:
                                   (0482) _TX_23_PutSHexInt:
                                   (0483)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0484)     swap  A,X
                                   (0485)     call  TX_23_PutSHexByte            ; Print MSB
                                   (0486)     mov   A,X                          ; Move LSB into position
                                   (0487)     call  TX_23_PutSHexByte            ; Print LSB
                                   (0488)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)     ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: TX_23_PutChar
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Send character out through UART TX port.
                                   (0498) ;
                                   (0499) ;
                                   (0500) ;  ARGUMENTS:
                                   (0501) ;     A has Character to send to UART Tx Port
                                   (0502) ;
0E15: 70 BF    AND   F,191         (0503) ;  RETURNS:
0E17: 62 D3 03 MOV   REG[211],3    (0504) ;     none
0E1A: 4F       MOV   X,SP          (0505) ;
                                   (0506) ;  SIDE EFFECTS:
                                   (0507) ;    The A and X registers may be modified by this or future implementations
0E1B: 52 FB    MOV   A,[X-5]       (0508) ;    of this function.  The same is true for all RAM page pointer registers in
0E1D: A0 1A    JZ    0x0E38        (0509) ;    the Large Memory Model.  When necessary, it is the calling function's
0E1F: 7B FB    DEC   [X-5]         (0510) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0511) ;    functions.
                                   (0512) ;
0E21: 52 FC    MOV   A,[X-4]       (0513)    macro InLinePutChar( Source )
                                   (0514) .BufEmptyWaitLoop:
                                   (0515)    tst REG[TX_23_CONTROL_REG], TX_23_TX_BUFFER_EMPTY    ; Check Tx Status
0E23: 59 FD    MOV   X,[X-3]       (0516)    jz  .BufEmptyWaitLoop
0E25: 60 D3    MOV   REG[211],A    (0517)    mov REG[TX_23_TX_BUFFER_REG], @Source    ; Write data to Tx Port
0E27: 52 00    MOV   A,[X+0]       (0518)    endm
0E29: 49 2F 10 TST   REG[47],16
0E2C: AF FC    JZ    0x0E29        (0519) 
0E2E: 60 2D    MOV   REG[45],A
0E30: 4F       MOV   X,SP          (0520) 
0E31: 62 D3 03 MOV   REG[211],3    (0521)  TX_23_PutChar:
0E34: 77 FD    INC   [X-3]         (0522) _TX_23_PutChar:
0E36: 8F E4    JMP   0x0E1B        (0523)    RAM_PROLOGUE RAM_USE_CLASS_1
0E38: 70 3F    AND   F,63
                                   (0524)    InLinePutChar A
                                   (0525)    RAM_EPILOGUE RAM_USE_CLASS_1
0E3A: 71 C0    OR    F,192         (0526)    ret
0E3C: 7F       RET                 (0527) 
                                   (0528) .ENDSECTION
                                   (0529) 
                                   (0530) 
                                   (0531) ;-----------------------------------------------
                                   (0532) ;  High Level TX functions
                                   (0533) ;-----------------------------------------------
                                   (0534) 
                                   (0535) 
                                   (0536) .SECTION
                                   (0537) ;-----------------------------------------------------------------------------
                                   (0538) ;  FUNCTION NAME: TX_23_PutString
                                   (0539) ;
                                   (0540) ;  DESCRIPTION:
                                   (0541) ;     Send String out through UART TX port.
                                   (0542) ;
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;     Pointer to String
                                   (0546) ;     A has MSB of string address
                                   (0547) ;     X has LSB of string address
                                   (0548) ;
                                   (0549) ;  RETURNS:
                                   (0550) ;     none
                                   (0551) ;
                                   (0552) ;  SIDE EFFECTS:
                                   (0553) ;    The A and X registers may be modified by this or future implementations
                                   (0554) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0555) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0556) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0557) ;    functions.
                                   (0558) ;          
                                   (0559) ;    Currently only the page pointer registers listed below are modified: 
                                   (0560) ;          IDX_PP
                                   (0561) ;
                                   (0562)  TX_23_PutString:
                                   (0563) _TX_23_PutString:
0E3D: 4F       MOV   X,SP          (0564)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0565)    RAM_SETPAGE_IDX A
                                   (0566) .PutStringLoop:
                                   (0567)    mov   A,[X]                             ; Get value pointed to by X
0E3E: 3D FA 00 CMP   [X-6],0       (0568)    jz    End_PutString                     ; Check for end of string
0E41: B0 06    JNZ   0x0E48        (0569)    call  TX_23_PutChar                      ; Send character to Tx port
0E43: 3D FB 00 CMP   [X-5],0       (0570)    inc   X                                 ; Advance pointer to next character
0E46: A0 1D    JZ    0x0E64        (0571)    jmp   .PutStringLoop                     ; Get next character
                                   (0572) 
                                   (0573) End_PutString:
0E48: 10       PUSH  X             (0574)    RAM_EPILOGUE RAM_USE_CLASS_3
0E49: 52 FC    MOV   A,[X-4]       (0575)    ret
0E4B: 59 FD    MOV   X,[X-3]       (0576) .ENDSECTION
0E4D: 28       ROMX                (0577) 
0E4E: 49 2F 10 TST   REG[47],16
0E51: AF FC    JZ    0x0E4E        (0578) .SECTION
0E53: 60 2D    MOV   REG[45],A
0E55: 20       POP   X             (0579) ;-----------------------------------------------------------------------------
                                   (0580) ;  FUNCTION NAME: TX_23_Write
0E56: 07 FD 01 ADD   [X-3],1       (0581) ;
0E59: 0F FC 00 ADC   [X-4],0       (0582) ;  DESCRIPTION:
                                   (0583) ;     Send String of length X to serial port
                                   (0584) ;
0E5C: 17 FB 01 SUB   [X-5],1       (0585) ;
0E5F: 1F FA 00 SBB   [X-6],0       (0586) ;  ARGUMENTS:
                                   (0587) ;     Pointer to String
0E62: 8F DB    JMP   0x0E3E        (0588) ;     [SP-5] Count of characters to send
                                   (0589) ;     [SP-4] has MSB of string address
                                   (0590) ;     [SP-3] has LSB of string address
                                   (0591) ;
0E64: 7F       RET                 (0592) ;  RETURNS:
                                   (0593) ;     none
                                   (0594) ;
                                   (0595) ;  SIDE EFFECTS:
                                   (0596) ;    The A and X registers may be modified by this or future implementations
                                   (0597) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0598) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0599) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0600) ;    functions.
                                   (0601) ;          
                                   (0602) ;    Currently only the page pointer registers listed below are modified: 
                                   (0603) ;          IDX_PP
                                   (0604) ;
                                   (0605) CNT_LEN:    equ -5           ; Length of data to send
                                   (0606) STR_MSB:    equ -4           ; MSB pointer of string
                                   (0607) STR_LSB:    equ -3           ; LSB pointer of string
                                   (0608) 
                                   (0609)  TX_23_Write:
                                   (0610) _TX_23_Write:
                                   (0611)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0612)    RAM_SETPAGE_IDX2STK
                                   (0613)    mov   X, SP
                                   (0614) 
                                   (0615) .NextByteLoop:
                                   (0616)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
                                   (0617)    jz    .End_Write
                                   (0618)    dec   [X+CNT_LEN]                       ; Decrement counter
                                   (0619) 
                                   (0620)    IF SYSTEM_LARGE_MEMORY_MODEL
0E65: 08       PUSH  A             (0621)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
0E66: 10       PUSH  X             (0622)    ENDIF
0E67: 28       ROMX                (0623) 
0E68: A0 0B    JZ    0x0E74        (0624)    mov   X,[X+STR_LSB]                     ; Get character to send
0E6A: 9F 8F    CALL  0x0DFB        (0625)    RAM_SETPAGE_IDX A                        ; switch index pages
0E6C: 20       POP   X             (0626)    mov   A,[X]
0E6D: 18       POP   A             (0627)    InLinePutChar A                          ; Send character to UART
0E6E: 75       INC   X             (0628)    mov   X, SP
0E6F: DF F5    JNC   0x0E65        (0629)    RAM_SETPAGE_IDX2STK
0E71: 74       INC   A             (0630)    inc   [X+STR_LSB]
0E72: 8F F2    JMP   0x0E65        (0631)    jmp   .NextByteLoop
                                   (0632) 
                                   (0633) .End_Write:
                                   (0634)    RAM_EPILOGUE RAM_USE_CLASS_3
0E74: 38 FE    ADD   SP,254        (0635)    ret
                                   (0636) .ENDSECTION
0E76: 7F       RET                 (0637) 
                                   (0638) .SECTION
                                   (0639) ;-----------------------------------------------------------------------------
                                   (0640) ;  FUNCTION NAME: TX_23_CWrite
                                   (0641) ;
                                   (0642) ;             WARNING WARNING NOT COMPLETE
                                   (0643) ;
                                   (0644) ;  DESCRIPTION:
                                   (0645) ;     Send String of length X to serial port
                                   (0646) ;
                                   (0647) ;  ARGUMENTS:
                                   (0648) ;     Pointer to String
                                   (0649) ;     [SP-6] MSB of Count of character to send
                                   (0650) ;     [SP-5] LSB of Count of character to send
                                   (0651) ;     [SP-4] has MSB of string address
                                   (0652) ;     [SP-3] has LSB of string address
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
0E77: 50 0D    MOV   A,13          (0663) ;
0E79: 9F 80    CALL  0x0DFB        (0664) CLEN_MSB:   equ -6           ; MSB Length of data to send
0E7B: 50 0A    MOV   A,10          (0665) CLEN_LSB:   equ -5           ; LSB Length of data to send
0E7D: 9F 7C    CALL  0x0DFB        (0666) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (0667) CSTR_LSB:   equ -3           ; LSB pointer of string
0E81: 43 E1 04 OR    REG[225],4    (0668) 

FILE: lib\tx_014.asm
                                   (0109) ;;*****************************************************************************
0E84: 7F       RET                 (0110) ;;*****************************************************************************
                                   (0111) ;;  FILENAME: TX_014.asm
                                   (0112) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:51
                                   (0113) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0114) ;;
                                   (0115) ;;  DESCRIPTION: TX8 User Module software implementation file
                                   (0116) ;;               for 22/24/25/26/27xxx PSoc family of devices.
                                   (0117) ;;
                                   (0118) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0119) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0120) ;;        This means it is the caller's responsibility to preserve any values
                                   (0121) ;;        in the X and A registers that are still needed after the API functions
                                   (0122) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0123) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0124) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0125) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0126) ;;-----------------------------------------------------------------------------
                                   (0127) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0128) ;;*****************************************************************************
                                   (0129) ;;*****************************************************************************
                                   (0130) 
                                   (0131) ;-----------------------------------------------
                                   (0132) ; include instance specific register definitions
                                   (0133) ;-----------------------------------------------
                                   (0134) include "m8c.inc"
                                   (0135) include "memory.inc"
                                   (0136) include "TX_014.inc"
0E85: 41 E1 FB AND   REG[225],251  (0137) 
                                   (0138) area UserModules (ROM, REL)
0E88: 7F       RET                 (0139) ;-----------------------------------------------
                                   (0140) ;  Global Symbols
                                   (0141) ;-----------------------------------------------
                                   (0142) export   TX_014_SetTxIntMode
                                   (0143) export  _TX_014_SetTxIntMode
                                   (0144) export   TX_014_EnableInt
                                   (0145) export  _TX_014_EnableInt
                                   (0146) export   TX_014_DisableInt
                                   (0147) export  _TX_014_DisableInt
                                   (0148) export   TX_014_Start
                                   (0149) export  _TX_014_Start
                                   (0150) export   TX_014_Stop
                                   (0151) export  _TX_014_Stop
                                   (0152) export   TX_014_SendData
                                   (0153) export  _TX_014_SendData
                                   (0154) export   TX_014_bReadTxStatus
                                   (0155) export  _TX_014_bReadTxStatus
                                   (0156) 
                                   (0157) // Old labels, will be removed in future release
                                   (0158) // Do Not Use.
                                   (0159) export   bTX_014_ReadTxStatus
                                   (0160) export  _bTX_014_ReadTxStatus
                                   (0161) 
                                   (0162) ;-----------------------------------------------
                                   (0163) ;  High Level TX functions
                                   (0164) ;-----------------------------------------------
                                   (0165) export  TX_014_PutSHexByte
                                   (0166) export _TX_014_PutSHexByte
                                   (0167) export  TX_014_PutSHexInt
                                   (0168) export _TX_014_PutSHexInt
                                   (0169) 
0E89: 71 10    OR    F,16          (0170) export  TX_014_CPutString
0E8B: 21 01    AND   A,1           (0171) export _TX_014_CPutString
0E8D: A0 07    JZ    0x0E95        (0172) export  TX_014_PutString
0E8F: 43 28 10 OR    REG[40],16    (0173) export _TX_014_PutString
0E92: 70 EF    AND   F,239         (0174) export  TX_014_PutChar
                                   (0175) export _TX_014_PutChar
0E94: 7F       RET                 (0176) export  TX_014_Write
                                   (0177) export _TX_014_Write
                                   (0178) export  TX_014_CWrite
0E95: 41 28 EF AND   REG[40],239   (0179) export _TX_014_CWrite
0E98: 70 EF    AND   F,239         (0180) export  TX_014_PutCRLF
                                   (0181) export _TX_014_PutCRLF 
0E9A: 7F       RET                 (0182) 
                                   (0183) ;-----------------------------------------------
                                   (0184) ;  EQUATES
                                   (0185) ;-----------------------------------------------
                                   (0186) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0187) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                   (0188) 
                                   (0189) AREA UserModules (ROM, REL)
                                   (0190) 
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: TX_014_EnableInt
                                   (0194) ;
                                   (0195) ;  DESCRIPTION:
                                   (0196) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                   (0197) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0198) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0199) ;
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201) ;
                                   (0202) ;  ARGUMENTS: none
                                   (0203) ;
                                   (0204) ;  RETURNS: none
                                   (0205) ;
                                   (0206) ;  SIDE EFFECTS:
                                   (0207) ;    The A and X registers may be modified by this or future implementations
                                   (0208) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0210) ;    responsibility to perserve their values across calls to fastcall16 
0E9B: 29 01    OR    A,1           (0211) ;    functions.
0E9D: 60 2B    MOV   REG[43],A     (0212) ;
                                   (0213)  TX_014_EnableInt:
0E9F: 7F       RET                 (0214) _TX_014_EnableInt:
                                   (0215)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0216)    M8C_EnableIntMask  TX_014_INT_REG, TX_014_bINT_MASK
                                   (0217)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0218)    ret
                                   (0219) .ENDSECTION
                                   (0220) 
                                   (0221) .SECTION
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) ;  FUNCTION NAME: TX_014_DisableInt
                                   (0224) ;
                                   (0225) ;  DESCRIPTION:
                                   (0226) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                   (0227) ;     associated with this User Module.
                                   (0228) ;
                                   (0229) ;-----------------------------------------------------------------------------
                                   (0230) ;
                                   (0231) ;  ARGUMENTS:  none
                                   (0232) ;
                                   (0233) ;  RETURNS:  none
                                   (0234) ;
                                   (0235) ;  SIDE EFFECTS:
                                   (0236) ;    The A and X registers may be modified by this or future implementations
                                   (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0239) ;    responsibility to perserve their values across calls to fastcall16 
0EA0: 41 2B FE AND   REG[43],254   (0240) ;    functions.
                                   (0241) ;
0EA3: 7F       RET                 (0242)  TX_014_DisableInt:
                                   (0243) _TX_014_DisableInt:
                                   (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0245)    M8C_DisableIntMask TX_014_INT_REG, TX_014_bINT_MASK
                                   (0246)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0247)    ret
                                   (0248) .ENDSECTION
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: TX_014_SetTxIntMode(BYTE bTxIntMode)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0256) ;
                                   (0257) ;  ARGUMENTS:
                                   (0258) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0259) ;        Passed in the A register
                                   (0260) ;
                                   (0261) ;  RETURNS:
                                   (0262) ;     none.
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    The A and X registers may be modified by this or future implementations
                                   (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0268) ;    responsibility to perserve their values across calls to fastcall16 
0EA4: 60 29    MOV   REG[41],A     (0269) ;    functions.
                                   (0270) ;
0EA6: 7F       RET                 (0271) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0272) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0273) ;     on TX register empty or TX transmit complete
                                   (0274) ;
                                   (0275)  TX_014_SetTxIntMode:
                                   (0276) _TX_014_SetTxIntMode:
                                   (0277)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0278)    M8C_SetBank1
                                   (0279)    and   A, TX_014_INT_MODE_TX_COMPLETE
                                   (0280)    jz    .SetModeRegEmpty
                                   (0281)    or    REG[TX_014_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0282)    M8C_SetBank0
                                   (0283)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0284)    ret
                                   (0285) 
                                   (0286) .SetModeRegEmpty:
                                   (0287)    and   REG[TX_014_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0288)    M8C_SetBank0
                                   (0289)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0290)    ret
                                   (0291) .ENDSECTION
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_014_Start(BYTE bParity)
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0299) ;     The transmitter will begin transmitting if a byte has been written into the
                                   (0300) ;     transmit buffer.
0EA7: 5D 2B    MOV   A,REG[43]     (0301) ;
                                   (0302) ;-----------------------------------------------------------------------------
0EA9: 7F       RET                 (0303) ;
0EAA: 30       HALT  
0EAB: 31 32    XOR   A,50
0EAD: 33 34    XOR   A,[X+52]
0EAF: 35 36    XOR   [X+54],A
0EB1: 37 38 39 XOR   [X+56],57
0EB4: 41 42 43 AND   REG[66],67
0EB7: 44 45 46 OR    REG[X+69],70
                                   (0304) ;  ARGUMENTS:
                                   (0305) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                   (0306) ;
                                   (0307) ;  RETURNS:  none
                                   (0308) ;
                                   (0309) ;  SIDE EFFECTS:
                                   (0310) ;    The A and X registers may be modified by this or future implementations
                                   (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0314) ;    functions.
                                   (0315) ;
                                   (0316)  TX_014_Start:
                                   (0317) _TX_014_Start:
                                   (0318)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0319)    or    A, bfCONTROL_REG_START_BIT
                                   (0320)    mov   REG[TX_014_CONTROL_REG], A
                                   (0321)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0322)    ret
                                   (0323) .ENDSECTION
                                   (0324) 
                                   (0325) .SECTION
                                   (0326) ;-----------------------------------------------------------------------------
                                   (0327) ;  FUNCTION NAME: TX_014_Stop
                                   (0328) ;
                                   (0329) ;  DESCRIPTION:
                                   (0330) ;     Disables TX8 operation.
                                   (0331) ;
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:  none
0EBA: 08       PUSH  A             (0335) ;
0EBB: 67       ASR   A             (0336) ;  RETURNS:  none
0EBC: 67       ASR   A             (0337) ;
0EBD: 67       ASR   A             (0338) ;  SIDE EFFECTS:
0EBE: 67       ASR   A             (0339) ;    The A and X registers may be modified by this or future implementations
0EBF: 21 0F    AND   A,15          (0340) ;    of this function.  The same is true for all RAM page pointer registers in
0EC1: FF E7    INDEX 0x0EAA        (0341) ;    the Large Memory Model.  When necessary, it is the calling function's
0EC3: 90 0F    CALL  0x0ED4        (0342) ;    responsibility to perserve their values across calls to fastcall16 
0EC5: 18       POP   A             (0343) ;    functions.
0EC6: 21 0F    AND   A,15          (0344) ;
0EC8: FF E0    INDEX 0x0EAA        (0345)  TX_014_Stop:
0ECA: 90 08    CALL  0x0ED4        (0346) _TX_014_Stop:
                                   (0347)    RAM_PROLOGUE RAM_USE_CLASS_1
0ECC: 7F       RET                 (0348)    and   REG[TX_014_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0349)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0350)    ret
                                   (0351) .ENDSECTION
                                   (0352) 
                                   (0353) .SECTION
                                   (0354) ;-----------------------------------------------------------------------------
                                   (0355) ;  FUNCTION NAME: TX_014_SendData
                                   (0356) ;
                                   (0357) ;  DESCRIPTION:
                                   (0358) ;     Sends one byte through serial port.
                                   (0359) ;
                                   (0360) ;-----------------------------------------------------------------------------
                                   (0361) ;
                                   (0362) ;  ARGUMENTS:
                                   (0363) ;     BYTE  TxData - data to transmit.
                                   (0364) ;
                                   (0365) ;  RETURNS:
                                   (0366) ;
                                   (0367) ;  SIDE EFFECTS:
                                   (0368) ;    The A and X registers may be modified by this or future implementations
                                   (0369) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0370) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0371) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0372) ;    functions.
                                   (0373) ;
                                   (0374)  TX_014_SendData:
                                   (0375) _TX_014_SendData:
0ECD: 4B       SWAP  A,X           (0376)    RAM_PROLOGUE RAM_USE_CLASS_1
0ECE: 9F EA    CALL  0x0EBA        (0377)    mov REG[TX_014_TX_BUFFER_REG], A
0ED0: 5B       MOV   A,X           (0378)    RAM_EPILOGUE RAM_USE_CLASS_1
0ED1: 9F E7    CALL  0x0EBA        (0379)    ret
                                   (0380) .ENDSECTION
0ED3: 7F       RET                 (0381) 
0ED4: 49 2B 10 TST   REG[43],16
                                   (0382) .SECTION
                                   (0383) ;-----------------------------------------------------------------------------
                                   (0384) ;  FUNCTION NAME: TX_014_bReadTxStatus
                                   (0385) ;
                                   (0386) ;  DESCRIPTION:
                                   (0387) ;     Reads the Tx Status bits in the Control/Status register.
                                   (0388) ;
                                   (0389) ;-----------------------------------------------------------------------------
                                   (0390) ;
                                   (0391) ;  ARGUMENTS:
                                   (0392) ;
                                   (0393) ;  RETURNS:
                                   (0394) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                   (0395) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;
                                   (0404)  TX_014_bReadTxStatus:
                                   (0405) _TX_014_bReadTxStatus:
                                   (0406)  bTX_014_ReadTxStatus:
                                   (0407) _bTX_014_ReadTxStatus:
                                   (0408)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0409)    mov A,  REG[TX_014_CONTROL_REG]
                                   (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0411)    ret
                                   (0412) 
                                   (0413) .ENDSECTION
                                   (0414) 
                                   (0415) ;-----------------------------------------------------------------------------
0ED7: AF FC    JZ    0x0ED4        (0416) ;  FUNCTION NAME: TX_014_PutSHexByte
0ED9: 60 29    MOV   REG[41],A
                                   (0417) ;
0EDB: 7F       RET                 (0418) ;  DESCRIPTION:
                                   (0419) ;     Print a byte in Hex (two characters) to the UART Tx
                                   (0420) ;
                                   (0421) ;  ARGUMENTS:
                                   (0422) ;     A  => (BYTE) Data/char to be printed
                                   (0423) ;
                                   (0424) ;  RETURNS:
                                   (0425) ;     none.
                                   (0426) ;
                                   (0427) ;  SIDE EFFECTS:
                                   (0428) ;    The A and X registers may be modified by this or future implementations
                                   (0429) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0430) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0431) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0432) ;    functions.
                                   (0433) ;
                                   (0434) .LITERAL
                                   (0435) TX_014_HEX_STR:
                                   (0436)      DS    "0123456789ABCDEF"
                                   (0437) .ENDLITERAL
                                   (0438) 
                                   (0439) .SECTION
                                   (0440)  TX_014_PutSHexByte:
                                   (0441) _TX_014_PutSHexByte:
                                   (0442)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0443)     push  A                            ; Save lower nibble
                                   (0444)     asr   A                            ; Shift high nibble to right
                                   (0445)     asr   A
                                   (0446)     asr   A
                                   (0447)     asr   A
                                   (0448)     and   A,0Fh                        ; Mask off nibble
                                   (0449)     index TX_014_HEX_STR               ; Get Hex value
                                   (0450)     call  TX_014_PutChar               ; Write data to screen
                                   (0451)     pop   A                            ; Restore value
                                   (0452)     and   A,0Fh                        ; Mask off lower nibble
                                   (0453)     index TX_014_HEX_STR               ; Get Hex value
                                   (0454)     call  TX_014_PutChar               ; Write data to screen
                                   (0455)     RAM_EPILOGUE RAM_USE_CLASS_1
0EDC: 70 BF    AND   F,191         (0456)     ret
0EDE: 60 D3    MOV   REG[211],A    (0457) .ENDSECTION
                                   (0458) 
0EE0: 52 00    MOV   A,[X+0]       (0459) .SECTION
0EE2: A0 06    JZ    0x0EE9        (0460) ;-----------------------------------------------------------------------------
0EE4: 9F EE    CALL  0x0ED4        (0461) ;  FUNCTION NAME: TX_014_PutSHexInt
0EE6: 75       INC   X             (0462) ;
0EE7: 8F F8    JMP   0x0EE0        (0463) ;  DESCRIPTION:
0EE9: 70 3F    AND   F,63
                                   (0464) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0465) ;
0EEB: 71 C0    OR    F,192         (0466) ;  ARGUMENTS:
0EED: 7F       RET                 (0467) ;     Pointer to string
                                   (0468) ;     A  => ASB of Int
                                   (0469) ;     X  => MSB of Int
                                   (0470) ;
                                   (0471) ;  RETURNS:
                                   (0472) ;     none.
                                   (0473) ;
                                   (0474) ;  SIDE EFFECTS:
                                   (0475) ;    The A and X registers may be modified by this or future implementations
                                   (0476) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0477) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0478) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0479) ;    functions.
                                   (0480) ;
                                   (0481)  TX_014_PutSHexInt:
                                   (0482) _TX_014_PutSHexInt:
                                   (0483)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0484)     swap  A,X
                                   (0485)     call  TX_014_PutSHexByte           ; Print MSB
                                   (0486)     mov   A,X                          ; Move LSB into position
                                   (0487)     call  TX_014_PutSHexByte           ; Print LSB
                                   (0488)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)     ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: TX_014_PutChar
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Send character out through UART TX port.
                                   (0498) ;
                                   (0499) ;
                                   (0500) ;  ARGUMENTS:
                                   (0501) ;     A has Character to send to UART Tx Port
                                   (0502) ;
0EEE: 70 BF    AND   F,191         (0503) ;  RETURNS:
0EF0: 62 D3 03 MOV   REG[211],3    (0504) ;     none
0EF3: 4F       MOV   X,SP          (0505) ;
                                   (0506) ;  SIDE EFFECTS:
                                   (0507) ;    The A and X registers may be modified by this or future implementations
0EF4: 52 FB    MOV   A,[X-5]       (0508) ;    of this function.  The same is true for all RAM page pointer registers in
0EF6: A0 1A    JZ    0x0F11        (0509) ;    the Large Memory Model.  When necessary, it is the calling function's
0EF8: 7B FB    DEC   [X-5]         (0510) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0511) ;    functions.
                                   (0512) ;
0EFA: 52 FC    MOV   A,[X-4]       (0513)    macro InLinePutChar( Source )
                                   (0514) .BufEmptyWaitLoop:
                                   (0515)    tst REG[TX_014_CONTROL_REG], TX_014_TX_BUFFER_EMPTY    ; Check Tx Status
0EFC: 59 FD    MOV   X,[X-3]       (0516)    jz  .BufEmptyWaitLoop
0EFE: 60 D3    MOV   REG[211],A    (0517)    mov REG[TX_014_TX_BUFFER_REG], @Source    ; Write data to Tx Port
0F00: 52 00    MOV   A,[X+0]       (0518)    endm
0F02: 49 2B 10 TST   REG[43],16
0F05: AF FC    JZ    0x0F02        (0519) 
0F07: 60 29    MOV   REG[41],A
0F09: 4F       MOV   X,SP          (0520) 
0F0A: 62 D3 03 MOV   REG[211],3    (0521)  TX_014_PutChar:
0F0D: 77 FD    INC   [X-3]         (0522) _TX_014_PutChar:
0F0F: 8F E4    JMP   0x0EF4        (0523)    RAM_PROLOGUE RAM_USE_CLASS_1
0F11: 70 3F    AND   F,63
                                   (0524)    InLinePutChar A
                                   (0525)    RAM_EPILOGUE RAM_USE_CLASS_1
0F13: 71 C0    OR    F,192         (0526)    ret
0F15: 7F       RET                 (0527) 
                                   (0528) .ENDSECTION
                                   (0529) 
                                   (0530) 
                                   (0531) ;-----------------------------------------------
                                   (0532) ;  High Level TX functions
                                   (0533) ;-----------------------------------------------
                                   (0534) 
                                   (0535) 
                                   (0536) .SECTION
                                   (0537) ;-----------------------------------------------------------------------------
                                   (0538) ;  FUNCTION NAME: TX_014_PutString
                                   (0539) ;
                                   (0540) ;  DESCRIPTION:
                                   (0541) ;     Send String out through UART TX port.
                                   (0542) ;
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;     Pointer to String
                                   (0546) ;     A has MSB of string address
                                   (0547) ;     X has LSB of string address
                                   (0548) ;
                                   (0549) ;  RETURNS:
                                   (0550) ;     none
                                   (0551) ;
                                   (0552) ;  SIDE EFFECTS:
                                   (0553) ;    The A and X registers may be modified by this or future implementations
                                   (0554) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0555) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0556) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0557) ;    functions.
                                   (0558) ;          
                                   (0559) ;    Currently only the page pointer registers listed below are modified: 
                                   (0560) ;          IDX_PP
                                   (0561) ;
                                   (0562)  TX_014_PutString:
                                   (0563) _TX_014_PutString:
0F16: 4F       MOV   X,SP          (0564)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0565)    RAM_SETPAGE_IDX A
                                   (0566) .PutStringLoop:
                                   (0567)    mov   A,[X]                             ; Get value pointed to by X
0F17: 3D FA 00 CMP   [X-6],0       (0568)    jz    End_PutString                     ; Check for end of string
0F1A: B0 06    JNZ   0x0F21        (0569)    call  TX_014_PutChar                     ; Send character to Tx port
0F1C: 3D FB 00 CMP   [X-5],0       (0570)    inc   X                                 ; Advance pointer to next character
0F1F: A0 1D    JZ    0x0F3D        (0571)    jmp   .PutStringLoop                     ; Get next character
                                   (0572) 
                                   (0573) End_PutString:
0F21: 10       PUSH  X             (0574)    RAM_EPILOGUE RAM_USE_CLASS_3
0F22: 52 FC    MOV   A,[X-4]       (0575)    ret
0F24: 59 FD    MOV   X,[X-3]       (0576) .ENDSECTION
0F26: 28       ROMX                (0577) 
0F27: 49 2B 10 TST   REG[43],16
0F2A: AF FC    JZ    0x0F27        (0578) .SECTION
0F2C: 60 29    MOV   REG[41],A
0F2E: 20       POP   X             (0579) ;-----------------------------------------------------------------------------
                                   (0580) ;  FUNCTION NAME: TX_014_Write
0F2F: 07 FD 01 ADD   [X-3],1       (0581) ;
0F32: 0F FC 00 ADC   [X-4],0       (0582) ;  DESCRIPTION:
                                   (0583) ;     Send String of length X to serial port
                                   (0584) ;
0F35: 17 FB 01 SUB   [X-5],1       (0585) ;
0F38: 1F FA 00 SBB   [X-6],0       (0586) ;  ARGUMENTS:
                                   (0587) ;     Pointer to String
0F3B: 8F DB    JMP   0x0F17        (0588) ;     [SP-5] Count of characters to send
                                   (0589) ;     [SP-4] has MSB of string address
                                   (0590) ;     [SP-3] has LSB of string address
                                   (0591) ;
0F3D: 7F       RET                 (0592) ;  RETURNS:
                                   (0593) ;     none
                                   (0594) ;
                                   (0595) ;  SIDE EFFECTS:
                                   (0596) ;    The A and X registers may be modified by this or future implementations
                                   (0597) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0598) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0599) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0600) ;    functions.
                                   (0601) ;          
                                   (0602) ;    Currently only the page pointer registers listed below are modified: 
                                   (0603) ;          IDX_PP
                                   (0604) ;
                                   (0605) CNT_LEN:    equ -5           ; Length of data to send
                                   (0606) STR_MSB:    equ -4           ; MSB pointer of string
                                   (0607) STR_LSB:    equ -3           ; LSB pointer of string
                                   (0608) 
                                   (0609)  TX_014_Write:
                                   (0610) _TX_014_Write:
                                   (0611)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0612)    RAM_SETPAGE_IDX2STK
                                   (0613)    mov   X, SP
                                   (0614) 
                                   (0615) .NextByteLoop:
                                   (0616)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
                                   (0617)    jz    .End_Write
                                   (0618)    dec   [X+CNT_LEN]                       ; Decrement counter
                                   (0619) 
                                   (0620)    IF SYSTEM_LARGE_MEMORY_MODEL
0F3E: 08       PUSH  A             (0621)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
0F3F: 10       PUSH  X             (0622)    ENDIF
0F40: 28       ROMX                (0623) 
0F41: A0 0B    JZ    0x0F4D        (0624)    mov   X,[X+STR_LSB]                     ; Get character to send
0F43: 9F 8F    CALL  0x0ED4        (0625)    RAM_SETPAGE_IDX A                        ; switch index pages
0F45: 20       POP   X             (0626)    mov   A,[X]
0F46: 18       POP   A             (0627)    InLinePutChar A                          ; Send character to UART
0F47: 75       INC   X             (0628)    mov   X, SP
0F48: DF F5    JNC   0x0F3E        (0629)    RAM_SETPAGE_IDX2STK
0F4A: 74       INC   A             (0630)    inc   [X+STR_LSB]
0F4B: 8F F2    JMP   0x0F3E        (0631)    jmp   .NextByteLoop
                                   (0632) 
                                   (0633) .End_Write:
                                   (0634)    RAM_EPILOGUE RAM_USE_CLASS_3
0F4D: 38 FE    ADD   SP,254        (0635)    ret
                                   (0636) .ENDSECTION
0F4F: 7F       RET                 (0637) 
                                   (0638) .SECTION
                                   (0639) ;-----------------------------------------------------------------------------
                                   (0640) ;  FUNCTION NAME: TX_014_CWrite
                                   (0641) ;
                                   (0642) ;             WARNING WARNING NOT COMPLETE
                                   (0643) ;
                                   (0644) ;  DESCRIPTION:
                                   (0645) ;     Send String of length X to serial port
                                   (0646) ;
                                   (0647) ;  ARGUMENTS:
                                   (0648) ;     Pointer to String
                                   (0649) ;     [SP-6] MSB of Count of character to send
                                   (0650) ;     [SP-5] LSB of Count of character to send
                                   (0651) ;     [SP-4] has MSB of string address
                                   (0652) ;     [SP-3] has LSB of string address
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
0F50: 50 0D    MOV   A,13          (0663) ;
0F52: 9F 80    CALL  0x0ED4        (0664) CLEN_MSB:   equ -6           ; MSB Length of data to send
0F54: 50 0A    MOV   A,10          (0665) CLEN_LSB:   equ -5           ; LSB Length of data to send
0F56: 9F 7C    CALL  0x0ED4        (0666) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (0667) CSTR_LSB:   equ -3           ; LSB pointer of string
0F59: 43 E1 02 OR    REG[225],2    (0668) 

FILE: lib\tx_01234_timeout.asm
                                   (0102) ;;*****************************************************************************
0F5C: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: TX_01234_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "TX_01234_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
0F5D: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
0F60: 7F       RET                 (0131) export  TX_01234_TIMEOUT_EnableInt
                                   (0132) export _TX_01234_TIMEOUT_EnableInt
                                   (0133) export  TX_01234_TIMEOUT_DisableInt
                                   (0134) export _TX_01234_TIMEOUT_DisableInt
                                   (0135) export  TX_01234_TIMEOUT_Start
                                   (0136) export _TX_01234_TIMEOUT_Start
                                   (0137) export  TX_01234_TIMEOUT_Stop
                                   (0138) export _TX_01234_TIMEOUT_Stop
                                   (0139) export  TX_01234_TIMEOUT_WritePeriod
                                   (0140) export _TX_01234_TIMEOUT_WritePeriod
                                   (0141) export  TX_01234_TIMEOUT_WriteCompareValue
                                   (0142) export _TX_01234_TIMEOUT_WriteCompareValue
                                   (0143) export  TX_01234_TIMEOUT_wReadCompareValue
                                   (0144) export _TX_01234_TIMEOUT_wReadCompareValue
                                   (0145) export  TX_01234_TIMEOUT_wReadTimer
                                   (0146) export _TX_01234_TIMEOUT_wReadTimer
                                   (0147) export  TX_01234_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _TX_01234_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wTX_01234_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wTX_01234_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wTX_01234_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wTX_01234_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wTX_01234_TIMEOUT_ReadTimerSaveCV   ; deprecated
0F61: 43 23 01 OR    REG[35],1     (0157) export _wTX_01234_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
0F64: 7F       RET                 (0159) export  wTX_01234_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wTX_01234_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wTX_01234_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wTX_01234_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA my_response_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: TX_01234_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
0F65: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
0F68: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  TX_01234_TIMEOUT_EnableInt:
                                   (0200) _TX_01234_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    TX_01234_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: TX_01234_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
0F69: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
0F6B: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
0F6C: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
0F6E: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  TX_01234_TIMEOUT_DisableInt:
                                   (0228) _TX_01234_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    TX_01234_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: TX_01234_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
0F6F: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
0F71: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
0F72: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
0F74: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  TX_01234_TIMEOUT_Start:
                                   (0256) _TX_01234_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    TX_01234_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: TX_01234_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
0F75: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
0F77: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
0F78: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
0F7A: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  TX_01234_TIMEOUT_Stop:
                                   (0284) _TX_01234_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    TX_01234_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_01234_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  TX_01234_TIMEOUT_WritePeriod:
                                   (0313) _TX_01234_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[TX_01234_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[TX_01234_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: TX_01234_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call TX_01234_TIMEOUT_Stop to disable).
0F7B: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
0F7C: 38 03    ADD   SP,3          (0334) ;
0F7E: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
0F80: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
0F81: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
0F83: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
0F84: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
0F86: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
0F87: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
0F89: 5D 26    MOV   A,REG[38]     (0343) ;
0F8B: 54 01    MOV   [X+1],A       (0344)  TX_01234_TIMEOUT_WriteCompareValue:
0F8D: 5D 22    MOV   A,REG[34]     (0345) _TX_01234_TIMEOUT_WriteCompareValue:
0F8F: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
0F91: 50 00    MOV   A,0           (0347)    mov   reg[TX_01234_TIMEOUT_COMPARE_LSB_REG], A
0F93: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
0F96: A0 03    JZ    0x0F9A        (0349)    mov   reg[TX_01234_TIMEOUT_COMPARE_MSB_REG], A
0F98: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
0F9A: 54 00    MOV   [X+0],A       (0352) 
0F9C: 70 FE    AND   F,254         (0353) .ENDSECTION
0F9E: 41 23 FE AND   REG[35],254   (0354) 
0FA1: 18       POP   A             (0355) 
0FA2: 60 26    MOV   REG[38],A     (0356) .SECTION
0FA4: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
0FA5: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: TX_01234_TIMEOUT_wReadCompareValue
0FA7: 18       POP   A             (0359) ;
0FA8: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
0FAA: 18       POP   A             (0361) ;     Reads the Compare registers.
0FAB: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
0FAC: 70 3F    AND   F,63
0FAE: 71 C0    OR    F,192         (0363) ;
0FB0: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  TX_01234_TIMEOUT_wReadCompareValue:
                                   (0374) _TX_01234_TIMEOUT_wReadCompareValue:
                                   (0375)  wTX_01234_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wTX_01234_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[TX_01234_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[TX_01234_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: TX_01234_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
0FB1: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
0FB3: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
0FB5: 5C       MOV   X,A           (0409) ;
0FB6: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
0FBA: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\servo_tx.asm
                                   (0109) ;;*****************************************************************************
0FBD: 7F       RET                 (0110) ;;*****************************************************************************
                                   (0111) ;;  FILENAME: SERVO_TX.asm
                                   (0112) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:51
                                   (0113) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0114) ;;
                                   (0115) ;;  DESCRIPTION: TX8 User Module software implementation file
                                   (0116) ;;               for 22/24/25/26/27xxx PSoc family of devices.
                                   (0117) ;;
                                   (0118) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0119) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0120) ;;        This means it is the caller's responsibility to preserve any values
                                   (0121) ;;        in the X and A registers that are still needed after the API functions
                                   (0122) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0123) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0124) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0125) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0126) ;;-----------------------------------------------------------------------------
                                   (0127) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0128) ;;*****************************************************************************
                                   (0129) ;;*****************************************************************************
                                   (0130) 
                                   (0131) ;-----------------------------------------------
                                   (0132) ; include instance specific register definitions
                                   (0133) ;-----------------------------------------------
                                   (0134) include "m8c.inc"
                                   (0135) include "memory.inc"
                                   (0136) include "SERVO_TX.inc"
0FBE: 41 E1 FB AND   REG[225],251  (0137) 
                                   (0138) area UserModules (ROM, REL)
0FC1: 7F       RET                 (0139) ;-----------------------------------------------
                                   (0140) ;  Global Symbols
                                   (0141) ;-----------------------------------------------
                                   (0142) export   SERVO_TX_SetTxIntMode
                                   (0143) export  _SERVO_TX_SetTxIntMode
                                   (0144) export   SERVO_TX_EnableInt
                                   (0145) export  _SERVO_TX_EnableInt
                                   (0146) export   SERVO_TX_DisableInt
                                   (0147) export  _SERVO_TX_DisableInt
                                   (0148) export   SERVO_TX_Start
                                   (0149) export  _SERVO_TX_Start
                                   (0150) export   SERVO_TX_Stop
                                   (0151) export  _SERVO_TX_Stop
                                   (0152) export   SERVO_TX_SendData
                                   (0153) export  _SERVO_TX_SendData
                                   (0154) export   SERVO_TX_bReadTxStatus
                                   (0155) export  _SERVO_TX_bReadTxStatus
                                   (0156) 
                                   (0157) // Old labels, will be removed in future release
                                   (0158) // Do Not Use.
                                   (0159) export   bSERVO_TX_ReadTxStatus
                                   (0160) export  _bSERVO_TX_ReadTxStatus
                                   (0161) 
                                   (0162) ;-----------------------------------------------
                                   (0163) ;  High Level TX functions
                                   (0164) ;-----------------------------------------------
                                   (0165) export  SERVO_TX_PutSHexByte
                                   (0166) export _SERVO_TX_PutSHexByte
                                   (0167) export  SERVO_TX_PutSHexInt
                                   (0168) export _SERVO_TX_PutSHexInt
                                   (0169) 
0FC2: 71 10    OR    F,16          (0170) export  SERVO_TX_CPutString
0FC4: 21 01    AND   A,1           (0171) export _SERVO_TX_CPutString
0FC6: A0 07    JZ    0x0FCE        (0172) export  SERVO_TX_PutString
0FC8: 43 28 10 OR    REG[40],16    (0173) export _SERVO_TX_PutString
0FCB: 70 EF    AND   F,239         (0174) export  SERVO_TX_PutChar
                                   (0175) export _SERVO_TX_PutChar
0FCD: 7F       RET                 (0176) export  SERVO_TX_Write
                                   (0177) export _SERVO_TX_Write
                                   (0178) export  SERVO_TX_CWrite
0FCE: 41 28 EF AND   REG[40],239   (0179) export _SERVO_TX_CWrite
0FD1: 70 EF    AND   F,239         (0180) export  SERVO_TX_PutCRLF
                                   (0181) export _SERVO_TX_PutCRLF 
0FD3: 7F       RET                 (0182) 
                                   (0183) ;-----------------------------------------------
                                   (0184) ;  EQUATES
                                   (0185) ;-----------------------------------------------
                                   (0186) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0187) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                   (0188) 
                                   (0189) AREA UserModules (ROM, REL)
                                   (0190) 
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: SERVO_TX_EnableInt
                                   (0194) ;
                                   (0195) ;  DESCRIPTION:
                                   (0196) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                   (0197) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0198) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0199) ;
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201) ;
                                   (0202) ;  ARGUMENTS: none
                                   (0203) ;
                                   (0204) ;  RETURNS: none
                                   (0205) ;
                                   (0206) ;  SIDE EFFECTS:
                                   (0207) ;    The A and X registers may be modified by this or future implementations
                                   (0208) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0210) ;    responsibility to perserve their values across calls to fastcall16 
0FD4: 29 01    OR    A,1           (0211) ;    functions.
0FD6: 60 2B    MOV   REG[43],A     (0212) ;
                                   (0213)  SERVO_TX_EnableInt:
0FD8: 7F       RET                 (0214) _SERVO_TX_EnableInt:
                                   (0215)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0216)    M8C_EnableIntMask  SERVO_TX_INT_REG, SERVO_TX_bINT_MASK
                                   (0217)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0218)    ret
                                   (0219) .ENDSECTION
                                   (0220) 
                                   (0221) .SECTION
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) ;  FUNCTION NAME: SERVO_TX_DisableInt
                                   (0224) ;
                                   (0225) ;  DESCRIPTION:
                                   (0226) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                   (0227) ;     associated with this User Module.
                                   (0228) ;
                                   (0229) ;-----------------------------------------------------------------------------
                                   (0230) ;
                                   (0231) ;  ARGUMENTS:  none
                                   (0232) ;
                                   (0233) ;  RETURNS:  none
                                   (0234) ;
                                   (0235) ;  SIDE EFFECTS:
                                   (0236) ;    The A and X registers may be modified by this or future implementations
                                   (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0239) ;    responsibility to perserve their values across calls to fastcall16 
0FD9: 41 2B FE AND   REG[43],254   (0240) ;    functions.
                                   (0241) ;
0FDC: 7F       RET                 (0242)  SERVO_TX_DisableInt:
                                   (0243) _SERVO_TX_DisableInt:
                                   (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0245)    M8C_DisableIntMask SERVO_TX_INT_REG, SERVO_TX_bINT_MASK
                                   (0246)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0247)    ret
                                   (0248) .ENDSECTION
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: SERVO_TX_SetTxIntMode(BYTE bTxIntMode)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0256) ;
                                   (0257) ;  ARGUMENTS:
                                   (0258) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0259) ;        Passed in the A register
                                   (0260) ;
                                   (0261) ;  RETURNS:
                                   (0262) ;     none.
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    The A and X registers may be modified by this or future implementations
                                   (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0268) ;    responsibility to perserve their values across calls to fastcall16 
0FDD: 60 29    MOV   REG[41],A     (0269) ;    functions.
                                   (0270) ;
0FDF: 7F       RET                 (0271) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0272) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0273) ;     on TX register empty or TX transmit complete
                                   (0274) ;
                                   (0275)  SERVO_TX_SetTxIntMode:
                                   (0276) _SERVO_TX_SetTxIntMode:
                                   (0277)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0278)    M8C_SetBank1
                                   (0279)    and   A, SERVO_TX_INT_MODE_TX_COMPLETE
                                   (0280)    jz    .SetModeRegEmpty
                                   (0281)    or    REG[SERVO_TX_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0282)    M8C_SetBank0
                                   (0283)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0284)    ret
                                   (0285) 
                                   (0286) .SetModeRegEmpty:
                                   (0287)    and   REG[SERVO_TX_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0288)    M8C_SetBank0
                                   (0289)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0290)    ret
                                   (0291) .ENDSECTION
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: SERVO_TX_Start(BYTE bParity)
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0299) ;     The transmitter will begin transmitting if a byte has been written into the
                                   (0300) ;     transmit buffer.
0FE0: 5D 2B    MOV   A,REG[43]     (0301) ;
                                   (0302) ;-----------------------------------------------------------------------------
0FE2: 7F       RET                 (0303) ;
0FE3: 30       HALT  
0FE4: 31 32    XOR   A,50
0FE6: 33 34    XOR   A,[X+52]
0FE8: 35 36    XOR   [X+54],A
0FEA: 37 38 39 XOR   [X+56],57
0FED: 41 42 43 AND   REG[66],67
0FF0: 44 45 46 OR    REG[X+69],70
                                   (0304) ;  ARGUMENTS:
                                   (0305) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                   (0306) ;
                                   (0307) ;  RETURNS:  none
                                   (0308) ;
                                   (0309) ;  SIDE EFFECTS:
                                   (0310) ;    The A and X registers may be modified by this or future implementations
                                   (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0314) ;    functions.
                                   (0315) ;
                                   (0316)  SERVO_TX_Start:
                                   (0317) _SERVO_TX_Start:
                                   (0318)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0319)    or    A, bfCONTROL_REG_START_BIT
                                   (0320)    mov   REG[SERVO_TX_CONTROL_REG], A
                                   (0321)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0322)    ret
                                   (0323) .ENDSECTION
                                   (0324) 
                                   (0325) .SECTION
                                   (0326) ;-----------------------------------------------------------------------------
                                   (0327) ;  FUNCTION NAME: SERVO_TX_Stop
                                   (0328) ;
                                   (0329) ;  DESCRIPTION:
                                   (0330) ;     Disables TX8 operation.
                                   (0331) ;
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:  none
0FF3: 08       PUSH  A             (0335) ;
0FF4: 67       ASR   A             (0336) ;  RETURNS:  none
0FF5: 67       ASR   A             (0337) ;
0FF6: 67       ASR   A             (0338) ;  SIDE EFFECTS:
0FF7: 67       ASR   A             (0339) ;    The A and X registers may be modified by this or future implementations
0FF8: 21 0F    AND   A,15          (0340) ;    of this function.  The same is true for all RAM page pointer registers in
0FFA: FF E7    INDEX 0x0FE3        (0341) ;    the Large Memory Model.  When necessary, it is the calling function's
0FFC: 90 0F    CALL  0x100D        (0342) ;    responsibility to perserve their values across calls to fastcall16 
0FFE: 18       POP   A             (0343) ;    functions.
0FFF: 21 0F    AND   A,15          (0344) ;
1001: FF E0    INDEX 0x0FE3        (0345)  SERVO_TX_Stop:
1003: 90 08    CALL  0x100D        (0346) _SERVO_TX_Stop:
                                   (0347)    RAM_PROLOGUE RAM_USE_CLASS_1
1005: 7F       RET                 (0348)    and   REG[SERVO_TX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0349)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0350)    ret
                                   (0351) .ENDSECTION
                                   (0352) 
                                   (0353) .SECTION
                                   (0354) ;-----------------------------------------------------------------------------
                                   (0355) ;  FUNCTION NAME: SERVO_TX_SendData
                                   (0356) ;
                                   (0357) ;  DESCRIPTION:
                                   (0358) ;     Sends one byte through serial port.
                                   (0359) ;
                                   (0360) ;-----------------------------------------------------------------------------
                                   (0361) ;
                                   (0362) ;  ARGUMENTS:
                                   (0363) ;     BYTE  TxData - data to transmit.
                                   (0364) ;
                                   (0365) ;  RETURNS:
                                   (0366) ;
                                   (0367) ;  SIDE EFFECTS:
                                   (0368) ;    The A and X registers may be modified by this or future implementations
                                   (0369) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0370) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0371) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0372) ;    functions.
                                   (0373) ;
                                   (0374)  SERVO_TX_SendData:
                                   (0375) _SERVO_TX_SendData:
1006: 4B       SWAP  A,X           (0376)    RAM_PROLOGUE RAM_USE_CLASS_1
1007: 9F EA    CALL  0x0FF3        (0377)    mov REG[SERVO_TX_TX_BUFFER_REG], A
1009: 5B       MOV   A,X           (0378)    RAM_EPILOGUE RAM_USE_CLASS_1
100A: 9F E7    CALL  0x0FF3        (0379)    ret
                                   (0380) .ENDSECTION
100C: 7F       RET                 (0381) 
100D: 49 2B 10 TST   REG[43],16
                                   (0382) .SECTION
                                   (0383) ;-----------------------------------------------------------------------------
                                   (0384) ;  FUNCTION NAME: SERVO_TX_bReadTxStatus
                                   (0385) ;
                                   (0386) ;  DESCRIPTION:
                                   (0387) ;     Reads the Tx Status bits in the Control/Status register.
                                   (0388) ;
                                   (0389) ;-----------------------------------------------------------------------------
                                   (0390) ;
                                   (0391) ;  ARGUMENTS:
                                   (0392) ;
                                   (0393) ;  RETURNS:
                                   (0394) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                   (0395) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;
                                   (0404)  SERVO_TX_bReadTxStatus:
                                   (0405) _SERVO_TX_bReadTxStatus:
                                   (0406)  bSERVO_TX_ReadTxStatus:
                                   (0407) _bSERVO_TX_ReadTxStatus:
                                   (0408)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0409)    mov A,  REG[SERVO_TX_CONTROL_REG]
                                   (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0411)    ret
                                   (0412) 
                                   (0413) .ENDSECTION
                                   (0414) 
                                   (0415) ;-----------------------------------------------------------------------------
1010: AF FC    JZ    0x100D        (0416) ;  FUNCTION NAME: SERVO_TX_PutSHexByte
1012: 60 29    MOV   REG[41],A
                                   (0417) ;
1014: 7F       RET                 (0418) ;  DESCRIPTION:
                                   (0419) ;     Print a byte in Hex (two characters) to the UART Tx
                                   (0420) ;
                                   (0421) ;  ARGUMENTS:
                                   (0422) ;     A  => (BYTE) Data/char to be printed
                                   (0423) ;
                                   (0424) ;  RETURNS:
                                   (0425) ;     none.
                                   (0426) ;
                                   (0427) ;  SIDE EFFECTS:
                                   (0428) ;    The A and X registers may be modified by this or future implementations
                                   (0429) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0430) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0431) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0432) ;    functions.
                                   (0433) ;
                                   (0434) .LITERAL
                                   (0435) SERVO_TX_HEX_STR:
                                   (0436)      DS    "0123456789ABCDEF"
                                   (0437) .ENDLITERAL
                                   (0438) 
                                   (0439) .SECTION
                                   (0440)  SERVO_TX_PutSHexByte:
                                   (0441) _SERVO_TX_PutSHexByte:
                                   (0442)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0443)     push  A                            ; Save lower nibble
                                   (0444)     asr   A                            ; Shift high nibble to right
                                   (0445)     asr   A
                                   (0446)     asr   A
                                   (0447)     asr   A
                                   (0448)     and   A,0Fh                        ; Mask off nibble
                                   (0449)     index SERVO_TX_HEX_STR             ; Get Hex value
                                   (0450)     call  SERVO_TX_PutChar             ; Write data to screen
                                   (0451)     pop   A                            ; Restore value
                                   (0452)     and   A,0Fh                        ; Mask off lower nibble
                                   (0453)     index SERVO_TX_HEX_STR             ; Get Hex value
                                   (0454)     call  SERVO_TX_PutChar             ; Write data to screen
                                   (0455)     RAM_EPILOGUE RAM_USE_CLASS_1
1015: 70 BF    AND   F,191         (0456)     ret
1017: 60 D3    MOV   REG[211],A    (0457) .ENDSECTION
                                   (0458) 
1019: 52 00    MOV   A,[X+0]       (0459) .SECTION
101B: A0 06    JZ    0x1022        (0460) ;-----------------------------------------------------------------------------
101D: 9F EE    CALL  0x100D        (0461) ;  FUNCTION NAME: SERVO_TX_PutSHexInt
101F: 75       INC   X             (0462) ;
1020: 8F F8    JMP   0x1019        (0463) ;  DESCRIPTION:
1022: 70 3F    AND   F,63
                                   (0464) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0465) ;
1024: 71 C0    OR    F,192         (0466) ;  ARGUMENTS:
1026: 7F       RET                 (0467) ;     Pointer to string
                                   (0468) ;     A  => ASB of Int
                                   (0469) ;     X  => MSB of Int
                                   (0470) ;
                                   (0471) ;  RETURNS:
                                   (0472) ;     none.
                                   (0473) ;
                                   (0474) ;  SIDE EFFECTS:
                                   (0475) ;    The A and X registers may be modified by this or future implementations
                                   (0476) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0477) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0478) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0479) ;    functions.
                                   (0480) ;
                                   (0481)  SERVO_TX_PutSHexInt:
                                   (0482) _SERVO_TX_PutSHexInt:
                                   (0483)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0484)     swap  A,X
                                   (0485)     call  SERVO_TX_PutSHexByte         ; Print MSB
                                   (0486)     mov   A,X                          ; Move LSB into position
                                   (0487)     call  SERVO_TX_PutSHexByte         ; Print LSB
                                   (0488)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)     ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: SERVO_TX_PutChar
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Send character out through UART TX port.
                                   (0498) ;
                                   (0499) ;
                                   (0500) ;  ARGUMENTS:
                                   (0501) ;     A has Character to send to UART Tx Port
                                   (0502) ;
1027: 70 BF    AND   F,191         (0503) ;  RETURNS:
1029: 62 D3 03 MOV   REG[211],3    (0504) ;     none
102C: 4F       MOV   X,SP          (0505) ;
                                   (0506) ;  SIDE EFFECTS:
                                   (0507) ;    The A and X registers may be modified by this or future implementations
102D: 52 FB    MOV   A,[X-5]       (0508) ;    of this function.  The same is true for all RAM page pointer registers in
102F: A0 1A    JZ    0x104A        (0509) ;    the Large Memory Model.  When necessary, it is the calling function's
1031: 7B FB    DEC   [X-5]         (0510) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0511) ;    functions.
                                   (0512) ;
1033: 52 FC    MOV   A,[X-4]       (0513)    macro InLinePutChar( Source )
                                   (0514) .BufEmptyWaitLoop:
                                   (0515)    tst REG[SERVO_TX_CONTROL_REG], SERVO_TX_TX_BUFFER_EMPTY    ; Check Tx Status
1035: 59 FD    MOV   X,[X-3]       (0516)    jz  .BufEmptyWaitLoop
1037: 60 D3    MOV   REG[211],A    (0517)    mov REG[SERVO_TX_TX_BUFFER_REG], @Source    ; Write data to Tx Port
1039: 52 00    MOV   A,[X+0]       (0518)    endm
103B: 49 2B 10 TST   REG[43],16
103E: AF FC    JZ    0x103B        (0519) 
1040: 60 29    MOV   REG[41],A
1042: 4F       MOV   X,SP          (0520) 
1043: 62 D3 03 MOV   REG[211],3    (0521)  SERVO_TX_PutChar:
1046: 77 FD    INC   [X-3]         (0522) _SERVO_TX_PutChar:
1048: 8F E4    JMP   0x102D        (0523)    RAM_PROLOGUE RAM_USE_CLASS_1
104A: 70 3F    AND   F,63
                                   (0524)    InLinePutChar A
                                   (0525)    RAM_EPILOGUE RAM_USE_CLASS_1
104C: 71 C0    OR    F,192         (0526)    ret
104E: 7F       RET                 (0527) 
                                   (0528) .ENDSECTION
                                   (0529) 
                                   (0530) 
                                   (0531) ;-----------------------------------------------
                                   (0532) ;  High Level TX functions
                                   (0533) ;-----------------------------------------------
                                   (0534) 
                                   (0535) 
                                   (0536) .SECTION
                                   (0537) ;-----------------------------------------------------------------------------
                                   (0538) ;  FUNCTION NAME: SERVO_TX_PutString
                                   (0539) ;
                                   (0540) ;  DESCRIPTION:
                                   (0541) ;     Send String out through UART TX port.
                                   (0542) ;
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;     Pointer to String
                                   (0546) ;     A has MSB of string address
                                   (0547) ;     X has LSB of string address
                                   (0548) ;
                                   (0549) ;  RETURNS:
                                   (0550) ;     none
                                   (0551) ;
                                   (0552) ;  SIDE EFFECTS:
                                   (0553) ;    The A and X registers may be modified by this or future implementations
                                   (0554) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0555) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0556) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0557) ;    functions.
                                   (0558) ;          
                                   (0559) ;    Currently only the page pointer registers listed below are modified: 
                                   (0560) ;          IDX_PP
                                   (0561) ;
                                   (0562)  SERVO_TX_PutString:
                                   (0563) _SERVO_TX_PutString:
104F: 4F       MOV   X,SP          (0564)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0565)    RAM_SETPAGE_IDX A
                                   (0566) .PutStringLoop:
                                   (0567)    mov   A,[X]                             ; Get value pointed to by X
1050: 3D FA 00 CMP   [X-6],0       (0568)    jz    End_PutString                     ; Check for end of string
1053: B0 06    JNZ   0x105A        (0569)    call  SERVO_TX_PutChar                   ; Send character to Tx port
1055: 3D FB 00 CMP   [X-5],0       (0570)    inc   X                                 ; Advance pointer to next character
1058: A0 1D    JZ    0x1076        (0571)    jmp   .PutStringLoop                     ; Get next character
                                   (0572) 
                                   (0573) End_PutString:
105A: 10       PUSH  X             (0574)    RAM_EPILOGUE RAM_USE_CLASS_3
105B: 52 FC    MOV   A,[X-4]       (0575)    ret
105D: 59 FD    MOV   X,[X-3]       (0576) .ENDSECTION
105F: 28       ROMX                (0577) 
1060: 49 2B 10 TST   REG[43],16
1063: AF FC    JZ    0x1060        (0578) .SECTION
1065: 60 29    MOV   REG[41],A
1067: 20       POP   X             (0579) ;-----------------------------------------------------------------------------
                                   (0580) ;  FUNCTION NAME: SERVO_TX_Write
1068: 07 FD 01 ADD   [X-3],1       (0581) ;
106B: 0F FC 00 ADC   [X-4],0       (0582) ;  DESCRIPTION:
                                   (0583) ;     Send String of length X to serial port
                                   (0584) ;
106E: 17 FB 01 SUB   [X-5],1       (0585) ;
1071: 1F FA 00 SBB   [X-6],0       (0586) ;  ARGUMENTS:
                                   (0587) ;     Pointer to String
1074: 8F DB    JMP   0x1050        (0588) ;     [SP-5] Count of characters to send
                                   (0589) ;     [SP-4] has MSB of string address
                                   (0590) ;     [SP-3] has LSB of string address
                                   (0591) ;
1076: 7F       RET                 (0592) ;  RETURNS:
                                   (0593) ;     none
                                   (0594) ;
                                   (0595) ;  SIDE EFFECTS:
                                   (0596) ;    The A and X registers may be modified by this or future implementations
                                   (0597) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0598) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0599) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0600) ;    functions.
                                   (0601) ;          
                                   (0602) ;    Currently only the page pointer registers listed below are modified: 
                                   (0603) ;          IDX_PP
                                   (0604) ;
                                   (0605) CNT_LEN:    equ -5           ; Length of data to send
                                   (0606) STR_MSB:    equ -4           ; MSB pointer of string
                                   (0607) STR_LSB:    equ -3           ; LSB pointer of string
                                   (0608) 
                                   (0609)  SERVO_TX_Write:
                                   (0610) _SERVO_TX_Write:
                                   (0611)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0612)    RAM_SETPAGE_IDX2STK
                                   (0613)    mov   X, SP
                                   (0614) 
                                   (0615) .NextByteLoop:
                                   (0616)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
                                   (0617)    jz    .End_Write
                                   (0618)    dec   [X+CNT_LEN]                       ; Decrement counter
                                   (0619) 
                                   (0620)    IF SYSTEM_LARGE_MEMORY_MODEL
1077: 08       PUSH  A             (0621)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
1078: 10       PUSH  X             (0622)    ENDIF
1079: 28       ROMX                (0623) 
107A: A0 0B    JZ    0x1086        (0624)    mov   X,[X+STR_LSB]                     ; Get character to send
107C: 9F 8F    CALL  0x100D        (0625)    RAM_SETPAGE_IDX A                        ; switch index pages
107E: 20       POP   X             (0626)    mov   A,[X]
107F: 18       POP   A             (0627)    InLinePutChar A                          ; Send character to UART
1080: 75       INC   X             (0628)    mov   X, SP
1081: DF F5    JNC   0x1077        (0629)    RAM_SETPAGE_IDX2STK
1083: 74       INC   A             (0630)    inc   [X+STR_LSB]
1084: 8F F2    JMP   0x1077        (0631)    jmp   .NextByteLoop
                                   (0632) 
                                   (0633) .End_Write:
                                   (0634)    RAM_EPILOGUE RAM_USE_CLASS_3
1086: 38 FE    ADD   SP,254        (0635)    ret
                                   (0636) .ENDSECTION
1088: 7F       RET                 (0637) 
                                   (0638) .SECTION
                                   (0639) ;-----------------------------------------------------------------------------
                                   (0640) ;  FUNCTION NAME: SERVO_TX_CWrite
                                   (0641) ;
                                   (0642) ;             WARNING WARNING NOT COMPLETE
                                   (0643) ;
                                   (0644) ;  DESCRIPTION:
                                   (0645) ;     Send String of length X to serial port
                                   (0646) ;
                                   (0647) ;  ARGUMENTS:
                                   (0648) ;     Pointer to String
                                   (0649) ;     [SP-6] MSB of Count of character to send
                                   (0650) ;     [SP-5] LSB of Count of character to send
                                   (0651) ;     [SP-4] has MSB of string address
                                   (0652) ;     [SP-3] has LSB of string address
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
1089: 50 0D    MOV   A,13          (0663) ;
108B: 9F 80    CALL  0x100D        (0664) CLEN_MSB:   equ -6           ; MSB Length of data to send
108D: 50 0A    MOV   A,10          (0665) CLEN_LSB:   equ -5           ; LSB Length of data to send
108F: 9F 7C    CALL  0x100D        (0666) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (0667) CSTR_LSB:   equ -3           ; LSB pointer of string
1092: 08       PUSH  A             (0668) 

FILE: lib\rx8_2int.asm
1093: 10       PUSH  X             (0104) ;;*****************************************************************************
1094: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: RX8_2INT.asm
1096: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1097: 58 03    MOV   X,[3]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1099: 5D 2F    MOV   A,REG[47]     (0111) ;;-----------------------------------------------------------------------------
109B: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
109C: 21 08    AND   A,8           (0114) ;;*****************************************************************************
109E: B0 04    JNZ   0x10A3        (0115) 
10A0: 18       POP   A             (0116) include "m8c.inc"
10A1: 80 5E    JMP   0x1100        (0117) include "memory.inc"
                                   (0118) include "RX8_2.inc"
                                   (0119) 
                                   (0120) 
10A3: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
10A4: 21 E0    AND   A,224         (0124) export  _RX8_2_ISR
10A6: A0 12    JZ    0x10B9        (0125) 
                                   (0126) 
10A8: 2C 02    OR    [2],A         (0127) IF (RX8_2_RXBUF_ENABLE)
                                   (0128) export  RX8_2_aRxBuffer
10AA: 49 2E 00 TST   REG[46],0     (0129) export _RX8_2_aRxBuffer
                                   (0130) export  RX8_2_bRxCnt
10AD: 21 20    AND   A,32          (0131) export _RX8_2_bRxCnt
10AF: A0 50    JZ    0x1100        (0132) export  RX8_2_fStatus
                                   (0133) export _RX8_2_fStatus
                                   (0134) ENDIF
                                   (0135) 
10B1: 41 2F FE AND   REG[47],254   (0136) 
10B4: 43 2F 01 OR    REG[47],1     (0137) ;-----------------------------------------------
10B7: 80 48    JMP   0x1100        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (RX8_2_RXBUF_ENABLE)
10B9: 5D 2E    MOV   A,REG[46]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  RX8_2_fStatus:
                                   (0144) _RX8_2_fStatus:      BLK  1
10BB: 47 02 01 TST   [2],1         (0145)  RX8_2_bRxCnt:
10BE: B0 41    JNZ   0x1100        (0146) _RX8_2_bRxCnt:       BLK  1
                                   (0147) AREA RX8_2_RAM(RAM,REL,CON)
10C0: 39 00    CMP   A,0           (0148)  RX8_2_aRxBuffer:    
10C2: B0 14    JNZ   0x10D7        (0149) _RX8_2_aRxBuffer:    BLK RX8_2_RX_BUFFER_SIZE
10C4: 2E 02 01 OR    [2],1         (0150) ENDIF
                                   (0151) 
10C7: 62 D3 00 MOV   REG[211],0    (0152) 
10CA: 70 3F    AND   F,63
10CC: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
10CE: 56 58 00 MOV   [X+88],0      (0154) 
10D1: 70 3F    AND   F,63
10D3: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
10D5: 80 2A    JMP   0x1100        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
10D7: 3C 03 0F CMP   [3],15        (0167) ;------------------------
10DA: C0 14    JC    0x10EF        (0168) 
10DC: 2E 02 10 OR    [2],16        (0169) 
                                   (0170) ;------------------------
10DF: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
10E2: 70 3F    AND   F,63
10E4: 71 80    OR    F,128         (0172) ;------------------------
10E6: 56 58 00 MOV   [X+88],0      (0173) 
10E9: 70 3F    AND   F,63
10EB: 71 00    OR    F,0           (0174) 
10ED: 80 12    JMP   0x1100        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
10EF: 75       INC   X             (0179) 
10F0: 5A 03    MOV   [3],X         (0180) 
10F2: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
10F3: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
10F6: 70 3F    AND   F,63
10F8: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _RX8_2_ISR
10FA: 54 58    MOV   [X+88],A      (0185) ;
10FC: 70 3F    AND   F,63
10FE: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1100: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1101: 60 D3    MOV   REG[211],A    (0191) _RX8_2_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1103: 20       POP   X             (0195)    ; Insert your custom code below this banner
1104: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1106: 43 E1 08 OR    REG[225],8    (0201)    ; Insert your custom code above this banner

FILE: lib\rx8_2.asm
                                   (0121) ;;*****************************************************************************
1109: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: RX8_2.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "RX8_2.inc"
110A: 41 E1 F7 AND   REG[225],247  (0149) 
                                   (0150) 
110D: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   RX8_2_EnableInt
                                   (0155) export  _RX8_2_EnableInt
                                   (0156) export   RX8_2_DisableInt
                                   (0157) export  _RX8_2_DisableInt
                                   (0158) export   RX8_2_Start
                                   (0159) export  _RX8_2_Start
                                   (0160) export   RX8_2_Stop
                                   (0161) export  _RX8_2_Stop
                                   (0162) export   RX8_2_bReadRxData
                                   (0163) export  _RX8_2_bReadRxData
                                   (0164) export   RX8_2_bReadRxStatus
                                   (0165) export  _RX8_2_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bRX8_2_ReadRxData
                                   (0170) export _bRX8_2_ReadRxData
                                   (0171) export  bRX8_2_ReadRxStatus
                                   (0172) export _bRX8_2_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  RX8_2_cGetChar
110E: 29 01    OR    A,1           (0179) export _RX8_2_cGetChar
1110: 60 2F    MOV   REG[47],A     (0180) export  RX8_2_cReadChar
                                   (0181) export _RX8_2_cReadChar
1112: 7F       RET                 (0182) export  RX8_2_iReadChar
                                   (0183) export _RX8_2_iReadChar
                                   (0184) 
                                   (0185) IF (RX8_2_RXBUF_ENABLE)
                                   (0186) export  RX8_2_CmdReset
                                   (0187) export _RX8_2_CmdReset
                                   (0188) export  RX8_2_bCmdCheck
                                   (0189) export _RX8_2_bCmdCheck
                                   (0190) export  RX8_2_bCmdLength
                                   (0191) export _RX8_2_bCmdLength
                                   (0192) export  RX8_2_bErrCheck
                                   (0193) export _RX8_2_bErrCheck
                                   (0194) 
                                   (0195) export  RX8_2_szGetParam
                                   (0196) export _RX8_2_szGetParam
                                   (0197) export  RX8_2_szGetRestOfParams
                                   (0198) export _RX8_2_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA RX8_2_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1113: 41 2F FE AND   REG[47],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1116: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: RX8_2_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  RX8_2_EnableInt:
                                   (0238) _RX8_2_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1117: 5D 2E    MOV   A,REG[46]     (0240)    M8C_EnableIntMask RX8_2_INT_REG, RX8_2_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1119: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: RX8_2_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  RX8_2_DisableInt:
                                   (0267) _RX8_2_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask RX8_2_INT_REG, RX8_2_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
111A: 5D 2F    MOV   A,REG[47]     (0272) .ENDSECTION
                                   (0273) 
111C: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: RX8_2_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  RX8_2_Start:
                                   (0297) _RX8_2_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[RX8_2_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: RX8_2_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
111D: 49 2F 08 TST   REG[47],8     (0311) ;
1120: AF FC    JZ    0x111D        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1122: 5D 2E    MOV   A,REG[46]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1124: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  RX8_2_Stop:
                                   (0326) _RX8_2_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[RX8_2_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: RX8_2_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1125: 5D 2F    MOV   A,REG[47]     (0346) ;    bRxData - returned in A.
1127: 08       PUSH  A             (0347) ;
1128: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
112A: B0 04    JNZ   0x112F        (0349) ;    The A and X registers may be modified by this or future implementations
112C: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
112D: 80 0B    JMP   0x1139        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
112F: 5D 2E    MOV   A,REG[46]     (0354) ;
1131: 4B       SWAP  A,X           (0355)  RX8_2_bReadRxData:
                                   (0356) _RX8_2_bReadRxData:
1132: 18       POP   A             (0357)  bRX8_2_ReadRxData:
1133: 21 A0    AND   A,160         (0358) _bRX8_2_ReadRxData:
1135: B0 03    JNZ   0x1139        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1137: 4B       SWAP  A,X           (0360)    mov A, REG[RX8_2_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1138: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1139: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: RX8_2_bReadRxStatus
                                   (0368) ;
113B: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  RX8_2_bReadRxStatus:
                                   (0388) _RX8_2_bReadRxStatus:
                                   (0389)  bRX8_2_ReadRxStatus:
                                   (0390) _bRX8_2_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[RX8_2_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: RX8_2_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
113C: 5D 2F    MOV   A,REG[47]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
113E: 21 E8    AND   A,232         (0408) ;
1140: 08       PUSH  A             (0409) ;  ARGUMENTS:
1141: 21 08    AND   A,8           (0410) ;      none
1143: B0 07    JNZ   0x114B        (0411) ;
1145: 18       POP   A             (0412) ;  RETURNS:
1146: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1148: 4B       SWAP  A,X           (0414) ;
1149: 80 07    JMP   0x1151        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
114B: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
114C: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
114E: 4B       SWAP  A,X           (0420) ;    functions.
114F: 5D 2E    MOV   A,REG[46]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1151: 7F       RET                 (0426)  RX8_2_cGetChar:
                                   (0427) _RX8_2_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[RX8_2_CONTROL_REG],RX8_2_RX_REG_FULL  ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[RX8_2_RX_BUFFER_REG]               ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: RX8_2_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  RX8_2_cReadChar:
                                   (0463) _RX8_2_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[RX8_2_CONTROL_REG]                           ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,RX8_2_RX_COMPLETE                                ; Check if a character is ready
1152: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1155: 55 58 00 MOV   [88],0        (0470)    pop  A
1158: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
115B: 55 DD 00 MOV   [221],0       (0472) 
115E: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1161: 55 03 00 MOV   [3],0         (0474)    mov  A,REG[RX8_2_RX_BUFFER_REG]                         ; Read data first, then
1164: 26 02 00 AND   [2],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1167: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(RX8_2_RX_PARITY_ERROR | RX8_2_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_RX8_2_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: RX8_2_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1168: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
116B: 51 02    MOV   A,[2]         (0511) ;        0x40CC    Overrun Error
116D: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
116F: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  RX8_2_iReadChar:
                                   (0523) _RX8_2_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[RX8_2_CONTROL_REG]                           ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(RX8_2_RX_ERROR|RX8_2_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,RX8_2_RX_COMPLETE                                ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,RX8_2_RX_NO_DATA                                 ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_RX8_2_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,RX8_2_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[RX8_2_RX_BUFFER_REG]                         ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_RX8_2_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (RX8_2_RXBUF_ENABLE)
                                   (0552) .SECTION
1170: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1173: 51 02    MOV   A,[2]         (0554) ;-----------------------------------------------------------------------------
1175: 21 F0    AND   A,240         (0555) ;
1177: 26 02 0F AND   [2],15        (0556) ;     Command Buffer commands
                                   (0557) ;
117A: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: RX8_2_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  RX8_2_CmdReset:
117B: 62 D0 00 MOV   REG[208],0    (0587) _RX8_2_CmdReset:
117E: 51 03    MOV   A,[3]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >RX8_2_aRxBuffer
1180: 7F       RET                 (0590)    mov [RX8_2_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >RX8_2_bRxCnt
                                   (0594)    mov [RX8_2_bRxCnt], 0x00
                                   (0595)    and [RX8_2_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: RX8_2_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  RX8_2_bCmdCheck:
                                   (0628) _RX8_2_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >RX8_2_fStatus
                                   (0631)    mov A,  [RX8_2_fStatus]
                                   (0632)    and A, RX8_2_RX_BUF_CMDTERM                   ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: RX8_2_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1181: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1183: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1186: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1189: 50 58    MOV   A,88          (0648) ;     BYTE  fStatus - Status of command receive buffer.
118B: 02 DD    ADD   A,[221]       (0649) ;                     Returns non-zero value in A if command is valid.
118D: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
118E: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1190: B0 04    JNZ   0x1195        (0653) ;           0x10 => Software Buffer OverRun
1192: 10       PUSH  X             (0654) ;
1193: 80 33    JMP   0x11C7        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1195: 39 00    CMP   A,0           (0660) ;    functions.
1197: B0 11    JNZ   0x11A9        (0661) ;          
1199: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
119A: 76 DD    INC   [221]         (0663) ;          CUR_PP
119C: 52 00    MOV   A,[X+0]       (0664) ;
119E: 3C DD 0F CMP   [221],15      (0665) ;     Error Status is clear when read.
11A1: BF F3    JNZ   0x1195        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
11A3: 10       PUSH  X             (0669) ;
                                   (0670)  RX8_2_bErrCheck:
11A4: 56 00 00 MOV   [X+0],0       (0671) _RX8_2_bErrCheck:
11A7: 80 1F    JMP   0x11C7        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >RX8_2_fStatus
                                   (0674)    mov A,  [RX8_2_fStatus]
11A9: 10       PUSH  X             (0675)    and A, RX8_2_RX_BUF_ERROR                     ; Mask off Error status
                                   (0676)    and [RX8_2_fStatus], ~RX8_2_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
11AA: 75       INC   X             (0679) .ENDSECTION
11AB: 76 DD    INC   [221]         (0680) 
11AD: 3C DD 0F CMP   [221],15      (0681) .SECTION
11B0: AF F3    JZ    0x11A4        (0682) ;-----------------------------------------------------------------------------
11B2: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: RX8_2_bCmdLength
11B4: A0 12    JZ    0x11C7        (0684) ;
11B6: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
11B8: BF F1    JNZ   0x11AA        (0686) ;     Get length of command string
                                   (0687) ;
11BA: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
11BD: 76 DD    INC   [221]         (0689) ;     none.
11BF: 3C DD 0F CMP   [221],15      (0690) ;
11C2: B0 04    JNZ   0x11C7        (0691) ;  RETURNS:
11C4: 55 DD 0F MOV   [221],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
11C7: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
11C8: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
11C9: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
11CC: B0 0B    JNZ   0x11D8        (0699) ;    functions.
11CE: 20       POP   X             (0700) ;          
11CF: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
11D1: 50 00    MOV   A,0           (0702) ;          CUR_PP
11D3: 70 3F    AND   F,63
11D5: 71 C0    OR    F,192         (0703) ;
                                   (0704)  RX8_2_bCmdLength:
11D7: 7F       RET                 (0705) _RX8_2_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >RX8_2_bRxCnt
11D8: 20       POP   X             (0708)    mov A,  [RX8_2_bRxCnt]
11D9: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
11DB: 70 3F    AND   F,63
11DD: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
11DF: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: RX8_2_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
11E0: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
11E3: 50 58    MOV   A,88          (0744) ;     each lexically distinct element into a null-terminated string by replacing
11E5: 02 DD    ADD   A,[221]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
11E7: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
11E8: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     RX8_2_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, RX8_2_szGetParam, is
11EB: 43 E1 02 OR    REG[225],2    (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\init_timeout.asm
                                   (0102) ;;*****************************************************************************
11EE: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: INIT_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "INIT_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
11EF: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
11F2: 7F       RET                 (0131) export  INIT_TIMEOUT_EnableInt
                                   (0132) export _INIT_TIMEOUT_EnableInt
                                   (0133) export  INIT_TIMEOUT_DisableInt
                                   (0134) export _INIT_TIMEOUT_DisableInt
                                   (0135) export  INIT_TIMEOUT_Start
                                   (0136) export _INIT_TIMEOUT_Start
                                   (0137) export  INIT_TIMEOUT_Stop
                                   (0138) export _INIT_TIMEOUT_Stop
                                   (0139) export  INIT_TIMEOUT_WritePeriod
                                   (0140) export _INIT_TIMEOUT_WritePeriod
                                   (0141) export  INIT_TIMEOUT_WriteCompareValue
                                   (0142) export _INIT_TIMEOUT_WriteCompareValue
                                   (0143) export  INIT_TIMEOUT_wReadCompareValue
                                   (0144) export _INIT_TIMEOUT_wReadCompareValue
                                   (0145) export  INIT_TIMEOUT_wReadTimer
                                   (0146) export _INIT_TIMEOUT_wReadTimer
                                   (0147) export  INIT_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _INIT_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wINIT_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wINIT_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wINIT_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wINIT_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wINIT_TIMEOUT_ReadTimerSaveCV   ; deprecated
11F3: 43 23 01 OR    REG[35],1     (0157) export _wINIT_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
11F6: 7F       RET                 (0159) export  wINIT_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wINIT_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wINIT_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wINIT_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA initial_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: INIT_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
11F7: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
11FA: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  INIT_TIMEOUT_EnableInt:
                                   (0200) _INIT_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    INIT_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: INIT_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
11FB: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
11FD: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
11FE: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
1200: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  INIT_TIMEOUT_DisableInt:
                                   (0228) _INIT_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    INIT_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: INIT_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
1201: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
1203: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
1204: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
1206: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  INIT_TIMEOUT_Start:
                                   (0256) _INIT_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    INIT_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: INIT_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
1207: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
1209: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
120A: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
120C: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  INIT_TIMEOUT_Stop:
                                   (0284) _INIT_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    INIT_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: INIT_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  INIT_TIMEOUT_WritePeriod:
                                   (0313) _INIT_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[INIT_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[INIT_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: INIT_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call INIT_TIMEOUT_Stop to disable).
120D: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
120E: 38 03    ADD   SP,3          (0334) ;
1210: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
1212: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
1213: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
1215: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
1216: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
1218: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
1219: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
121B: 5D 26    MOV   A,REG[38]     (0343) ;
121D: 54 01    MOV   [X+1],A       (0344)  INIT_TIMEOUT_WriteCompareValue:
121F: 5D 22    MOV   A,REG[34]     (0345) _INIT_TIMEOUT_WriteCompareValue:
1221: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
1223: 50 00    MOV   A,0           (0347)    mov   reg[INIT_TIMEOUT_COMPARE_LSB_REG], A
1225: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
1228: A0 03    JZ    0x122C        (0349)    mov   reg[INIT_TIMEOUT_COMPARE_MSB_REG], A
122A: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
122C: 54 00    MOV   [X+0],A       (0352) 
122E: 70 FE    AND   F,254         (0353) .ENDSECTION
1230: 41 23 FE AND   REG[35],254   (0354) 
1233: 18       POP   A             (0355) 
1234: 60 26    MOV   REG[38],A     (0356) .SECTION
1236: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
1237: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: INIT_TIMEOUT_wReadCompareValue
1239: 18       POP   A             (0359) ;
123A: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
123C: 18       POP   A             (0361) ;     Reads the Compare registers.
123D: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
123E: 70 3F    AND   F,63
1240: 71 C0    OR    F,192         (0363) ;
1242: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  INIT_TIMEOUT_wReadCompareValue:
                                   (0374) _INIT_TIMEOUT_wReadCompareValue:
                                   (0375)  wINIT_TIMEOUT_ReadCompareValue:                 ; this name deprecated
                                   (0376) _wINIT_TIMEOUT_ReadCompareValue:                 ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[INIT_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[INIT_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: INIT_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
1243: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
1245: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
1247: 5C       MOV   X,A           (0409) ;
1248: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
124B: 08       PUSH  A             (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\init_rxint.asm
124C: 10       PUSH  X             (0104) ;;*****************************************************************************
124D: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: INIT_RXINT.asm
124F: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1250: 58 07    MOV   X,[7]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1252: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
1254: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1255: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1257: B0 04    JNZ   0x125C        (0115) 
1259: 18       POP   A             (0116) include "m8c.inc"
125A: 80 5E    JMP   0x12B9        (0117) include "memory.inc"
                                   (0118) include "INIT_RX.inc"
                                   (0119) 
                                   (0120) 
125C: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
125D: 21 E0    AND   A,224         (0124) export  _INIT_RX_ISR
125F: A0 12    JZ    0x1272        (0125) 
                                   (0126) 
1261: 2C 06    OR    [6],A         (0127) IF (INIT_RX_RXBUF_ENABLE)
                                   (0128) export  INIT_RX_aRxBuffer
1263: 49 2A 00 TST   REG[42],0     (0129) export _INIT_RX_aRxBuffer
                                   (0130) export  INIT_RX_bRxCnt
1266: 21 20    AND   A,32          (0131) export _INIT_RX_bRxCnt
1268: A0 50    JZ    0x12B9        (0132) export  INIT_RX_fStatus
                                   (0133) export _INIT_RX_fStatus
                                   (0134) ENDIF
                                   (0135) 
126A: 41 2B FE AND   REG[43],254   (0136) 
126D: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
1270: 80 48    JMP   0x12B9        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (INIT_RX_RXBUF_ENABLE)
1272: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  INIT_RX_fStatus:
                                   (0144) _INIT_RX_fStatus:      BLK  1
1274: 47 06 01 TST   [6],1         (0145)  INIT_RX_bRxCnt:
1277: B0 41    JNZ   0x12B9        (0146) _INIT_RX_bRxCnt:       BLK  1
                                   (0147) AREA INIT_RX_RAM(RAM,REL,CON)
1279: 39 00    CMP   A,0           (0148)  INIT_RX_aRxBuffer:    
127B: B0 14    JNZ   0x1290        (0149) _INIT_RX_aRxBuffer:    BLK INIT_RX_RX_BUFFER_SIZE
127D: 2E 06 01 OR    [6],1         (0150) ENDIF
                                   (0151) 
1280: 62 D3 00 MOV   REG[211],0    (0152) 
1283: 70 3F    AND   F,63
1285: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1287: 56 48 00 MOV   [X+72],0      (0154) 
128A: 70 3F    AND   F,63
128C: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
128E: 80 2A    JMP   0x12B9        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1290: 3C 07 0F CMP   [7],15        (0167) ;------------------------
1293: C0 14    JC    0x12A8        (0168) 
1295: 2E 06 10 OR    [6],16        (0169) 
                                   (0170) ;------------------------
1298: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
129B: 70 3F    AND   F,63
129D: 71 80    OR    F,128         (0172) ;------------------------
129F: 56 48 00 MOV   [X+72],0      (0173) 
12A2: 70 3F    AND   F,63
12A4: 71 00    OR    F,0           (0174) 
12A6: 80 12    JMP   0x12B9        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
12A8: 75       INC   X             (0179) 
12A9: 5A 07    MOV   [7],X         (0180) 
12AB: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
12AC: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
12AF: 70 3F    AND   F,63
12B1: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _INIT_RX_ISR
12B3: 54 48    MOV   [X+72],A      (0185) ;
12B5: 70 3F    AND   F,63
12B7: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
12B9: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
12BA: 60 D3    MOV   REG[211],A    (0191) _INIT_RX_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
12BC: 20       POP   X             (0195)    ; Insert your custom code below this banner
12BD: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
12BF: 43 E1 04 OR    REG[225],4    (0201)    ; Insert your custom code above this banner

FILE: lib\init_rx.asm
                                   (0121) ;;*****************************************************************************
12C2: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: INIT_RX.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "INIT_RX.inc"
12C3: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
12C6: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   INIT_RX_EnableInt
                                   (0155) export  _INIT_RX_EnableInt
                                   (0156) export   INIT_RX_DisableInt
                                   (0157) export  _INIT_RX_DisableInt
                                   (0158) export   INIT_RX_Start
                                   (0159) export  _INIT_RX_Start
                                   (0160) export   INIT_RX_Stop
                                   (0161) export  _INIT_RX_Stop
                                   (0162) export   INIT_RX_bReadRxData
                                   (0163) export  _INIT_RX_bReadRxData
                                   (0164) export   INIT_RX_bReadRxStatus
                                   (0165) export  _INIT_RX_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bINIT_RX_ReadRxData
                                   (0170) export _bINIT_RX_ReadRxData
                                   (0171) export  bINIT_RX_ReadRxStatus
                                   (0172) export _bINIT_RX_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  INIT_RX_cGetChar
12C7: 29 01    OR    A,1           (0179) export _INIT_RX_cGetChar
12C9: 60 2B    MOV   REG[43],A     (0180) export  INIT_RX_cReadChar
                                   (0181) export _INIT_RX_cReadChar
12CB: 7F       RET                 (0182) export  INIT_RX_iReadChar
                                   (0183) export _INIT_RX_iReadChar
                                   (0184) 
                                   (0185) IF (INIT_RX_RXBUF_ENABLE)
                                   (0186) export  INIT_RX_CmdReset
                                   (0187) export _INIT_RX_CmdReset
                                   (0188) export  INIT_RX_bCmdCheck
                                   (0189) export _INIT_RX_bCmdCheck
                                   (0190) export  INIT_RX_bCmdLength
                                   (0191) export _INIT_RX_bCmdLength
                                   (0192) export  INIT_RX_bErrCheck
                                   (0193) export _INIT_RX_bErrCheck
                                   (0194) 
                                   (0195) export  INIT_RX_szGetParam
                                   (0196) export _INIT_RX_szGetParam
                                   (0197) export  INIT_RX_szGetRestOfParams
                                   (0198) export _INIT_RX_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA INIT_RX_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
12CC: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
12CF: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: INIT_RX_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  INIT_RX_EnableInt:
                                   (0238) _INIT_RX_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
12D0: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask INIT_RX_INT_REG, INIT_RX_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
12D2: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: INIT_RX_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  INIT_RX_DisableInt:
                                   (0267) _INIT_RX_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask INIT_RX_INT_REG, INIT_RX_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
12D3: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
12D5: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: INIT_RX_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  INIT_RX_Start:
                                   (0297) _INIT_RX_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[INIT_RX_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: INIT_RX_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
12D6: 49 2B 08 TST   REG[43],8     (0311) ;
12D9: AF FC    JZ    0x12D6        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
12DB: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
12DD: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  INIT_RX_Stop:
                                   (0326) _INIT_RX_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[INIT_RX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: INIT_RX_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
12DE: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
12E0: 08       PUSH  A             (0347) ;
12E1: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
12E3: B0 04    JNZ   0x12E8        (0349) ;    The A and X registers may be modified by this or future implementations
12E5: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
12E6: 80 0B    JMP   0x12F2        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
12E8: 5D 2A    MOV   A,REG[42]     (0354) ;
12EA: 4B       SWAP  A,X           (0355)  INIT_RX_bReadRxData:
                                   (0356) _INIT_RX_bReadRxData:
12EB: 18       POP   A             (0357)  bINIT_RX_ReadRxData:
12EC: 21 A0    AND   A,160         (0358) _bINIT_RX_ReadRxData:
12EE: B0 03    JNZ   0x12F2        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
12F0: 4B       SWAP  A,X           (0360)    mov A, REG[INIT_RX_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
12F1: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
12F2: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: INIT_RX_bReadRxStatus
                                   (0368) ;
12F4: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  INIT_RX_bReadRxStatus:
                                   (0388) _INIT_RX_bReadRxStatus:
                                   (0389)  bINIT_RX_ReadRxStatus:
                                   (0390) _bINIT_RX_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[INIT_RX_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: INIT_RX_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
12F5: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
12F7: 21 E8    AND   A,232         (0408) ;
12F9: 08       PUSH  A             (0409) ;  ARGUMENTS:
12FA: 21 08    AND   A,8           (0410) ;      none
12FC: B0 07    JNZ   0x1304        (0411) ;
12FE: 18       POP   A             (0412) ;  RETURNS:
12FF: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1301: 4B       SWAP  A,X           (0414) ;
1302: 80 07    JMP   0x130A        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1304: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1305: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1307: 4B       SWAP  A,X           (0420) ;    functions.
1308: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
130A: 7F       RET                 (0426)  INIT_RX_cGetChar:
                                   (0427) _INIT_RX_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[INIT_RX_CONTROL_REG],INIT_RX_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[INIT_RX_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: INIT_RX_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  INIT_RX_cReadChar:
                                   (0463) _INIT_RX_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[INIT_RX_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,INIT_RX_RX_COMPLETE                              ; Check if a character is ready
130B: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
130E: 55 48 00 MOV   [72],0        (0470)    pop  A
1311: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1314: 55 DC 00 MOV   [220],0       (0472) 
1317: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
131A: 55 07 00 MOV   [7],0         (0474)    mov  A,REG[INIT_RX_RX_BUFFER_REG]                       ; Read data first, then
131D: 26 06 00 AND   [6],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1320: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(INIT_RX_RX_PARITY_ERROR | INIT_RX_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_INIT_RX_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: INIT_RX_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1321: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1324: 51 06    MOV   A,[6]         (0511) ;        0x40CC    Overrun Error
1326: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1328: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  INIT_RX_iReadChar:
                                   (0523) _INIT_RX_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[INIT_RX_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(INIT_RX_RX_ERROR|INIT_RX_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,INIT_RX_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,INIT_RX_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_INIT_RX_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,INIT_RX_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[INIT_RX_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_INIT_RX_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (INIT_RX_RXBUF_ENABLE)
                                   (0552) .SECTION
1329: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
132C: 51 06    MOV   A,[6]         (0554) ;-----------------------------------------------------------------------------
132E: 21 F0    AND   A,240         (0555) ;
1330: 26 06 0F AND   [6],15        (0556) ;     Command Buffer commands
                                   (0557) ;
1333: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: INIT_RX_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  INIT_RX_CmdReset:
1334: 62 D0 00 MOV   REG[208],0    (0587) _INIT_RX_CmdReset:
1337: 51 07    MOV   A,[7]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >INIT_RX_aRxBuffer
1339: 7F       RET                 (0590)    mov [INIT_RX_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >INIT_RX_bRxCnt
                                   (0594)    mov [INIT_RX_bRxCnt], 0x00
                                   (0595)    and [INIT_RX_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: INIT_RX_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  INIT_RX_bCmdCheck:
                                   (0628) _INIT_RX_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >INIT_RX_fStatus
                                   (0631)    mov A,  [INIT_RX_fStatus]
                                   (0632)    and A, INIT_RX_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: INIT_RX_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
133A: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
133C: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
133F: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1342: 50 48    MOV   A,72          (0648) ;     BYTE  fStatus - Status of command receive buffer.
1344: 02 DC    ADD   A,[220]       (0649) ;                     Returns non-zero value in A if command is valid.
1346: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1347: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1349: B0 04    JNZ   0x134E        (0653) ;           0x10 => Software Buffer OverRun
134B: 10       PUSH  X             (0654) ;
134C: 80 33    JMP   0x1380        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
134E: 39 00    CMP   A,0           (0660) ;    functions.
1350: B0 11    JNZ   0x1362        (0661) ;          
1352: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1353: 76 DC    INC   [220]         (0663) ;          CUR_PP
1355: 52 00    MOV   A,[X+0]       (0664) ;
1357: 3C DC 0F CMP   [220],15      (0665) ;     Error Status is clear when read.
135A: BF F3    JNZ   0x134E        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
135C: 10       PUSH  X             (0669) ;
                                   (0670)  INIT_RX_bErrCheck:
135D: 56 00 00 MOV   [X+0],0       (0671) _INIT_RX_bErrCheck:
1360: 80 1F    JMP   0x1380        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >INIT_RX_fStatus
                                   (0674)    mov A,  [INIT_RX_fStatus]
1362: 10       PUSH  X             (0675)    and A, INIT_RX_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [INIT_RX_fStatus], ~INIT_RX_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
1363: 75       INC   X             (0679) .ENDSECTION
1364: 76 DC    INC   [220]         (0680) 
1366: 3C DC 0F CMP   [220],15      (0681) .SECTION
1369: AF F3    JZ    0x135D        (0682) ;-----------------------------------------------------------------------------
136B: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: INIT_RX_bCmdLength
136D: A0 12    JZ    0x1380        (0684) ;
136F: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1371: BF F1    JNZ   0x1363        (0686) ;     Get length of command string
                                   (0687) ;
1373: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
1376: 76 DC    INC   [220]         (0689) ;     none.
1378: 3C DC 0F CMP   [220],15      (0690) ;
137B: B0 04    JNZ   0x1380        (0691) ;  RETURNS:
137D: 55 DC 0F MOV   [220],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1380: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1381: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
1382: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1385: B0 0B    JNZ   0x1391        (0699) ;    functions.
1387: 20       POP   X             (0700) ;          
1388: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
138A: 50 00    MOV   A,0           (0702) ;          CUR_PP
138C: 70 3F    AND   F,63
138E: 71 C0    OR    F,192         (0703) ;
                                   (0704)  INIT_RX_bCmdLength:
1390: 7F       RET                 (0705) _INIT_RX_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >INIT_RX_bRxCnt
1391: 20       POP   X             (0708)    mov A,  [INIT_RX_bRxCnt]
1392: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1394: 70 3F    AND   F,63
1396: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1398: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: INIT_RX_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1399: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
139C: 50 48    MOV   A,72          (0744) ;     each lexically distinct element into a null-terminated string by replacing
139E: 02 DC    ADD   A,[220]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
13A0: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
13A1: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     INIT_RX_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, INIT_RX_szGetParam, is
13A4: 43 E1 02 OR    REG[225],2    (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\hello_timeout.asm
                                   (0102) ;;*****************************************************************************
13A7: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: HELLO_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "HELLO_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
13A8: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
13AB: 7F       RET                 (0131) export  HELLO_TIMEOUT_EnableInt
                                   (0132) export _HELLO_TIMEOUT_EnableInt
                                   (0133) export  HELLO_TIMEOUT_DisableInt
                                   (0134) export _HELLO_TIMEOUT_DisableInt
                                   (0135) export  HELLO_TIMEOUT_Start
                                   (0136) export _HELLO_TIMEOUT_Start
                                   (0137) export  HELLO_TIMEOUT_Stop
                                   (0138) export _HELLO_TIMEOUT_Stop
                                   (0139) export  HELLO_TIMEOUT_WritePeriod
                                   (0140) export _HELLO_TIMEOUT_WritePeriod
                                   (0141) export  HELLO_TIMEOUT_WriteCompareValue
                                   (0142) export _HELLO_TIMEOUT_WriteCompareValue
                                   (0143) export  HELLO_TIMEOUT_wReadCompareValue
                                   (0144) export _HELLO_TIMEOUT_wReadCompareValue
                                   (0145) export  HELLO_TIMEOUT_wReadTimer
                                   (0146) export _HELLO_TIMEOUT_wReadTimer
                                   (0147) export  HELLO_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _HELLO_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wHELLO_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wHELLO_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wHELLO_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wHELLO_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wHELLO_TIMEOUT_ReadTimerSaveCV   ; deprecated
13AC: 43 23 01 OR    REG[35],1     (0157) export _wHELLO_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
13AF: 7F       RET                 (0159) export  wHELLO_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wHELLO_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wHELLO_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wHELLO_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA hello_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: HELLO_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
13B0: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
13B3: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  HELLO_TIMEOUT_EnableInt:
                                   (0200) _HELLO_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    HELLO_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: HELLO_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
13B4: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
13B6: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
13B7: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
13B9: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  HELLO_TIMEOUT_DisableInt:
                                   (0228) _HELLO_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    HELLO_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: HELLO_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
13BA: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
13BC: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
13BD: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
13BF: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  HELLO_TIMEOUT_Start:
                                   (0256) _HELLO_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    HELLO_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: HELLO_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
13C0: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
13C2: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
13C3: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
13C5: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  HELLO_TIMEOUT_Stop:
                                   (0284) _HELLO_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    HELLO_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: HELLO_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  HELLO_TIMEOUT_WritePeriod:
                                   (0313) _HELLO_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[HELLO_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[HELLO_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: HELLO_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call HELLO_TIMEOUT_Stop to disable).
13C6: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
13C7: 38 03    ADD   SP,3          (0334) ;
13C9: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
13CB: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
13CC: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
13CE: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
13CF: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
13D1: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
13D2: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
13D4: 5D 26    MOV   A,REG[38]     (0343) ;
13D6: 54 01    MOV   [X+1],A       (0344)  HELLO_TIMEOUT_WriteCompareValue:
13D8: 5D 22    MOV   A,REG[34]     (0345) _HELLO_TIMEOUT_WriteCompareValue:
13DA: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
13DC: 50 00    MOV   A,0           (0347)    mov   reg[HELLO_TIMEOUT_COMPARE_LSB_REG], A
13DE: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
13E1: A0 03    JZ    0x13E5        (0349)    mov   reg[HELLO_TIMEOUT_COMPARE_MSB_REG], A
13E3: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
13E5: 54 00    MOV   [X+0],A       (0352) 
13E7: 70 FE    AND   F,254         (0353) .ENDSECTION
13E9: 41 23 FE AND   REG[35],254   (0354) 
13EC: 18       POP   A             (0355) 
13ED: 60 26    MOV   REG[38],A     (0356) .SECTION
13EF: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
13F0: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: HELLO_TIMEOUT_wReadCompareValue
13F2: 18       POP   A             (0359) ;
13F3: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
13F5: 18       POP   A             (0361) ;     Reads the Compare registers.
13F6: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
13F7: 70 3F    AND   F,63
13F9: 71 C0    OR    F,192         (0363) ;
13FB: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  HELLO_TIMEOUT_wReadCompareValue:
                                   (0374) _HELLO_TIMEOUT_wReadCompareValue:
                                   (0375)  wHELLO_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wHELLO_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[HELLO_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[HELLO_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: HELLO_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
13FC: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
13FE: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
1400: 5C       MOV   X,A           (0409) ;
1401: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
1404: 08       PUSH  A             (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\hello_4int.asm
1405: 10       PUSH  X             (0104) ;;*****************************************************************************
1406: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: HELLO_4INT.asm
1408: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1409: 58 09    MOV   X,[9]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
140B: 5D 3F    MOV   A,REG[63]     (0111) ;;-----------------------------------------------------------------------------
140D: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
140E: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1410: B0 04    JNZ   0x1415        (0115) 
1412: 18       POP   A             (0116) include "m8c.inc"
1413: 80 5E    JMP   0x1472        (0117) include "memory.inc"
                                   (0118) include "HELLO_4.inc"
                                   (0119) 
                                   (0120) 
1415: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1416: 21 E0    AND   A,224         (0124) export  _HELLO_4_ISR
1418: A0 12    JZ    0x142B        (0125) 
                                   (0126) 
141A: 2C 08    OR    [8],A         (0127) IF (HELLO_4_RXBUF_ENABLE)
                                   (0128) export  HELLO_4_aRxBuffer
141C: 49 3E 00 TST   REG[62],0     (0129) export _HELLO_4_aRxBuffer
                                   (0130) export  HELLO_4_bRxCnt
141F: 21 20    AND   A,32          (0131) export _HELLO_4_bRxCnt
1421: A0 50    JZ    0x1472        (0132) export  HELLO_4_fStatus
                                   (0133) export _HELLO_4_fStatus
                                   (0134) ENDIF
                                   (0135) 
1423: 41 3F FE AND   REG[63],254   (0136) 
1426: 43 3F 01 OR    REG[63],1     (0137) ;-----------------------------------------------
1429: 80 48    JMP   0x1472        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (HELLO_4_RXBUF_ENABLE)
142B: 5D 3E    MOV   A,REG[62]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  HELLO_4_fStatus:
                                   (0144) _HELLO_4_fStatus:      BLK  1
142D: 47 08 01 TST   [8],1         (0145)  HELLO_4_bRxCnt:
1430: B0 41    JNZ   0x1472        (0146) _HELLO_4_bRxCnt:       BLK  1
                                   (0147) AREA HELLO_4_RAM(RAM,REL,CON)
1432: 39 00    CMP   A,0           (0148)  HELLO_4_aRxBuffer:    
1434: B0 14    JNZ   0x1449        (0149) _HELLO_4_aRxBuffer:    BLK HELLO_4_RX_BUFFER_SIZE
1436: 2E 08 01 OR    [8],1         (0150) ENDIF
                                   (0151) 
1439: 62 D3 00 MOV   REG[211],0    (0152) 
143C: 70 3F    AND   F,63
143E: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1440: 56 18 00 MOV   [X+24],0      (0154) 
1443: 70 3F    AND   F,63
1445: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
1447: 80 2A    JMP   0x1472        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1449: 3C 09 0F CMP   [9],15        (0167) ;------------------------
144C: C0 14    JC    0x1461        (0168) 
144E: 2E 08 10 OR    [8],16        (0169) 
                                   (0170) ;------------------------
1451: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
1454: 70 3F    AND   F,63
1456: 71 80    OR    F,128         (0172) ;------------------------
1458: 56 18 00 MOV   [X+24],0      (0173) 
145B: 70 3F    AND   F,63
145D: 71 00    OR    F,0           (0174) 
145F: 80 12    JMP   0x1472        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1461: 75       INC   X             (0179) 
1462: 5A 09    MOV   [9],X         (0180) 
1464: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1465: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1468: 70 3F    AND   F,63
146A: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _HELLO_4_ISR
146C: 54 18    MOV   [X+24],A      (0185) ;
146E: 70 3F    AND   F,63
1470: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1472: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1473: 60 D3    MOV   REG[211],A    (0191) _HELLO_4_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1475: 20       POP   X             (0195)    ; Insert your custom code below this banner
1476: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1478: 43 E1 80 OR    REG[225],128  (0201)    ; Insert your custom code above this banner

FILE: lib\hello_4.asm
                                   (0121) ;;*****************************************************************************
147B: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: HELLO_4.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "HELLO_4.inc"
147C: 41 E1 7F AND   REG[225],127  (0149) 
                                   (0150) 
147F: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   HELLO_4_EnableInt
                                   (0155) export  _HELLO_4_EnableInt
                                   (0156) export   HELLO_4_DisableInt
                                   (0157) export  _HELLO_4_DisableInt
                                   (0158) export   HELLO_4_Start
                                   (0159) export  _HELLO_4_Start
                                   (0160) export   HELLO_4_Stop
                                   (0161) export  _HELLO_4_Stop
                                   (0162) export   HELLO_4_bReadRxData
                                   (0163) export  _HELLO_4_bReadRxData
                                   (0164) export   HELLO_4_bReadRxStatus
                                   (0165) export  _HELLO_4_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bHELLO_4_ReadRxData
                                   (0170) export _bHELLO_4_ReadRxData
                                   (0171) export  bHELLO_4_ReadRxStatus
                                   (0172) export _bHELLO_4_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  HELLO_4_cGetChar
1480: 29 01    OR    A,1           (0179) export _HELLO_4_cGetChar
1482: 60 3F    MOV   REG[63],A     (0180) export  HELLO_4_cReadChar
                                   (0181) export _HELLO_4_cReadChar
1484: 7F       RET                 (0182) export  HELLO_4_iReadChar
                                   (0183) export _HELLO_4_iReadChar
                                   (0184) 
                                   (0185) IF (HELLO_4_RXBUF_ENABLE)
                                   (0186) export  HELLO_4_CmdReset
                                   (0187) export _HELLO_4_CmdReset
                                   (0188) export  HELLO_4_bCmdCheck
                                   (0189) export _HELLO_4_bCmdCheck
                                   (0190) export  HELLO_4_bCmdLength
                                   (0191) export _HELLO_4_bCmdLength
                                   (0192) export  HELLO_4_bErrCheck
                                   (0193) export _HELLO_4_bErrCheck
                                   (0194) 
                                   (0195) export  HELLO_4_szGetParam
                                   (0196) export _HELLO_4_szGetParam
                                   (0197) export  HELLO_4_szGetRestOfParams
                                   (0198) export _HELLO_4_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA HELLO_4_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1485: 41 3F FE AND   REG[63],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1488: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: HELLO_4_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  HELLO_4_EnableInt:
                                   (0238) _HELLO_4_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1489: 5D 3E    MOV   A,REG[62]     (0240)    M8C_EnableIntMask HELLO_4_INT_REG, HELLO_4_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
148B: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: HELLO_4_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  HELLO_4_DisableInt:
                                   (0267) _HELLO_4_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask HELLO_4_INT_REG, HELLO_4_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
148C: 5D 3F    MOV   A,REG[63]     (0272) .ENDSECTION
                                   (0273) 
148E: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: HELLO_4_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  HELLO_4_Start:
                                   (0297) _HELLO_4_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[HELLO_4_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: HELLO_4_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
148F: 49 3F 08 TST   REG[63],8     (0311) ;
1492: AF FC    JZ    0x148F        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1494: 5D 3E    MOV   A,REG[62]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1496: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  HELLO_4_Stop:
                                   (0326) _HELLO_4_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[HELLO_4_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: HELLO_4_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1497: 5D 3F    MOV   A,REG[63]     (0346) ;    bRxData - returned in A.
1499: 08       PUSH  A             (0347) ;
149A: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
149C: B0 04    JNZ   0x14A1        (0349) ;    The A and X registers may be modified by this or future implementations
149E: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
149F: 80 0B    JMP   0x14AB        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
14A1: 5D 3E    MOV   A,REG[62]     (0354) ;
14A3: 4B       SWAP  A,X           (0355)  HELLO_4_bReadRxData:
                                   (0356) _HELLO_4_bReadRxData:
14A4: 18       POP   A             (0357)  bHELLO_4_ReadRxData:
14A5: 21 A0    AND   A,160         (0358) _bHELLO_4_ReadRxData:
14A7: B0 03    JNZ   0x14AB        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
14A9: 4B       SWAP  A,X           (0360)    mov A, REG[HELLO_4_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
14AA: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
14AB: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: HELLO_4_bReadRxStatus
                                   (0368) ;
14AD: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  HELLO_4_bReadRxStatus:
                                   (0388) _HELLO_4_bReadRxStatus:
                                   (0389)  bHELLO_4_ReadRxStatus:
                                   (0390) _bHELLO_4_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[HELLO_4_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: HELLO_4_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
14AE: 5D 3F    MOV   A,REG[63]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
14B0: 21 E8    AND   A,232         (0408) ;
14B2: 08       PUSH  A             (0409) ;  ARGUMENTS:
14B3: 21 08    AND   A,8           (0410) ;      none
14B5: B0 07    JNZ   0x14BD        (0411) ;
14B7: 18       POP   A             (0412) ;  RETURNS:
14B8: 29 01    OR    A,1           (0413) ;     char that is returned from UART
14BA: 4B       SWAP  A,X           (0414) ;
14BB: 80 07    JMP   0x14C3        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
14BD: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
14BE: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
14C0: 4B       SWAP  A,X           (0420) ;    functions.
14C1: 5D 3E    MOV   A,REG[62]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
14C3: 7F       RET                 (0426)  HELLO_4_cGetChar:
                                   (0427) _HELLO_4_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[HELLO_4_CONTROL_REG],HELLO_4_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[HELLO_4_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: HELLO_4_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  HELLO_4_cReadChar:
                                   (0463) _HELLO_4_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[HELLO_4_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,HELLO_4_RX_COMPLETE                              ; Check if a character is ready
14C4: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
14C7: 55 18 00 MOV   [24],0        (0470)    pop  A
14CA: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
14CD: 55 DB 00 MOV   [219],0       (0472) 
14D0: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
14D3: 55 09 00 MOV   [9],0         (0474)    mov  A,REG[HELLO_4_RX_BUFFER_REG]                       ; Read data first, then
14D6: 26 08 00 AND   [8],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
14D9: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(HELLO_4_RX_PARITY_ERROR | HELLO_4_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_HELLO_4_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: HELLO_4_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
14DA: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
14DD: 51 08    MOV   A,[8]         (0511) ;        0x40CC    Overrun Error
14DF: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
14E1: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  HELLO_4_iReadChar:
                                   (0523) _HELLO_4_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[HELLO_4_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(HELLO_4_RX_ERROR|HELLO_4_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,HELLO_4_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,HELLO_4_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_HELLO_4_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,HELLO_4_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[HELLO_4_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_HELLO_4_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (HELLO_4_RXBUF_ENABLE)
                                   (0552) .SECTION
14E2: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
14E5: 51 08    MOV   A,[8]         (0554) ;-----------------------------------------------------------------------------
14E7: 21 F0    AND   A,240         (0555) ;
14E9: 26 08 0F AND   [8],15        (0556) ;     Command Buffer commands
                                   (0557) ;
14EC: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: HELLO_4_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  HELLO_4_CmdReset:
14ED: 62 D0 00 MOV   REG[208],0    (0587) _HELLO_4_CmdReset:
14F0: 51 09    MOV   A,[9]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >HELLO_4_aRxBuffer
14F2: 7F       RET                 (0590)    mov [HELLO_4_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >HELLO_4_bRxCnt
                                   (0594)    mov [HELLO_4_bRxCnt], 0x00
                                   (0595)    and [HELLO_4_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: HELLO_4_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  HELLO_4_bCmdCheck:
                                   (0628) _HELLO_4_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >HELLO_4_fStatus
                                   (0631)    mov A,  [HELLO_4_fStatus]
                                   (0632)    and A, HELLO_4_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: HELLO_4_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
14F3: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
14F5: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
14F8: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
14FB: 50 18    MOV   A,24          (0648) ;     BYTE  fStatus - Status of command receive buffer.
14FD: 02 DB    ADD   A,[219]       (0649) ;                     Returns non-zero value in A if command is valid.
14FF: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1500: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1502: B0 04    JNZ   0x1507        (0653) ;           0x10 => Software Buffer OverRun
1504: 10       PUSH  X             (0654) ;
1505: 80 33    JMP   0x1539        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1507: 39 00    CMP   A,0           (0660) ;    functions.
1509: B0 11    JNZ   0x151B        (0661) ;          
150B: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
150C: 76 DB    INC   [219]         (0663) ;          CUR_PP
150E: 52 00    MOV   A,[X+0]       (0664) ;
1510: 3C DB 0F CMP   [219],15      (0665) ;     Error Status is clear when read.
1513: BF F3    JNZ   0x1507        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
1515: 10       PUSH  X             (0669) ;
                                   (0670)  HELLO_4_bErrCheck:
1516: 56 00 00 MOV   [X+0],0       (0671) _HELLO_4_bErrCheck:
1519: 80 1F    JMP   0x1539        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >HELLO_4_fStatus
                                   (0674)    mov A,  [HELLO_4_fStatus]
151B: 10       PUSH  X             (0675)    and A, HELLO_4_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [HELLO_4_fStatus], ~HELLO_4_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
151C: 75       INC   X             (0679) .ENDSECTION
151D: 76 DB    INC   [219]         (0680) 
151F: 3C DB 0F CMP   [219],15      (0681) .SECTION
1522: AF F3    JZ    0x1516        (0682) ;-----------------------------------------------------------------------------
1524: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: HELLO_4_bCmdLength
1526: A0 12    JZ    0x1539        (0684) ;
1528: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
152A: BF F1    JNZ   0x151C        (0686) ;     Get length of command string
                                   (0687) ;
152C: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
152F: 76 DB    INC   [219]         (0689) ;     none.
1531: 3C DB 0F CMP   [219],15      (0690) ;
1534: B0 04    JNZ   0x1539        (0691) ;  RETURNS:
1536: 55 DB 0F MOV   [219],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1539: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
153A: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
153B: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
153E: B0 0B    JNZ   0x154A        (0699) ;    functions.
1540: 20       POP   X             (0700) ;          
1541: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
1543: 50 00    MOV   A,0           (0702) ;          CUR_PP
1545: 70 3F    AND   F,63
1547: 71 C0    OR    F,192         (0703) ;
                                   (0704)  HELLO_4_bCmdLength:
1549: 7F       RET                 (0705) _HELLO_4_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >HELLO_4_bRxCnt
154A: 20       POP   X             (0708)    mov A,  [HELLO_4_bRxCnt]
154B: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
154D: 70 3F    AND   F,63
154F: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1551: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: HELLO_4_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1552: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1555: 50 18    MOV   A,24          (0744) ;     each lexically distinct element into a null-terminated string by replacing
1557: 02 DB    ADD   A,[219]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
1559: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
155A: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     HELLO_4_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, HELLO_4_szGetParam, is
155D: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\hello_3int.asm
155E: 10       PUSH  X             (0104) ;;*****************************************************************************
155F: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: HELLO_3INT.asm
1561: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1562: 58 0B    MOV   X,[11]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1564: 5D 3B    MOV   A,REG[59]     (0111) ;;-----------------------------------------------------------------------------
1566: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1567: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1569: B0 04    JNZ   0x156E        (0115) 
156B: 18       POP   A             (0116) include "m8c.inc"
156C: 80 5E    JMP   0x15CB        (0117) include "memory.inc"
                                   (0118) include "HELLO_3.inc"
                                   (0119) 
                                   (0120) 
156E: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
156F: 21 E0    AND   A,224         (0124) export  _HELLO_3_ISR
1571: A0 12    JZ    0x1584        (0125) 
                                   (0126) 
1573: 2C 0A    OR    [10],A        (0127) IF (HELLO_3_RXBUF_ENABLE)
                                   (0128) export  HELLO_3_aRxBuffer
1575: 49 3A 00 TST   REG[58],0     (0129) export _HELLO_3_aRxBuffer
                                   (0130) export  HELLO_3_bRxCnt
1578: 21 20    AND   A,32          (0131) export _HELLO_3_bRxCnt
157A: A0 50    JZ    0x15CB        (0132) export  HELLO_3_fStatus
                                   (0133) export _HELLO_3_fStatus
                                   (0134) ENDIF
                                   (0135) 
157C: 41 3B FE AND   REG[59],254   (0136) 
157F: 43 3B 01 OR    REG[59],1     (0137) ;-----------------------------------------------
1582: 80 48    JMP   0x15CB        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (HELLO_3_RXBUF_ENABLE)
1584: 5D 3A    MOV   A,REG[58]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  HELLO_3_fStatus:
                                   (0144) _HELLO_3_fStatus:      BLK  1
1586: 47 0A 01 TST   [10],1        (0145)  HELLO_3_bRxCnt:
1589: B0 41    JNZ   0x15CB        (0146) _HELLO_3_bRxCnt:       BLK  1
                                   (0147) AREA HELLO_3_RAM(RAM,REL,CON)
158B: 39 00    CMP   A,0           (0148)  HELLO_3_aRxBuffer:    
158D: B0 14    JNZ   0x15A2        (0149) _HELLO_3_aRxBuffer:    BLK HELLO_3_RX_BUFFER_SIZE
158F: 2E 0A 01 OR    [10],1        (0150) ENDIF
                                   (0151) 
1592: 62 D3 00 MOV   REG[211],0    (0152) 
1595: 70 3F    AND   F,63
1597: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1599: 56 28 00 MOV   [X+40],0      (0154) 
159C: 70 3F    AND   F,63
159E: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
15A0: 80 2A    JMP   0x15CB        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
15A2: 3C 0B 0F CMP   [11],15       (0167) ;------------------------
15A5: C0 14    JC    0x15BA        (0168) 
15A7: 2E 0A 10 OR    [10],16       (0169) 
                                   (0170) ;------------------------
15AA: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
15AD: 70 3F    AND   F,63
15AF: 71 80    OR    F,128         (0172) ;------------------------
15B1: 56 28 00 MOV   [X+40],0      (0173) 
15B4: 70 3F    AND   F,63
15B6: 71 00    OR    F,0           (0174) 
15B8: 80 12    JMP   0x15CB        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
15BA: 75       INC   X             (0179) 
15BB: 5A 0B    MOV   [11],X        (0180) 
15BD: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
15BE: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
15C1: 70 3F    AND   F,63
15C3: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _HELLO_3_ISR
15C5: 54 28    MOV   [X+40],A      (0185) ;
15C7: 70 3F    AND   F,63
15C9: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
15CB: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
15CC: 60 D3    MOV   REG[211],A    (0191) _HELLO_3_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
15CE: 20       POP   X             (0195)    ; Insert your custom code below this banner
15CF: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
15D1: 43 E1 40 OR    REG[225],64   (0201)    ; Insert your custom code above this banner

FILE: lib\hello_3.asm
                                   (0121) ;;*****************************************************************************
15D4: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: HELLO_3.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "HELLO_3.inc"
15D5: 41 E1 BF AND   REG[225],191  (0149) 
                                   (0150) 
15D8: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   HELLO_3_EnableInt
                                   (0155) export  _HELLO_3_EnableInt
                                   (0156) export   HELLO_3_DisableInt
                                   (0157) export  _HELLO_3_DisableInt
                                   (0158) export   HELLO_3_Start
                                   (0159) export  _HELLO_3_Start
                                   (0160) export   HELLO_3_Stop
                                   (0161) export  _HELLO_3_Stop
                                   (0162) export   HELLO_3_bReadRxData
                                   (0163) export  _HELLO_3_bReadRxData
                                   (0164) export   HELLO_3_bReadRxStatus
                                   (0165) export  _HELLO_3_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bHELLO_3_ReadRxData
                                   (0170) export _bHELLO_3_ReadRxData
                                   (0171) export  bHELLO_3_ReadRxStatus
                                   (0172) export _bHELLO_3_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  HELLO_3_cGetChar
15D9: 29 01    OR    A,1           (0179) export _HELLO_3_cGetChar
15DB: 60 3B    MOV   REG[59],A     (0180) export  HELLO_3_cReadChar
                                   (0181) export _HELLO_3_cReadChar
15DD: 7F       RET                 (0182) export  HELLO_3_iReadChar
                                   (0183) export _HELLO_3_iReadChar
                                   (0184) 
                                   (0185) IF (HELLO_3_RXBUF_ENABLE)
                                   (0186) export  HELLO_3_CmdReset
                                   (0187) export _HELLO_3_CmdReset
                                   (0188) export  HELLO_3_bCmdCheck
                                   (0189) export _HELLO_3_bCmdCheck
                                   (0190) export  HELLO_3_bCmdLength
                                   (0191) export _HELLO_3_bCmdLength
                                   (0192) export  HELLO_3_bErrCheck
                                   (0193) export _HELLO_3_bErrCheck
                                   (0194) 
                                   (0195) export  HELLO_3_szGetParam
                                   (0196) export _HELLO_3_szGetParam
                                   (0197) export  HELLO_3_szGetRestOfParams
                                   (0198) export _HELLO_3_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA HELLO_3_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
15DE: 41 3B FE AND   REG[59],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
15E1: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: HELLO_3_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  HELLO_3_EnableInt:
                                   (0238) _HELLO_3_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
15E2: 5D 3A    MOV   A,REG[58]     (0240)    M8C_EnableIntMask HELLO_3_INT_REG, HELLO_3_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
15E4: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: HELLO_3_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  HELLO_3_DisableInt:
                                   (0267) _HELLO_3_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask HELLO_3_INT_REG, HELLO_3_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
15E5: 5D 3B    MOV   A,REG[59]     (0272) .ENDSECTION
                                   (0273) 
15E7: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: HELLO_3_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  HELLO_3_Start:
                                   (0297) _HELLO_3_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[HELLO_3_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: HELLO_3_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
15E8: 49 3B 08 TST   REG[59],8     (0311) ;
15EB: AF FC    JZ    0x15E8        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
15ED: 5D 3A    MOV   A,REG[58]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
15EF: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  HELLO_3_Stop:
                                   (0326) _HELLO_3_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[HELLO_3_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: HELLO_3_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
15F0: 5D 3B    MOV   A,REG[59]     (0346) ;    bRxData - returned in A.
15F2: 08       PUSH  A             (0347) ;
15F3: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
15F5: B0 04    JNZ   0x15FA        (0349) ;    The A and X registers may be modified by this or future implementations
15F7: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
15F8: 80 0B    JMP   0x1604        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
15FA: 5D 3A    MOV   A,REG[58]     (0354) ;
15FC: 4B       SWAP  A,X           (0355)  HELLO_3_bReadRxData:
                                   (0356) _HELLO_3_bReadRxData:
15FD: 18       POP   A             (0357)  bHELLO_3_ReadRxData:
15FE: 21 A0    AND   A,160         (0358) _bHELLO_3_ReadRxData:
1600: B0 03    JNZ   0x1604        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1602: 4B       SWAP  A,X           (0360)    mov A, REG[HELLO_3_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1603: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1604: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: HELLO_3_bReadRxStatus
                                   (0368) ;
1606: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  HELLO_3_bReadRxStatus:
                                   (0388) _HELLO_3_bReadRxStatus:
                                   (0389)  bHELLO_3_ReadRxStatus:
                                   (0390) _bHELLO_3_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[HELLO_3_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: HELLO_3_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1607: 5D 3B    MOV   A,REG[59]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1609: 21 E8    AND   A,232         (0408) ;
160B: 08       PUSH  A             (0409) ;  ARGUMENTS:
160C: 21 08    AND   A,8           (0410) ;      none
160E: B0 07    JNZ   0x1616        (0411) ;
1610: 18       POP   A             (0412) ;  RETURNS:
1611: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1613: 4B       SWAP  A,X           (0414) ;
1614: 80 07    JMP   0x161C        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1616: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1617: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1619: 4B       SWAP  A,X           (0420) ;    functions.
161A: 5D 3A    MOV   A,REG[58]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
161C: 7F       RET                 (0426)  HELLO_3_cGetChar:
                                   (0427) _HELLO_3_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[HELLO_3_CONTROL_REG],HELLO_3_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[HELLO_3_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: HELLO_3_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  HELLO_3_cReadChar:
                                   (0463) _HELLO_3_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[HELLO_3_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,HELLO_3_RX_COMPLETE                              ; Check if a character is ready
161D: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1620: 55 28 00 MOV   [40],0        (0470)    pop  A
1623: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1626: 55 DA 00 MOV   [218],0       (0472) 
1629: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
162C: 55 0B 00 MOV   [11],0        (0474)    mov  A,REG[HELLO_3_RX_BUFFER_REG]                       ; Read data first, then
162F: 26 0A 00 AND   [10],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1632: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(HELLO_3_RX_PARITY_ERROR | HELLO_3_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_HELLO_3_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: HELLO_3_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1633: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1636: 51 0A    MOV   A,[10]        (0511) ;        0x40CC    Overrun Error
1638: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
163A: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  HELLO_3_iReadChar:
                                   (0523) _HELLO_3_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[HELLO_3_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(HELLO_3_RX_ERROR|HELLO_3_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,HELLO_3_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,HELLO_3_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_HELLO_3_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,HELLO_3_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[HELLO_3_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_HELLO_3_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (HELLO_3_RXBUF_ENABLE)
                                   (0552) .SECTION
163B: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
163E: 51 0A    MOV   A,[10]        (0554) ;-----------------------------------------------------------------------------
1640: 21 F0    AND   A,240         (0555) ;
1642: 26 0A 0F AND   [10],15       (0556) ;     Command Buffer commands
                                   (0557) ;
1645: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: HELLO_3_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  HELLO_3_CmdReset:
1646: 62 D0 00 MOV   REG[208],0    (0587) _HELLO_3_CmdReset:
1649: 51 0B    MOV   A,[11]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >HELLO_3_aRxBuffer
164B: 7F       RET                 (0590)    mov [HELLO_3_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >HELLO_3_bRxCnt
                                   (0594)    mov [HELLO_3_bRxCnt], 0x00
                                   (0595)    and [HELLO_3_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: HELLO_3_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  HELLO_3_bCmdCheck:
                                   (0628) _HELLO_3_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >HELLO_3_fStatus
                                   (0631)    mov A,  [HELLO_3_fStatus]
                                   (0632)    and A, HELLO_3_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: HELLO_3_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
164C: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
164E: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1651: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1654: 50 28    MOV   A,40          (0648) ;     BYTE  fStatus - Status of command receive buffer.
1656: 02 DA    ADD   A,[218]       (0649) ;                     Returns non-zero value in A if command is valid.
1658: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1659: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
165B: B0 04    JNZ   0x1660        (0653) ;           0x10 => Software Buffer OverRun
165D: 10       PUSH  X             (0654) ;
165E: 80 33    JMP   0x1692        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1660: 39 00    CMP   A,0           (0660) ;    functions.
1662: B0 11    JNZ   0x1674        (0661) ;          
1664: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1665: 76 DA    INC   [218]         (0663) ;          CUR_PP
1667: 52 00    MOV   A,[X+0]       (0664) ;
1669: 3C DA 0F CMP   [218],15      (0665) ;     Error Status is clear when read.
166C: BF F3    JNZ   0x1660        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
166E: 10       PUSH  X             (0669) ;
                                   (0670)  HELLO_3_bErrCheck:
166F: 56 00 00 MOV   [X+0],0       (0671) _HELLO_3_bErrCheck:
1672: 80 1F    JMP   0x1692        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >HELLO_3_fStatus
                                   (0674)    mov A,  [HELLO_3_fStatus]
1674: 10       PUSH  X             (0675)    and A, HELLO_3_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [HELLO_3_fStatus], ~HELLO_3_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
1675: 75       INC   X             (0679) .ENDSECTION
1676: 76 DA    INC   [218]         (0680) 
1678: 3C DA 0F CMP   [218],15      (0681) .SECTION
167B: AF F3    JZ    0x166F        (0682) ;-----------------------------------------------------------------------------
167D: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: HELLO_3_bCmdLength
167F: A0 12    JZ    0x1692        (0684) ;
1681: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1683: BF F1    JNZ   0x1675        (0686) ;     Get length of command string
                                   (0687) ;
1685: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
1688: 76 DA    INC   [218]         (0689) ;     none.
168A: 3C DA 0F CMP   [218],15      (0690) ;
168D: B0 04    JNZ   0x1692        (0691) ;  RETURNS:
168F: 55 DA 0F MOV   [218],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1692: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1693: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
1694: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1697: B0 0B    JNZ   0x16A3        (0699) ;    functions.
1699: 20       POP   X             (0700) ;          
169A: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
169C: 50 00    MOV   A,0           (0702) ;          CUR_PP
169E: 70 3F    AND   F,63
16A0: 71 C0    OR    F,192         (0703) ;
                                   (0704)  HELLO_3_bCmdLength:
16A2: 7F       RET                 (0705) _HELLO_3_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >HELLO_3_bRxCnt
16A3: 20       POP   X             (0708)    mov A,  [HELLO_3_bRxCnt]
16A4: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
16A6: 70 3F    AND   F,63
16A8: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
16AA: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: HELLO_3_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
16AB: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
16AE: 50 28    MOV   A,40          (0744) ;     each lexically distinct element into a null-terminated string by replacing
16B0: 02 DA    ADD   A,[218]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
16B2: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
16B3: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     HELLO_3_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, HELLO_3_szGetParam, is
16B6: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\hello_2int.asm
16B7: 10       PUSH  X             (0104) ;;*****************************************************************************
16B8: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: HELLO_2INT.asm
16BA: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
16BB: 58 0D    MOV   X,[13]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
16BD: 5D 2F    MOV   A,REG[47]     (0111) ;;-----------------------------------------------------------------------------
16BF: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
16C0: 21 08    AND   A,8           (0114) ;;*****************************************************************************
16C2: B0 04    JNZ   0x16C7        (0115) 
16C4: 18       POP   A             (0116) include "m8c.inc"
16C5: 80 5E    JMP   0x1724        (0117) include "memory.inc"
                                   (0118) include "HELLO_2.inc"
                                   (0119) 
                                   (0120) 
16C7: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
16C8: 21 E0    AND   A,224         (0124) export  _HELLO_2_ISR
16CA: A0 12    JZ    0x16DD        (0125) 
                                   (0126) 
16CC: 2C 0C    OR    [12],A        (0127) IF (HELLO_2_RXBUF_ENABLE)
                                   (0128) export  HELLO_2_aRxBuffer
16CE: 49 2E 00 TST   REG[46],0     (0129) export _HELLO_2_aRxBuffer
                                   (0130) export  HELLO_2_bRxCnt
16D1: 21 20    AND   A,32          (0131) export _HELLO_2_bRxCnt
16D3: A0 50    JZ    0x1724        (0132) export  HELLO_2_fStatus
                                   (0133) export _HELLO_2_fStatus
                                   (0134) ENDIF
                                   (0135) 
16D5: 41 2F FE AND   REG[47],254   (0136) 
16D8: 43 2F 01 OR    REG[47],1     (0137) ;-----------------------------------------------
16DB: 80 48    JMP   0x1724        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (HELLO_2_RXBUF_ENABLE)
16DD: 5D 2E    MOV   A,REG[46]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  HELLO_2_fStatus:
                                   (0144) _HELLO_2_fStatus:      BLK  1
16DF: 47 0C 01 TST   [12],1        (0145)  HELLO_2_bRxCnt:
16E2: B0 41    JNZ   0x1724        (0146) _HELLO_2_bRxCnt:       BLK  1
                                   (0147) AREA HELLO_2_RAM(RAM,REL,CON)
16E4: 39 00    CMP   A,0           (0148)  HELLO_2_aRxBuffer:    
16E6: B0 14    JNZ   0x16FB        (0149) _HELLO_2_aRxBuffer:    BLK HELLO_2_RX_BUFFER_SIZE
16E8: 2E 0C 01 OR    [12],1        (0150) ENDIF
                                   (0151) 
16EB: 62 D3 00 MOV   REG[211],0    (0152) 
16EE: 70 3F    AND   F,63
16F0: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
16F2: 56 B8 00 MOV   [X-72],0      (0154) 
16F5: 70 3F    AND   F,63
16F7: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
16F9: 80 2A    JMP   0x1724        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
16FB: 3C 0D 0F CMP   [13],15       (0167) ;------------------------
16FE: C0 14    JC    0x1713        (0168) 
1700: 2E 0C 10 OR    [12],16       (0169) 
                                   (0170) ;------------------------
1703: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
1706: 70 3F    AND   F,63
1708: 71 80    OR    F,128         (0172) ;------------------------
170A: 56 B8 00 MOV   [X-72],0      (0173) 
170D: 70 3F    AND   F,63
170F: 71 00    OR    F,0           (0174) 
1711: 80 12    JMP   0x1724        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1713: 75       INC   X             (0179) 
1714: 5A 0D    MOV   [13],X        (0180) 
1716: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1717: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
171A: 70 3F    AND   F,63
171C: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _HELLO_2_ISR
171E: 54 B8    MOV   [X-72],A      (0185) ;
1720: 70 3F    AND   F,63
1722: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1724: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1725: 60 D3    MOV   REG[211],A    (0191) _HELLO_2_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1727: 20       POP   X             (0195)    ; Insert your custom code below this banner
1728: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
172A: 43 E1 08 OR    REG[225],8    (0201)    ; Insert your custom code above this banner

FILE: lib\hello_2.asm
                                   (0121) ;;*****************************************************************************
172D: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: HELLO_2.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "HELLO_2.inc"
172E: 41 E1 F7 AND   REG[225],247  (0149) 
                                   (0150) 
1731: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   HELLO_2_EnableInt
                                   (0155) export  _HELLO_2_EnableInt
                                   (0156) export   HELLO_2_DisableInt
                                   (0157) export  _HELLO_2_DisableInt
                                   (0158) export   HELLO_2_Start
                                   (0159) export  _HELLO_2_Start
                                   (0160) export   HELLO_2_Stop
                                   (0161) export  _HELLO_2_Stop
                                   (0162) export   HELLO_2_bReadRxData
                                   (0163) export  _HELLO_2_bReadRxData
                                   (0164) export   HELLO_2_bReadRxStatus
                                   (0165) export  _HELLO_2_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bHELLO_2_ReadRxData
                                   (0170) export _bHELLO_2_ReadRxData
                                   (0171) export  bHELLO_2_ReadRxStatus
                                   (0172) export _bHELLO_2_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  HELLO_2_cGetChar
1732: 29 01    OR    A,1           (0179) export _HELLO_2_cGetChar
1734: 60 2F    MOV   REG[47],A     (0180) export  HELLO_2_cReadChar
                                   (0181) export _HELLO_2_cReadChar
1736: 7F       RET                 (0182) export  HELLO_2_iReadChar
                                   (0183) export _HELLO_2_iReadChar
                                   (0184) 
                                   (0185) IF (HELLO_2_RXBUF_ENABLE)
                                   (0186) export  HELLO_2_CmdReset
                                   (0187) export _HELLO_2_CmdReset
                                   (0188) export  HELLO_2_bCmdCheck
                                   (0189) export _HELLO_2_bCmdCheck
                                   (0190) export  HELLO_2_bCmdLength
                                   (0191) export _HELLO_2_bCmdLength
                                   (0192) export  HELLO_2_bErrCheck
                                   (0193) export _HELLO_2_bErrCheck
                                   (0194) 
                                   (0195) export  HELLO_2_szGetParam
                                   (0196) export _HELLO_2_szGetParam
                                   (0197) export  HELLO_2_szGetRestOfParams
                                   (0198) export _HELLO_2_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA HELLO_2_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1737: 41 2F FE AND   REG[47],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
173A: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: HELLO_2_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  HELLO_2_EnableInt:
                                   (0238) _HELLO_2_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
173B: 5D 2E    MOV   A,REG[46]     (0240)    M8C_EnableIntMask HELLO_2_INT_REG, HELLO_2_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
173D: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: HELLO_2_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  HELLO_2_DisableInt:
                                   (0267) _HELLO_2_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask HELLO_2_INT_REG, HELLO_2_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
173E: 5D 2F    MOV   A,REG[47]     (0272) .ENDSECTION
                                   (0273) 
1740: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: HELLO_2_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  HELLO_2_Start:
                                   (0297) _HELLO_2_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[HELLO_2_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: HELLO_2_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1741: 49 2F 08 TST   REG[47],8     (0311) ;
1744: AF FC    JZ    0x1741        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1746: 5D 2E    MOV   A,REG[46]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1748: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  HELLO_2_Stop:
                                   (0326) _HELLO_2_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[HELLO_2_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: HELLO_2_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1749: 5D 2F    MOV   A,REG[47]     (0346) ;    bRxData - returned in A.
174B: 08       PUSH  A             (0347) ;
174C: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
174E: B0 04    JNZ   0x1753        (0349) ;    The A and X registers may be modified by this or future implementations
1750: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1751: 80 0B    JMP   0x175D        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1753: 5D 2E    MOV   A,REG[46]     (0354) ;
1755: 4B       SWAP  A,X           (0355)  HELLO_2_bReadRxData:
                                   (0356) _HELLO_2_bReadRxData:
1756: 18       POP   A             (0357)  bHELLO_2_ReadRxData:
1757: 21 A0    AND   A,160         (0358) _bHELLO_2_ReadRxData:
1759: B0 03    JNZ   0x175D        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
175B: 4B       SWAP  A,X           (0360)    mov A, REG[HELLO_2_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
175C: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
175D: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: HELLO_2_bReadRxStatus
                                   (0368) ;
175F: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  HELLO_2_bReadRxStatus:
                                   (0388) _HELLO_2_bReadRxStatus:
                                   (0389)  bHELLO_2_ReadRxStatus:
                                   (0390) _bHELLO_2_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[HELLO_2_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: HELLO_2_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1760: 5D 2F    MOV   A,REG[47]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1762: 21 E8    AND   A,232         (0408) ;
1764: 08       PUSH  A             (0409) ;  ARGUMENTS:
1765: 21 08    AND   A,8           (0410) ;      none
1767: B0 07    JNZ   0x176F        (0411) ;
1769: 18       POP   A             (0412) ;  RETURNS:
176A: 29 01    OR    A,1           (0413) ;     char that is returned from UART
176C: 4B       SWAP  A,X           (0414) ;
176D: 80 07    JMP   0x1775        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
176F: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1770: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1772: 4B       SWAP  A,X           (0420) ;    functions.
1773: 5D 2E    MOV   A,REG[46]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1775: 7F       RET                 (0426)  HELLO_2_cGetChar:
                                   (0427) _HELLO_2_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[HELLO_2_CONTROL_REG],HELLO_2_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[HELLO_2_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: HELLO_2_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  HELLO_2_cReadChar:
                                   (0463) _HELLO_2_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[HELLO_2_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,HELLO_2_RX_COMPLETE                              ; Check if a character is ready
1776: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1779: 55 B8 00 MOV   [184],0       (0470)    pop  A
177C: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
177F: 55 D9 00 MOV   [217],0       (0472) 
1782: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1785: 55 0D 00 MOV   [13],0        (0474)    mov  A,REG[HELLO_2_RX_BUFFER_REG]                       ; Read data first, then
1788: 26 0C 00 AND   [12],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
178B: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(HELLO_2_RX_PARITY_ERROR | HELLO_2_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_HELLO_2_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: HELLO_2_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
178C: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
178F: 51 0C    MOV   A,[12]        (0511) ;        0x40CC    Overrun Error
1791: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1793: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  HELLO_2_iReadChar:
                                   (0523) _HELLO_2_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[HELLO_2_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(HELLO_2_RX_ERROR|HELLO_2_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,HELLO_2_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,HELLO_2_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_HELLO_2_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,HELLO_2_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[HELLO_2_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_HELLO_2_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (HELLO_2_RXBUF_ENABLE)
                                   (0552) .SECTION
1794: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1797: 51 0C    MOV   A,[12]        (0554) ;-----------------------------------------------------------------------------
1799: 21 F0    AND   A,240         (0555) ;
179B: 26 0C 0F AND   [12],15       (0556) ;     Command Buffer commands
                                   (0557) ;
179E: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: HELLO_2_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  HELLO_2_CmdReset:
179F: 62 D0 00 MOV   REG[208],0    (0587) _HELLO_2_CmdReset:
17A2: 51 0D    MOV   A,[13]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >HELLO_2_aRxBuffer
17A4: 7F       RET                 (0590)    mov [HELLO_2_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >HELLO_2_bRxCnt
                                   (0594)    mov [HELLO_2_bRxCnt], 0x00
                                   (0595)    and [HELLO_2_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: HELLO_2_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  HELLO_2_bCmdCheck:
                                   (0628) _HELLO_2_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >HELLO_2_fStatus
                                   (0631)    mov A,  [HELLO_2_fStatus]
                                   (0632)    and A, HELLO_2_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: HELLO_2_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
17A5: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
17A7: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
17AA: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
17AD: 50 B8    MOV   A,184         (0648) ;     BYTE  fStatus - Status of command receive buffer.
17AF: 02 D9    ADD   A,[217]       (0649) ;                     Returns non-zero value in A if command is valid.
17B1: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
17B2: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
17B4: B0 04    JNZ   0x17B9        (0653) ;           0x10 => Software Buffer OverRun
17B6: 10       PUSH  X             (0654) ;
17B7: 80 33    JMP   0x17EB        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
17B9: 39 00    CMP   A,0           (0660) ;    functions.
17BB: B0 11    JNZ   0x17CD        (0661) ;          
17BD: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
17BE: 76 D9    INC   [217]         (0663) ;          CUR_PP
17C0: 52 00    MOV   A,[X+0]       (0664) ;
17C2: 3C D9 0F CMP   [217],15      (0665) ;     Error Status is clear when read.
17C5: BF F3    JNZ   0x17B9        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
17C7: 10       PUSH  X             (0669) ;
                                   (0670)  HELLO_2_bErrCheck:
17C8: 56 00 00 MOV   [X+0],0       (0671) _HELLO_2_bErrCheck:
17CB: 80 1F    JMP   0x17EB        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >HELLO_2_fStatus
                                   (0674)    mov A,  [HELLO_2_fStatus]
17CD: 10       PUSH  X             (0675)    and A, HELLO_2_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [HELLO_2_fStatus], ~HELLO_2_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
17CE: 75       INC   X             (0679) .ENDSECTION
17CF: 76 D9    INC   [217]         (0680) 
17D1: 3C D9 0F CMP   [217],15      (0681) .SECTION
17D4: AF F3    JZ    0x17C8        (0682) ;-----------------------------------------------------------------------------
17D6: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: HELLO_2_bCmdLength
17D8: A0 12    JZ    0x17EB        (0684) ;
17DA: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
17DC: BF F1    JNZ   0x17CE        (0686) ;     Get length of command string
                                   (0687) ;
17DE: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
17E1: 76 D9    INC   [217]         (0689) ;     none.
17E3: 3C D9 0F CMP   [217],15      (0690) ;
17E6: B0 04    JNZ   0x17EB        (0691) ;  RETURNS:
17E8: 55 D9 0F MOV   [217],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
17EB: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
17EC: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
17ED: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
17F0: B0 0B    JNZ   0x17FC        (0699) ;    functions.
17F2: 20       POP   X             (0700) ;          
17F3: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
17F5: 50 00    MOV   A,0           (0702) ;          CUR_PP
17F7: 70 3F    AND   F,63
17F9: 71 C0    OR    F,192         (0703) ;
                                   (0704)  HELLO_2_bCmdLength:
17FB: 7F       RET                 (0705) _HELLO_2_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >HELLO_2_bRxCnt
17FC: 20       POP   X             (0708)    mov A,  [HELLO_2_bRxCnt]
17FD: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
17FF: 70 3F    AND   F,63
1801: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1803: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: HELLO_2_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1804: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1807: 50 B8    MOV   A,184         (0744) ;     each lexically distinct element into a null-terminated string by replacing
1809: 02 D9    ADD   A,[217]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
180B: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
180C: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     HELLO_2_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, HELLO_2_szGetParam, is
180F: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\hello_1int.asm
1810: 10       PUSH  X             (0104) ;;*****************************************************************************
1811: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: HELLO_1INT.asm
1813: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1814: 58 0F    MOV   X,[15]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1816: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
1818: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1819: 21 08    AND   A,8           (0114) ;;*****************************************************************************
181B: B0 04    JNZ   0x1820        (0115) 
181D: 18       POP   A             (0116) include "m8c.inc"
181E: 80 5E    JMP   0x187D        (0117) include "memory.inc"
                                   (0118) include "HELLO_1.inc"
                                   (0119) 
                                   (0120) 
1820: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1821: 21 E0    AND   A,224         (0124) export  _HELLO_1_ISR
1823: A0 12    JZ    0x1836        (0125) 
                                   (0126) 
1825: 2C 0E    OR    [14],A        (0127) IF (HELLO_1_RXBUF_ENABLE)
                                   (0128) export  HELLO_1_aRxBuffer
1827: 49 2A 00 TST   REG[42],0     (0129) export _HELLO_1_aRxBuffer
                                   (0130) export  HELLO_1_bRxCnt
182A: 21 20    AND   A,32          (0131) export _HELLO_1_bRxCnt
182C: A0 50    JZ    0x187D        (0132) export  HELLO_1_fStatus
                                   (0133) export _HELLO_1_fStatus
                                   (0134) ENDIF
                                   (0135) 
182E: 41 2B FE AND   REG[43],254   (0136) 
1831: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
1834: 80 48    JMP   0x187D        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (HELLO_1_RXBUF_ENABLE)
1836: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  HELLO_1_fStatus:
                                   (0144) _HELLO_1_fStatus:      BLK  1
1838: 47 0E 01 TST   [14],1        (0145)  HELLO_1_bRxCnt:
183B: B0 41    JNZ   0x187D        (0146) _HELLO_1_bRxCnt:       BLK  1
                                   (0147) AREA HELLO_1_RAM(RAM,REL,CON)
183D: 39 00    CMP   A,0           (0148)  HELLO_1_aRxBuffer:    
183F: B0 14    JNZ   0x1854        (0149) _HELLO_1_aRxBuffer:    BLK HELLO_1_RX_BUFFER_SIZE
1841: 2E 0E 01 OR    [14],1        (0150) ENDIF
                                   (0151) 
1844: 62 D3 00 MOV   REG[211],0    (0152) 
1847: 70 3F    AND   F,63
1849: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
184B: 56 78 00 MOV   [X+120],0     (0154) 
184E: 70 3F    AND   F,63
1850: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
1852: 80 2A    JMP   0x187D        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1854: 3C 0F 0F CMP   [15],15       (0167) ;------------------------
1857: C0 14    JC    0x186C        (0168) 
1859: 2E 0E 10 OR    [14],16       (0169) 
                                   (0170) ;------------------------
185C: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
185F: 70 3F    AND   F,63
1861: 71 80    OR    F,128         (0172) ;------------------------
1863: 56 78 00 MOV   [X+120],0     (0173) 
1866: 70 3F    AND   F,63
1868: 71 00    OR    F,0           (0174) 
186A: 80 12    JMP   0x187D        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
186C: 75       INC   X             (0179) 
186D: 5A 0F    MOV   [15],X        (0180) 
186F: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1870: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1873: 70 3F    AND   F,63
1875: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _HELLO_1_ISR
1877: 54 78    MOV   [X+120],A     (0185) ;
1879: 70 3F    AND   F,63
187B: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
187D: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
187E: 60 D3    MOV   REG[211],A    (0191) _HELLO_1_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1880: 20       POP   X             (0195)    ; Insert your custom code below this banner
1881: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1883: 43 E1 04 OR    REG[225],4    (0201)    ; Insert your custom code above this banner

FILE: lib\hello_1.asm
                                   (0121) ;;*****************************************************************************
1886: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: HELLO_1.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "HELLO_1.inc"
1887: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
188A: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   HELLO_1_EnableInt
                                   (0155) export  _HELLO_1_EnableInt
                                   (0156) export   HELLO_1_DisableInt
                                   (0157) export  _HELLO_1_DisableInt
                                   (0158) export   HELLO_1_Start
                                   (0159) export  _HELLO_1_Start
                                   (0160) export   HELLO_1_Stop
                                   (0161) export  _HELLO_1_Stop
                                   (0162) export   HELLO_1_bReadRxData
                                   (0163) export  _HELLO_1_bReadRxData
                                   (0164) export   HELLO_1_bReadRxStatus
                                   (0165) export  _HELLO_1_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bHELLO_1_ReadRxData
                                   (0170) export _bHELLO_1_ReadRxData
                                   (0171) export  bHELLO_1_ReadRxStatus
                                   (0172) export _bHELLO_1_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  HELLO_1_cGetChar
188B: 29 01    OR    A,1           (0179) export _HELLO_1_cGetChar
188D: 60 2B    MOV   REG[43],A     (0180) export  HELLO_1_cReadChar
                                   (0181) export _HELLO_1_cReadChar
188F: 7F       RET                 (0182) export  HELLO_1_iReadChar
                                   (0183) export _HELLO_1_iReadChar
                                   (0184) 
                                   (0185) IF (HELLO_1_RXBUF_ENABLE)
                                   (0186) export  HELLO_1_CmdReset
                                   (0187) export _HELLO_1_CmdReset
                                   (0188) export  HELLO_1_bCmdCheck
                                   (0189) export _HELLO_1_bCmdCheck
                                   (0190) export  HELLO_1_bCmdLength
                                   (0191) export _HELLO_1_bCmdLength
                                   (0192) export  HELLO_1_bErrCheck
                                   (0193) export _HELLO_1_bErrCheck
                                   (0194) 
                                   (0195) export  HELLO_1_szGetParam
                                   (0196) export _HELLO_1_szGetParam
                                   (0197) export  HELLO_1_szGetRestOfParams
                                   (0198) export _HELLO_1_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA HELLO_1_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1890: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1893: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: HELLO_1_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  HELLO_1_EnableInt:
                                   (0238) _HELLO_1_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1894: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask HELLO_1_INT_REG, HELLO_1_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1896: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: HELLO_1_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  HELLO_1_DisableInt:
                                   (0267) _HELLO_1_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask HELLO_1_INT_REG, HELLO_1_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
1897: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
1899: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: HELLO_1_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  HELLO_1_Start:
                                   (0297) _HELLO_1_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[HELLO_1_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: HELLO_1_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
189A: 49 2B 08 TST   REG[43],8     (0311) ;
189D: AF FC    JZ    0x189A        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
189F: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
18A1: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  HELLO_1_Stop:
                                   (0326) _HELLO_1_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[HELLO_1_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: HELLO_1_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
18A2: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
18A4: 08       PUSH  A             (0347) ;
18A5: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
18A7: B0 04    JNZ   0x18AC        (0349) ;    The A and X registers may be modified by this or future implementations
18A9: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
18AA: 80 0B    JMP   0x18B6        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
18AC: 5D 2A    MOV   A,REG[42]     (0354) ;
18AE: 4B       SWAP  A,X           (0355)  HELLO_1_bReadRxData:
                                   (0356) _HELLO_1_bReadRxData:
18AF: 18       POP   A             (0357)  bHELLO_1_ReadRxData:
18B0: 21 A0    AND   A,160         (0358) _bHELLO_1_ReadRxData:
18B2: B0 03    JNZ   0x18B6        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
18B4: 4B       SWAP  A,X           (0360)    mov A, REG[HELLO_1_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
18B5: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
18B6: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: HELLO_1_bReadRxStatus
                                   (0368) ;
18B8: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  HELLO_1_bReadRxStatus:
                                   (0388) _HELLO_1_bReadRxStatus:
                                   (0389)  bHELLO_1_ReadRxStatus:
                                   (0390) _bHELLO_1_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[HELLO_1_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: HELLO_1_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
18B9: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
18BB: 21 E8    AND   A,232         (0408) ;
18BD: 08       PUSH  A             (0409) ;  ARGUMENTS:
18BE: 21 08    AND   A,8           (0410) ;      none
18C0: B0 07    JNZ   0x18C8        (0411) ;
18C2: 18       POP   A             (0412) ;  RETURNS:
18C3: 29 01    OR    A,1           (0413) ;     char that is returned from UART
18C5: 4B       SWAP  A,X           (0414) ;
18C6: 80 07    JMP   0x18CE        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
18C8: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
18C9: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
18CB: 4B       SWAP  A,X           (0420) ;    functions.
18CC: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
18CE: 7F       RET                 (0426)  HELLO_1_cGetChar:
                                   (0427) _HELLO_1_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[HELLO_1_CONTROL_REG],HELLO_1_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[HELLO_1_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: HELLO_1_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  HELLO_1_cReadChar:
                                   (0463) _HELLO_1_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[HELLO_1_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,HELLO_1_RX_COMPLETE                              ; Check if a character is ready
18CF: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
18D2: 55 78 00 MOV   [120],0       (0470)    pop  A
18D5: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
18D8: 55 D8 00 MOV   [216],0       (0472) 
18DB: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
18DE: 55 0F 00 MOV   [15],0        (0474)    mov  A,REG[HELLO_1_RX_BUFFER_REG]                       ; Read data first, then
18E1: 26 0E 00 AND   [14],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
18E4: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(HELLO_1_RX_PARITY_ERROR | HELLO_1_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_HELLO_1_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: HELLO_1_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
18E5: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
18E8: 51 0E    MOV   A,[14]        (0511) ;        0x40CC    Overrun Error
18EA: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
18EC: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  HELLO_1_iReadChar:
                                   (0523) _HELLO_1_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[HELLO_1_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(HELLO_1_RX_ERROR|HELLO_1_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,HELLO_1_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,HELLO_1_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_HELLO_1_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,HELLO_1_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[HELLO_1_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_HELLO_1_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (HELLO_1_RXBUF_ENABLE)
                                   (0552) .SECTION
18ED: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
18F0: 51 0E    MOV   A,[14]        (0554) ;-----------------------------------------------------------------------------
18F2: 21 F0    AND   A,240         (0555) ;
18F4: 26 0E 0F AND   [14],15       (0556) ;     Command Buffer commands
                                   (0557) ;
18F7: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: HELLO_1_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  HELLO_1_CmdReset:
18F8: 62 D0 00 MOV   REG[208],0    (0587) _HELLO_1_CmdReset:
18FB: 51 0F    MOV   A,[15]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >HELLO_1_aRxBuffer
18FD: 7F       RET                 (0590)    mov [HELLO_1_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >HELLO_1_bRxCnt
                                   (0594)    mov [HELLO_1_bRxCnt], 0x00
                                   (0595)    and [HELLO_1_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: HELLO_1_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  HELLO_1_bCmdCheck:
                                   (0628) _HELLO_1_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >HELLO_1_fStatus
                                   (0631)    mov A,  [HELLO_1_fStatus]
                                   (0632)    and A, HELLO_1_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: HELLO_1_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
18FE: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1900: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1903: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1906: 50 78    MOV   A,120         (0648) ;     BYTE  fStatus - Status of command receive buffer.
1908: 02 D8    ADD   A,[216]       (0649) ;                     Returns non-zero value in A if command is valid.
190A: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
190B: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
190D: B0 04    JNZ   0x1912        (0653) ;           0x10 => Software Buffer OverRun
190F: 10       PUSH  X             (0654) ;
1910: 80 33    JMP   0x1944        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1912: 39 00    CMP   A,0           (0660) ;    functions.
1914: B0 11    JNZ   0x1926        (0661) ;          
1916: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1917: 76 D8    INC   [216]         (0663) ;          CUR_PP
1919: 52 00    MOV   A,[X+0]       (0664) ;
191B: 3C D8 0F CMP   [216],15      (0665) ;     Error Status is clear when read.
191E: BF F3    JNZ   0x1912        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
1920: 10       PUSH  X             (0669) ;
                                   (0670)  HELLO_1_bErrCheck:
1921: 56 00 00 MOV   [X+0],0       (0671) _HELLO_1_bErrCheck:
1924: 80 1F    JMP   0x1944        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >HELLO_1_fStatus
                                   (0674)    mov A,  [HELLO_1_fStatus]
1926: 10       PUSH  X             (0675)    and A, HELLO_1_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [HELLO_1_fStatus], ~HELLO_1_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
1927: 75       INC   X             (0679) .ENDSECTION
1928: 76 D8    INC   [216]         (0680) 
192A: 3C D8 0F CMP   [216],15      (0681) .SECTION
192D: AF F3    JZ    0x1921        (0682) ;-----------------------------------------------------------------------------
192F: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: HELLO_1_bCmdLength
1931: A0 12    JZ    0x1944        (0684) ;
1933: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1935: BF F1    JNZ   0x1927        (0686) ;     Get length of command string
                                   (0687) ;
1937: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
193A: 76 D8    INC   [216]         (0689) ;     none.
193C: 3C D8 0F CMP   [216],15      (0690) ;
193F: B0 04    JNZ   0x1944        (0691) ;  RETURNS:
1941: 55 D8 0F MOV   [216],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1944: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1945: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
1946: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1949: B0 0B    JNZ   0x1955        (0699) ;    functions.
194B: 20       POP   X             (0700) ;          
194C: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
194E: 50 00    MOV   A,0           (0702) ;          CUR_PP
1950: 70 3F    AND   F,63
1952: 71 C0    OR    F,192         (0703) ;
                                   (0704)  HELLO_1_bCmdLength:
1954: 7F       RET                 (0705) _HELLO_1_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >HELLO_1_bRxCnt
1955: 20       POP   X             (0708)    mov A,  [HELLO_1_bRxCnt]
1956: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1958: 70 3F    AND   F,63
195A: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
195C: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: HELLO_1_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
195D: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1960: 50 78    MOV   A,120         (0744) ;     each lexically distinct element into a null-terminated string by replacing
1962: 02 D8    ADD   A,[216]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
1964: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
1965: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     HELLO_1_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, HELLO_1_szGetParam, is
1968: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\child_4int.asm
1969: 10       PUSH  X             (0104) ;;*****************************************************************************
196A: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: CHILD_4INT.asm
196C: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
196D: 58 11    MOV   X,[17]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
196F: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
1971: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1972: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1974: B0 04    JNZ   0x1979        (0115) 
1976: 18       POP   A             (0116) include "m8c.inc"
1977: 80 5E    JMP   0x19D6        (0117) include "memory.inc"
                                   (0118) include "CHILD_4.inc"
                                   (0119) 
                                   (0120) 
1979: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
197A: 21 E0    AND   A,224         (0124) export  _CHILD_4_ISR
197C: A0 12    JZ    0x198F        (0125) 
                                   (0126) 
197E: 2C 10    OR    [16],A        (0127) IF (CHILD_4_RXBUF_ENABLE)
                                   (0128) export  CHILD_4_aRxBuffer
1980: 49 2A 00 TST   REG[42],0     (0129) export _CHILD_4_aRxBuffer
                                   (0130) export  CHILD_4_bRxCnt
1983: 21 20    AND   A,32          (0131) export _CHILD_4_bRxCnt
1985: A0 50    JZ    0x19D6        (0132) export  CHILD_4_fStatus
                                   (0133) export _CHILD_4_fStatus
                                   (0134) ENDIF
                                   (0135) 
1987: 41 2B FE AND   REG[43],254   (0136) 
198A: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
198D: 80 48    JMP   0x19D6        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (CHILD_4_RXBUF_ENABLE)
198F: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  CHILD_4_fStatus:
                                   (0144) _CHILD_4_fStatus:      BLK  1
1991: 47 10 01 TST   [16],1        (0145)  CHILD_4_bRxCnt:
1994: B0 41    JNZ   0x19D6        (0146) _CHILD_4_bRxCnt:       BLK  1
                                   (0147) AREA CHILD_4_RAM(RAM,REL,CON)
1996: 39 00    CMP   A,0           (0148)  CHILD_4_aRxBuffer:    
1998: B0 14    JNZ   0x19AD        (0149) _CHILD_4_aRxBuffer:    BLK CHILD_4_RX_BUFFER_SIZE
199A: 2E 10 01 OR    [16],1        (0150) ENDIF
                                   (0151) 
199D: 62 D3 00 MOV   REG[211],0    (0152) 
19A0: 70 3F    AND   F,63
19A2: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
19A4: 56 88 00 MOV   [X-120],0     (0154) 
19A7: 70 3F    AND   F,63
19A9: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
19AB: 80 2A    JMP   0x19D6        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
19AD: 3C 11 0F CMP   [17],15       (0167) ;------------------------
19B0: C0 14    JC    0x19C5        (0168) 
19B2: 2E 10 10 OR    [16],16       (0169) 
                                   (0170) ;------------------------
19B5: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
19B8: 70 3F    AND   F,63
19BA: 71 80    OR    F,128         (0172) ;------------------------
19BC: 56 88 00 MOV   [X-120],0     (0173) 
19BF: 70 3F    AND   F,63
19C1: 71 00    OR    F,0           (0174) 
19C3: 80 12    JMP   0x19D6        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
19C5: 75       INC   X             (0179) 
19C6: 5A 11    MOV   [17],X        (0180) 
19C8: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
19C9: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
19CC: 70 3F    AND   F,63
19CE: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _CHILD_4_ISR
19D0: 54 88    MOV   [X-120],A     (0185) ;
19D2: 70 3F    AND   F,63
19D4: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
19D6: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
19D7: 60 D3    MOV   REG[211],A    (0191) _CHILD_4_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
19D9: 20       POP   X             (0195)    ; Insert your custom code below this banner
19DA: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
19DC: 43 E1 02 OR    REG[225],2    (0201)    ; Insert your custom code above this banner

FILE: lib\child_4_timeout.asm
                                   (0102) ;;*****************************************************************************
19DF: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: CHILD_4_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "CHILD_4_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
19E0: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
19E3: 7F       RET                 (0131) export  CHILD_4_TIMEOUT_EnableInt
                                   (0132) export _CHILD_4_TIMEOUT_EnableInt
                                   (0133) export  CHILD_4_TIMEOUT_DisableInt
                                   (0134) export _CHILD_4_TIMEOUT_DisableInt
                                   (0135) export  CHILD_4_TIMEOUT_Start
                                   (0136) export _CHILD_4_TIMEOUT_Start
                                   (0137) export  CHILD_4_TIMEOUT_Stop
                                   (0138) export _CHILD_4_TIMEOUT_Stop
                                   (0139) export  CHILD_4_TIMEOUT_WritePeriod
                                   (0140) export _CHILD_4_TIMEOUT_WritePeriod
                                   (0141) export  CHILD_4_TIMEOUT_WriteCompareValue
                                   (0142) export _CHILD_4_TIMEOUT_WriteCompareValue
                                   (0143) export  CHILD_4_TIMEOUT_wReadCompareValue
                                   (0144) export _CHILD_4_TIMEOUT_wReadCompareValue
                                   (0145) export  CHILD_4_TIMEOUT_wReadTimer
                                   (0146) export _CHILD_4_TIMEOUT_wReadTimer
                                   (0147) export  CHILD_4_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _CHILD_4_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wCHILD_4_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wCHILD_4_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wCHILD_4_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wCHILD_4_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wCHILD_4_TIMEOUT_ReadTimerSaveCV   ; deprecated
19E4: 43 23 01 OR    REG[35],1     (0157) export _wCHILD_4_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
19E7: 7F       RET                 (0159) export  wCHILD_4_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wCHILD_4_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wCHILD_4_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wCHILD_4_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA response4_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: CHILD_4_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
19E8: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
19EB: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  CHILD_4_TIMEOUT_EnableInt:
                                   (0200) _CHILD_4_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    CHILD_4_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: CHILD_4_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
19EC: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
19EE: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
19EF: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
19F1: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  CHILD_4_TIMEOUT_DisableInt:
                                   (0228) _CHILD_4_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    CHILD_4_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: CHILD_4_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
19F2: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
19F4: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
19F5: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
19F7: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  CHILD_4_TIMEOUT_Start:
                                   (0256) _CHILD_4_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    CHILD_4_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: CHILD_4_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
19F8: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
19FA: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
19FB: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
19FD: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  CHILD_4_TIMEOUT_Stop:
                                   (0284) _CHILD_4_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    CHILD_4_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: CHILD_4_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  CHILD_4_TIMEOUT_WritePeriod:
                                   (0313) _CHILD_4_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[CHILD_4_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[CHILD_4_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: CHILD_4_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call CHILD_4_TIMEOUT_Stop to disable).
19FE: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
19FF: 38 03    ADD   SP,3          (0334) ;
1A01: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
1A03: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
1A04: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
1A06: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
1A07: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
1A09: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
1A0A: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
1A0C: 5D 26    MOV   A,REG[38]     (0343) ;
1A0E: 54 01    MOV   [X+1],A       (0344)  CHILD_4_TIMEOUT_WriteCompareValue:
1A10: 5D 22    MOV   A,REG[34]     (0345) _CHILD_4_TIMEOUT_WriteCompareValue:
1A12: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
1A14: 50 00    MOV   A,0           (0347)    mov   reg[CHILD_4_TIMEOUT_COMPARE_LSB_REG], A
1A16: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
1A19: A0 03    JZ    0x1A1D        (0349)    mov   reg[CHILD_4_TIMEOUT_COMPARE_MSB_REG], A
1A1B: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
1A1D: 54 00    MOV   [X+0],A       (0352) 
1A1F: 70 FE    AND   F,254         (0353) .ENDSECTION
1A21: 41 23 FE AND   REG[35],254   (0354) 
1A24: 18       POP   A             (0355) 
1A25: 60 26    MOV   REG[38],A     (0356) .SECTION
1A27: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
1A28: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: CHILD_4_TIMEOUT_wReadCompareValue
1A2A: 18       POP   A             (0359) ;
1A2B: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
1A2D: 18       POP   A             (0361) ;     Reads the Compare registers.
1A2E: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
1A2F: 70 3F    AND   F,63
1A31: 71 C0    OR    F,192         (0363) ;
1A33: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  CHILD_4_TIMEOUT_wReadCompareValue:
                                   (0374) _CHILD_4_TIMEOUT_wReadCompareValue:
                                   (0375)  wCHILD_4_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wCHILD_4_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[CHILD_4_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[CHILD_4_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: CHILD_4_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
1A34: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
1A36: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
1A38: 5C       MOV   X,A           (0409) ;
1A39: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
1A3C: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\child_4.asm
                                   (0121) ;;*****************************************************************************
1A3F: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: CHILD_4.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "CHILD_4.inc"
1A40: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
1A43: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   CHILD_4_EnableInt
                                   (0155) export  _CHILD_4_EnableInt
                                   (0156) export   CHILD_4_DisableInt
                                   (0157) export  _CHILD_4_DisableInt
                                   (0158) export   CHILD_4_Start
                                   (0159) export  _CHILD_4_Start
                                   (0160) export   CHILD_4_Stop
                                   (0161) export  _CHILD_4_Stop
                                   (0162) export   CHILD_4_bReadRxData
                                   (0163) export  _CHILD_4_bReadRxData
                                   (0164) export   CHILD_4_bReadRxStatus
                                   (0165) export  _CHILD_4_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bCHILD_4_ReadRxData
                                   (0170) export _bCHILD_4_ReadRxData
                                   (0171) export  bCHILD_4_ReadRxStatus
                                   (0172) export _bCHILD_4_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  CHILD_4_cGetChar
1A44: 29 01    OR    A,1           (0179) export _CHILD_4_cGetChar
1A46: 60 2B    MOV   REG[43],A     (0180) export  CHILD_4_cReadChar
                                   (0181) export _CHILD_4_cReadChar
1A48: 7F       RET                 (0182) export  CHILD_4_iReadChar
                                   (0183) export _CHILD_4_iReadChar
                                   (0184) 
                                   (0185) IF (CHILD_4_RXBUF_ENABLE)
                                   (0186) export  CHILD_4_CmdReset
                                   (0187) export _CHILD_4_CmdReset
                                   (0188) export  CHILD_4_bCmdCheck
                                   (0189) export _CHILD_4_bCmdCheck
                                   (0190) export  CHILD_4_bCmdLength
                                   (0191) export _CHILD_4_bCmdLength
                                   (0192) export  CHILD_4_bErrCheck
                                   (0193) export _CHILD_4_bErrCheck
                                   (0194) 
                                   (0195) export  CHILD_4_szGetParam
                                   (0196) export _CHILD_4_szGetParam
                                   (0197) export  CHILD_4_szGetRestOfParams
                                   (0198) export _CHILD_4_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA CHILD_4_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1A49: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1A4C: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: CHILD_4_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  CHILD_4_EnableInt:
                                   (0238) _CHILD_4_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1A4D: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask CHILD_4_INT_REG, CHILD_4_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1A4F: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: CHILD_4_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  CHILD_4_DisableInt:
                                   (0267) _CHILD_4_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask CHILD_4_INT_REG, CHILD_4_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
1A50: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
1A52: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: CHILD_4_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  CHILD_4_Start:
                                   (0297) _CHILD_4_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[CHILD_4_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: CHILD_4_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1A53: 49 2B 08 TST   REG[43],8     (0311) ;
1A56: AF FC    JZ    0x1A53        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1A58: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1A5A: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  CHILD_4_Stop:
                                   (0326) _CHILD_4_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[CHILD_4_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: CHILD_4_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1A5B: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
1A5D: 08       PUSH  A             (0347) ;
1A5E: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
1A60: B0 04    JNZ   0x1A65        (0349) ;    The A and X registers may be modified by this or future implementations
1A62: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1A63: 80 0B    JMP   0x1A6F        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1A65: 5D 2A    MOV   A,REG[42]     (0354) ;
1A67: 4B       SWAP  A,X           (0355)  CHILD_4_bReadRxData:
                                   (0356) _CHILD_4_bReadRxData:
1A68: 18       POP   A             (0357)  bCHILD_4_ReadRxData:
1A69: 21 A0    AND   A,160         (0358) _bCHILD_4_ReadRxData:
1A6B: B0 03    JNZ   0x1A6F        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1A6D: 4B       SWAP  A,X           (0360)    mov A, REG[CHILD_4_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1A6E: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1A6F: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: CHILD_4_bReadRxStatus
                                   (0368) ;
1A71: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  CHILD_4_bReadRxStatus:
                                   (0388) _CHILD_4_bReadRxStatus:
                                   (0389)  bCHILD_4_ReadRxStatus:
                                   (0390) _bCHILD_4_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[CHILD_4_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: CHILD_4_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1A72: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1A74: 21 E8    AND   A,232         (0408) ;
1A76: 08       PUSH  A             (0409) ;  ARGUMENTS:
1A77: 21 08    AND   A,8           (0410) ;      none
1A79: B0 07    JNZ   0x1A81        (0411) ;
1A7B: 18       POP   A             (0412) ;  RETURNS:
1A7C: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1A7E: 4B       SWAP  A,X           (0414) ;
1A7F: 80 07    JMP   0x1A87        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1A81: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1A82: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1A84: 4B       SWAP  A,X           (0420) ;    functions.
1A85: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1A87: 7F       RET                 (0426)  CHILD_4_cGetChar:
                                   (0427) _CHILD_4_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[CHILD_4_CONTROL_REG],CHILD_4_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[CHILD_4_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: CHILD_4_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  CHILD_4_cReadChar:
                                   (0463) _CHILD_4_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[CHILD_4_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,CHILD_4_RX_COMPLETE                              ; Check if a character is ready
1A88: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1A8B: 55 88 00 MOV   [136],0       (0470)    pop  A
1A8E: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1A91: 55 D7 00 MOV   [215],0       (0472) 
1A94: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1A97: 55 11 00 MOV   [17],0        (0474)    mov  A,REG[CHILD_4_RX_BUFFER_REG]                       ; Read data first, then
1A9A: 26 10 00 AND   [16],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1A9D: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(CHILD_4_RX_PARITY_ERROR | CHILD_4_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_CHILD_4_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: CHILD_4_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1A9E: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1AA1: 51 10    MOV   A,[16]        (0511) ;        0x40CC    Overrun Error
1AA3: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1AA5: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  CHILD_4_iReadChar:
                                   (0523) _CHILD_4_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[CHILD_4_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(CHILD_4_RX_ERROR|CHILD_4_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,CHILD_4_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,CHILD_4_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_CHILD_4_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,CHILD_4_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[CHILD_4_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_CHILD_4_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (CHILD_4_RXBUF_ENABLE)
                                   (0552) .SECTION
1AA6: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1AA9: 51 10    MOV   A,[16]        (0554) ;-----------------------------------------------------------------------------
1AAB: 21 F0    AND   A,240         (0555) ;
1AAD: 26 10 0F AND   [16],15       (0556) ;     Command Buffer commands
                                   (0557) ;
1AB0: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: CHILD_4_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  CHILD_4_CmdReset:
1AB1: 62 D0 00 MOV   REG[208],0    (0587) _CHILD_4_CmdReset:
1AB4: 51 11    MOV   A,[17]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >CHILD_4_aRxBuffer
1AB6: 7F       RET                 (0590)    mov [CHILD_4_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >CHILD_4_bRxCnt
                                   (0594)    mov [CHILD_4_bRxCnt], 0x00
                                   (0595)    and [CHILD_4_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: CHILD_4_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  CHILD_4_bCmdCheck:
                                   (0628) _CHILD_4_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >CHILD_4_fStatus
                                   (0631)    mov A,  [CHILD_4_fStatus]
                                   (0632)    and A, CHILD_4_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: CHILD_4_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1AB7: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1AB9: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1ABC: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1ABF: 50 88    MOV   A,136         (0648) ;     BYTE  fStatus - Status of command receive buffer.
1AC1: 02 D7    ADD   A,[215]       (0649) ;                     Returns non-zero value in A if command is valid.
1AC3: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1AC4: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1AC6: B0 04    JNZ   0x1ACB        (0653) ;           0x10 => Software Buffer OverRun
1AC8: 10       PUSH  X             (0654) ;
1AC9: 80 33    JMP   0x1AFD        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1ACB: 39 00    CMP   A,0           (0660) ;    functions.
1ACD: B0 11    JNZ   0x1ADF        (0661) ;          
1ACF: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1AD0: 76 D7    INC   [215]         (0663) ;          CUR_PP
1AD2: 52 00    MOV   A,[X+0]       (0664) ;
1AD4: 3C D7 0F CMP   [215],15      (0665) ;     Error Status is clear when read.
1AD7: BF F3    JNZ   0x1ACB        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
1AD9: 10       PUSH  X             (0669) ;
                                   (0670)  CHILD_4_bErrCheck:
1ADA: 56 00 00 MOV   [X+0],0       (0671) _CHILD_4_bErrCheck:
1ADD: 80 1F    JMP   0x1AFD        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >CHILD_4_fStatus
                                   (0674)    mov A,  [CHILD_4_fStatus]
1ADF: 10       PUSH  X             (0675)    and A, CHILD_4_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [CHILD_4_fStatus], ~CHILD_4_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
1AE0: 75       INC   X             (0679) .ENDSECTION
1AE1: 76 D7    INC   [215]         (0680) 
1AE3: 3C D7 0F CMP   [215],15      (0681) .SECTION
1AE6: AF F3    JZ    0x1ADA        (0682) ;-----------------------------------------------------------------------------
1AE8: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: CHILD_4_bCmdLength
1AEA: A0 12    JZ    0x1AFD        (0684) ;
1AEC: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1AEE: BF F1    JNZ   0x1AE0        (0686) ;     Get length of command string
                                   (0687) ;
1AF0: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
1AF3: 76 D7    INC   [215]         (0689) ;     none.
1AF5: 3C D7 0F CMP   [215],15      (0690) ;
1AF8: B0 04    JNZ   0x1AFD        (0691) ;  RETURNS:
1AFA: 55 D7 0F MOV   [215],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1AFD: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1AFE: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
1AFF: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1B02: B0 0B    JNZ   0x1B0E        (0699) ;    functions.
1B04: 20       POP   X             (0700) ;          
1B05: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
1B07: 50 00    MOV   A,0           (0702) ;          CUR_PP
1B09: 70 3F    AND   F,63
1B0B: 71 C0    OR    F,192         (0703) ;
                                   (0704)  CHILD_4_bCmdLength:
1B0D: 7F       RET                 (0705) _CHILD_4_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >CHILD_4_bRxCnt
1B0E: 20       POP   X             (0708)    mov A,  [CHILD_4_bRxCnt]
1B0F: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1B11: 70 3F    AND   F,63
1B13: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1B15: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: CHILD_4_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1B16: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1B19: 50 88    MOV   A,136         (0744) ;     each lexically distinct element into a null-terminated string by replacing
1B1B: 02 D7    ADD   A,[215]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
1B1D: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
1B1E: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     CHILD_4_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, CHILD_4_szGetParam, is
1B21: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\child_3int.asm
1B22: 10       PUSH  X             (0104) ;;*****************************************************************************
1B23: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: CHILD_3INT.asm
1B25: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1B26: 58 13    MOV   X,[19]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1B28: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
1B2A: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1B2B: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1B2D: B0 04    JNZ   0x1B32        (0115) 
1B2F: 18       POP   A             (0116) include "m8c.inc"
1B30: 80 5E    JMP   0x1B8F        (0117) include "memory.inc"
                                   (0118) include "CHILD_3.inc"
                                   (0119) 
                                   (0120) 
1B32: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1B33: 21 E0    AND   A,224         (0124) export  _CHILD_3_ISR
1B35: A0 12    JZ    0x1B48        (0125) 
                                   (0126) 
1B37: 2C 12    OR    [18],A        (0127) IF (CHILD_3_RXBUF_ENABLE)
                                   (0128) export  CHILD_3_aRxBuffer
1B39: 49 2A 00 TST   REG[42],0     (0129) export _CHILD_3_aRxBuffer
                                   (0130) export  CHILD_3_bRxCnt
1B3C: 21 20    AND   A,32          (0131) export _CHILD_3_bRxCnt
1B3E: A0 50    JZ    0x1B8F        (0132) export  CHILD_3_fStatus
                                   (0133) export _CHILD_3_fStatus
                                   (0134) ENDIF
                                   (0135) 
1B40: 41 2B FE AND   REG[43],254   (0136) 
1B43: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
1B46: 80 48    JMP   0x1B8F        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (CHILD_3_RXBUF_ENABLE)
1B48: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  CHILD_3_fStatus:
                                   (0144) _CHILD_3_fStatus:      BLK  1
1B4A: 47 12 01 TST   [18],1        (0145)  CHILD_3_bRxCnt:
1B4D: B0 41    JNZ   0x1B8F        (0146) _CHILD_3_bRxCnt:       BLK  1
                                   (0147) AREA CHILD_3_RAM(RAM,REL,CON)
1B4F: 39 00    CMP   A,0           (0148)  CHILD_3_aRxBuffer:    
1B51: B0 14    JNZ   0x1B66        (0149) _CHILD_3_aRxBuffer:    BLK CHILD_3_RX_BUFFER_SIZE
1B53: 2E 12 01 OR    [18],1        (0150) ENDIF
                                   (0151) 
1B56: 62 D3 00 MOV   REG[211],0    (0152) 
1B59: 70 3F    AND   F,63
1B5B: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1B5D: 56 38 00 MOV   [X+56],0      (0154) 
1B60: 70 3F    AND   F,63
1B62: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
1B64: 80 2A    JMP   0x1B8F        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1B66: 3C 13 0F CMP   [19],15       (0167) ;------------------------
1B69: C0 14    JC    0x1B7E        (0168) 
1B6B: 2E 12 10 OR    [18],16       (0169) 
                                   (0170) ;------------------------
1B6E: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
1B71: 70 3F    AND   F,63
1B73: 71 80    OR    F,128         (0172) ;------------------------
1B75: 56 38 00 MOV   [X+56],0      (0173) 
1B78: 70 3F    AND   F,63
1B7A: 71 00    OR    F,0           (0174) 
1B7C: 80 12    JMP   0x1B8F        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1B7E: 75       INC   X             (0179) 
1B7F: 5A 13    MOV   [19],X        (0180) 
1B81: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1B82: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1B85: 70 3F    AND   F,63
1B87: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _CHILD_3_ISR
1B89: 54 38    MOV   [X+56],A      (0185) ;
1B8B: 70 3F    AND   F,63
1B8D: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1B8F: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1B90: 60 D3    MOV   REG[211],A    (0191) _CHILD_3_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1B92: 20       POP   X             (0195)    ; Insert your custom code below this banner
1B93: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1B95: 43 E1 02 OR    REG[225],2    (0201)    ; Insert your custom code above this banner

FILE: lib\child_3_timeout.asm
                                   (0102) ;;*****************************************************************************
1B98: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: CHILD_3_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "CHILD_3_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
1B99: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
1B9C: 7F       RET                 (0131) export  CHILD_3_TIMEOUT_EnableInt
                                   (0132) export _CHILD_3_TIMEOUT_EnableInt
                                   (0133) export  CHILD_3_TIMEOUT_DisableInt
                                   (0134) export _CHILD_3_TIMEOUT_DisableInt
                                   (0135) export  CHILD_3_TIMEOUT_Start
                                   (0136) export _CHILD_3_TIMEOUT_Start
                                   (0137) export  CHILD_3_TIMEOUT_Stop
                                   (0138) export _CHILD_3_TIMEOUT_Stop
                                   (0139) export  CHILD_3_TIMEOUT_WritePeriod
                                   (0140) export _CHILD_3_TIMEOUT_WritePeriod
                                   (0141) export  CHILD_3_TIMEOUT_WriteCompareValue
                                   (0142) export _CHILD_3_TIMEOUT_WriteCompareValue
                                   (0143) export  CHILD_3_TIMEOUT_wReadCompareValue
                                   (0144) export _CHILD_3_TIMEOUT_wReadCompareValue
                                   (0145) export  CHILD_3_TIMEOUT_wReadTimer
                                   (0146) export _CHILD_3_TIMEOUT_wReadTimer
                                   (0147) export  CHILD_3_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _CHILD_3_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wCHILD_3_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wCHILD_3_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wCHILD_3_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wCHILD_3_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wCHILD_3_TIMEOUT_ReadTimerSaveCV   ; deprecated
1B9D: 43 23 01 OR    REG[35],1     (0157) export _wCHILD_3_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
1BA0: 7F       RET                 (0159) export  wCHILD_3_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wCHILD_3_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wCHILD_3_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wCHILD_3_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA response3_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: CHILD_3_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
1BA1: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
1BA4: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  CHILD_3_TIMEOUT_EnableInt:
                                   (0200) _CHILD_3_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    CHILD_3_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: CHILD_3_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
1BA5: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
1BA7: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
1BA8: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
1BAA: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  CHILD_3_TIMEOUT_DisableInt:
                                   (0228) _CHILD_3_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    CHILD_3_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: CHILD_3_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
1BAB: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
1BAD: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
1BAE: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
1BB0: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  CHILD_3_TIMEOUT_Start:
                                   (0256) _CHILD_3_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    CHILD_3_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: CHILD_3_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
1BB1: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
1BB3: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
1BB4: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
1BB6: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  CHILD_3_TIMEOUT_Stop:
                                   (0284) _CHILD_3_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    CHILD_3_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: CHILD_3_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  CHILD_3_TIMEOUT_WritePeriod:
                                   (0313) _CHILD_3_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[CHILD_3_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[CHILD_3_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: CHILD_3_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call CHILD_3_TIMEOUT_Stop to disable).
1BB7: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
1BB8: 38 03    ADD   SP,3          (0334) ;
1BBA: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
1BBC: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
1BBD: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
1BBF: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
1BC0: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
1BC2: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
1BC3: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
1BC5: 5D 26    MOV   A,REG[38]     (0343) ;
1BC7: 54 01    MOV   [X+1],A       (0344)  CHILD_3_TIMEOUT_WriteCompareValue:
1BC9: 5D 22    MOV   A,REG[34]     (0345) _CHILD_3_TIMEOUT_WriteCompareValue:
1BCB: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
1BCD: 50 00    MOV   A,0           (0347)    mov   reg[CHILD_3_TIMEOUT_COMPARE_LSB_REG], A
1BCF: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
1BD2: A0 03    JZ    0x1BD6        (0349)    mov   reg[CHILD_3_TIMEOUT_COMPARE_MSB_REG], A
1BD4: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
1BD6: 54 00    MOV   [X+0],A       (0352) 
1BD8: 70 FE    AND   F,254         (0353) .ENDSECTION
1BDA: 41 23 FE AND   REG[35],254   (0354) 
1BDD: 18       POP   A             (0355) 
1BDE: 60 26    MOV   REG[38],A     (0356) .SECTION
1BE0: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
1BE1: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: CHILD_3_TIMEOUT_wReadCompareValue
1BE3: 18       POP   A             (0359) ;
1BE4: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
1BE6: 18       POP   A             (0361) ;     Reads the Compare registers.
1BE7: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
1BE8: 70 3F    AND   F,63
1BEA: 71 C0    OR    F,192         (0363) ;
1BEC: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  CHILD_3_TIMEOUT_wReadCompareValue:
                                   (0374) _CHILD_3_TIMEOUT_wReadCompareValue:
                                   (0375)  wCHILD_3_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wCHILD_3_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[CHILD_3_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[CHILD_3_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: CHILD_3_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
1BED: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
1BEF: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
1BF1: 5C       MOV   X,A           (0409) ;
1BF2: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
1BF5: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\child_3.asm
                                   (0121) ;;*****************************************************************************
1BF8: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: CHILD_3.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "CHILD_3.inc"
1BF9: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
1BFC: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   CHILD_3_EnableInt
                                   (0155) export  _CHILD_3_EnableInt
                                   (0156) export   CHILD_3_DisableInt
                                   (0157) export  _CHILD_3_DisableInt
                                   (0158) export   CHILD_3_Start
                                   (0159) export  _CHILD_3_Start
                                   (0160) export   CHILD_3_Stop
                                   (0161) export  _CHILD_3_Stop
                                   (0162) export   CHILD_3_bReadRxData
                                   (0163) export  _CHILD_3_bReadRxData
                                   (0164) export   CHILD_3_bReadRxStatus
                                   (0165) export  _CHILD_3_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bCHILD_3_ReadRxData
                                   (0170) export _bCHILD_3_ReadRxData
                                   (0171) export  bCHILD_3_ReadRxStatus
                                   (0172) export _bCHILD_3_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  CHILD_3_cGetChar
1BFD: 29 01    OR    A,1           (0179) export _CHILD_3_cGetChar
1BFF: 60 2B    MOV   REG[43],A     (0180) export  CHILD_3_cReadChar
                                   (0181) export _CHILD_3_cReadChar
1C01: 7F       RET                 (0182) export  CHILD_3_iReadChar
                                   (0183) export _CHILD_3_iReadChar
                                   (0184) 
                                   (0185) IF (CHILD_3_RXBUF_ENABLE)
                                   (0186) export  CHILD_3_CmdReset
                                   (0187) export _CHILD_3_CmdReset
                                   (0188) export  CHILD_3_bCmdCheck
                                   (0189) export _CHILD_3_bCmdCheck
                                   (0190) export  CHILD_3_bCmdLength
                                   (0191) export _CHILD_3_bCmdLength
                                   (0192) export  CHILD_3_bErrCheck
                                   (0193) export _CHILD_3_bErrCheck
                                   (0194) 
                                   (0195) export  CHILD_3_szGetParam
                                   (0196) export _CHILD_3_szGetParam
                                   (0197) export  CHILD_3_szGetRestOfParams
                                   (0198) export _CHILD_3_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA CHILD_3_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1C02: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1C05: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: CHILD_3_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  CHILD_3_EnableInt:
                                   (0238) _CHILD_3_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1C06: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask CHILD_3_INT_REG, CHILD_3_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1C08: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: CHILD_3_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  CHILD_3_DisableInt:
                                   (0267) _CHILD_3_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask CHILD_3_INT_REG, CHILD_3_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
1C09: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
1C0B: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: CHILD_3_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  CHILD_3_Start:
                                   (0297) _CHILD_3_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[CHILD_3_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: CHILD_3_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1C0C: 49 2B 08 TST   REG[43],8     (0311) ;
1C0F: AF FC    JZ    0x1C0C        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1C11: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1C13: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  CHILD_3_Stop:
                                   (0326) _CHILD_3_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[CHILD_3_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: CHILD_3_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1C14: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
1C16: 08       PUSH  A             (0347) ;
1C17: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
1C19: B0 04    JNZ   0x1C1E        (0349) ;    The A and X registers may be modified by this or future implementations
1C1B: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1C1C: 80 0B    JMP   0x1C28        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1C1E: 5D 2A    MOV   A,REG[42]     (0354) ;
1C20: 4B       SWAP  A,X           (0355)  CHILD_3_bReadRxData:
                                   (0356) _CHILD_3_bReadRxData:
1C21: 18       POP   A             (0357)  bCHILD_3_ReadRxData:
1C22: 21 A0    AND   A,160         (0358) _bCHILD_3_ReadRxData:
1C24: B0 03    JNZ   0x1C28        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1C26: 4B       SWAP  A,X           (0360)    mov A, REG[CHILD_3_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1C27: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1C28: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: CHILD_3_bReadRxStatus
                                   (0368) ;
1C2A: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  CHILD_3_bReadRxStatus:
                                   (0388) _CHILD_3_bReadRxStatus:
                                   (0389)  bCHILD_3_ReadRxStatus:
                                   (0390) _bCHILD_3_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[CHILD_3_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: CHILD_3_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1C2B: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1C2D: 21 E8    AND   A,232         (0408) ;
1C2F: 08       PUSH  A             (0409) ;  ARGUMENTS:
1C30: 21 08    AND   A,8           (0410) ;      none
1C32: B0 07    JNZ   0x1C3A        (0411) ;
1C34: 18       POP   A             (0412) ;  RETURNS:
1C35: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1C37: 4B       SWAP  A,X           (0414) ;
1C38: 80 07    JMP   0x1C40        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1C3A: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1C3B: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1C3D: 4B       SWAP  A,X           (0420) ;    functions.
1C3E: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1C40: 7F       RET                 (0426)  CHILD_3_cGetChar:
                                   (0427) _CHILD_3_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[CHILD_3_CONTROL_REG],CHILD_3_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[CHILD_3_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: CHILD_3_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  CHILD_3_cReadChar:
                                   (0463) _CHILD_3_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[CHILD_3_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,CHILD_3_RX_COMPLETE                              ; Check if a character is ready
1C41: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1C44: 55 38 00 MOV   [56],0        (0470)    pop  A
1C47: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1C4A: 55 D6 00 MOV   [CHILD+3],0   (0472) 
1C4D: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1C50: 55 13 00 MOV   [19],0        (0474)    mov  A,REG[CHILD_3_RX_BUFFER_REG]                       ; Read data first, then
1C53: 26 12 00 AND   [18],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1C56: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(CHILD_3_RX_PARITY_ERROR | CHILD_3_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_CHILD_3_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: CHILD_3_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1C57: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1C5A: 51 12    MOV   A,[18]        (0511) ;        0x40CC    Overrun Error
1C5C: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1C5E: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  CHILD_3_iReadChar:
                                   (0523) _CHILD_3_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[CHILD_3_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(CHILD_3_RX_ERROR|CHILD_3_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,CHILD_3_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,CHILD_3_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_CHILD_3_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,CHILD_3_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[CHILD_3_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_CHILD_3_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (CHILD_3_RXBUF_ENABLE)
                                   (0552) .SECTION
1C5F: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1C62: 51 12    MOV   A,[18]        (0554) ;-----------------------------------------------------------------------------
1C64: 21 F0    AND   A,240         (0555) ;
1C66: 26 12 0F AND   [18],15       (0556) ;     Command Buffer commands
                                   (0557) ;
1C69: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: CHILD_3_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  CHILD_3_CmdReset:
1C6A: 62 D0 00 MOV   REG[208],0    (0587) _CHILD_3_CmdReset:
1C6D: 51 13    MOV   A,[19]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >CHILD_3_aRxBuffer
1C6F: 7F       RET                 (0590)    mov [CHILD_3_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >CHILD_3_bRxCnt
                                   (0594)    mov [CHILD_3_bRxCnt], 0x00
                                   (0595)    and [CHILD_3_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: CHILD_3_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  CHILD_3_bCmdCheck:
                                   (0628) _CHILD_3_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >CHILD_3_fStatus
                                   (0631)    mov A,  [CHILD_3_fStatus]
                                   (0632)    and A, CHILD_3_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: CHILD_3_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1C70: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1C72: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1C75: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1C78: 50 38    MOV   A,56          (0648) ;     BYTE  fStatus - Status of command receive buffer.
1C7A: 02 D6    ADD   A,[CHILD+3]   (0649) ;                     Returns non-zero value in A if command is valid.
1C7C: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1C7D: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1C7F: B0 04    JNZ   0x1C84        (0653) ;           0x10 => Software Buffer OverRun
1C81: 10       PUSH  X             (0654) ;
1C82: 80 33    JMP   0x1CB6        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1C84: 39 00    CMP   A,0           (0660) ;    functions.
1C86: B0 11    JNZ   0x1C98        (0661) ;          
1C88: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1C89: 76 D6    INC   [CHILD+3]     (0663) ;          CUR_PP
1C8B: 52 00    MOV   A,[X+0]       (0664) ;
1C8D: 3C D6 0F CMP   [CHILD+3],15  (0665) ;     Error Status is clear when read.
1C90: BF F3    JNZ   0x1C84        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
1C92: 10       PUSH  X             (0669) ;
                                   (0670)  CHILD_3_bErrCheck:
1C93: 56 00 00 MOV   [X+0],0       (0671) _CHILD_3_bErrCheck:
1C96: 80 1F    JMP   0x1CB6        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >CHILD_3_fStatus
                                   (0674)    mov A,  [CHILD_3_fStatus]
1C98: 10       PUSH  X             (0675)    and A, CHILD_3_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [CHILD_3_fStatus], ~CHILD_3_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
1C99: 75       INC   X             (0679) .ENDSECTION
1C9A: 76 D6    INC   [CHILD+3]     (0680) 
1C9C: 3C D6 0F CMP   [CHILD+3],15  (0681) .SECTION
1C9F: AF F3    JZ    0x1C93        (0682) ;-----------------------------------------------------------------------------
1CA1: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: CHILD_3_bCmdLength
1CA3: A0 12    JZ    0x1CB6        (0684) ;
1CA5: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1CA7: BF F1    JNZ   0x1C99        (0686) ;     Get length of command string
                                   (0687) ;
1CA9: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
1CAC: 76 D6    INC   [CHILD+3]     (0689) ;     none.
1CAE: 3C D6 0F CMP   [CHILD+3],15  (0690) ;
1CB1: B0 04    JNZ   0x1CB6        (0691) ;  RETURNS:
1CB3: 55 D6 0F MOV   [CHILD+3],15  (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1CB6: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1CB7: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
1CB8: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1CBB: B0 0B    JNZ   0x1CC7        (0699) ;    functions.
1CBD: 20       POP   X             (0700) ;          
1CBE: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
1CC0: 50 00    MOV   A,0           (0702) ;          CUR_PP
1CC2: 70 3F    AND   F,63
1CC4: 71 C0    OR    F,192         (0703) ;
                                   (0704)  CHILD_3_bCmdLength:
1CC6: 7F       RET                 (0705) _CHILD_3_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >CHILD_3_bRxCnt
1CC7: 20       POP   X             (0708)    mov A,  [CHILD_3_bRxCnt]
1CC8: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1CCA: 70 3F    AND   F,63
1CCC: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1CCE: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: CHILD_3_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1CCF: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1CD2: 50 38    MOV   A,56          (0744) ;     each lexically distinct element into a null-terminated string by replacing
1CD4: 02 D6    ADD   A,[CHILD+3]   (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
1CD6: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
1CD7: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     CHILD_3_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, CHILD_3_szGetParam, is
1CDA: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\child_2int.asm
1CDB: 10       PUSH  X             (0104) ;;*****************************************************************************
1CDC: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: CHILD_2INT.asm
1CDE: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1CDF: 58 15    MOV   X,[21]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1CE1: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
1CE3: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1CE4: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1CE6: B0 04    JNZ   0x1CEB        (0115) 
1CE8: 18       POP   A             (0116) include "m8c.inc"
1CE9: 80 5E    JMP   0x1D48        (0117) include "memory.inc"
                                   (0118) include "CHILD_2.inc"
                                   (0119) 
                                   (0120) 
1CEB: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1CEC: 21 E0    AND   A,224         (0124) export  _CHILD_2_ISR
1CEE: A0 12    JZ    0x1D01        (0125) 
                                   (0126) 
1CF0: 2C 14    OR    [20],A        (0127) IF (CHILD_2_RXBUF_ENABLE)
                                   (0128) export  CHILD_2_aRxBuffer
1CF2: 49 2A 00 TST   REG[42],0     (0129) export _CHILD_2_aRxBuffer
                                   (0130) export  CHILD_2_bRxCnt
1CF5: 21 20    AND   A,32          (0131) export _CHILD_2_bRxCnt
1CF7: A0 50    JZ    0x1D48        (0132) export  CHILD_2_fStatus
                                   (0133) export _CHILD_2_fStatus
                                   (0134) ENDIF
                                   (0135) 
1CF9: 41 2B FE AND   REG[43],254   (0136) 
1CFC: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
1CFF: 80 48    JMP   0x1D48        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (CHILD_2_RXBUF_ENABLE)
1D01: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  CHILD_2_fStatus:
                                   (0144) _CHILD_2_fStatus:      BLK  1
1D03: 47 14 01 TST   [20],1        (0145)  CHILD_2_bRxCnt:
1D06: B0 41    JNZ   0x1D48        (0146) _CHILD_2_bRxCnt:       BLK  1
                                   (0147) AREA CHILD_2_RAM(RAM,REL,CON)
1D08: 39 00    CMP   A,0           (0148)  CHILD_2_aRxBuffer:    
1D0A: B0 14    JNZ   0x1D1F        (0149) _CHILD_2_aRxBuffer:    BLK CHILD_2_RX_BUFFER_SIZE
1D0C: 2E 14 01 OR    [20],1        (0150) ENDIF
                                   (0151) 
1D0F: 62 D3 00 MOV   REG[211],0    (0152) 
1D12: 70 3F    AND   F,63
1D14: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1D16: 56 98 00 MOV   [X-104],0     (0154) 
1D19: 70 3F    AND   F,63
1D1B: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
1D1D: 80 2A    JMP   0x1D48        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1D1F: 3C 15 0F CMP   [21],15       (0167) ;------------------------
1D22: C0 14    JC    0x1D37        (0168) 
1D24: 2E 14 10 OR    [20],16       (0169) 
                                   (0170) ;------------------------
1D27: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
1D2A: 70 3F    AND   F,63
1D2C: 71 80    OR    F,128         (0172) ;------------------------
1D2E: 56 98 00 MOV   [X-104],0     (0173) 
1D31: 70 3F    AND   F,63
1D33: 71 00    OR    F,0           (0174) 
1D35: 80 12    JMP   0x1D48        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1D37: 75       INC   X             (0179) 
1D38: 5A 15    MOV   [21],X        (0180) 
1D3A: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1D3B: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1D3E: 70 3F    AND   F,63
1D40: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _CHILD_2_ISR
1D42: 54 98    MOV   [X-104],A     (0185) ;
1D44: 70 3F    AND   F,63
1D46: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1D48: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1D49: 60 D3    MOV   REG[211],A    (0191) _CHILD_2_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1D4B: 20       POP   X             (0195)    ; Insert your custom code below this banner
1D4C: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1D4E: 43 E1 02 OR    REG[225],2    (0201)    ; Insert your custom code above this banner

FILE: lib\child_2_timeout.asm
                                   (0102) ;;*****************************************************************************
1D51: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: CHILD_2_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "CHILD_2_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
1D52: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
1D55: 7F       RET                 (0131) export  CHILD_2_TIMEOUT_EnableInt
                                   (0132) export _CHILD_2_TIMEOUT_EnableInt
                                   (0133) export  CHILD_2_TIMEOUT_DisableInt
                                   (0134) export _CHILD_2_TIMEOUT_DisableInt
                                   (0135) export  CHILD_2_TIMEOUT_Start
                                   (0136) export _CHILD_2_TIMEOUT_Start
                                   (0137) export  CHILD_2_TIMEOUT_Stop
                                   (0138) export _CHILD_2_TIMEOUT_Stop
                                   (0139) export  CHILD_2_TIMEOUT_WritePeriod
                                   (0140) export _CHILD_2_TIMEOUT_WritePeriod
                                   (0141) export  CHILD_2_TIMEOUT_WriteCompareValue
                                   (0142) export _CHILD_2_TIMEOUT_WriteCompareValue
                                   (0143) export  CHILD_2_TIMEOUT_wReadCompareValue
                                   (0144) export _CHILD_2_TIMEOUT_wReadCompareValue
                                   (0145) export  CHILD_2_TIMEOUT_wReadTimer
                                   (0146) export _CHILD_2_TIMEOUT_wReadTimer
                                   (0147) export  CHILD_2_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _CHILD_2_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wCHILD_2_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wCHILD_2_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wCHILD_2_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wCHILD_2_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wCHILD_2_TIMEOUT_ReadTimerSaveCV   ; deprecated
1D56: 43 23 01 OR    REG[35],1     (0157) export _wCHILD_2_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
1D59: 7F       RET                 (0159) export  wCHILD_2_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wCHILD_2_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wCHILD_2_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wCHILD_2_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA response2_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: CHILD_2_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
1D5A: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
1D5D: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  CHILD_2_TIMEOUT_EnableInt:
                                   (0200) _CHILD_2_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    CHILD_2_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: CHILD_2_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
1D5E: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
1D60: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
1D61: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
1D63: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  CHILD_2_TIMEOUT_DisableInt:
                                   (0228) _CHILD_2_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    CHILD_2_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: CHILD_2_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
1D64: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
1D66: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
1D67: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
1D69: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  CHILD_2_TIMEOUT_Start:
                                   (0256) _CHILD_2_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    CHILD_2_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: CHILD_2_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
1D6A: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
1D6C: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
1D6D: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
1D6F: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  CHILD_2_TIMEOUT_Stop:
                                   (0284) _CHILD_2_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    CHILD_2_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: CHILD_2_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  CHILD_2_TIMEOUT_WritePeriod:
                                   (0313) _CHILD_2_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[CHILD_2_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[CHILD_2_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: CHILD_2_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call CHILD_2_TIMEOUT_Stop to disable).
1D70: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
1D71: 38 03    ADD   SP,3          (0334) ;
1D73: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
1D75: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
1D76: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
1D78: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
1D79: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
1D7B: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
1D7C: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
1D7E: 5D 26    MOV   A,REG[38]     (0343) ;
1D80: 54 01    MOV   [X+1],A       (0344)  CHILD_2_TIMEOUT_WriteCompareValue:
1D82: 5D 22    MOV   A,REG[34]     (0345) _CHILD_2_TIMEOUT_WriteCompareValue:
1D84: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
1D86: 50 00    MOV   A,0           (0347)    mov   reg[CHILD_2_TIMEOUT_COMPARE_LSB_REG], A
1D88: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
1D8B: A0 03    JZ    0x1D8F        (0349)    mov   reg[CHILD_2_TIMEOUT_COMPARE_MSB_REG], A
1D8D: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
1D8F: 54 00    MOV   [X+0],A       (0352) 
1D91: 70 FE    AND   F,254         (0353) .ENDSECTION
1D93: 41 23 FE AND   REG[35],254   (0354) 
1D96: 18       POP   A             (0355) 
1D97: 60 26    MOV   REG[38],A     (0356) .SECTION
1D99: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
1D9A: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: CHILD_2_TIMEOUT_wReadCompareValue
1D9C: 18       POP   A             (0359) ;
1D9D: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
1D9F: 18       POP   A             (0361) ;     Reads the Compare registers.
1DA0: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
1DA1: 70 3F    AND   F,63
1DA3: 71 C0    OR    F,192         (0363) ;
1DA5: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  CHILD_2_TIMEOUT_wReadCompareValue:
                                   (0374) _CHILD_2_TIMEOUT_wReadCompareValue:
                                   (0375)  wCHILD_2_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wCHILD_2_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[CHILD_2_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[CHILD_2_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: CHILD_2_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
1DA6: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
1DA8: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
1DAA: 5C       MOV   X,A           (0409) ;
1DAB: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
1DAE: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\child_2.asm
                                   (0121) ;;*****************************************************************************
1DB1: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: CHILD_2.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "CHILD_2.inc"
1DB2: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
1DB5: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   CHILD_2_EnableInt
                                   (0155) export  _CHILD_2_EnableInt
                                   (0156) export   CHILD_2_DisableInt
                                   (0157) export  _CHILD_2_DisableInt
                                   (0158) export   CHILD_2_Start
                                   (0159) export  _CHILD_2_Start
                                   (0160) export   CHILD_2_Stop
                                   (0161) export  _CHILD_2_Stop
                                   (0162) export   CHILD_2_bReadRxData
                                   (0163) export  _CHILD_2_bReadRxData
                                   (0164) export   CHILD_2_bReadRxStatus
                                   (0165) export  _CHILD_2_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bCHILD_2_ReadRxData
                                   (0170) export _bCHILD_2_ReadRxData
                                   (0171) export  bCHILD_2_ReadRxStatus
                                   (0172) export _bCHILD_2_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  CHILD_2_cGetChar
1DB6: 29 01    OR    A,1           (0179) export _CHILD_2_cGetChar
1DB8: 60 2B    MOV   REG[43],A     (0180) export  CHILD_2_cReadChar
                                   (0181) export _CHILD_2_cReadChar
1DBA: 7F       RET                 (0182) export  CHILD_2_iReadChar
                                   (0183) export _CHILD_2_iReadChar
                                   (0184) 
                                   (0185) IF (CHILD_2_RXBUF_ENABLE)
                                   (0186) export  CHILD_2_CmdReset
                                   (0187) export _CHILD_2_CmdReset
                                   (0188) export  CHILD_2_bCmdCheck
                                   (0189) export _CHILD_2_bCmdCheck
                                   (0190) export  CHILD_2_bCmdLength
                                   (0191) export _CHILD_2_bCmdLength
                                   (0192) export  CHILD_2_bErrCheck
                                   (0193) export _CHILD_2_bErrCheck
                                   (0194) 
                                   (0195) export  CHILD_2_szGetParam
                                   (0196) export _CHILD_2_szGetParam
                                   (0197) export  CHILD_2_szGetRestOfParams
                                   (0198) export _CHILD_2_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA CHILD_2_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1DBB: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1DBE: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: CHILD_2_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  CHILD_2_EnableInt:
                                   (0238) _CHILD_2_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1DBF: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask CHILD_2_INT_REG, CHILD_2_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1DC1: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: CHILD_2_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  CHILD_2_DisableInt:
                                   (0267) _CHILD_2_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask CHILD_2_INT_REG, CHILD_2_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
1DC2: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
1DC4: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: CHILD_2_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  CHILD_2_Start:
                                   (0297) _CHILD_2_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[CHILD_2_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: CHILD_2_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1DC5: 49 2B 08 TST   REG[43],8     (0311) ;
1DC8: AF FC    JZ    0x1DC5        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1DCA: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1DCC: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  CHILD_2_Stop:
                                   (0326) _CHILD_2_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[CHILD_2_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: CHILD_2_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1DCD: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
1DCF: 08       PUSH  A             (0347) ;
1DD0: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
1DD2: B0 04    JNZ   0x1DD7        (0349) ;    The A and X registers may be modified by this or future implementations
1DD4: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1DD5: 80 0B    JMP   0x1DE1        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1DD7: 5D 2A    MOV   A,REG[42]     (0354) ;
1DD9: 4B       SWAP  A,X           (0355)  CHILD_2_bReadRxData:
                                   (0356) _CHILD_2_bReadRxData:
1DDA: 18       POP   A             (0357)  bCHILD_2_ReadRxData:
1DDB: 21 A0    AND   A,160         (0358) _bCHILD_2_ReadRxData:
1DDD: B0 03    JNZ   0x1DE1        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1DDF: 4B       SWAP  A,X           (0360)    mov A, REG[CHILD_2_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1DE0: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1DE1: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: CHILD_2_bReadRxStatus
                                   (0368) ;
1DE3: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  CHILD_2_bReadRxStatus:
                                   (0388) _CHILD_2_bReadRxStatus:
                                   (0389)  bCHILD_2_ReadRxStatus:
                                   (0390) _bCHILD_2_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[CHILD_2_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: CHILD_2_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1DE4: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1DE6: 21 E8    AND   A,232         (0408) ;
1DE8: 08       PUSH  A             (0409) ;  ARGUMENTS:
1DE9: 21 08    AND   A,8           (0410) ;      none
1DEB: B0 07    JNZ   0x1DF3        (0411) ;
1DED: 18       POP   A             (0412) ;  RETURNS:
1DEE: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1DF0: 4B       SWAP  A,X           (0414) ;
1DF1: 80 07    JMP   0x1DF9        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1DF3: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1DF4: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1DF6: 4B       SWAP  A,X           (0420) ;    functions.
1DF7: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1DF9: 7F       RET                 (0426)  CHILD_2_cGetChar:
                                   (0427) _CHILD_2_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[CHILD_2_CONTROL_REG],CHILD_2_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[CHILD_2_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: CHILD_2_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  CHILD_2_cReadChar:
                                   (0463) _CHILD_2_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[CHILD_2_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,CHILD_2_RX_COMPLETE                              ; Check if a character is ready
1DFA: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1DFD: 55 98 00 MOV   [152],0       (0470)    pop  A
1E00: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1E03: 55 D5 00 MOV   [CHILD+2],0   (0472) 
1E06: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1E09: 55 15 00 MOV   [21],0        (0474)    mov  A,REG[CHILD_2_RX_BUFFER_REG]                       ; Read data first, then
1E0C: 26 14 00 AND   [20],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1E0F: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(CHILD_2_RX_PARITY_ERROR | CHILD_2_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_CHILD_2_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: CHILD_2_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1E10: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1E13: 51 14    MOV   A,[20]        (0511) ;        0x40CC    Overrun Error
1E15: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1E17: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  CHILD_2_iReadChar:
                                   (0523) _CHILD_2_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[CHILD_2_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(CHILD_2_RX_ERROR|CHILD_2_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,CHILD_2_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,CHILD_2_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_CHILD_2_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,CHILD_2_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[CHILD_2_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_CHILD_2_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (CHILD_2_RXBUF_ENABLE)
                                   (0552) .SECTION
1E18: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1E1B: 51 14    MOV   A,[20]        (0554) ;-----------------------------------------------------------------------------
1E1D: 21 F0    AND   A,240         (0555) ;
1E1F: 26 14 0F AND   [20],15       (0556) ;     Command Buffer commands
                                   (0557) ;
1E22: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: CHILD_2_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  CHILD_2_CmdReset:
1E23: 62 D0 00 MOV   REG[208],0    (0587) _CHILD_2_CmdReset:
1E26: 51 15    MOV   A,[21]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >CHILD_2_aRxBuffer
1E28: 7F       RET                 (0590)    mov [CHILD_2_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >CHILD_2_bRxCnt
                                   (0594)    mov [CHILD_2_bRxCnt], 0x00
                                   (0595)    and [CHILD_2_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: CHILD_2_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  CHILD_2_bCmdCheck:
                                   (0628) _CHILD_2_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >CHILD_2_fStatus
                                   (0631)    mov A,  [CHILD_2_fStatus]
                                   (0632)    and A, CHILD_2_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: CHILD_2_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1E29: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1E2B: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1E2E: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1E31: 50 98    MOV   A,152         (0648) ;     BYTE  fStatus - Status of command receive buffer.
1E33: 02 D5    ADD   A,[CHILD+2]   (0649) ;                     Returns non-zero value in A if command is valid.
1E35: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1E36: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1E38: B0 04    JNZ   0x1E3D        (0653) ;           0x10 => Software Buffer OverRun
1E3A: 10       PUSH  X             (0654) ;
1E3B: 80 33    JMP   0x1E6F        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1E3D: 39 00    CMP   A,0           (0660) ;    functions.
1E3F: B0 11    JNZ   0x1E51        (0661) ;          
1E41: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1E42: 76 D5    INC   [CHILD+2]     (0663) ;          CUR_PP
1E44: 52 00    MOV   A,[X+0]       (0664) ;
1E46: 3C D5 0F CMP   [CHILD+2],15  (0665) ;     Error Status is clear when read.
1E49: BF F3    JNZ   0x1E3D        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
1E4B: 10       PUSH  X             (0669) ;
                                   (0670)  CHILD_2_bErrCheck:
1E4C: 56 00 00 MOV   [X+0],0       (0671) _CHILD_2_bErrCheck:
1E4F: 80 1F    JMP   0x1E6F        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >CHILD_2_fStatus
                                   (0674)    mov A,  [CHILD_2_fStatus]
1E51: 10       PUSH  X             (0675)    and A, CHILD_2_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [CHILD_2_fStatus], ~CHILD_2_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
1E52: 75       INC   X             (0679) .ENDSECTION
1E53: 76 D5    INC   [CHILD+2]     (0680) 
1E55: 3C D5 0F CMP   [CHILD+2],15  (0681) .SECTION
1E58: AF F3    JZ    0x1E4C        (0682) ;-----------------------------------------------------------------------------
1E5A: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: CHILD_2_bCmdLength
1E5C: A0 12    JZ    0x1E6F        (0684) ;
1E5E: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1E60: BF F1    JNZ   0x1E52        (0686) ;     Get length of command string
                                   (0687) ;
1E62: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
1E65: 76 D5    INC   [CHILD+2]     (0689) ;     none.
1E67: 3C D5 0F CMP   [CHILD+2],15  (0690) ;
1E6A: B0 04    JNZ   0x1E6F        (0691) ;  RETURNS:
1E6C: 55 D5 0F MOV   [CHILD+2],15  (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1E6F: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1E70: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
1E71: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1E74: B0 0B    JNZ   0x1E80        (0699) ;    functions.
1E76: 20       POP   X             (0700) ;          
1E77: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
1E79: 50 00    MOV   A,0           (0702) ;          CUR_PP
1E7B: 70 3F    AND   F,63
1E7D: 71 C0    OR    F,192         (0703) ;
                                   (0704)  CHILD_2_bCmdLength:
1E7F: 7F       RET                 (0705) _CHILD_2_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >CHILD_2_bRxCnt
1E80: 20       POP   X             (0708)    mov A,  [CHILD_2_bRxCnt]
1E81: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1E83: 70 3F    AND   F,63
1E85: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1E87: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: CHILD_2_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1E88: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1E8B: 50 98    MOV   A,152         (0744) ;     each lexically distinct element into a null-terminated string by replacing
1E8D: 02 D5    ADD   A,[CHILD+2]   (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
1E8F: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
1E90: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     CHILD_2_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, CHILD_2_szGetParam, is
1E93: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\child_1int.asm
1E94: 10       PUSH  X             (0104) ;;*****************************************************************************
1E95: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: CHILD_1INT.asm
1E97: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1E98: 58 17    MOV   X,[23]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1E9A: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
1E9C: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1E9D: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1E9F: B0 04    JNZ   0x1EA4        (0115) 
1EA1: 18       POP   A             (0116) include "m8c.inc"
1EA2: 80 5E    JMP   0x1F01        (0117) include "memory.inc"
                                   (0118) include "CHILD_1.inc"
                                   (0119) 
                                   (0120) 
1EA4: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1EA5: 21 E0    AND   A,224         (0124) export  _CHILD_1_ISR
1EA7: A0 12    JZ    0x1EBA        (0125) 
                                   (0126) 
1EA9: 2C 16    OR    [22],A        (0127) IF (CHILD_1_RXBUF_ENABLE)
                                   (0128) export  CHILD_1_aRxBuffer
1EAB: 49 2A 00 TST   REG[42],0     (0129) export _CHILD_1_aRxBuffer
                                   (0130) export  CHILD_1_bRxCnt
1EAE: 21 20    AND   A,32          (0131) export _CHILD_1_bRxCnt
1EB0: A0 50    JZ    0x1F01        (0132) export  CHILD_1_fStatus
                                   (0133) export _CHILD_1_fStatus
                                   (0134) ENDIF
                                   (0135) 
1EB2: 41 2B FE AND   REG[43],254   (0136) 
1EB5: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
1EB8: 80 48    JMP   0x1F01        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (CHILD_1_RXBUF_ENABLE)
1EBA: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  CHILD_1_fStatus:
                                   (0144) _CHILD_1_fStatus:      BLK  1
1EBC: 47 16 01 TST   [22],1        (0145)  CHILD_1_bRxCnt:
1EBF: B0 41    JNZ   0x1F01        (0146) _CHILD_1_bRxCnt:       BLK  1
                                   (0147) AREA CHILD_1_RAM(RAM,REL,CON)
1EC1: 39 00    CMP   A,0           (0148)  CHILD_1_aRxBuffer:    
1EC3: B0 14    JNZ   0x1ED8        (0149) _CHILD_1_aRxBuffer:    BLK CHILD_1_RX_BUFFER_SIZE
1EC5: 2E 16 01 OR    [22],1        (0150) ENDIF
                                   (0151) 
1EC8: 62 D3 00 MOV   REG[211],0    (0152) 
1ECB: 70 3F    AND   F,63
1ECD: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1ECF: 56 A8 00 MOV   [X-88],0      (0154) 
1ED2: 70 3F    AND   F,63
1ED4: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
1ED6: 80 2A    JMP   0x1F01        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1ED8: 3C 17 0F CMP   [23],15       (0167) ;------------------------
1EDB: C0 14    JC    0x1EF0        (0168) 
1EDD: 2E 16 10 OR    [22],16       (0169) 
                                   (0170) ;------------------------
1EE0: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
1EE3: 70 3F    AND   F,63
1EE5: 71 80    OR    F,128         (0172) ;------------------------
1EE7: 56 A8 00 MOV   [X-88],0      (0173) 
1EEA: 70 3F    AND   F,63
1EEC: 71 00    OR    F,0           (0174) 
1EEE: 80 12    JMP   0x1F01        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1EF0: 75       INC   X             (0179) 
1EF1: 5A 17    MOV   [23],X        (0180) 
1EF3: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1EF4: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1EF7: 70 3F    AND   F,63
1EF9: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _CHILD_1_ISR
1EFB: 54 A8    MOV   [X-88],A      (0185) ;
1EFD: 70 3F    AND   F,63
1EFF: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1F01: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1F02: 60 D3    MOV   REG[211],A    (0191) _CHILD_1_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1F04: 20       POP   X             (0195)    ; Insert your custom code below this banner
1F05: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1F07: 43 E1 02 OR    REG[225],2    (0201)    ; Insert your custom code above this banner

FILE: lib\child_1_timeout.asm
                                   (0102) ;;*****************************************************************************
1F0A: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: CHILD_1_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "CHILD_1_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
1F0B: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
1F0E: 7F       RET                 (0131) export  CHILD_1_TIMEOUT_EnableInt
                                   (0132) export _CHILD_1_TIMEOUT_EnableInt
                                   (0133) export  CHILD_1_TIMEOUT_DisableInt
                                   (0134) export _CHILD_1_TIMEOUT_DisableInt
                                   (0135) export  CHILD_1_TIMEOUT_Start
                                   (0136) export _CHILD_1_TIMEOUT_Start
                                   (0137) export  CHILD_1_TIMEOUT_Stop
                                   (0138) export _CHILD_1_TIMEOUT_Stop
                                   (0139) export  CHILD_1_TIMEOUT_WritePeriod
                                   (0140) export _CHILD_1_TIMEOUT_WritePeriod
                                   (0141) export  CHILD_1_TIMEOUT_WriteCompareValue
                                   (0142) export _CHILD_1_TIMEOUT_WriteCompareValue
                                   (0143) export  CHILD_1_TIMEOUT_wReadCompareValue
                                   (0144) export _CHILD_1_TIMEOUT_wReadCompareValue
                                   (0145) export  CHILD_1_TIMEOUT_wReadTimer
                                   (0146) export _CHILD_1_TIMEOUT_wReadTimer
                                   (0147) export  CHILD_1_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _CHILD_1_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wCHILD_1_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wCHILD_1_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wCHILD_1_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wCHILD_1_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wCHILD_1_TIMEOUT_ReadTimerSaveCV   ; deprecated
1F0F: 43 23 01 OR    REG[35],1     (0157) export _wCHILD_1_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
1F12: 7F       RET                 (0159) export  wCHILD_1_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wCHILD_1_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wCHILD_1_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wCHILD_1_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA response1_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: CHILD_1_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
1F13: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
1F16: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  CHILD_1_TIMEOUT_EnableInt:
                                   (0200) _CHILD_1_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    CHILD_1_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: CHILD_1_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
1F17: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
1F19: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
1F1A: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
1F1C: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  CHILD_1_TIMEOUT_DisableInt:
                                   (0228) _CHILD_1_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    CHILD_1_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: CHILD_1_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
1F1D: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
1F1F: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
1F20: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
1F22: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  CHILD_1_TIMEOUT_Start:
                                   (0256) _CHILD_1_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    CHILD_1_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: CHILD_1_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
1F23: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
1F25: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
1F26: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
1F28: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  CHILD_1_TIMEOUT_Stop:
                                   (0284) _CHILD_1_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    CHILD_1_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: CHILD_1_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  CHILD_1_TIMEOUT_WritePeriod:
                                   (0313) _CHILD_1_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[CHILD_1_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[CHILD_1_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: CHILD_1_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call CHILD_1_TIMEOUT_Stop to disable).
1F29: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
1F2A: 38 03    ADD   SP,3          (0334) ;
1F2C: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
1F2E: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
1F2F: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
1F31: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
1F32: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
1F34: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
1F35: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
1F37: 5D 26    MOV   A,REG[38]     (0343) ;
1F39: 54 01    MOV   [X+1],A       (0344)  CHILD_1_TIMEOUT_WriteCompareValue:
1F3B: 5D 22    MOV   A,REG[34]     (0345) _CHILD_1_TIMEOUT_WriteCompareValue:
1F3D: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
1F3F: 50 00    MOV   A,0           (0347)    mov   reg[CHILD_1_TIMEOUT_COMPARE_LSB_REG], A
1F41: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
1F44: A0 03    JZ    0x1F48        (0349)    mov   reg[CHILD_1_TIMEOUT_COMPARE_MSB_REG], A
1F46: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
1F48: 54 00    MOV   [X+0],A       (0352) 
1F4A: 70 FE    AND   F,254         (0353) .ENDSECTION
1F4C: 41 23 FE AND   REG[35],254   (0354) 
1F4F: 18       POP   A             (0355) 
1F50: 60 26    MOV   REG[38],A     (0356) .SECTION
1F52: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
1F53: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: CHILD_1_TIMEOUT_wReadCompareValue
1F55: 18       POP   A             (0359) ;
1F56: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
1F58: 18       POP   A             (0361) ;     Reads the Compare registers.
1F59: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
1F5A: 70 3F    AND   F,63
1F5C: 71 C0    OR    F,192         (0363) ;
1F5E: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  CHILD_1_TIMEOUT_wReadCompareValue:
                                   (0374) _CHILD_1_TIMEOUT_wReadCompareValue:
                                   (0375)  wCHILD_1_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wCHILD_1_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[CHILD_1_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[CHILD_1_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: CHILD_1_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
1F5F: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
1F61: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
1F63: 5C       MOV   X,A           (0409) ;
1F64: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
1F67: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\child_1.asm
                                   (0121) ;;*****************************************************************************
1F6A: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: CHILD_1.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "CHILD_1.inc"
1F6B: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
1F6E: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   CHILD_1_EnableInt
                                   (0155) export  _CHILD_1_EnableInt
                                   (0156) export   CHILD_1_DisableInt
                                   (0157) export  _CHILD_1_DisableInt
                                   (0158) export   CHILD_1_Start
                                   (0159) export  _CHILD_1_Start
                                   (0160) export   CHILD_1_Stop
                                   (0161) export  _CHILD_1_Stop
                                   (0162) export   CHILD_1_bReadRxData
                                   (0163) export  _CHILD_1_bReadRxData
                                   (0164) export   CHILD_1_bReadRxStatus
                                   (0165) export  _CHILD_1_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bCHILD_1_ReadRxData
                                   (0170) export _bCHILD_1_ReadRxData
                                   (0171) export  bCHILD_1_ReadRxStatus
                                   (0172) export _bCHILD_1_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  CHILD_1_cGetChar
1F6F: 29 01    OR    A,1           (0179) export _CHILD_1_cGetChar
1F71: 60 2B    MOV   REG[43],A     (0180) export  CHILD_1_cReadChar
                                   (0181) export _CHILD_1_cReadChar
1F73: 7F       RET                 (0182) export  CHILD_1_iReadChar
                                   (0183) export _CHILD_1_iReadChar
                                   (0184) 
                                   (0185) IF (CHILD_1_RXBUF_ENABLE)
                                   (0186) export  CHILD_1_CmdReset
                                   (0187) export _CHILD_1_CmdReset
                                   (0188) export  CHILD_1_bCmdCheck
                                   (0189) export _CHILD_1_bCmdCheck
                                   (0190) export  CHILD_1_bCmdLength
                                   (0191) export _CHILD_1_bCmdLength
                                   (0192) export  CHILD_1_bErrCheck
                                   (0193) export _CHILD_1_bErrCheck
                                   (0194) 
                                   (0195) export  CHILD_1_szGetParam
                                   (0196) export _CHILD_1_szGetParam
                                   (0197) export  CHILD_1_szGetRestOfParams
                                   (0198) export _CHILD_1_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA CHILD_1_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1F74: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1F77: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: CHILD_1_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  CHILD_1_EnableInt:
                                   (0238) _CHILD_1_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1F78: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask CHILD_1_INT_REG, CHILD_1_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1F7A: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: CHILD_1_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  CHILD_1_DisableInt:
                                   (0267) _CHILD_1_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask CHILD_1_INT_REG, CHILD_1_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
1F7B: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
1F7D: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: CHILD_1_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  CHILD_1_Start:
                                   (0297) _CHILD_1_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[CHILD_1_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: CHILD_1_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1F7E: 49 2B 08 TST   REG[43],8     (0311) ;
1F81: AF FC    JZ    0x1F7E        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1F83: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1F85: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  CHILD_1_Stop:
                                   (0326) _CHILD_1_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[CHILD_1_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: CHILD_1_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1F86: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
1F88: 08       PUSH  A             (0347) ;
1F89: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
1F8B: B0 04    JNZ   0x1F90        (0349) ;    The A and X registers may be modified by this or future implementations
1F8D: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1F8E: 80 0B    JMP   0x1F9A        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1F90: 5D 2A    MOV   A,REG[42]     (0354) ;
1F92: 4B       SWAP  A,X           (0355)  CHILD_1_bReadRxData:
                                   (0356) _CHILD_1_bReadRxData:
1F93: 18       POP   A             (0357)  bCHILD_1_ReadRxData:
1F94: 21 A0    AND   A,160         (0358) _bCHILD_1_ReadRxData:
1F96: B0 03    JNZ   0x1F9A        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1F98: 4B       SWAP  A,X           (0360)    mov A, REG[CHILD_1_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1F99: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1F9A: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: CHILD_1_bReadRxStatus
                                   (0368) ;
1F9C: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  CHILD_1_bReadRxStatus:
                                   (0388) _CHILD_1_bReadRxStatus:
                                   (0389)  bCHILD_1_ReadRxStatus:
                                   (0390) _bCHILD_1_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[CHILD_1_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: CHILD_1_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1F9D: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1F9F: 21 E8    AND   A,232         (0408) ;
1FA1: 08       PUSH  A             (0409) ;  ARGUMENTS:
1FA2: 21 08    AND   A,8           (0410) ;      none
1FA4: B0 07    JNZ   0x1FAC        (0411) ;
1FA6: 18       POP   A             (0412) ;  RETURNS:
1FA7: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1FA9: 4B       SWAP  A,X           (0414) ;
1FAA: 80 07    JMP   0x1FB2        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1FAC: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1FAD: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1FAF: 4B       SWAP  A,X           (0420) ;    functions.
1FB0: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1FB2: 7F       RET                 (0426)  CHILD_1_cGetChar:
                                   (0427) _CHILD_1_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[CHILD_1_CONTROL_REG],CHILD_1_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[CHILD_1_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: CHILD_1_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  CHILD_1_cReadChar:
                                   (0463) _CHILD_1_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[CHILD_1_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,CHILD_1_RX_COMPLETE                              ; Check if a character is ready
1FB3: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1FB6: 55 A8 00 MOV   [168],0       (0470)    pop  A
1FB9: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1FBC: 55 D4 00 MOV   [CHILD+1],0   (0472) 
1FBF: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1FC2: 55 17 00 MOV   [23],0        (0474)    mov  A,REG[CHILD_1_RX_BUFFER_REG]                       ; Read data first, then
1FC5: 26 16 00 AND   [22],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1FC8: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(CHILD_1_RX_PARITY_ERROR | CHILD_1_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_CHILD_1_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: CHILD_1_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1FC9: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1FCC: 51 16    MOV   A,[22]        (0511) ;        0x40CC    Overrun Error
1FCE: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1FD0: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  CHILD_1_iReadChar:
                                   (0523) _CHILD_1_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[CHILD_1_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(CHILD_1_RX_ERROR|CHILD_1_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,CHILD_1_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,CHILD_1_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_CHILD_1_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,CHILD_1_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[CHILD_1_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_CHILD_1_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (CHILD_1_RXBUF_ENABLE)
                                   (0552) .SECTION
1FD1: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1FD4: 51 16    MOV   A,[22]        (0554) ;-----------------------------------------------------------------------------
1FD6: 21 F0    AND   A,240         (0555) ;
1FD8: 26 16 0F AND   [22],15       (0556) ;     Command Buffer commands
                                   (0557) ;
1FDB: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: CHILD_1_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  CHILD_1_CmdReset:
1FDC: 62 D0 00 MOV   REG[208],0    (0587) _CHILD_1_CmdReset:
1FDF: 51 17    MOV   A,[23]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >CHILD_1_aRxBuffer
1FE1: 7F       RET                 (0590)    mov [CHILD_1_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >CHILD_1_bRxCnt
                                   (0594)    mov [CHILD_1_bRxCnt], 0x00
                                   (0595)    and [CHILD_1_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: CHILD_1_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  CHILD_1_bCmdCheck:
                                   (0628) _CHILD_1_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >CHILD_1_fStatus
                                   (0631)    mov A,  [CHILD_1_fStatus]
                                   (0632)    and A, CHILD_1_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: CHILD_1_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1FE2: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1FE4: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1FE7: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1FEA: 50 A8    MOV   A,168         (0648) ;     BYTE  fStatus - Status of command receive buffer.
1FEC: 02 D4    ADD   A,[CHILD+1]   (0649) ;                     Returns non-zero value in A if command is valid.
1FEE: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1FEF: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1FF1: B0 04    JNZ   0x1FF6        (0653) ;           0x10 => Software Buffer OverRun
1FF3: 10       PUSH  X             (0654) ;
1FF4: 80 33    JMP   0x2028        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1FF6: 39 00    CMP   A,0           (0660) ;    functions.
1FF8: B0 11    JNZ   0x200A        (0661) ;          
1FFA: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1FFB: 76 D4    INC   [CHILD+1]     (0663) ;          CUR_PP
1FFD: 52 00    MOV   A,[X+0]       (0664) ;
1FFF: 3C D4 0F CMP   [CHILD+1],15  (0665) ;     Error Status is clear when read.
2002: BF F3    JNZ   0x1FF6        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
2004: 10       PUSH  X             (0669) ;
                                   (0670)  CHILD_1_bErrCheck:
2005: 56 00 00 MOV   [X+0],0       (0671) _CHILD_1_bErrCheck:
2008: 80 1F    JMP   0x2028        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >CHILD_1_fStatus
                                   (0674)    mov A,  [CHILD_1_fStatus]
200A: 10       PUSH  X             (0675)    and A, CHILD_1_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [CHILD_1_fStatus], ~CHILD_1_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
200B: 75       INC   X             (0679) .ENDSECTION
200C: 76 D4    INC   [CHILD+1]     (0680) 
200E: 3C D4 0F CMP   [CHILD+1],15  (0681) .SECTION
2011: AF F3    JZ    0x2005        (0682) ;-----------------------------------------------------------------------------
2013: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: CHILD_1_bCmdLength
2015: A0 12    JZ    0x2028        (0684) ;
2017: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
2019: BF F1    JNZ   0x200B        (0686) ;     Get length of command string
                                   (0687) ;
201B: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
201E: 76 D4    INC   [CHILD+1]     (0689) ;     none.
2020: 3C D4 0F CMP   [CHILD+1],15  (0690) ;
2023: B0 04    JNZ   0x2028        (0691) ;  RETURNS:
2025: 55 D4 0F MOV   [CHILD+1],15  (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
2028: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
2029: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
202A: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
202D: B0 0B    JNZ   0x2039        (0699) ;    functions.
202F: 20       POP   X             (0700) ;          
2030: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
2032: 50 00    MOV   A,0           (0702) ;          CUR_PP
2034: 70 3F    AND   F,63
2036: 71 C0    OR    F,192         (0703) ;
                                   (0704)  CHILD_1_bCmdLength:
2038: 7F       RET                 (0705) _CHILD_1_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >CHILD_1_bRxCnt
2039: 20       POP   X             (0708)    mov A,  [CHILD_1_bRxCnt]
203A: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
203C: 70 3F    AND   F,63
203E: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
2040: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: CHILD_1_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
2041: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
2044: 50 A8    MOV   A,168         (0744) ;     each lexically distinct element into a null-terminated string by replacing
2046: 02 D4    ADD   A,[CHILD+1]   (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
2048: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
2049: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     CHILD_1_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, CHILD_1_szGetParam, is
_main:
__text_start:
204C: 62 D0 00 MOV   REG[208],0    (0750) ;     not called until the buffer has been loaded with an entire command
204F: 55 D3 00 MOV   [CHILD],0

FILE: C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
(0158) // Author: Jason Tennyson
2052: 62 D0 00 MOV   REG[208],0
2055: 55 CE 00 MOV   [CONFIGURED+1],0
2058: 55 CD 00 MOV   [CONFIGURED],0
(0159) // Date: 1-25-11
205B: 62 D0 00 MOV   REG[208],0
205E: 55 D2 00 MOV   [TIMEOUT+1],0
2061: 55 D1 00 MOV   [TIMEOUT],0
(0160) // File: main.c
2064: 62 D0 00 MOV   REG[208],0
2067: 55 E0 00 MOV   [COMMAND_PARAM],0
(0161) //
206A: 62 D0 00 MOV   REG[208],0
206D: 55 D0 00 MOV   [STATE+1],0
2070: 55 CF 00 MOV   [STATE],0
(0162) // This is the design for the revolute modules for Jason Tennyson's Thesis.
2073: 62 D0 00 MOV   REG[208],0
2076: 55 E4 FB MOV   [ID],251
(0163) // This design is made for a PSoC CY8C28433-24PVXI.
(0164) //
2079: 71 01    OR    F,1
(0165) // Packet Structure
(0166) // ----------------
207B: 43 E0 20 OR    REG[224],32
(0167) // START BYTE/START BYTE/SOURCE ID BYTE/DESTINATION ID BYTE/COMMAND TYPE/PARAM 1/.../PARAM N/END TRANSMIT
(0168) 
(0169) #include <m8c.h>        	// Part-specific constants and macros.
207E: 7C 2F AC LCALL _servoBootWait
(0170) #include "PSoCAPI.h"    	// PSoC API definitions for all User Modules.
(0171) #include "psocdynamic.h"	// Required for dynamically swapping configurations at run time.
(0172) 
2081: 7C 2C E1 LCALL _servoFinder
2084: 80 12    JMP   0x2097
(0173) // These are declarations of all of the timer interrupts that are used for all configurations.
(0174) #pragma interrupt_handler WAIT_NC_TIMEOUT_ISR
(0175) #pragma interrupt_handler TX_01234_TIMEOUT_ISR
(0176) #pragma interrupt_handler CHILD_1_TIMEOUT_ISR
(0177) #pragma interrupt_handler CHILD_2_TIMEOUT_ISR
2086: 92 82    CALL  _commandReady
2088: 62 D0 00 MOV   REG[208],0
208B: 3C CC 00 CMP   [__r0],0
208E: B0 06    JNZ   0x2095
2090: 3C CB 00 CMP   [__r1],0
2093: A0 03    JZ    0x2097
(0178) #pragma interrupt_handler CHILD_3_TIMEOUT_ISR
(0179) #pragma interrupt_handler CHILD_4_TIMEOUT_ISR
(0180) #pragma interrupt_handler HELLO_TIMEOUT_ISR
2095: 96 55    CALL  _takeAction
2097: 8F EE    JMP   0x2086
2099: 8F FF    JMP   0x2099
(0181) #pragma interrupt_handler INIT_TIMEOUT_ISR
(0182) 
(0183) // These defines are used as parameters of the configToggle function.  Passing one of
(0184) // these identifiers to configToggle will put the chip in that device configuration.
(0185) #define		WAIT						(1)
(0186) #define		MY_RESPONSE					(2)
(0187) #define 	RESPONSE_1					(3)
(0188) #define 	RESPONSE_2					(4)
_sayHello:
209B: 50 00    MOV   A,0
209D: 08       PUSH  A
209E: 50 02    MOV   A,2
20A0: 08       PUSH  A
20A1: 90 5D    CALL  _configToggle
20A3: 38 FE    ADD   SP,254
(0189) #define 	RESPONSE_3					(5)
(0190) #define 	RESPONSE_4					(6)
(0191) #define		HELLO_MODE					(7)
20A5: 10       PUSH  X
20A6: 50 FC    MOV   A,252
20A8: 7C 0E D4 LCALL 0x0ED4
20AB: 20       POP   X
(0192) #define		INITIALIZE					(8)
20AC: 10       PUSH  X
20AD: 50 FC    MOV   A,252
20AF: 7C 0E D4 LCALL 0x0ED4
20B2: 20       POP   X
(0193) #define		SERVO_COMM					(9)
20B3: 10       PUSH  X
20B4: 62 D0 00 MOV   REG[208],0
20B7: 51 E4    MOV   A,[ID]
20B9: 7C 0E D4 LCALL 0x0ED4
20BC: 20       POP   X
(0194) 
20BD: 10       PUSH  X
20BE: 50 00    MOV   A,0
20C0: 7C 0E D4 LCALL 0x0ED4
20C3: 20       POP   X
(0195) // These defines are used as comparisons to find what port the next module connected to.
20C4: 10       PUSH  X
20C5: 50 C8    MOV   A,200
20C7: 7C 0E D4 LCALL 0x0ED4
20CA: 20       POP   X
(0196) #define		PORT_A						('A')
20CB: 10       PUSH  X
20CC: 62 D0 00 MOV   REG[208],0
20CF: 51 D3    MOV   A,[CHILD]
20D1: 7C 0E D4 LCALL 0x0ED4
20D4: 20       POP   X
(0197) #define		PORT_B						('B')
20D5: 10       PUSH  X
20D6: 50 FD    MOV   A,253
20D8: 7C 0E D4 LCALL 0x0ED4
20DB: 20       POP   X
(0198) #define		PORT_C						('C')
20DC: 10       PUSH  X
20DD: 50 FD    MOV   A,253
20DF: 7C 0E D4 LCALL 0x0ED4
20E2: 20       POP   X
(0199) #define		PORT_D						('D')
(0200) 
(0201) // These defines are used as transmission indicators for transmissions between PSoC controllers.
20E3: 10       PUSH  X
20E4: 7C 0E A7 LCALL 0x0EA7
20E7: 62 D0 00 MOV   REG[208],0
20EA: 20       POP   X
20EB: 53 CC    MOV   [__r0],A
20ED: 47 CC 20 TST   [__r0],32
20F0: AF F2    JZ    0x20E3
(0202) #define		START_TRANSMIT				(252)	// Indicates the beginning of a transmission.
(0203) #define		END_TRANSMIT				(253)	// Indicates the end of a transmission.
(0204) #define		HELLO_BYTE					(200)	// Indicates master is ready to talk.
20F2: 7C 2F 8D LCALL _xmitWait
(0205) #define		ID_ASSIGNMENT				(201)	// Indicates an ID assignment from the master.
(0206) #define		ID_ASSIGN_OK				(202)	// Indicates an ID assignment is complete.
20F5: 50 00    MOV   A,0
20F7: 08       PUSH  A
20F8: 50 01    MOV   A,1
20FA: 08       PUSH  A
20FB: 90 03    CALL  _configToggle
20FD: 38 FE    ADD   SP,254
20FF: 7F       RET   
(0207) #define		PING						(203)	// Indicates a ping message to or from the master.
(0208) #define		CLEAR_CONFIG				(204)	// Indicates that the master is asking for a config clear.
(0209) #define		CONFIG_CLEARED				(205)	// Indicates that a module has cleared its own config.
(0210) #define		MASTER_ID					(0)		// The master node's ID.
(0211) #define		DEFAULT_ID					(251)	// The ID that all modules start with.
(0212) #define		BROADCAST					(254)	// The broadcast ID for all controllers and servos.
_configToggle:
  mode                 --> X-5
2100: 10       PUSH  X
2101: 4F       MOV   X,SP
(0213) 
(0214) // SERVO DEFINES
(0215) // These numbers can all be found in the AX-12+ datasheet.
2102: 43 00 1F OR    REG[0],31
(0216) // These defines cover the range of IDs these servos are capable of.
2105: 41 02 E0 AND   REG[2],224
(0217) #define		SERVO_ID_MIN				(0)		// This is the lowest servo ID possible.
(0218) #define		SERVO_ID_MAX				(253)	// This is the highest servo ID possible.
(0219) // These defines are servo transmission indicators.
(0220) #define		SERVO_START					(255)	// This is the start byte for a servo transmission.
2108: 62 D0 00 MOV   REG[208],0
210B: 3C CF 00 CMP   [STATE],0
210E: B0 06    JNZ   0x2115
2110: 3C D0 00 CMP   [STATE+1],0
2113: A0 11    JZ    0x2125
(0221) // These defines are used to fill in the length parameter for a given command type.  These are the only
(0222) // lengths used by this controller for servo configuration purposes.  It is worth noting that any type
2115: 62 D0 00 MOV   REG[208],0
2118: 51 CF    MOV   A,[STATE]
211A: 08       PUSH  A
211B: 51 D0    MOV   A,[STATE+1]
211D: 08       PUSH  A
211E: 7C 2A 79 LCALL _unloadConfig
2121: 38 FE    ADD   SP,254
(0223) // and length of command can be issued from the master after configuration is complete.
2123: 80 04    JMP   0x2128
(0224) #define		READ_LENGTH					(4)		// This is the length value for all reads.
(0225) #define		WRITE_LENGTH				(4)		// This is the length value for all writes.
(0226) #define		PING_LENGTH					(2)		// This is the length value for a ping.
2125: 7C 2A 5D LCALL _unloadAllConfigs
(0227) #define		RESET_LENGTH				(2)		// This is the length value for a reset.
(0228) // These defines are used to fill in the servo's EEPROM address parameter for a given command type.
(0229) #define		ID_ADDRESS					(3)		// This is the address where servo ID is stored.
(0230) #define		STATUS_RET_ADDRESS			(16)	// This is where the status return level is stored.
(0231) // These defines are used to fill in the instruction we are using on the servo.
2128: 3D FB 00 CMP   [X-5],0
212B: B0 22    JNZ   0x214E
212D: 3D FC 01 CMP   [X-4],1
2130: B0 1D    JNZ   0x214E
(0232) #define		PING_SERVO					(1)		// This is the instruction number for ping.
(0233) #define		READ_SERVO					(2)		// This is the instruction number for a read.
(0234) #define		WRITE_SERVO					(3)		// This is the instruction number for a write.
(0235) #define		RESET_SERVO					(6)		// This is the instruction to reset the servo EEPROM.
2132: 7C 06 A2 LCALL 0x06A2
(0236) // These defines cover all of the status return level possibilities.
(0237) #define		STATUS_RET_NEVER			(0)		// Only respond to ping commands.
(0238) #define		STATUS_RET_READ				(1)		// Only respond to read data commands (recommended).
2135: 10       PUSH  X
2136: 50 00    MOV   A,0
2138: 7C 0C CA LCALL 0x0CCA
213B: 20       POP   X
(0239) #define		STATUS_RET_ALL				(2)		// Respond to every command.
213C: 10       PUSH  X
213D: 50 00    MOV   A,0
213F: 7C 11 0E LCALL 0x110E
2142: 20       POP   X
(0240) 
(0241) // This is the number of attempts we make to contact the servo per sweep of attempts before
(0242) // writing to its EEPROM in an attempt to alter settings that keep us from communicating.
2143: 62 D0 00 MOV   REG[208],0
2146: 55 D0 01 MOV   [STATE+1],1
2149: 55 CF 00 MOV   [STATE],0
(0243) #define		SERVO_COMM_ATTEMPTS			(10)
214C: 81 A0    JMP   0x22ED
(0244) // This is the number of times we do a loop of SERVO_COMM_ATTEMPTS.  We would like this to be at least 2.
214E: 3D FB 00 CMP   [X-5],0
2151: B0 4C    JNZ   0x219E
2153: 3D FC 02 CMP   [X-4],2
2156: B0 47    JNZ   0x219E
(0245) // This is because we do an EEPROM write after the first unsuccessful loop of SERVO_COMM_ATTEMPTS.
(0246) // If we don't then do at least one more loop, the EEPROM write was done for no reason.
(0247) #define		SERVO_COMM_LOOPS			(2)
2158: 7C 08 46 LCALL 0x0846
(0248) // This is the number of timeout periods to wait through while the servo boots up (2 ms per period).
(0249) #define		SERVO_BOOT_TIMEOUTS			(75)
(0250) 
215B: 62 D0 00 MOV   REG[208],0
215E: 55 D2 00 MOV   [TIMEOUT+1],0
2161: 55 D1 00 MOV   [TIMEOUT],0
(0251) // This is the number of iterations we loop waiting for bytes to reset the timeout on a child response.
(0252) // This will be the amount of iterations we do after the last byte has been received as well.
(0253) #define		RESPONSE_ITERATIONS			(10)
2164: 10       PUSH  X
2165: 50 00    MOV   A,0
2167: 7C 0E 9B LCALL 0x0E9B
216A: 20       POP   X
(0254) 
216B: 10       PUSH  X
216C: 50 00    MOV   A,0
216E: 7C 0D C2 LCALL 0x0DC2
(0255) // This is the status return level, which is set to one of the possible status return values above.
(0256) // We want the status return level to be return on read commands only so that we don't have garbage
2171: 7C 0F 59 LCALL 0x0F59
(0257) // return packets flying around every time we tell the servo to move.
2174: 7C 0F 61 LCALL 0x0F61
2177: 20       POP   X
(0258) #define		STATUS_RET_LEVEL			(STATUS_RET_READ)
(0259) 
(0260) // This function receives a mode identifier as a parameter and toggles the system configuration.
(0261) void configToggle(int mode);
2178: 62 D0 00 MOV   REG[208],0
217B: 3C D1 00 CMP   [TIMEOUT],0
217E: B0 06    JNZ   0x2185
2180: 3C D2 00 CMP   [TIMEOUT+1],0
2183: AF F4    JZ    0x2178
(0262) // This function unloads all configurations.  This should only be needed at startup.
(0263) void unloadAllConfigs(void);
2185: 10       PUSH  X
2186: 7C 0F 65 LCALL 0x0F65
2189: 20       POP   X
(0264) // This function unloads the configuration corresponding to the number passed to it.
218A: 62 D0 00 MOV   REG[208],0
218D: 55 D2 00 MOV   [TIMEOUT+1],0
2190: 55 D1 00 MOV   [TIMEOUT],0
(0265) void unloadConfig(int config_num);
(0266) // This function is a response to the master sending out a hello message.
(0267) void sayHello(void);
2193: 62 D0 00 MOV   REG[208],0
2196: 55 D0 02 MOV   [STATE+1],2
2199: 55 CF 00 MOV   [STATE],0
(0268) // This function looks for commands and returns 1 if a command has been read, 0 if not.
219C: 81 50    JMP   0x22ED
(0269) int commandReady(void);
219E: 3D FB 00 CMP   [X-5],0
21A1: B0 2A    JNZ   0x21CC
21A3: 3D FC 03 CMP   [X-4],3
21A6: B0 25    JNZ   0x21CC
(0270) // This function interprets the command that has just been read and performs an action accordingly.
(0271) void takeAction(void);
(0272) // This function responds to a ping.
21A8: 7C 08 AD LCALL 0x08AD
(0273) void pingResponse(void);
(0274) // This function tells the master node that an ID assignment was completed on this module.
(0275) void assignedID(void);
21AB: 62 D0 00 MOV   REG[208],0
21AE: 55 D2 00 MOV   [TIMEOUT+1],0
21B1: 55 D1 00 MOV   [TIMEOUT],0
(0276) // This function sends out an acknowledgement of a configuration reset.
(0277) void configCleared(void);
(0278) // This function listens for children and registers the port that they talk to.
21B4: 10       PUSH  X
21B5: 50 00    MOV   A,0
21B7: 7C 1F 6F LCALL 0x1F6F
(0279) int childListen(void);
(0280) // This function waits for a known child's response to a command to that child from the master.
21BA: 7C 1F 07 LCALL 0x1F07
(0281) int childResponse(void);
21BD: 7C 1F 0F LCALL 0x1F0F
21C0: 20       POP   X
(0282) // This function does everything it can to find the servo attached to this controller.
(0283) void servoFinder(void);
(0284) // This function carries out the passed servo instruction.
21C1: 62 D0 00 MOV   REG[208],0
21C4: 55 D0 03 MOV   [STATE+1],3
21C7: 55 CF 00 MOV   [STATE],0
(0285) void servoInstruction(char id, char length, char instruction, char address, char value);
21CA: 81 22    JMP   0x22ED
(0286) // This function does a simple for loop to stall and make doubly sure that the transmission finished.
21CC: 3D FB 00 CMP   [X-5],0
21CF: B0 2A    JNZ   0x21FA
21D1: 3D FC 04 CMP   [X-4],4
21D4: B0 25    JNZ   0x21FA
(0287) // It is meant to be used as a definite amount of wait time after the transmission complete flag is set.
(0288) void xmitWait(void);
(0289) // This function is called to do nothing while we wait for the servo to boot up.
21D6: 7C 09 50 LCALL 0x0950
(0290) void servoBootWait(void);
(0291) // This function is used to wait for other controllers to find their servos while not
(0292) // driving any pins (which would keep a child from talking to its servo).
21D9: 62 D0 00 MOV   REG[208],0
21DC: 55 D2 00 MOV   [TIMEOUT+1],0
21DF: 55 D1 00 MOV   [TIMEOUT],0
(0293) void servoConfigWait(void);
(0294) 
(0295) char CHILD;		// Keeps track of where the child is connected.
21E2: 10       PUSH  X
21E3: 50 00    MOV   A,0
21E5: 7C 1D B6 LCALL 0x1DB6
(0296) char ID;		// Stores the ID that the master gives this module.
(0297) 
21E8: 7C 1D 4E LCALL 0x1D4E
(0298) int CONFIGURED;	// Keeps track of whether or not this module has been configured by the master.
21EB: 7C 1D 56 LCALL 0x1D56
21EE: 20       POP   X
(0299) int TIMEOUT;	// This flag is set if a timeout occurs.
(0300) int STATE;		// This stores the ID of the currently-loaded configuration.
(0301) 
21EF: 62 D0 00 MOV   REG[208],0
21F2: 55 D0 04 MOV   [STATE+1],4
21F5: 55 CF 00 MOV   [STATE],0
(0302) char COMMAND_SOURCE;		// Stores who the current command is from.
21F8: 80 F4    JMP   0x22ED
(0303) char COMMAND_DESTINATION;	// Stores who the current command is for.
21FA: 3D FB 00 CMP   [X-5],0
21FD: B0 2A    JNZ   0x2228
21FF: 3D FC 05 CMP   [X-4],5
2202: B0 25    JNZ   0x2228
(0304) char COMMAND_TYPE;			// Stores the type of command that was just read.
(0305) char COMMAND_PARAM;			// Stores a parameter that accompanies the command (if any).
(0306) char COMMAND_LENGTH;		// Stores the length parameter of a servo command.
2204: 7C 09 F3 LCALL 0x09F3
(0307) char COMMAND_ERROR;			// Stores the error code of a servo command.
(0308) 
(0309) char SERVO_ID;				// Stores the ID of the servo inside of this module.
2207: 62 D0 00 MOV   REG[208],0
220A: 55 D2 00 MOV   [TIMEOUT+1],0
220D: 55 D1 00 MOV   [TIMEOUT],0
(0310) 
(0311) void main()
(0312) {	
2210: 10       PUSH  X
2211: 50 00    MOV   A,0
2213: 7C 1B FD LCALL 0x1BFD
(0313) 	// Initial value assignment for variables of importance.
(0314) 	CHILD = 0;				// There is no child yet.
2216: 7C 1B 95 LCALL 0x1B95
(0315) 	CONFIGURED = 0;			// This module is not configured yet.
2219: 7C 1B 9D LCALL 0x1B9D
221C: 20       POP   X
(0316) 	TIMEOUT = 0;			// Set the timeout flag low to start.
(0317) 	COMMAND_PARAM = 0;		// There is no parameter yet.
(0318) 	STATE = 0;				// There is no state yet.
221D: 62 D0 00 MOV   REG[208],0
2220: 55 D0 05 MOV   [STATE+1],5
2223: 55 CF 00 MOV   [STATE],0
(0319) 	ID = DEFAULT_ID;		// Set the ID of this controller to the default to start with.
2226: 80 C6    JMP   0x22ED
(0320) 
2228: 3D FB 00 CMP   [X-5],0
222B: B0 2A    JNZ   0x2256
222D: 3D FC 06 CMP   [X-4],6
2230: B0 25    JNZ   0x2256
(0321) 	M8C_EnableGInt;			// Turn on global interrupts for the transmission timeout timer.
(0322) 	
(0323) 	M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); // Activate GPIO ISR
2232: 7C 0A 96 LCALL 0x0A96
(0324) 	
(0325) 	// We have to wait for the servo to power up and get ready for communications.
(0326) 	servoBootWait();
2235: 62 D0 00 MOV   REG[208],0
2238: 55 D2 00 MOV   [TIMEOUT+1],0
223B: 55 D1 00 MOV   [TIMEOUT],0
(0327) 	
(0328) 	// Find the servo that is inside of this module.
(0329) 	servoFinder();
223E: 10       PUSH  X
223F: 50 00    MOV   A,0
2241: 7C 1A 44 LCALL 0x1A44
(0330) 	
(0331) 	// Loop and wait for commands.
2244: 7C 19 DC LCALL 0x19DC
(0332) 	while(1)
2247: 7C 19 E4 LCALL 0x19E4
224A: 20       POP   X
(0333) 	{	
(0334) 		if(commandReady())
(0335) 		{
224B: 62 D0 00 MOV   REG[208],0
224E: 55 D0 06 MOV   [STATE+1],6
2251: 55 CF 00 MOV   [STATE],0
(0336) 			// If the command is ready, take action.
2254: 80 98    JMP   0x22ED
(0337) 			takeAction();
2256: 3D FB 00 CMP   [X-5],0
2259: B0 3F    JNZ   0x2299
225B: 3D FC 07 CMP   [X-4],7
225E: B0 3A    JNZ   0x2299
(0338) 		}
(0339) 	}
(0340) }
2260: 7C 07 09 LCALL 0x0709
(0341) 
(0342) // This function transmits a response to a hello command from the master.
(0343) void sayHello(void)
2263: 62 D0 00 MOV   REG[208],0
2266: 55 D2 00 MOV   [TIMEOUT+1],0
2269: 55 D1 00 MOV   [TIMEOUT],0
(0344) {	
(0345) 	configToggle(MY_RESPONSE);		// Switch to response mode.
(0346) 	
(0347) 	// Transmit a hello response to the master node.
(0348) 	TX_014_PutChar(START_TRANSMIT);	// Start byte one
(0349) 	TX_014_PutChar(START_TRANSMIT);	// Start byte two
226C: 10       PUSH  X
226D: 50 00    MOV   A,0
226F: 7C 18 8B LCALL 0x188B
2272: 20       POP   X
(0350) 	TX_014_PutChar(ID);				// My ID (source)
(0351) 	TX_014_PutChar(MASTER_ID);		// Master ID (destination)
(0352) 	TX_014_PutChar(HELLO_BYTE);		// This is a hello command.
(0353) 	TX_014_PutChar(CHILD);			// Sends child port value, default 0.
(0354) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission.
2273: 10       PUSH  X
2274: 50 00    MOV   A,0
2276: 7C 17 32 LCALL 0x1732
2279: 20       POP   X
(0355) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission.
(0356) 	
(0357) 	// Wait for the transmission to finish.
(0358) 	while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
(0359) 	
227A: 10       PUSH  X
227B: 50 00    MOV   A,0
227D: 7C 15 D9 LCALL 0x15D9
2280: 20       POP   X
(0360) 	// Make completely sure we're done.
(0361) 	xmitWait();
(0362) 
(0363) 	configToggle(WAIT);				// Switch back to wait mode.
(0364) }
2281: 10       PUSH  X
2282: 50 00    MOV   A,0
2284: 7C 14 80 LCALL 0x1480
(0365) 
(0366) // This function receives a mode flag and switches the microcontroller to the
(0367) // desired hardware configuration.
2287: 7C 13 A4 LCALL 0x13A4
(0368) void configToggle(int mode)
228A: 7C 13 AC LCALL 0x13AC
228D: 20       POP   X
(0369) {	
(0370) 	// Set the pins high and disconnect from the global bus.
(0371) 	// This keeps false start bits from happening while we swap configs.
228E: 62 D0 00 MOV   REG[208],0
2291: 55 D0 07 MOV   [STATE+1],7
2294: 55 CF 00 MOV   [STATE],0
(0372) 	PRT0DR |= 0b00011111;	// Set pins P00 through P04 high.
2297: 80 55    JMP   0x22ED
(0373) 	PRT0GS &= 0b11100000;	// Disconnect pins P00 through P04 from the global bus.
2299: 3D FB 00 CMP   [X-5],0
229C: B0 2A    JNZ   0x22C7
229E: 3D FC 08 CMP   [X-4],8
22A1: B0 25    JNZ   0x22C7
(0374) 	
(0375) 	// Unload the configuration of the current state.
(0376) 	// If there is no state, blindly wipe all configurations.
22A3: 7C 07 AC LCALL 0x07AC
(0377) 	if(STATE)
(0378) 	{
(0379) 		unloadConfig(STATE);
22A6: 62 D0 00 MOV   REG[208],0
22A9: 55 D2 00 MOV   [TIMEOUT+1],0
22AC: 55 D1 00 MOV   [TIMEOUT],0
(0380) 	}
(0381) 	else
(0382) 	{
22AF: 10       PUSH  X
22B0: 50 00    MOV   A,0
22B2: 7C 12 C7 LCALL 0x12C7
(0383) 		unloadAllConfigs();
(0384) 	}
22B5: 7C 11 EB LCALL 0x11EB
(0385) 	
22B8: 7C 11 F3 LCALL 0x11F3
22BB: 20       POP   X
(0386) 	// Go through the list of possible modes until we find the one that was passed in to us.
(0387) 	// Then, load that configuration and initialize whatever needs to be initialized.
(0388) 	if(mode == WAIT)
22BC: 62 D0 00 MOV   REG[208],0
22BF: 55 D0 08 MOV   [STATE+1],8
22C2: 55 CF 00 MOV   [STATE],0
(0389) 	{
22C5: 80 27    JMP   0x22ED
(0390) 		// Load the wait receiver configuration.  This is the receiver configuration used after
22C7: 3D FB 00 CMP   [X-5],0
22CA: B0 22    JNZ   0x22ED
22CC: 3D FC 09 CMP   [X-4],9
22CF: B0 1D    JNZ   0x22ED
(0391) 		// initialization is complete.  It listens and forwards everything it hears.
(0392) 		LoadConfig_waiting();
(0393) 		
22D1: 7C 0B 42 LCALL 0x0B42
(0394) 		// Start the receivers.
(0395) 		WAIT_RECV_Start(WAIT_RECV_PARITY_NONE);
(0396) 		RX8_2_Start(RX8_2_PARITY_NONE);
22D4: 62 D0 00 MOV   REG[208],0
22D7: 55 D2 00 MOV   [TIMEOUT+1],0
22DA: 55 D1 00 MOV   [TIMEOUT],0
(0397) 		
(0398) 		// Set the current state.
(0399) 		STATE = WAIT;
22DD: 10       PUSH  X
22DE: 50 00    MOV   A,0
22E0: 7C 0F D4 LCALL 0x0FD4
22E3: 20       POP   X
(0400) 	}
(0401) 	else if(mode == MY_RESPONSE)
(0402) 	{
22E4: 62 D0 00 MOV   REG[208],0
22E7: 55 D0 09 MOV   [STATE+1],9
22EA: 55 CF 00 MOV   [STATE],0
(0403) 		// Load the transmitter configuration.  This is for transmitting messages on all ports.
(0404) 		LoadConfig_my_response();
(0405) 		
(0406) 		// Clear the timeout flag.
22ED: 62 D0 00 MOV   REG[208],0
22F0: 3C CD 00 CMP   [CONFIGURED],0
22F3: B0 06    JNZ   0x22FA
22F5: 3C CE 00 CMP   [CONFIGURED+1],0
22F8: A0 09    JZ    0x2302
(0407) 		TIMEOUT = 0;
(0408) 		
22FA: 43 02 1F OR    REG[2],31
(0409) 		// Start the transmitters.
22FD: 41 08 FE AND   REG[8],254
(0410) 		TX_014_Start(TX_014_PARITY_NONE);	// Transmits on P00, P01, and P04.
2300: 80 07    JMP   0x2308
(0411) 		TX_23_Start(TX_23_PARITY_NONE);		// Transmits on P02 and P03.
(0412) 		
(0413) 		TX_01234_TIMEOUT_EnableInt();		// Make sure interrupts are enabled.
2302: 43 02 01 OR    REG[2],1
(0414) 		TX_01234_TIMEOUT_Start();			// Start the timer.
2305: 43 08 01 OR    REG[8],1
(0415) 		
2308: 20       POP   X
2309: 7F       RET   
(0416) 		// Do nothing while we wait for one timeout period (1 ms).
(0417) 		// This is to allow everyone to get in the right configuration before talking.
(0418) 		while(!TIMEOUT) { }
(0419) 		
(0420) 		TX_01234_TIMEOUT_Stop();			// Stop the timer.
(0421) 		TIMEOUT = 0;						// Reset the timeout flag.
(0422) 	
_commandReady:
  i                    --> X+1
  tempByte             --> X+0
230A: 10       PUSH  X
230B: 4F       MOV   X,SP
230C: 38 03    ADD   SP,3
(0423) 		// Set the current state.
230E: 56 02 00 MOV   [X+2],0
2311: 56 01 00 MOV   [X+1],0
(0424) 		STATE = MY_RESPONSE;
2314: 56 00 00 MOV   [X+0],0
(0425) 	}
(0426) 	else if(mode == RESPONSE_1)
(0427) 	{
(0428) 		// Load the response wait on port 1.
2317: 62 D0 00 MOV   REG[208],0
231A: 3C CF 00 CMP   [STATE],0
231D: B0 D4    JNZ   0x23F2
231F: 3C D0 01 CMP   [STATE+1],1
2322: B0 CF    JNZ   0x23F2
(0429) 		LoadConfig_response1();
(0430) 		
(0431) 		// Clear the timeout flag.
(0432) 		TIMEOUT = 0;
2324: 10       PUSH  X
2325: 7C 0C D9 LCALL 0x0CD9
2328: 62 D0 00 MOV   REG[208],0
232B: 20       POP   X
232C: 54 00    MOV   [X+0],A
(0433) 		
(0434) 		// Start listening for a response through child port 1.
(0435) 		CHILD_1_Start(CHILD_1_PARITY_NONE);
232E: 3D 00 FC CMP   [X+0],252
2331: B0 47    JNZ   0x2379
(0436) 		
2333: 80 0B    JMP   0x233F
(0437) 		CHILD_1_TIMEOUT_EnableInt();		// Make sure interrupts are enabled.
(0438) 		CHILD_1_TIMEOUT_Start();			// Start the timer.
(0439) 		
(0440) 		// Set the current state.
2335: 10       PUSH  X
2336: 7C 0C D9 LCALL 0x0CD9
2339: 62 D0 00 MOV   REG[208],0
233C: 20       POP   X
233D: 54 00    MOV   [X+0],A
233F: 3D 00 FC CMP   [X+0],252
2342: AF F2    JZ    0x2335
(0441) 		STATE = RESPONSE_1;
(0442) 	}
(0443) 	else if(mode == RESPONSE_2)
(0444) 	{
2344: 3D 00 00 CMP   [X+0],0
2347: B3 97    JNZ   0x26DF
(0445) 		// Load the response wait on port 2.
(0446) 		LoadConfig_response2();
2349: 52 00    MOV   A,[X+0]
234B: 62 D0 00 MOV   REG[208],0
234E: 53 E3    MOV   [COMMAND_SOURCE],A
(0447) 		
2350: 10       PUSH  X
2351: 7C 0C D9 LCALL 0x0CD9
2354: 20       POP   X
2355: 62 D0 00 MOV   REG[208],0
2358: 53 E2    MOV   [COMMAND_DESTINATION],A
(0448) 		// Clear the timeout flag.
235A: 10       PUSH  X
235B: 7C 0C D9 LCALL 0x0CD9
235E: 20       POP   X
235F: 62 D0 00 MOV   REG[208],0
2362: 53 E1    MOV   [COMMAND_TYPE],A
(0449) 		TIMEOUT = 0;
2364: 10       PUSH  X
2365: 7C 0C D9 LCALL 0x0CD9
2368: 20       POP   X
2369: 62 D0 00 MOV   REG[208],0
236C: 53 E0    MOV   [COMMAND_PARAM],A
(0450) 		
(0451) 		// Start listening for a response through child port 2.
236E: 62 D0 00 MOV   REG[208],0
2371: 55 CB 01 MOV   [__r1],1
2374: 55 CC 00 MOV   [__r0],0
2377: 83 70    JMP   0x26E8
(0452) 		CHILD_2_Start(CHILD_2_PARITY_NONE);
(0453) 		
(0454) 		CHILD_2_TIMEOUT_EnableInt();		// Make sure interrupts are enabled.
2379: 3D 00 FF CMP   [X+0],255
237C: B3 62    JNZ   0x26DF
(0455) 		CHILD_2_TIMEOUT_Start();			// Start the timer.
237E: 80 0B    JMP   0x238A
(0456) 		
(0457) 		// Set the current state.
(0458) 		STATE = RESPONSE_2;
(0459) 	}
2380: 10       PUSH  X
2381: 7C 0C D9 LCALL 0x0CD9
2384: 62 D0 00 MOV   REG[208],0
2387: 20       POP   X
2388: 54 00    MOV   [X+0],A
238A: 3D 00 FF CMP   [X+0],255
238D: AF F2    JZ    0x2380
(0460) 	else if(mode == RESPONSE_3)
(0461) 	{
(0462) 		// Load the response wait on port 3.
(0463) 		LoadConfig_response3();
238F: 62 D0 00 MOV   REG[208],0
2392: 55 E3 00 MOV   [COMMAND_SOURCE],0
(0464) 		
(0465) 		// Clear the timeout flag.
2395: 52 00    MOV   A,[X+0]
2397: 62 D0 00 MOV   REG[208],0
239A: 53 E2    MOV   [COMMAND_DESTINATION],A
(0466) 		TIMEOUT = 0;
(0467) 		
(0468) 		// Start listening for a response through child port 3.
(0469) 		CHILD_3_Start(CHILD_3_PARITY_NONE);
(0470) 		
239C: 10       PUSH  X
239D: 7C 0C D9 LCALL 0x0CD9
23A0: 62 D0 00 MOV   REG[208],0
23A3: 20       POP   X
23A4: 54 00    MOV   [X+0],A
(0471) 		CHILD_3_TIMEOUT_EnableInt();		// Make sure interrupts are enabled.
(0472) 		CHILD_3_TIMEOUT_Start();			// Start the timer.
(0473) 		
23A6: 10       PUSH  X
23A7: 7C 0C D9 LCALL 0x0CD9
23AA: 20       POP   X
23AB: 62 D0 00 MOV   REG[208],0
23AE: 53 E1    MOV   [COMMAND_TYPE],A
(0474) 		// Set the current state.
(0475) 		STATE = RESPONSE_3;
(0476) 	}
23B0: 56 02 00 MOV   [X+2],0
23B3: 56 01 00 MOV   [X+1],0
23B6: 80 0E    JMP   0x23C5
(0477) 	else if(mode == RESPONSE_4)
(0478) 	{
23B8: 10       PUSH  X
23B9: 7C 0C D9 LCALL 0x0CD9
23BC: 62 D0 00 MOV   REG[208],0
23BF: 20       POP   X
23C0: 77 02    INC   [X+2]
23C2: 0F 01 00 ADC   [X+1],0
23C5: 62 D0 00 MOV   REG[208],0
23C8: 52 00    MOV   A,[X+0]
23CA: 53 CB    MOV   [__r1],A
23CC: 55 CC 00 MOV   [__r0],0
23CF: 16 CB 01 SUB   [__r1],1
23D2: 1E CC 00 SBB   [__r0],0
23D5: 52 02    MOV   A,[X+2]
23D7: 12 CB    SUB   A,[__r1]
23D9: 51 CC    MOV   A,[__r0]
23DB: 31 80    XOR   A,128
23DD: 53 CA    MOV   [__rX],A
23DF: 52 01    MOV   A,[X+1]
23E1: 31 80    XOR   A,128
23E3: 1A CA    SBB   A,[__rX]
23E5: CF D2    JC    0x23B8
(0479) 		// Load the response wait on port 4.
(0480) 		LoadConfig_response4();
(0481) 		
23E7: 62 D0 00 MOV   REG[208],0
23EA: 55 CB 01 MOV   [__r1],1
23ED: 55 CC 00 MOV   [__r0],0
23F0: 82 F7    JMP   0x26E8
(0482) 		// Clear the timeout flag.
(0483) 		TIMEOUT = 0;
(0484) 		
23F2: 62 D0 00 MOV   REG[208],0
23F5: 3C CF 00 CMP   [STATE],0
23F8: B0 6E    JNZ   0x2467
23FA: 3C D0 07 CMP   [STATE+1],7
23FD: B0 69    JNZ   0x2467
(0485) 		// Start listening for a response through child port 4.
(0486) 		CHILD_4_Start(CHILD_4_PARITY_NONE);
(0487) 		
23FF: 10       PUSH  X
2400: 7C 18 A2 LCALL 0x18A2
2403: 20       POP   X
2404: 39 FC    CMP   A,252
2406: B0 12    JNZ   0x2419
(0488) 		CHILD_4_TIMEOUT_EnableInt();		// Make sure interrupts are enabled.
(0489) 		CHILD_4_TIMEOUT_Start();			// Start the timer.
2408: 62 D0 00 MOV   REG[208],0
240B: 55 D3 41 MOV   [CHILD],65
(0490) 		
(0491) 		// Set the current state.
240E: 62 D0 00 MOV   REG[208],0
2411: 55 CB 01 MOV   [__r1],1
2414: 55 CC 00 MOV   [__r0],0
2417: 82 D0    JMP   0x26E8
(0492) 		STATE = RESPONSE_4;
(0493) 	}
2419: 10       PUSH  X
241A: 7C 17 49 LCALL 0x1749
241D: 20       POP   X
241E: 39 FC    CMP   A,252
2420: B0 12    JNZ   0x2433
(0494) 	else if(mode == HELLO_MODE)
(0495) 	{
2422: 62 D0 00 MOV   REG[208],0
2425: 55 D3 42 MOV   [CHILD],66
(0496) 		// Load the hello wait mode.  This is for listening on all ports for a hello response.
(0497) 		LoadConfig_hello();
2428: 62 D0 00 MOV   REG[208],0
242B: 55 CB 01 MOV   [__r1],1
242E: 55 CC 00 MOV   [__r0],0
2431: 82 B6    JMP   0x26E8
(0498) 		
(0499) 		// Clear the timeout flag.
2433: 10       PUSH  X
2434: 7C 15 F0 LCALL 0x15F0
2437: 20       POP   X
2438: 39 FC    CMP   A,252
243A: B0 12    JNZ   0x244D
(0500) 		TIMEOUT = 0;
(0501) 		
243C: 62 D0 00 MOV   REG[208],0
243F: 55 D3 43 MOV   [CHILD],67
(0502) 		// The seemingly unnecessary brackets around each line are unfortunately needed.
(0503) 	
2442: 62 D0 00 MOV   REG[208],0
2445: 55 CB 01 MOV   [__r1],1
2448: 55 CC 00 MOV   [__r0],0
244B: 82 9C    JMP   0x26E8
(0504) 		{
(0505) 		// Start listening for a response through child port 1.
244D: 10       PUSH  X
244E: 7C 14 97 LCALL 0x1497
2451: 20       POP   X
2452: 39 FC    CMP   A,252
2454: B2 8A    JNZ   0x26DF
(0506) 		HELLO_1_Start(HELLO_1_PARITY_NONE);
(0507) 		}
2456: 62 D0 00 MOV   REG[208],0
2459: 55 D3 44 MOV   [CHILD],68
(0508) 		
(0509) 		{
245C: 62 D0 00 MOV   REG[208],0
245F: 55 CB 01 MOV   [__r1],1
2462: 55 CC 00 MOV   [__r0],0
2465: 82 82    JMP   0x26E8
(0510) 		// Start listening for a response through child port 2.
(0511) 		HELLO_2_Start(HELLO_2_PARITY_NONE);
(0512) 		}
2467: 62 D0 00 MOV   REG[208],0
246A: 3C CF 00 CMP   [STATE],0
246D: B0 81    JNZ   0x24EF
246F: 3C D0 03 CMP   [STATE+1],3
2472: B0 7C    JNZ   0x24EF
(0513) 		
(0514) 		{
2474: 10       PUSH  X
2475: 7C 1F 86 LCALL 0x1F86
2478: 62 D0 00 MOV   REG[208],0
247B: 20       POP   X
247C: 54 00    MOV   [X+0],A
247E: 39 00    CMP   A,0
2480: A2 5E    JZ    0x26DF
(0515) 		// Start listening for a response through child port 3.
(0516) 		HELLO_3_Start(HELLO_3_PARITY_NONE);
2482: 3D 00 FF CMP   [X+0],255
2485: B0 50    JNZ   0x24D6
(0517) 		}
(0518) 		
(0519) 		{
2487: 10       PUSH  X
2488: 7C 1F 7E LCALL 0x1F7E
248B: 62 D0 00 MOV   REG[208],0
248E: 20       POP   X
248F: 39 FF    CMP   A,255
2491: AF F5    JZ    0x2487
(0520) 		// Start listening for a response through child port 4.
(0521) 		HELLO_4_Start(HELLO_4_PARITY_NONE);
(0522) 		}
2493: 10       PUSH  X
2494: 7C 1F 7E LCALL 0x1F7E
2497: 62 D0 00 MOV   REG[208],0
249A: 20       POP   X
249B: 54 00    MOV   [X+0],A
(0523) 		
(0524) 		HELLO_TIMEOUT_EnableInt();	// Make sure interrupts are enabled.
(0525) 		HELLO_TIMEOUT_Start();		// Start the timer.
249D: 56 02 00 MOV   [X+2],0
24A0: 56 01 00 MOV   [X+1],0
24A3: 80 0E    JMP   0x24B2
(0526) 		
(0527) 		// Set the current state.
24A5: 10       PUSH  X
24A6: 7C 1F 7E LCALL 0x1F7E
24A9: 62 D0 00 MOV   REG[208],0
24AC: 20       POP   X
24AD: 77 02    INC   [X+2]
24AF: 0F 01 00 ADC   [X+1],0
24B2: 62 D0 00 MOV   REG[208],0
24B5: 52 00    MOV   A,[X+0]
24B7: 53 CB    MOV   [__r1],A
24B9: 52 02    MOV   A,[X+2]
24BB: 12 CB    SUB   A,[__r1]
24BD: 50 00    MOV   A,0
24BF: 31 80    XOR   A,128
24C1: 53 CA    MOV   [__rX],A
24C3: 52 01    MOV   A,[X+1]
24C5: 31 80    XOR   A,128
24C7: 1A CA    SBB   A,[__rX]
24C9: CF DB    JC    0x24A5
(0528) 		STATE = HELLO_MODE;
(0529) 	}
(0530) 	else if(mode == INITIALIZE)
24CB: 62 D0 00 MOV   REG[208],0
24CE: 55 CB 01 MOV   [__r1],1
24D1: 55 CC 00 MOV   [__r0],0
24D4: 82 13    JMP   0x26E8
(0531) 	{
(0532) 		// Load the configuration for initialization.  This config listens but does not forward.
24D6: 3D 00 FC CMP   [X+0],252
24D9: B2 05    JNZ   0x26DF
(0533) 		LoadConfig_initial();
(0534) 		
(0535) 		// Clear the timeout flag.
24DB: 10       PUSH  X
24DC: 7C 1F 7E LCALL 0x1F7E
24DF: 62 D0 00 MOV   REG[208],0
24E2: 20       POP   X
24E3: 39 FD    CMP   A,253
24E5: BF F5    JNZ   0x24DB
(0536) 		TIMEOUT = 0;
(0537) 		
24E7: 55 CB 01 MOV   [__r1],1
24EA: 55 CC 00 MOV   [__r0],0
24ED: 81 FA    JMP   0x26E8
(0538) 		// Start the receiver.
(0539) 		INIT_RX_Start(INIT_RX_PARITY_NONE);
(0540) 		
(0541) 		INIT_TIMEOUT_EnableInt();	// Make sure interrupts are enabled.
24EF: 62 D0 00 MOV   REG[208],0
24F2: 3C CF 00 CMP   [STATE],0
24F5: B0 81    JNZ   0x2577
24F7: 3C D0 04 CMP   [STATE+1],4
24FA: B0 7C    JNZ   0x2577
(0542) 		INIT_TIMEOUT_Start();		// Start the timer.
(0543) 		
24FC: 10       PUSH  X
24FD: 7C 1D CD LCALL 0x1DCD
2500: 62 D0 00 MOV   REG[208],0
2503: 20       POP   X
2504: 54 00    MOV   [X+0],A
2506: 39 00    CMP   A,0
2508: A1 D6    JZ    0x26DF
(0544) 		// Set the current state.
(0545) 		STATE = INITIALIZE;
250A: 3D 00 FF CMP   [X+0],255
250D: B0 50    JNZ   0x255E
(0546) 	}
(0547) 	else if(mode == SERVO_COMM)
(0548) 	{
250F: 10       PUSH  X
2510: 7C 1D C5 LCALL 0x1DC5
2513: 62 D0 00 MOV   REG[208],0
2516: 20       POP   X
2517: 39 FF    CMP   A,255
2519: AF F5    JZ    0x250F
(0549) 		// Load the configuration for servo communication.  This config only transmits on P00.
(0550) 		LoadConfig_servo_transmit();
(0551) 		
251B: 10       PUSH  X
251C: 7C 1D C5 LCALL 0x1DC5
251F: 62 D0 00 MOV   REG[208],0
2522: 20       POP   X
2523: 54 00    MOV   [X+0],A
(0552) 		// Clear the timeout flag.
(0553) 		TIMEOUT = 0;
(0554) 		
2525: 56 02 00 MOV   [X+2],0
2528: 56 01 00 MOV   [X+1],0
252B: 80 0E    JMP   0x253A
(0555) 		// Start the transmitter.
(0556) 		SERVO_TX_Start(SERVO_TX_PARITY_NONE);
252D: 10       PUSH  X
252E: 7C 1D C5 LCALL 0x1DC5
2531: 62 D0 00 MOV   REG[208],0
2534: 20       POP   X
2535: 77 02    INC   [X+2]
2537: 0F 01 00 ADC   [X+1],0
253A: 62 D0 00 MOV   REG[208],0
253D: 52 00    MOV   A,[X+0]
253F: 53 CB    MOV   [__r1],A
2541: 52 02    MOV   A,[X+2]
2543: 12 CB    SUB   A,[__r1]
2545: 50 00    MOV   A,0
2547: 31 80    XOR   A,128
2549: 53 CA    MOV   [__rX],A
254B: 52 01    MOV   A,[X+1]
254D: 31 80    XOR   A,128
254F: 1A CA    SBB   A,[__rX]
2551: CF DB    JC    0x252D
(0557) 	
(0558) 		// Set the current state.
(0559) 		STATE = SERVO_COMM;
2553: 62 D0 00 MOV   REG[208],0
2556: 55 CB 01 MOV   [__r1],1
2559: 55 CC 00 MOV   [__r0],0
255C: 81 8B    JMP   0x26E8
(0560) 	}
(0561) 	
255E: 3D 00 FC CMP   [X+0],252
2561: B1 7D    JNZ   0x26DF
(0562) 	// If this module is configured, talk on all pins for potential children.
(0563) 	if(CONFIGURED)
(0564) 	{
2563: 10       PUSH  X
2564: 7C 1D C5 LCALL 0x1DC5
2567: 62 D0 00 MOV   REG[208],0
256A: 20       POP   X
256B: 39 FD    CMP   A,253
256D: BF F5    JNZ   0x2563
(0565) 		PRT0GS |= 0b00011111;	// Connect all pins to the global bus.
(0566) 		PRT2DR &= 0b11111110;	// Turn on the LED (active low).
256F: 55 CB 01 MOV   [__r1],1
2572: 55 CC 00 MOV   [__r0],0
2575: 81 72    JMP   0x26E8
(0567) 	}
(0568) 	else
(0569) 	{
(0570) 		PRT0GS |= 0b00000001;	// Just connect pin 0;
2577: 62 D0 00 MOV   REG[208],0
257A: 3C CF 00 CMP   [STATE],0
257D: B0 81    JNZ   0x25FF
257F: 3C D0 05 CMP   [STATE+1],5
2582: B0 7C    JNZ   0x25FF
(0571) 		PRT2DR |= 0b00000001;	// Turn off the LED (active low).
(0572) 	}
2584: 10       PUSH  X
2585: 7C 1C 14 LCALL 0x1C14
2588: 62 D0 00 MOV   REG[208],0
258B: 20       POP   X
258C: 54 00    MOV   [X+0],A
258E: 39 00    CMP   A,0
2590: A1 4E    JZ    0x26DF
(0573) }
(0574) 
2592: 3D 00 FF CMP   [X+0],255
2595: B0 50    JNZ   0x25E6
(0575) // This function tries to peek and see if a start byte has been written to the bus.
(0576) // If there is no start byte, the function exits.  If a start byte is detected, the function
(0577) // blocks and waits for the transmission to finish.
2597: 10       PUSH  X
2598: 7C 1C 0C LCALL 0x1C0C
259B: 62 D0 00 MOV   REG[208],0
259E: 20       POP   X
259F: 39 FF    CMP   A,255
25A1: AF F5    JZ    0x2597
(0578) int commandReady(void)
(0579) {
(0580) 	int i = 0;			// This integer is used for looping through the remaining bytes of commands.
25A3: 10       PUSH  X
25A4: 7C 1C 0C LCALL 0x1C0C
25A7: 62 D0 00 MOV   REG[208],0
25AA: 20       POP   X
25AB: 54 00    MOV   [X+0],A
(0581) 	char tempByte = 0;	// This byte is used to store each byte for comparison as it comes in.
(0582) 	
(0583) 	// This conditional checks which configuration is loaded and uses the proper devices to
25AD: 56 02 00 MOV   [X+2],0
25B0: 56 01 00 MOV   [X+1],0
25B3: 80 0E    JMP   0x25C2
(0584) 	// read a transmission and store the important information from that transmission.
(0585) 	if(STATE == WAIT)
25B5: 10       PUSH  X
25B6: 7C 1C 0C LCALL 0x1C0C
25B9: 62 D0 00 MOV   REG[208],0
25BC: 20       POP   X
25BD: 77 02    INC   [X+2]
25BF: 0F 01 00 ADC   [X+1],0
25C2: 62 D0 00 MOV   REG[208],0
25C5: 52 00    MOV   A,[X+0]
25C7: 53 CB    MOV   [__r1],A
25C9: 52 02    MOV   A,[X+2]
25CB: 12 CB    SUB   A,[__r1]
25CD: 50 00    MOV   A,0
25CF: 31 80    XOR   A,128
25D1: 53 CA    MOV   [__rX],A
25D3: 52 01    MOV   A,[X+1]
25D5: 31 80    XOR   A,128
25D7: 1A CA    SBB   A,[__rX]
25D9: CF DB    JC    0x25B5
(0586) 	{	
(0587) 		// In wait mode, the only thing that progresses things forward is a master node transmission.
(0588) 		// With this being the case, we use a blocking operation to sit and wait for a byte.
25DB: 62 D0 00 MOV   REG[208],0
25DE: 55 CB 01 MOV   [__r1],1
25E1: 55 CC 00 MOV   [__r0],0
25E4: 81 03    JMP   0x26E8
(0589) 		tempByte = WAIT_RECV_cGetChar();
(0590) 		
25E6: 3D 00 FC CMP   [X+0],252
25E9: B0 F5    JNZ   0x26DF
(0591) 		// If a transmission has started for either a controller or a servo...
(0592) 		if(tempByte == START_TRANSMIT)
(0593) 		{
25EB: 10       PUSH  X
25EC: 7C 1C 0C LCALL 0x1C0C
25EF: 62 D0 00 MOV   REG[208],0
25F2: 20       POP   X
25F3: 39 FD    CMP   A,253
25F5: BF F5    JNZ   0x25EB
(0594) 			// While we keep reading start bytes, sit and spin.
(0595) 			while(tempByte == START_TRANSMIT)
25F7: 55 CB 01 MOV   [__r1],1
25FA: 55 CC 00 MOV   [__r0],0
25FD: 80 EA    JMP   0x26E8
(0596) 			{
(0597) 				tempByte = WAIT_RECV_cGetChar();
(0598) 			}
(0599) 			
25FF: 62 D0 00 MOV   REG[208],0
2602: 3C CF 00 CMP   [STATE],0
2605: B0 81    JNZ   0x2687
2607: 3C D0 06 CMP   [STATE+1],6
260A: B0 7C    JNZ   0x2687
(0600) 			// The tempByte variable contains the source ID.  If the source is good, store all bytes.
(0601) 			if(tempByte == MASTER_ID)
260C: 10       PUSH  X
260D: 7C 1A 5B LCALL 0x1A5B
2610: 62 D0 00 MOV   REG[208],0
2613: 20       POP   X
2614: 54 00    MOV   [X+0],A
2616: 39 00    CMP   A,0
2618: A0 C6    JZ    0x26DF
(0602) 			{
(0603) 				COMMAND_SOURCE = tempByte;
261A: 3D 00 FF CMP   [X+0],255
261D: B0 50    JNZ   0x266E
(0604) 				COMMAND_DESTINATION = WAIT_RECV_cGetChar();
(0605) 				COMMAND_TYPE = WAIT_RECV_cGetChar();
(0606) 				COMMAND_PARAM = WAIT_RECV_cGetChar();
261F: 10       PUSH  X
2620: 7C 1A 53 LCALL 0x1A53
2623: 62 D0 00 MOV   REG[208],0
2626: 20       POP   X
2627: 39 FF    CMP   A,255
2629: AF F5    JZ    0x261F
(0607) 				
(0608) 				return 1;
(0609) 			}
262B: 10       PUSH  X
262C: 7C 1A 53 LCALL 0x1A53
262F: 62 D0 00 MOV   REG[208],0
2632: 20       POP   X
2633: 54 00    MOV   [X+0],A
(0610) 		}
(0611) 		else if(tempByte == SERVO_START)
(0612) 		{
2635: 56 02 00 MOV   [X+2],0
2638: 56 01 00 MOV   [X+1],0
263B: 80 0E    JMP   0x264A
(0613) 			// While we keep reading start bytes, sit and spin.
(0614) 			while(tempByte == SERVO_START)
263D: 10       PUSH  X
263E: 7C 1A 53 LCALL 0x1A53
2641: 62 D0 00 MOV   REG[208],0
2644: 20       POP   X
2645: 77 02    INC   [X+2]
2647: 0F 01 00 ADC   [X+1],0
264A: 62 D0 00 MOV   REG[208],0
264D: 52 00    MOV   A,[X+0]
264F: 53 CB    MOV   [__r1],A
2651: 52 02    MOV   A,[X+2]
2653: 12 CB    SUB   A,[__r1]
2655: 50 00    MOV   A,0
2657: 31 80    XOR   A,128
2659: 53 CA    MOV   [__rX],A
265B: 52 01    MOV   A,[X+1]
265D: 31 80    XOR   A,128
265F: 1A CA    SBB   A,[__rX]
2661: CF DB    JC    0x263D
(0615) 			{
(0616) 				tempByte = WAIT_RECV_cGetChar();
(0617) 			}
2663: 62 D0 00 MOV   REG[208],0
2666: 55 CB 01 MOV   [__r1],1
2669: 55 CC 00 MOV   [__r0],0
266C: 80 7B    JMP   0x26E8
(0618) 			
(0619) 			// We assume (and hopefully rightly so) that this is a command from master.
266E: 3D 00 FC CMP   [X+0],252
2671: B0 6D    JNZ   0x26DF
(0620) 			COMMAND_SOURCE = MASTER_ID;
(0621) 			// The first parameter after the servo start is the destination.
(0622) 			COMMAND_DESTINATION = tempByte;
2673: 10       PUSH  X
2674: 7C 1A 53 LCALL 0x1A53
2677: 62 D0 00 MOV   REG[208],0
267A: 20       POP   X
267B: 39 FD    CMP   A,253
267D: BF F5    JNZ   0x2673
(0623) 			// The second parameter after the servo start is the command length.
(0624) 			// We don't need it to wait for the transmission to go through since the
267F: 55 CB 01 MOV   [__r1],1
2682: 55 CC 00 MOV   [__r0],0
2685: 80 62    JMP   0x26E8
(0625) 			// transmission goes through the chip with a delay of approximately 100 ns
(0626) 			// (it is already in and out by the time you read this byte).
(0627) 			tempByte = WAIT_RECV_cGetChar();
(0628) 			// Now we store the command type.  Depending on what the status return level
2687: 62 D0 00 MOV   REG[208],0
268A: 3C CF 00 CMP   [STATE],0
268D: B0 51    JNZ   0x26DF
268F: 3C D0 08 CMP   [STATE+1],8
2692: B0 4C    JNZ   0x26DF
(0629) 			// is, we have special duties.
(0630) 			COMMAND_TYPE = WAIT_RECV_cGetChar();
2694: 10       PUSH  X
2695: 7C 12 DE LCALL 0x12DE
2698: 62 D0 00 MOV   REG[208],0
269B: 20       POP   X
269C: 39 FF    CMP   A,255
269E: B0 40    JNZ   0x26DF
(0631) 			
(0632) 			// This basically waits for the rest of the command to pass through.
(0633) 			for(i = 0; i < (tempByte - 1); i++)
26A0: 10       PUSH  X
26A1: 7C 12 D6 LCALL 0x12D6
26A4: 62 D0 00 MOV   REG[208],0
26A7: 20       POP   X
26A8: 39 FF    CMP   A,255
26AA: B0 34    JNZ   0x26DF
(0634) 			{
(0635) 				WAIT_RECV_cGetChar();
(0636) 			}
(0637) 				
26AC: 10       PUSH  X
26AD: 7C 12 D6 LCALL 0x12D6
26B0: 20       POP   X
26B1: 62 D0 00 MOV   REG[208],0
26B4: 53 E3    MOV   [COMMAND_SOURCE],A
(0638) 			return 1;
26B6: 10       PUSH  X
26B7: 7C 12 D6 LCALL 0x12D6
26BA: 20       POP   X
26BB: 62 D0 00 MOV   REG[208],0
26BE: 53 DF    MOV   [COMMAND_LENGTH],A
(0639) 		}
26C0: 10       PUSH  X
26C1: 7C 12 D6 LCALL 0x12D6
26C4: 20       POP   X
26C5: 62 D0 00 MOV   REG[208],0
26C8: 53 DE    MOV   [COMMAND_ERROR],A
(0640) 	}
26CA: 10       PUSH  X
26CB: 7C 12 D6 LCALL 0x12D6
26CE: 20       POP   X
26CF: 62 D0 00 MOV   REG[208],0
26D2: 53 E0    MOV   [COMMAND_PARAM],A
(0641) 	else if(STATE == HELLO_MODE)
(0642) 	{
26D4: 62 D0 00 MOV   REG[208],0
26D7: 55 CB 01 MOV   [__r1],1
26DA: 55 CC 00 MOV   [__r0],0
26DD: 80 0A    JMP   0x26E8
(0643) 		// Check all of the ports for a start byte.  Only one port will produce one.
(0644) 		if(HELLO_1_cReadChar() == START_TRANSMIT)
(0645) 		{		
(0646) 			CHILD = PORT_A;
(0647) 			
26DF: 62 D0 00 MOV   REG[208],0
26E2: 55 CB 00 MOV   [__r1],0
26E5: 55 CC 00 MOV   [__r0],0
26E8: 38 FD    ADD   SP,253
26EA: 20       POP   X
26EB: 7F       RET   
(0648) 			return 1;
(0649) 		}
(0650) 		else if(HELLO_2_cReadChar() == START_TRANSMIT)
(0651) 		{		
(0652) 			CHILD = PORT_B;
(0653) 			
_takeAction:
  j                    --> X+4
  i                    --> X+2
  i                    --> X+0
26EC: 10       PUSH  X
26ED: 4F       MOV   X,SP
26EE: 38 06    ADD   SP,6
(0654) 			return 1;
26F0: 56 01 00 MOV   [X+1],0
26F3: 56 00 00 MOV   [X+0],0
(0655) 		}
(0656) 		else if(HELLO_3_cReadChar() == START_TRANSMIT)
26F6: 62 D0 00 MOV   REG[208],0
26F9: 3C E1 C8 CMP   [COMMAND_TYPE],200
26FC: B0 39    JNZ   0x2736
(0657) 		{
(0658) 			CHILD = PORT_C;
26FE: 62 D0 00 MOV   REG[208],0
2701: 3C CD 00 CMP   [CONFIGURED],0
2704: B0 0A    JNZ   0x270F
2706: 3C CE 00 CMP   [CONFIGURED+1],0
2709: B0 05    JNZ   0x270F
(0659) 			
(0660) 			return 1;
(0661) 		}
270B: 99 8E    CALL  _sayHello
(0662) 		else if(HELLO_4_cReadChar() == START_TRANSMIT)
270D: 82 0D    JMP   0x291B
(0663) 		{
270F: 62 D0 00 MOV   REG[208],0
2712: 3C D3 00 CMP   [CHILD],0
2715: B0 14    JNZ   0x272A
(0664) 			CHILD = PORT_D;
(0665) 			
(0666) 			return 1;
2717: 94 88    CALL  _childListen
2719: 62 D0 00 MOV   REG[208],0
271C: 3C CC 00 CMP   [__r0],0
271F: B0 06    JNZ   0x2726
2721: 3C CB 00 CMP   [__r1],0
2724: A1 F6    JZ    0x291B
(0667) 		}
(0668) 	}
(0669) 	else if(STATE == RESPONSE_1)
2726: 99 73    CALL  _sayHello
(0670) 	{
(0671) 		if(tempByte = CHILD_1_cReadChar())
2728: 81 F2    JMP   0x291B
(0672) 		{
272A: 62 D0 00 MOV   REG[208],0
272D: 3C D3 00 CMP   [CHILD],0
2730: A1 EA    JZ    0x291B
(0673) 			if(tempByte == SERVO_START)				// We have a servo response coming.
(0674) 			{
(0675) 				// Burn through the rest of the start bytes and the servo length.
2732: 94 C5    CALL  _childResponse
(0676) 				while(CHILD_1_cGetChar() == SERVO_START) { }
(0677) 				
2734: 81 E6    JMP   0x291B
(0678) 				// We store the length, since it is the next byte from the servo.
2736: 62 D0 00 MOV   REG[208],0
2739: 3C E1 CB CMP   [COMMAND_TYPE],203
273C: B0 21    JNZ   0x275E
(0679) 				tempByte = CHILD_1_cGetChar();
(0680) 				
(0681) 				// This basically waits for the rest of the command to pass through.
273E: 62 D0 00 MOV   REG[208],0
2741: 51 E2    MOV   A,[COMMAND_DESTINATION]
2743: 62 D0 00 MOV   REG[208],0
2746: 3A E4    CMP   A,[ID]
2748: B0 05    JNZ   0x274E
(0682) 				for(i = 0; i < tempByte; i++)
(0683) 				{
(0684) 					CHILD_1_cGetChar();
274A: 92 72    CALL  _pingResponse
(0685) 				}
274C: 81 CE    JMP   0x291B
(0686) 				
274E: 62 D0 00 MOV   REG[208],0
2751: 51 E4    MOV   A,[ID]
2753: 62 D0 00 MOV   REG[208],0
2756: 3A E2    CMP   A,[COMMAND_DESTINATION]
2758: D1 C2    JNC   0x291B
(0687) 				return 1;
(0688) 			}
(0689) 			else if (tempByte == START_TRANSMIT)	// We have a controller response coming.
275A: 94 9D    CALL  _childResponse
(0690) 			{
(0691) 				// We simply wait for the end transmit indicator.
275C: 81 BE    JMP   0x291B
(0692) 				while(CHILD_1_cGetChar() != END_TRANSMIT) { }
275E: 62 D0 00 MOV   REG[208],0
2761: 3C E1 C9 CMP   [COMMAND_TYPE],201
2764: B1 10    JNZ   0x2875
(0693) 				
(0694) 				return 1;
(0695) 			}
2766: 62 D0 00 MOV   REG[208],0
2769: 51 E2    MOV   A,[COMMAND_DESTINATION]
276B: 62 D0 00 MOV   REG[208],0
276E: 3A E4    CMP   A,[ID]
2770: B0 F4    JNZ   0x2865
(0696) 		}
(0697) 	}
2772: 62 D0 00 MOV   REG[208],0
2775: 50 00    MOV   A,0
2777: 3A E0    CMP   A,[COMMAND_PARAM]
2779: D1 A1    JNC   0x291B
277B: 62 D0 00 MOV   REG[208],0
277E: 3C E0 FB CMP   [COMMAND_PARAM],251
2781: D1 99    JNC   0x291B
(0698) 	else if(STATE == RESPONSE_2)
(0699) 	{
(0700) 		if(tempByte = CHILD_2_cReadChar())
2783: 62 D0 00 MOV   REG[208],0
2786: 51 E0    MOV   A,[COMMAND_PARAM]
2788: 62 D0 00 MOV   REG[208],0
278B: 53 E4    MOV   [ID],A
(0701) 		{
(0702) 			if(tempByte == SERVO_START)				// We have a servo response coming.
(0703) 			{
278D: 62 D0 00 MOV   REG[208],0
2790: 55 CE 01 MOV   [CONFIGURED+1],1
2793: 55 CD 00 MOV   [CONFIGURED],0
(0704) 				// Burn through the rest of the start bytes and the servo length.
(0705) 				while(CHILD_2_cGetChar() == SERVO_START) { }
(0706) 				
2796: 62 D0 00 MOV   REG[208],0
2799: 51 E4    MOV   A,[ID]
279B: 62 D0 00 MOV   REG[208],0
279E: 3A E6    CMP   A,[SERVO_ID]
27A0: A0 A8    JZ    0x2849
(0707) 				// We store the length, since it is the next byte from the servo.
(0708) 				tempByte = CHILD_2_cGetChar();
(0709) 				
(0710) 				// This basically waits for the rest of the command to pass through.
(0711) 				for(i = 0; i < tempByte; i++)
(0712) 				{
(0713) 					CHILD_2_cGetChar();
(0714) 				}
27A2: 56 05 00 MOV   [X+5],0
27A5: 56 04 00 MOV   [X+4],0
(0715) 				
(0716) 				return 1;
(0717) 			}
27A8: 62 D0 00 MOV   REG[208],0
27AB: 51 E4    MOV   A,[ID]
27AD: 08       PUSH  A
27AE: 50 03    MOV   A,3
27B0: 08       PUSH  A
27B1: 08       PUSH  A
27B2: 50 04    MOV   A,4
27B4: 08       PUSH  A
27B5: 62 D0 00 MOV   REG[208],0
27B8: 51 E6    MOV   A,[SERVO_ID]
27BA: 08       PUSH  A
27BB: 96 F2    CALL  _servoInstruction
27BD: 38 FB    ADD   SP,251
(0718) 			else if (tempByte == START_TRANSMIT)	// We have a controller response coming.
(0719) 			{
(0720) 				// We simply wait for the end transmit indicator.
27BF: 56 03 00 MOV   [X+3],0
27C2: 56 02 00 MOV   [X+2],0
(0721) 				while(CHILD_2_cGetChar() != END_TRANSMIT) { }
(0722) 				
(0723) 				return 1;
27C5: 50 00    MOV   A,0
27C7: 08       PUSH  A
27C8: 08       PUSH  A
27C9: 50 01    MOV   A,1
27CB: 08       PUSH  A
27CC: 50 02    MOV   A,2
27CE: 08       PUSH  A
27CF: 50 FE    MOV   A,254
27D1: 08       PUSH  A
27D2: 96 DB    CALL  _servoInstruction
27D4: 38 FB    ADD   SP,251
27D6: 80 43    JMP   0x281A
(0724) 			}
(0725) 		}
(0726) 	}
(0727) 	else if(STATE == RESPONSE_3)
(0728) 	{
(0729) 		if(tempByte = CHILD_3_cReadChar())
27D8: 9B 30    CALL  _commandReady
27DA: 62 D0 00 MOV   REG[208],0
27DD: 3C CC 00 CMP   [__r0],0
27E0: B0 06    JNZ   0x27E7
27E2: 3C CB 00 CMP   [__r1],0
27E5: A0 34    JZ    0x281A
(0730) 		{
(0731) 			if(tempByte == SERVO_START)				// We have a servo response coming.
27E7: 62 D0 00 MOV   REG[208],0
27EA: 3C DE 00 CMP   [COMMAND_ERROR],0
27ED: B0 2C    JNZ   0x281A
(0732) 			{
(0733) 				// Burn through the rest of the start bytes and the servo length.
(0734) 				while(CHILD_3_cGetChar() == SERVO_START) { }
27EF: 62 D0 00 MOV   REG[208],0
27F2: 51 E3    MOV   A,[COMMAND_SOURCE]
27F4: 62 D0 00 MOV   REG[208],0
27F7: 3A E4    CMP   A,[ID]
27F9: B0 20    JNZ   0x281A
(0735) 				
(0736) 				// We store the length, since it is the next byte from the servo.
(0737) 				tempByte = CHILD_3_cGetChar();
27FB: 62 D0 00 MOV   REG[208],0
27FE: 55 D2 01 MOV   [TIMEOUT+1],1
2801: 55 D1 00 MOV   [TIMEOUT],0
(0738) 				
(0739) 				// This basically waits for the rest of the command to pass through.
2804: 56 03 0A MOV   [X+3],10
2807: 56 02 00 MOV   [X+2],0
(0740) 				for(i = 0; i < tempByte; i++)
(0741) 				{
280A: 56 05 02 MOV   [X+5],2
280D: 56 04 00 MOV   [X+4],0
(0742) 					CHILD_3_cGetChar();
(0743) 				}
2810: 62 D0 00 MOV   REG[208],0
2813: 51 E4    MOV   A,[ID]
2815: 62 D0 00 MOV   REG[208],0
2818: 53 E6    MOV   [SERVO_ID],A
281A: 62 D0 00 MOV   REG[208],0
281D: 3C D1 00 CMP   [TIMEOUT],0
2820: B0 06    JNZ   0x2827
2822: 3C D2 00 CMP   [TIMEOUT+1],0
2825: AF B2    JZ    0x27D8
2827: 77 03    INC   [X+3]
2829: 0F 02 00 ADC   [X+2],0
282C: 52 03    MOV   A,[X+3]
282E: 11 0A    SUB   A,10
2830: 52 02    MOV   A,[X+2]
2832: 31 80    XOR   A,128
2834: 19 80    SBB   A,128
2836: CF 8E    JC    0x27C5
2838: 77 05    INC   [X+5]
283A: 0F 04 00 ADC   [X+4],0
283D: 52 05    MOV   A,[X+5]
283F: 11 02    SUB   A,2
2841: 52 04    MOV   A,[X+4]
2843: 31 80    XOR   A,128
2845: 19 80    SBB   A,128
2847: CF 60    JC    0x27A8
(0744) 				
(0745) 				return 1;
(0746) 			}
(0747) 			else if (tempByte == START_TRANSMIT)	// We have a controller response coming.
(0748) 			{
(0749) 				// We simply wait for the end transmit indicator.
(0750) 				while(CHILD_3_cGetChar() != END_TRANSMIT) { }
(0751) 				
(0752) 				return 1;
2849: 62 D0 00 MOV   REG[208],0
284C: 51 E4    MOV   A,[ID]
284E: 62 D0 00 MOV   REG[208],0
2851: 3A E6    CMP   A,[SERVO_ID]
2853: A0 0D    JZ    0x2861
(0753) 			}
(0754) 		}
(0755) 	}
2855: 50 00    MOV   A,0
2857: 08       PUSH  A
2858: 50 01    MOV   A,1
285A: 08       PUSH  A
285B: 98 A3    CALL  _configToggle
285D: 38 FE    ADD   SP,254
(0756) 	else if(STATE == RESPONSE_4)
285F: 80 BB    JMP   0x291B
(0757) 	{
(0758) 		if(tempByte = CHILD_4_cReadChar())
(0759) 		{
(0760) 			if(tempByte == SERVO_START)				// We have a servo response coming.
2861: 92 9F    CALL  _assignedID
(0761) 			{
(0762) 				// Burn through the rest of the start bytes and the servo length.
(0763) 				while(CHILD_4_cGetChar() == SERVO_START) { }
2863: 80 B7    JMP   0x291B
(0764) 				
2865: 62 D0 00 MOV   REG[208],0
2868: 51 E4    MOV   A,[ID]
286A: 62 D0 00 MOV   REG[208],0
286D: 3A E2    CMP   A,[COMMAND_DESTINATION]
286F: D0 AB    JNC   0x291B
(0765) 				// We store the length, since it is the next byte from the servo.
(0766) 				tempByte = CHILD_4_cGetChar();
(0767) 				
2871: 93 86    CALL  _childResponse
(0768) 				// This basically waits for the rest of the command to pass through.
(0769) 				for(i = 0; i < tempByte; i++)
2873: 80 A7    JMP   0x291B
(0770) 				{
2875: 62 D0 00 MOV   REG[208],0
2878: 3C E1 CC CMP   [COMMAND_TYPE],204
287B: B0 3D    JNZ   0x28B9
(0771) 					CHILD_4_cGetChar();
(0772) 				}
(0773) 				
287D: 62 D0 00 MOV   REG[208],0
2880: 51 E2    MOV   A,[COMMAND_DESTINATION]
2882: 62 D0 00 MOV   REG[208],0
2885: 3A E4    CMP   A,[ID]
2887: B0 03    JNZ   0x288B
(0774) 				return 1;
(0775) 			}
2889: 90 94    CALL  _configCleared
(0776) 			else if (tempByte == START_TRANSMIT)	// We have a controller response coming.
(0777) 			{
(0778) 				// We simply wait for the end transmit indicator.
(0779) 				while(CHILD_4_cGetChar() != END_TRANSMIT) { }
(0780) 				
(0781) 				return 1;
288B: 62 D0 00 MOV   REG[208],0
288E: 51 E4    MOV   A,[ID]
2890: 62 D0 00 MOV   REG[208],0
2893: 3A E2    CMP   A,[COMMAND_DESTINATION]
2895: D0 09    JNC   0x289F
2897: 62 D0 00 MOV   REG[208],0
289A: 3C E2 FE CMP   [COMMAND_DESTINATION],254
289D: B0 16    JNZ   0x28B4
(0782) 			}
(0783) 		}
289F: 62 D0 00 MOV   REG[208],0
28A2: 55 E4 FB MOV   [ID],251
(0784) 	}
28A5: 62 D0 00 MOV   REG[208],0
28A8: 55 CE 00 MOV   [CONFIGURED+1],0
28AB: 55 CD 00 MOV   [CONFIGURED],0
(0785) 	else if(STATE == INITIALIZE)
28AE: 62 D0 00 MOV   REG[208],0
28B1: 55 D3 00 MOV   [CHILD],0
(0786) 	{
(0787) 		if(INIT_RX_cReadChar() == SERVO_START)
(0788) 		{
(0789) 			// We officially have a transmission.
(0790) 			if(INIT_RX_cGetChar() == SERVO_START)
(0791) 			{
(0792) 				// If we definitely have a transmission starting, grab all bytes from the rx buffer
(0793) 				// and store them in the proper variables for actions to be taken later.
(0794) 				COMMAND_SOURCE = INIT_RX_cGetChar();
(0795) 				COMMAND_LENGTH = INIT_RX_cGetChar();
(0796) 				COMMAND_ERROR = INIT_RX_cGetChar();
(0797) 				COMMAND_PARAM = INIT_RX_cGetChar();
28B4: 43 08 01 OR    REG[8],1
(0798) 				
28B7: 80 63    JMP   0x291B
(0799) 				return 1;
28B9: 62 D0 00 MOV   REG[208],0
28BC: 3C E1 01 CMP   [COMMAND_TYPE],1
28BF: A0 06    JZ    0x28C6
28C1: 3C E1 02 CMP   [COMMAND_TYPE],2
28C4: B0 56    JNZ   0x291B
(0800) 			}
(0801) 		}
28C6: 62 D0 00 MOV   REG[208],0
28C9: 51 E4    MOV   A,[ID]
28CB: 62 D0 00 MOV   REG[208],0
28CE: 3A E2    CMP   A,[COMMAND_DESTINATION]
28D0: D0 05    JNC   0x28D6
(0802) 	}
(0803) 	
(0804) 	return 0;
28D2: 93 25    CALL  _childResponse
(0805) }
28D4: 80 46    JMP   0x291B
(0806) 
28D6: 62 D0 00 MOV   REG[208],0
28D9: 51 E4    MOV   A,[ID]
28DB: 62 D0 00 MOV   REG[208],0
28DE: 3A E2    CMP   A,[COMMAND_DESTINATION]
28E0: C0 3A    JC    0x291B
(0807) // This function interprets what has been read by the command ready function
(0808) // and performs the appropriate action.
(0809) void takeAction(void)
28E2: 10       PUSH  X
28E3: 7C 0C E1 LCALL 0x0CE1
28E6: 62 D0 00 MOV   REG[208],0
28E9: 20       POP   X
28EA: 39 FF    CMP   A,255
28EC: BF F5    JNZ   0x28E2
(0810) {
(0811) 	int i = 0;							// An index variable for looping.
(0812) 	
28EE: 56 01 00 MOV   [X+1],0
28F1: 56 00 00 MOV   [X+0],0
28F4: 80 1A    JMP   0x290F
(0813) 	if(COMMAND_TYPE == HELLO_BYTE)		// The master is probing for new modules.
(0814) 	{
(0815) 		if(!CONFIGURED)
(0816) 		{
(0817) 			// Announce this module's presence if not configured.
(0818) 			sayHello();
28F6: 10       PUSH  X
28F7: 7C 0C E1 LCALL 0x0CE1
28FA: 62 D0 00 MOV   REG[208],0
28FD: 20       POP   X
28FE: 39 00    CMP   A,0
2900: A0 09    JZ    0x290A
(0819) 		}
(0820) 		else if(!CHILD)
2902: 56 01 00 MOV   [X+1],0
2905: 56 00 00 MOV   [X+0],0
(0821) 		{
2908: 80 06    JMP   0x290F
(0822) 			// Listen for children if we have none.
(0823) 			if(childListen())
(0824) 			{
290A: 77 01    INC   [X+1]
290C: 0F 00 00 ADC   [X+0],0
290F: 52 01    MOV   A,[X+1]
2911: 11 0A    SUB   A,10
2913: 52 00    MOV   A,[X+0]
2915: 31 80    XOR   A,128
2917: 19 80    SBB   A,128
2919: CF DC    JC    0x28F6
(0825) 				// If a child was heard saying hello, forward the command with the port number added.
(0826) 				sayHello();
(0827) 			}
(0828) 		}
291B: 38 FA    ADD   SP,250
291D: 20       POP   X
291E: 7F       RET   
(0829) 		else if(CHILD)
(0830) 		{
(0831) 			// If you have a child established, listen to that child.
(0832) 			childResponse();
(0833) 		}
(0834) 	}
_configCleared:
291F: 50 00    MOV   A,0
2921: 08       PUSH  A
2922: 50 02    MOV   A,2
2924: 08       PUSH  A
2925: 7C 21 00 LCALL _configToggle
2928: 38 FE    ADD   SP,254
(0835) 	else if(COMMAND_TYPE == PING)		// The master is trying to find a module that is configured.
(0836) 	{
(0837) 		// If this is to me, act accordingly.
292A: 10       PUSH  X
292B: 50 FC    MOV   A,252
292D: 7C 0E D4 LCALL 0x0ED4
2930: 20       POP   X
(0838) 		if(COMMAND_DESTINATION == ID)
2931: 10       PUSH  X
2932: 50 FC    MOV   A,252
2934: 7C 0D FB LCALL 0x0DFB
2937: 20       POP   X
(0839) 		{
2938: 10       PUSH  X
2939: 50 FC    MOV   A,252
293B: 7C 0E D4 LCALL 0x0ED4
293E: 20       POP   X
(0840) 			// Ping back to the master.
293F: 10       PUSH  X
2940: 50 FC    MOV   A,252
2942: 7C 0D FB LCALL 0x0DFB
2945: 20       POP   X
(0841) 			pingResponse();
2946: 10       PUSH  X
2947: 62 D0 00 MOV   REG[208],0
294A: 51 E4    MOV   A,[ID]
294C: 7C 0E D4 LCALL 0x0ED4
294F: 20       POP   X
(0842) 		}
2950: 10       PUSH  X
2951: 62 D0 00 MOV   REG[208],0
2954: 51 E4    MOV   A,[ID]
2956: 7C 0D FB LCALL 0x0DFB
2959: 20       POP   X
(0843) 		else if(COMMAND_DESTINATION > ID)
295A: 10       PUSH  X
295B: 50 00    MOV   A,0
295D: 7C 0E D4 LCALL 0x0ED4
2960: 20       POP   X
(0844) 		{
2961: 10       PUSH  X
2962: 50 00    MOV   A,0
2964: 7C 0D FB LCALL 0x0DFB
2967: 20       POP   X
(0845) 			// If you have a child established, listen to that child.
2968: 10       PUSH  X
2969: 50 CD    MOV   A,205
296B: 7C 0E D4 LCALL 0x0ED4
296E: 20       POP   X
(0846) 			childResponse();
296F: 10       PUSH  X
2970: 50 CD    MOV   A,205
2972: 7C 0D FB LCALL 0x0DFB
2975: 20       POP   X
(0847) 		}
2976: 10       PUSH  X
2977: 50 FD    MOV   A,253
2979: 7C 0E D4 LCALL 0x0ED4
297C: 20       POP   X
(0848) 	}
297D: 10       PUSH  X
297E: 50 FD    MOV   A,253
2980: 7C 0D FB LCALL 0x0DFB
2983: 20       POP   X
(0849) 	else if(COMMAND_TYPE == ID_ASSIGNMENT)	// The master is assigning an ID to someone.
2984: 10       PUSH  X
2985: 50 FD    MOV   A,253
2987: 7C 0E D4 LCALL 0x0ED4
298A: 20       POP   X
(0850) 	{
298B: 10       PUSH  X
298C: 50 FD    MOV   A,253
298E: 7C 0D FB LCALL 0x0DFB
2991: 20       POP   X
(0851) 		// If this is meant for me, change my ID.
(0852) 		if(COMMAND_DESTINATION == ID)
(0853) 		{
2992: 10       PUSH  X
2993: 7C 0E A7 LCALL 0x0EA7
2996: 62 D0 00 MOV   REG[208],0
2999: 20       POP   X
299A: 53 CC    MOV   [__r0],A
299C: 47 CC 20 TST   [__r0],32
299F: AF F2    JZ    0x2992
(0854) 			if((COMMAND_PARAM > MASTER_ID) && (COMMAND_PARAM < DEFAULT_ID))
29A1: 10       PUSH  X
29A2: 7C 0D CE LCALL 0x0DCE
29A5: 62 D0 00 MOV   REG[208],0
29A8: 20       POP   X
29A9: 53 CC    MOV   [__r0],A
29AB: 47 CC 20 TST   [__r0],32
29AE: AF F2    JZ    0x29A1
(0855) 			{
(0856) 				// Assign this module the ID that has been passed by the master.
(0857) 				ID = COMMAND_PARAM;
29B0: 95 DB    CALL  _xmitWait
(0858) 				
(0859) 				// This module is now configured.
29B2: 50 00    MOV   A,0
29B4: 08       PUSH  A
29B5: 50 01    MOV   A,1
29B7: 08       PUSH  A
29B8: 7C 21 00 LCALL _configToggle
29BB: 38 FE    ADD   SP,254
29BD: 7F       RET   
(0860) 				CONFIGURED = 1;
(0861) 				
(0862) 				// If the servo ID doesn't match what we want, change it to match.
(0863) 				if(ID != SERVO_ID)
(0864) 				{
(0865) 					// These are our index variables for communication attempt timeouts.
_pingResponse:
29BE: 50 00    MOV   A,0
29C0: 08       PUSH  A
29C1: 50 02    MOV   A,2
29C3: 08       PUSH  A
29C4: 7C 21 00 LCALL _configToggle
29C7: 38 FE    ADD   SP,254
(0866) 					int i;
(0867) 					int j;
(0868) 					
29C9: 10       PUSH  X
29CA: 50 FC    MOV   A,252
29CC: 7C 0E D4 LCALL 0x0ED4
29CF: 20       POP   X
(0869) 					//while(ID != SERVO_ID)
29D0: 10       PUSH  X
29D1: 50 FC    MOV   A,252
29D3: 7C 0D FB LCALL 0x0DFB
29D6: 20       POP   X
(0870) 					
29D7: 10       PUSH  X
29D8: 50 FC    MOV   A,252
29DA: 7C 0E D4 LCALL 0x0ED4
29DD: 20       POP   X
(0871) 					for(j = 0; j < SERVO_COMM_LOOPS; j++)
29DE: 10       PUSH  X
29DF: 50 FC    MOV   A,252
29E1: 7C 0D FB LCALL 0x0DFB
29E4: 20       POP   X
(0872) 					{	
29E5: 10       PUSH  X
29E6: 62 D0 00 MOV   REG[208],0
29E9: 51 E4    MOV   A,[ID]
29EB: 7C 0E D4 LCALL 0x0ED4
29EE: 20       POP   X
(0873) 						// Send a request to change the servo ID to match the controller ID.
29EF: 10       PUSH  X
29F0: 62 D0 00 MOV   REG[208],0
29F3: 51 E4    MOV   A,[ID]
29F5: 7C 0D FB LCALL 0x0DFB
29F8: 20       POP   X
(0874) 						servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, ID_ADDRESS, ID);
29F9: 10       PUSH  X
29FA: 50 00    MOV   A,0
29FC: 7C 0E D4 LCALL 0x0ED4
29FF: 20       POP   X
(0875) 					
2A00: 10       PUSH  X
2A01: 50 00    MOV   A,0
2A03: 7C 0D FB LCALL 0x0DFB
2A06: 20       POP   X
(0876) 						// Try to read the servo's ID several times.
2A07: 10       PUSH  X
2A08: 50 CB    MOV   A,203
2A0A: 7C 0E D4 LCALL 0x0ED4
2A0D: 20       POP   X
(0877) 						for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
2A0E: 10       PUSH  X
2A0F: 50 CB    MOV   A,203
2A11: 7C 0D FB LCALL 0x0DFB
2A14: 20       POP   X
(0878) 						{
2A15: 10       PUSH  X
2A16: 50 FD    MOV   A,253
2A18: 7C 0E D4 LCALL 0x0ED4
2A1B: 20       POP   X
(0879) 							// Send a request for the servo ID, which is presumably now equal to ID.
2A1C: 10       PUSH  X
2A1D: 50 FD    MOV   A,253
2A1F: 7C 0D FB LCALL 0x0DFB
2A22: 20       POP   X
(0880) 							servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
2A23: 10       PUSH  X
2A24: 50 FD    MOV   A,253
2A26: 7C 0E D4 LCALL 0x0ED4
2A29: 20       POP   X
(0881) 							
2A2A: 10       PUSH  X
2A2B: 50 FD    MOV   A,253
2A2D: 7C 0D FB LCALL 0x0DFB
2A30: 20       POP   X
(0882) 							// Wait for either a timeout or an indication that we want to exit the loop.
(0883) 							while(!TIMEOUT)
(0884) 							{
2A31: 10       PUSH  X
2A32: 7C 0E A7 LCALL 0x0EA7
2A35: 62 D0 00 MOV   REG[208],0
2A38: 20       POP   X
2A39: 53 CC    MOV   [__r0],A
2A3B: 47 CC 20 TST   [__r0],32
2A3E: AF F2    JZ    0x2A31
(0885) 								// If we have a command to interpret, read it.
2A40: 10       PUSH  X
2A41: 7C 0D CE LCALL 0x0DCE
2A44: 62 D0 00 MOV   REG[208],0
2A47: 20       POP   X
2A48: 53 CC    MOV   [__r0],A
2A4A: 47 CC 20 TST   [__r0],32
2A4D: AF F2    JZ    0x2A40
(0886) 								if(commandReady())
(0887) 								{
(0888) 									if(!COMMAND_ERROR)
2A4F: 95 3C    CALL  _xmitWait
(0889) 									{
(0890) 										// If we have a valid servo ID, exit the loop.
2A51: 50 00    MOV   A,0
2A53: 08       PUSH  A
2A54: 50 01    MOV   A,1
2A56: 08       PUSH  A
2A57: 7C 21 00 LCALL _configToggle
2A5A: 38 FE    ADD   SP,254
2A5C: 7F       RET   
(0891) 										if(COMMAND_SOURCE == ID)
(0892) 										{
(0893) 											// Set the timeout flag to exit the while loop.
(0894) 											TIMEOUT = 1;
(0895) 											// Set i such that the for loop is exited.
(0896) 											i = SERVO_COMM_ATTEMPTS;
(0897) 											// Set j such that we exit the outer loop as well.
_unloadAllConfigs:
2A5D: 7C 06 E6 LCALL 0x06E6
(0898) 											j = SERVO_COMM_LOOPS;
2A60: 7C 07 55 LCALL 0x0755
(0899) 											// Store the ID value.
2A63: 7C 08 7A LCALL 0x087A
(0900) 											SERVO_ID = ID;
2A66: 7C 08 FC LCALL 0x08FC
(0901) 										}
2A69: 7C 09 9F LCALL 0x099F
(0902) 									}
2A6C: 7C 0A 42 LCALL 0x0A42
(0903) 								}
2A6F: 7C 0A EB LCALL 0x0AEB
(0904) 							}
2A72: 7C 07 F5 LCALL 0x07F5
(0905) 						}
2A75: 7C 0B 91 LCALL 0x0B91
2A78: 7F       RET   
(0906) 					}	
(0907) 				}
(0908) 				
(0909) 				if(ID != SERVO_ID)
(0910) 				{
(0911) 					// Toggle back to normal wait mode.
_unloadConfig:
  config_num           --> X-5
2A79: 10       PUSH  X
2A7A: 4F       MOV   X,SP
(0912) 					configToggle(WAIT);
2A7B: 3D FB 00 CMP   [X-5],0
2A7E: B0 0B    JNZ   0x2A8A
2A80: 3D FC 01 CMP   [X-4],1
2A83: B0 06    JNZ   0x2A8A
(0913) 				}
(0914) 				else
2A85: 7C 06 E6 LCALL 0x06E6
(0915) 				{
2A88: 80 77    JMP   0x2B00
(0916) 					// Let the master node know that you got the ID assignment.
2A8A: 3D FB 00 CMP   [X-5],0
2A8D: B0 0B    JNZ   0x2A99
2A8F: 3D FC 07 CMP   [X-4],7
2A92: B0 06    JNZ   0x2A99
(0917) 					assignedID();
(0918) 				}
2A94: 7C 07 55 LCALL 0x0755
(0919) 			}
2A97: 80 68    JMP   0x2B00
(0920) 		}
2A99: 3D FB 00 CMP   [X-5],0
2A9C: B0 0B    JNZ   0x2AA8
2A9E: 3D FC 02 CMP   [X-4],2
2AA1: B0 06    JNZ   0x2AA8
(0921) 		else if(COMMAND_DESTINATION > ID)
(0922) 		{
2AA3: 7C 08 7A LCALL 0x087A
(0923) 			// Switch to listen to your child.
2AA6: 80 59    JMP   0x2B00
(0924) 			childResponse();
2AA8: 3D FB 00 CMP   [X-5],0
2AAB: B0 0B    JNZ   0x2AB7
2AAD: 3D FC 03 CMP   [X-4],3
2AB0: B0 06    JNZ   0x2AB7
(0925) 		}
(0926) 	}
2AB2: 7C 08 FC LCALL 0x08FC
(0927) 	else if(COMMAND_TYPE == CLEAR_CONFIG)	// The master wants to clear one or all configurations.
2AB5: 80 4A    JMP   0x2B00
(0928) 	{
2AB7: 3D FB 00 CMP   [X-5],0
2ABA: B0 0B    JNZ   0x2AC6
2ABC: 3D FC 04 CMP   [X-4],4
2ABF: B0 06    JNZ   0x2AC6
(0929) 		// Only respond if this is directly to me and not a mass config clear.
(0930) 		if(COMMAND_DESTINATION == ID)
2AC1: 7C 09 9F LCALL 0x099F
(0931) 		{
2AC4: 80 3B    JMP   0x2B00
(0932) 			configCleared();	// Notify the master that I am clearing my config.
2AC6: 3D FB 00 CMP   [X-5],0
2AC9: B0 0B    JNZ   0x2AD5
2ACB: 3D FC 05 CMP   [X-4],5
2ACE: B0 06    JNZ   0x2AD5
(0933) 		}
(0934) 		
2AD0: 7C 0A 42 LCALL 0x0A42
(0935) 		// If this is meant for me, deconfigure.  Also, if a module ahead of you is
2AD3: 80 2C    JMP   0x2B00
(0936) 		// getting deconfigured, you have no choice but to deconfigure as well to
2AD5: 3D FB 00 CMP   [X-5],0
2AD8: B0 0B    JNZ   0x2AE4
2ADA: 3D FC 06 CMP   [X-4],6
2ADD: B0 06    JNZ   0x2AE4
(0937) 		// avoid errors on reconfiguration.
(0938) 		if((COMMAND_DESTINATION <= ID) || (COMMAND_DESTINATION == BROADCAST))
2ADF: 7C 0A EB LCALL 0x0AEB
(0939) 		{
2AE2: 80 1D    JMP   0x2B00
(0940) 			ID = DEFAULT_ID;	// Reset my ID to the default.
2AE4: 3D FB 00 CMP   [X-5],0
2AE7: B0 0B    JNZ   0x2AF3
2AE9: 3D FC 08 CMP   [X-4],8
2AEC: B0 06    JNZ   0x2AF3
(0941) 			CONFIGURED = 0;		// I am no longer configured.
(0942) 			CHILD = 0;			// No one can depend on you anymore.
2AEE: 7C 07 F5 LCALL 0x07F5
(0943) 		}
2AF1: 80 0E    JMP   0x2B00
(0944) //		else if(COMMAND_DESTINATION > ID)
2AF3: 3D FB 00 CMP   [X-5],0
2AF6: B0 09    JNZ   0x2B00
2AF8: 3D FC 09 CMP   [X-4],9
2AFB: B0 04    JNZ   0x2B00
(0945) //		{
(0946) //			// Switch to listen to your child.
2AFD: 7C 0B 91 LCALL 0x0B91
(0947) //			childResponse();
2B00: 20       POP   X
2B01: 7F       RET   
(0948) //			// Switch back to wait for a master response.
(0949) //			configToggle(WAIT);
(0950) //		}
(0951) //		Going to also have to take into account of this is my child.
(0952) 		
(0953) 		// Turn off the LED.
_assignedID:
2B02: 50 00    MOV   A,0
2B04: 08       PUSH  A
2B05: 50 02    MOV   A,2
2B07: 08       PUSH  A
2B08: 7C 21 00 LCALL _configToggle
2B0B: 38 FE    ADD   SP,254
(0954) 		PRT2DR |= 0b00000001;
(0955) 	}
(0956) 	else if((COMMAND_TYPE == PING_SERVO) || (COMMAND_TYPE == READ_SERVO))
2B0D: 10       PUSH  X
2B0E: 50 FC    MOV   A,252
2B10: 7C 0E D4 LCALL 0x0ED4
2B13: 20       POP   X
(0957) 	{
2B14: 10       PUSH  X
2B15: 50 FC    MOV   A,252
2B17: 7C 0D FB LCALL 0x0DFB
2B1A: 20       POP   X
(0958) 		if(COMMAND_DESTINATION > ID)
2B1B: 10       PUSH  X
2B1C: 50 FC    MOV   A,252
2B1E: 7C 0E D4 LCALL 0x0ED4
2B21: 20       POP   X
(0959) 		{
2B22: 10       PUSH  X
2B23: 50 FC    MOV   A,252
2B25: 7C 0D FB LCALL 0x0DFB
2B28: 20       POP   X
(0960) 			// Allow the child response through.
2B29: 10       PUSH  X
2B2A: 62 D0 00 MOV   REG[208],0
2B2D: 51 E4    MOV   A,[ID]
2B2F: 7C 0E D4 LCALL 0x0ED4
2B32: 20       POP   X
(0961) 			childResponse();
2B33: 10       PUSH  X
2B34: 62 D0 00 MOV   REG[208],0
2B37: 51 E4    MOV   A,[ID]
2B39: 7C 0D FB LCALL 0x0DFB
2B3C: 20       POP   X
(0962) 		}
2B3D: 10       PUSH  X
2B3E: 50 00    MOV   A,0
2B40: 7C 0E D4 LCALL 0x0ED4
2B43: 20       POP   X
(0963) 		else if(COMMAND_DESTINATION <= ID)
2B44: 10       PUSH  X
2B45: 50 00    MOV   A,0
2B47: 7C 0D FB LCALL 0x0DFB
2B4A: 20       POP   X
(0964) 		{
2B4B: 10       PUSH  X
2B4C: 50 CA    MOV   A,202
2B4E: 7C 0E D4 LCALL 0x0ED4
2B51: 20       POP   X
(0965) 			// Sit and spin while we wait for the transmission to start.
2B52: 10       PUSH  X
2B53: 50 CA    MOV   A,202
2B55: 7C 0D FB LCALL 0x0DFB
2B58: 20       POP   X
(0966) 			while(WAIT_RECV_cReadChar() != SERVO_START) { }
2B59: 10       PUSH  X
2B5A: 50 FD    MOV   A,253
2B5C: 7C 0E D4 LCALL 0x0ED4
2B5F: 20       POP   X
(0967) 			
2B60: 10       PUSH  X
2B61: 50 FD    MOV   A,253
2B63: 7C 0D FB LCALL 0x0DFB
2B66: 20       POP   X
(0968) 			// Reset the index variable.
2B67: 10       PUSH  X
2B68: 50 FD    MOV   A,253
2B6A: 7C 0E D4 LCALL 0x0ED4
2B6D: 20       POP   X
(0969) 			i = 0;
2B6E: 10       PUSH  X
2B6F: 50 FD    MOV   A,253
2B71: 7C 0D FB LCALL 0x0DFB
2B74: 20       POP   X
(0970) 			
(0971) 			// Wait for the transmission to go through.
(0972) 			// If no chars are read for RESPONSE_ITERATIONS iterations, move on.
2B75: 10       PUSH  X
2B76: 7C 0E A7 LCALL 0x0EA7
2B79: 62 D0 00 MOV   REG[208],0
2B7C: 20       POP   X
2B7D: 53 CC    MOV   [__r0],A
2B7F: 47 CC 20 TST   [__r0],32
2B82: AF F2    JZ    0x2B75
(0973) 			while(i < RESPONSE_ITERATIONS)
2B84: 10       PUSH  X
2B85: 7C 0D CE LCALL 0x0DCE
2B88: 62 D0 00 MOV   REG[208],0
2B8B: 20       POP   X
2B8C: 53 CC    MOV   [__r0],A
2B8E: 47 CC 20 TST   [__r0],32
2B91: AF F2    JZ    0x2B84
(0974) 			{
(0975) 				if(WAIT_RECV_cReadChar())
(0976) 				{
2B93: 93 F8    CALL  _xmitWait
(0977) 					i = 0;
(0978) 				}
2B95: 50 00    MOV   A,0
2B97: 08       PUSH  A
2B98: 50 01    MOV   A,1
2B9A: 08       PUSH  A
2B9B: 7C 21 00 LCALL _configToggle
2B9E: 38 FE    ADD   SP,254
2BA0: 7F       RET   
(0979) 				else
(0980) 				{
(0981) 					i++;
(0982) 				}
(0983) 			}
(0984) 		}
_childListen:
2BA1: 50 00    MOV   A,0
2BA3: 08       PUSH  A
2BA4: 50 07    MOV   A,7
2BA6: 08       PUSH  A
2BA7: 7C 21 00 LCALL _configToggle
2BAA: 38 FE    ADD   SP,254
2BAC: 80 1C    JMP   0x2BC9
(0985) 	}
(0986) }
(0987) 
(0988) // This function sends out an acknowledgement of a configuration reset.
(0989) void configCleared(void)
2BAE: 7C 23 0A LCALL _commandReady
2BB1: 62 D0 00 MOV   REG[208],0
2BB4: 3C CC 00 CMP   [__r0],0
2BB7: B0 06    JNZ   0x2BBE
2BB9: 3C CB 00 CMP   [__r1],0
2BBC: A0 0C    JZ    0x2BC9
(0990) {
(0991) 	configToggle(MY_RESPONSE);		// Switch to response mode.
2BBE: 62 D0 00 MOV   REG[208],0
2BC1: 55 CB 01 MOV   [__r1],1
2BC4: 55 CC 00 MOV   [__r0],0
2BC7: 80 30    JMP   0x2BF8
2BC9: 62 D0 00 MOV   REG[208],0
2BCC: 3C D1 00 CMP   [TIMEOUT],0
2BCF: B0 06    JNZ   0x2BD6
2BD1: 3C D2 00 CMP   [TIMEOUT+1],0
2BD4: AF D9    JZ    0x2BAE
(0992) 	
(0993) 	// Transmit a ping to everyone.
(0994) 	TX_014_PutChar(START_TRANSMIT);	// Start byte one
(0995) 	TX_23_PutChar(START_TRANSMIT);	// Start byte one
2BD6: 10       PUSH  X
2BD7: 7C 13 B0 LCALL 0x13B0
2BDA: 20       POP   X
(0996) 	TX_014_PutChar(START_TRANSMIT);	// Start byte two
2BDB: 62 D0 00 MOV   REG[208],0
2BDE: 55 D2 00 MOV   [TIMEOUT+1],0
2BE1: 55 D1 00 MOV   [TIMEOUT],0
(0997) 	TX_23_PutChar(START_TRANSMIT);	// Start byte two
(0998) 	TX_014_PutChar(ID);				// My ID
2BE4: 50 00    MOV   A,0
2BE6: 08       PUSH  A
2BE7: 50 01    MOV   A,1
2BE9: 08       PUSH  A
2BEA: 7C 21 00 LCALL _configToggle
2BED: 38 FE    ADD   SP,254
(0999) 	TX_23_PutChar(ID);				// My ID
(1000) 	TX_014_PutChar(MASTER_ID);		// Destination ID (master)
2BEF: 62 D0 00 MOV   REG[208],0
2BF2: 55 CB 00 MOV   [__r1],0
2BF5: 55 CC 00 MOV   [__r0],0
2BF8: 7F       RET   
(1001) 	TX_23_PutChar(MASTER_ID);		// Destination ID (master)
(1002) 	TX_014_PutChar(CONFIG_CLEARED);	// This is a ping response
(1003) 	TX_23_PutChar(CONFIG_CLEARED);	// This is a ping response
(1004) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1005) 	TX_23_PutChar(END_TRANSMIT);	// This is the end of this transmission
_childResponse:
  child_responded      --> X+0
2BF9: 10       PUSH  X
2BFA: 4F       MOV   X,SP
2BFB: 38 02    ADD   SP,2
(1006) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission
2BFD: 56 01 00 MOV   [X+1],0
2C00: 56 00 00 MOV   [X+0],0
(1007) 	TX_23_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1008) 	
(1009) 	// Wait for the transmission to finish.
2C03: 62 D0 00 MOV   REG[208],0
2C06: 3C D3 41 CMP   [CHILD],65
2C09: B0 0E    JNZ   0x2C18
(1010) 	while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
(1011) 	while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
2C0B: 50 00    MOV   A,0
2C0D: 08       PUSH  A
2C0E: 50 03    MOV   A,3
2C10: 08       PUSH  A
2C11: 7C 21 00 LCALL _configToggle
2C14: 38 FE    ADD   SP,254
(1012) 	
2C16: 80 56    JMP   0x2C6D
(1013) 	// Make completely sure we're done.
2C18: 62 D0 00 MOV   REG[208],0
2C1B: 3C D3 42 CMP   [CHILD],66
2C1E: B0 0E    JNZ   0x2C2D
(1014) 	xmitWait();
(1015) 	
2C20: 50 00    MOV   A,0
2C22: 08       PUSH  A
2C23: 50 04    MOV   A,4
2C25: 08       PUSH  A
2C26: 7C 21 00 LCALL _configToggle
2C29: 38 FE    ADD   SP,254
(1016) 	configToggle(WAIT);				// Switch back to wait for a master response.
2C2B: 80 41    JMP   0x2C6D
(1017) }
2C2D: 62 D0 00 MOV   REG[208],0
2C30: 3C D3 43 CMP   [CHILD],67
2C33: B0 0E    JNZ   0x2C42
(1018) 
(1019) // This function sends out a ping response for everyone to hear.
2C35: 50 00    MOV   A,0
2C37: 08       PUSH  A
2C38: 50 05    MOV   A,5
2C3A: 08       PUSH  A
2C3B: 7C 21 00 LCALL _configToggle
2C3E: 38 FE    ADD   SP,254
(1020) void pingResponse(void)
2C40: 80 2C    JMP   0x2C6D
(1021) {
2C42: 62 D0 00 MOV   REG[208],0
2C45: 3C D3 44 CMP   [CHILD],68
2C48: B0 24    JNZ   0x2C6D
(1022) 	configToggle(MY_RESPONSE);		// Switch to response mode.
(1023) 	
2C4A: 50 00    MOV   A,0
2C4C: 08       PUSH  A
2C4D: 50 06    MOV   A,6
2C4F: 08       PUSH  A
2C50: 7C 21 00 LCALL _configToggle
2C53: 38 FE    ADD   SP,254
(1024) 	// Transmit a ping to everyone.
2C55: 80 17    JMP   0x2C6D
(1025) 	TX_014_PutChar(START_TRANSMIT);	// Start byte one
(1026) 	TX_23_PutChar(START_TRANSMIT);	// Start byte one
(1027) 	TX_014_PutChar(START_TRANSMIT);	// Start byte two
(1028) 	TX_23_PutChar(START_TRANSMIT);	// Start byte two
(1029) 	TX_014_PutChar(ID);				// My ID
2C57: 7C 23 0A LCALL _commandReady
2C5A: 62 D0 00 MOV   REG[208],0
2C5D: 3C CC 00 CMP   [__r0],0
2C60: B0 06    JNZ   0x2C67
2C62: 3C CB 00 CMP   [__r1],0
2C65: A0 07    JZ    0x2C6D
(1030) 	TX_23_PutChar(ID);				// My ID
(1031) 	TX_014_PutChar(MASTER_ID);		// Destination ID (master)
2C67: 56 01 01 MOV   [X+1],1
2C6A: 56 00 00 MOV   [X+0],0
2C6D: 3D 00 00 CMP   [X+0],0
2C70: B0 13    JNZ   0x2C84
2C72: 3D 01 00 CMP   [X+1],0
2C75: B0 0E    JNZ   0x2C84
2C77: 62 D0 00 MOV   REG[208],0
2C7A: 3C D1 00 CMP   [TIMEOUT],0
2C7D: B0 06    JNZ   0x2C84
2C7F: 3C D2 00 CMP   [TIMEOUT+1],0
2C82: AF D4    JZ    0x2C57
(1032) 	TX_23_PutChar(MASTER_ID);		// Destination ID (master)
(1033) 	TX_014_PutChar(PING);			// This is a ping response
(1034) 	TX_23_PutChar(PING);			// This is a ping response
(1035) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1036) 	TX_23_PutChar(END_TRANSMIT);	// This is the end of this transmission
2C84: 62 D0 00 MOV   REG[208],0
2C87: 3C D3 41 CMP   [CHILD],65
2C8A: B0 08    JNZ   0x2C93
(1037) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1038) 	TX_23_PutChar(END_TRANSMIT);	// This is the end of this transmission
2C8C: 10       PUSH  X
2C8D: 7C 1F 13 LCALL 0x1F13
2C90: 20       POP   X
(1039) 	
2C91: 80 2C    JMP   0x2CBE
(1040) 	// Wait for the transmission to finish.
2C93: 62 D0 00 MOV   REG[208],0
2C96: 3C D3 42 CMP   [CHILD],66
2C99: B0 08    JNZ   0x2CA2
(1041) 	while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
(1042) 	while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
2C9B: 10       PUSH  X
2C9C: 7C 1D 5A LCALL 0x1D5A
2C9F: 20       POP   X
(1043) 	
2CA0: 80 1D    JMP   0x2CBE
(1044) 	// Make completely sure we're done.
2CA2: 62 D0 00 MOV   REG[208],0
2CA5: 3C D3 43 CMP   [CHILD],67
2CA8: B0 08    JNZ   0x2CB1
(1045) 	xmitWait();
(1046) 	
2CAA: 10       PUSH  X
2CAB: 7C 1B A1 LCALL 0x1BA1
2CAE: 20       POP   X
(1047) 	configToggle(WAIT);				// Switch back to wait for a master response.
2CAF: 80 0E    JMP   0x2CBE
(1048) }
2CB1: 62 D0 00 MOV   REG[208],0
2CB4: 3C D3 44 CMP   [CHILD],68
2CB7: B0 06    JNZ   0x2CBE
(1049) 
(1050) // This function blindly unloads all user configurations. This will be called once,
2CB9: 10       PUSH  X
2CBA: 7C 19 E8 LCALL 0x19E8
2CBD: 20       POP   X
(1051) // when the system initially has no known state.
(1052) void unloadAllConfigs(void)
(1053) {
2CBE: 62 D0 00 MOV   REG[208],0
2CC1: 55 D2 00 MOV   [TIMEOUT+1],0
2CC4: 55 D1 00 MOV   [TIMEOUT],0
(1054) 	UnloadConfig_waiting();
(1055) 	UnloadConfig_hello();
2CC7: 50 00    MOV   A,0
2CC9: 08       PUSH  A
2CCA: 50 01    MOV   A,1
2CCC: 08       PUSH  A
2CCD: 7C 21 00 LCALL _configToggle
2CD0: 38 FE    ADD   SP,254
(1056) 	UnloadConfig_my_response();
(1057) 	UnloadConfig_response1();
2CD2: 62 D0 00 MOV   REG[208],0
2CD5: 52 01    MOV   A,[X+1]
2CD7: 53 CB    MOV   [__r1],A
2CD9: 52 00    MOV   A,[X+0]
2CDB: 53 CC    MOV   [__r0],A
2CDD: 38 FE    ADD   SP,254
2CDF: 20       POP   X
2CE0: 7F       RET   
(1058) 	UnloadConfig_response2();
(1059) 	UnloadConfig_response3();
(1060) 	UnloadConfig_response4();
(1061) 	UnloadConfig_initial();
(1062) 	UnloadConfig_servo_transmit();
(1063) }
(1064) 
_servoFinder:
  flashWrite           --> X+7
  status_return_level  --> X+6
  total_attempts       --> X+4
  j                    --> X+2
  i                    --> X+0
2CE1: 10       PUSH  X
2CE2: 4F       MOV   X,SP
2CE3: 38 09    ADD   SP,9
(1065) // This function unloads the configuration corresponding to the config number passed to it.
(1066) // We do this instead of unloadAllConfigs to cut down on set up time.
2CE5: 56 01 00 MOV   [X+1],0
2CE8: 56 00 00 MOV   [X+0],0
(1067) void unloadConfig(int config_num)
2CEB: 56 03 00 MOV   [X+3],0
2CEE: 56 02 00 MOV   [X+2],0
(1068) {
(1069) 	if(config_num == WAIT)
2CF1: 56 05 00 MOV   [X+5],0
2CF4: 56 04 00 MOV   [X+4],0
(1070) 	{
(1071) 		UnloadConfig_waiting();
(1072) 	}
2CF7: 56 08 00 MOV   [X+8],0
2CFA: 56 07 00 MOV   [X+7],0
(1073) 	else if(config_num == HELLO_MODE)
(1074) 	{
(1075) 		UnloadConfig_hello();
2CFD: 56 06 03 MOV   [X+6],3
(1076) 	}
(1077) 	else if(config_num == MY_RESPONSE)
(1078) 	{
2D00: 62 D0 00 MOV   REG[208],0
2D03: 55 E6 FF MOV   [SERVO_ID],255
(1079) 		UnloadConfig_my_response();
(1080) 	}
(1081) 	else if(config_num == RESPONSE_1)
(1082) 	{
(1083) 		UnloadConfig_response1();
(1084) 	}
(1085) 	else if(config_num == RESPONSE_2)
(1086) 	{
(1087) 		UnloadConfig_response2();
2D06: 56 03 00 MOV   [X+3],0
2D09: 56 02 00 MOV   [X+2],0
(1088) 	}
(1089) 	else if(config_num == RESPONSE_3)
(1090) 	{
2D0C: 56 01 00 MOV   [X+1],0
2D0F: 56 00 00 MOV   [X+0],0
(1091) 		UnloadConfig_response3();
(1092) 	}
(1093) 	else if(config_num == RESPONSE_4)
2D12: 50 00    MOV   A,0
2D14: 08       PUSH  A
2D15: 08       PUSH  A
2D16: 50 01    MOV   A,1
2D18: 08       PUSH  A
2D19: 50 02    MOV   A,2
2D1B: 08       PUSH  A
2D1C: 50 FE    MOV   A,254
2D1E: 08       PUSH  A
2D1F: 91 8E    CALL  _servoInstruction
2D21: 38 FB    ADD   SP,251
(1094) 	{
(1095) 		UnloadConfig_response4();
2D23: 77 05    INC   [X+5]
2D25: 0F 04 00 ADC   [X+4],0
2D28: 80 4C    JMP   0x2D75
(1096) 	}
(1097) 	else if(config_num == INITIALIZE)
(1098) 	{
(1099) 		UnloadConfig_initial();
(1100) 	}
2D2A: 7C 23 0A LCALL _commandReady
2D2D: 62 D0 00 MOV   REG[208],0
2D30: 3C CC 00 CMP   [__r0],0
2D33: B0 06    JNZ   0x2D3A
2D35: 3C CB 00 CMP   [__r1],0
2D38: A0 3C    JZ    0x2D75
(1101) 	else if(config_num == SERVO_COMM)
(1102) 	{
(1103) 		UnloadConfig_servo_transmit();
2D3A: 62 D0 00 MOV   REG[208],0
2D3D: 3C E3 00 CMP   [COMMAND_SOURCE],0
2D40: C0 2B    JC    0x2D6C
2D42: 62 D0 00 MOV   REG[208],0
2D45: 50 FD    MOV   A,253
2D47: 3A E3    CMP   A,[COMMAND_SOURCE]
2D49: C0 22    JC    0x2D6C
(1104) 	}
(1105) }
(1106) 
2D4B: 62 D0 00 MOV   REG[208],0
2D4E: 55 D2 01 MOV   [TIMEOUT+1],1
2D51: 55 D1 00 MOV   [TIMEOUT],0
(1107) // This function responds that an ID has been assigned to it.
(1108) void assignedID(void)
2D54: 62 D0 00 MOV   REG[208],0
2D57: 51 E3    MOV   A,[COMMAND_SOURCE]
2D59: 62 D0 00 MOV   REG[208],0
2D5C: 53 E6    MOV   [SERVO_ID],A
(1109) {
(1110) 	configToggle(MY_RESPONSE);		// Switch to response mode.
2D5E: 56 01 0A MOV   [X+1],10
2D61: 56 00 00 MOV   [X+0],0
(1111) 	
(1112) 	// Transmit a ping to everyone.
2D64: 56 03 02 MOV   [X+3],2
2D67: 56 02 00 MOV   [X+2],0
(1113) 	TX_014_PutChar(START_TRANSMIT);	// Start byte one
2D6A: 80 0A    JMP   0x2D75
(1114) 	TX_23_PutChar(START_TRANSMIT);	// Start byte one
(1115) 	TX_014_PutChar(START_TRANSMIT);	// Start byte two
(1116) 	TX_23_PutChar(START_TRANSMIT);	// Start byte two
(1117) 	TX_014_PutChar(ID);				// My ID
2D6C: 62 D0 00 MOV   REG[208],0
2D6F: 55 D2 01 MOV   [TIMEOUT+1],1
2D72: 55 D1 00 MOV   [TIMEOUT],0
2D75: 62 D0 00 MOV   REG[208],0
2D78: 3C D1 00 CMP   [TIMEOUT],0
2D7B: B0 06    JNZ   0x2D82
2D7D: 3C D2 00 CMP   [TIMEOUT+1],0
2D80: AF A9    JZ    0x2D2A
2D82: 77 01    INC   [X+1]
2D84: 0F 00 00 ADC   [X+0],0
2D87: 52 01    MOV   A,[X+1]
2D89: 11 0A    SUB   A,10
2D8B: 52 00    MOV   A,[X+0]
2D8D: 31 80    XOR   A,128
2D8F: 19 80    SBB   A,128
2D91: CF 80    JC    0x2D12
(1118) 	TX_23_PutChar(ID);				// My ID
(1119) 	TX_014_PutChar(MASTER_ID);		// Destination ID (master)
(1120) 	TX_23_PutChar(MASTER_ID);		// Destination ID (master)
(1121) 	TX_014_PutChar(ID_ASSIGN_OK);	// This is an assignment ack response
(1122) 	TX_23_PutChar(ID_ASSIGN_OK);	// This is an assignment ack response
(1123) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1124) 	TX_23_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1125) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission
2D93: 62 D0 00 MOV   REG[208],0
2D96: 3C E6 FF CMP   [SERVO_ID],255
2D99: B0 22    JNZ   0x2DBC
2D9B: 3D 07 00 CMP   [X+7],0
2D9E: B0 1D    JNZ   0x2DBC
2DA0: 3D 08 00 CMP   [X+8],0
2DA3: B0 18    JNZ   0x2DBC
(1126) 	TX_23_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1127) 	
(1128) 	// Wait for the transmission to finish.
2DA5: 56 08 01 MOV   [X+8],1
2DA8: 56 07 00 MOV   [X+7],0
(1129) 	while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
(1130) 	while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
(1131) 	
(1132) 	// Make completely sure we're done.
2DAB: 50 00    MOV   A,0
2DAD: 08       PUSH  A
2DAE: 08       PUSH  A
2DAF: 50 06    MOV   A,6
2DB1: 08       PUSH  A
2DB2: 50 02    MOV   A,2
2DB4: 08       PUSH  A
2DB5: 50 FE    MOV   A,254
2DB7: 08       PUSH  A
2DB8: 90 F5    CALL  _servoInstruction
2DBA: 38 FB    ADD   SP,251
2DBC: 77 03    INC   [X+3]
2DBE: 0F 02 00 ADC   [X+2],0
2DC1: 52 03    MOV   A,[X+3]
2DC3: 11 02    SUB   A,2
2DC5: 52 02    MOV   A,[X+2]
2DC7: 31 80    XOR   A,128
2DC9: 19 80    SBB   A,128
2DCB: CF 40    JC    0x2D0C
(1133) 	xmitWait();
(1134) 	
(1135) 	configToggle(WAIT);				// Switch back to wait for a master response.
(1136) }
(1137) 
2DCD: 56 08 00 MOV   [X+8],0
2DD0: 56 07 00 MOV   [X+7],0
(1138) // This function listens for children and registers the port that they talk to.
(1139) int childListen(void)
(1140) {
(1141) 	configToggle(HELLO_MODE);	// Switch to listen for hellos on every port.
2DD3: 62 D0 00 MOV   REG[208],0
2DD6: 3C E6 FE CMP   [SERVO_ID],254
2DD9: D0 CD    JNC   0x2EA7
(1142) 	
(1143) 	// Wait to either hear a child or time out.
(1144) 	while(!TIMEOUT)
(1145) 	{		
(1146) 		if(commandReady())
(1147) 		{
2DDB: 56 03 00 MOV   [X+3],0
2DDE: 56 02 00 MOV   [X+2],0
(1148) 			return 1;
(1149) 		}
(1150) 	}
2DE1: 56 01 00 MOV   [X+1],0
2DE4: 56 00 00 MOV   [X+0],0
(1151) 	
(1152) 	HELLO_TIMEOUT_Stop();		// Stop the timer.
(1153) 	TIMEOUT = 0;				// Clear the timeout flag.
2DE7: 50 01    MOV   A,1
2DE9: 08       PUSH  A
2DEA: 50 10    MOV   A,16
2DEC: 08       PUSH  A
2DED: 50 02    MOV   A,2
2DEF: 08       PUSH  A
2DF0: 50 04    MOV   A,4
2DF2: 08       PUSH  A
2DF3: 62 D0 00 MOV   REG[208],0
2DF6: 51 E6    MOV   A,[SERVO_ID]
2DF8: 08       PUSH  A
2DF9: 90 B4    CALL  _servoInstruction
2DFB: 38 FB    ADD   SP,251
2DFD: 80 48    JMP   0x2E46
(1154) 	
(1155) 	configToggle(WAIT);			// Switch back to wait for a master response.
(1156) 	
(1157) 	return 0;					// Return the result of our listening session.
(1158) }
(1159) 
2DFF: 7C 23 0A LCALL _commandReady
2E02: 62 D0 00 MOV   REG[208],0
2E05: 3C CC 00 CMP   [__r0],0
2E08: B0 06    JNZ   0x2E0F
2E0A: 3C CB 00 CMP   [__r1],0
2E0D: A0 38    JZ    0x2E46
(1160) // This function waits for a child response.
(1161) int childResponse(void)
2E0F: 62 D0 00 MOV   REG[208],0
2E12: 3C DE 00 CMP   [COMMAND_ERROR],0
2E15: B0 30    JNZ   0x2E46
(1162) {
(1163) 	int child_responded = 0;
(1164) 	
2E17: 62 D0 00 MOV   REG[208],0
2E1A: 3C E0 01 CMP   [COMMAND_PARAM],1
2E1D: B0 1F    JNZ   0x2E3D
(1165) 	// Switch to the right port.
(1166) 	if(CHILD == PORT_A)
(1167) 	{
2E1F: 62 D0 00 MOV   REG[208],0
2E22: 55 D2 01 MOV   [TIMEOUT+1],1
2E25: 55 D1 00 MOV   [TIMEOUT],0
(1168) 		configToggle(RESPONSE_1);
(1169) 	}
2E28: 62 D0 00 MOV   REG[208],0
2E2B: 51 E0    MOV   A,[COMMAND_PARAM]
2E2D: 54 06    MOV   [X+6],A
(1170) 	else if(CHILD == PORT_B)
(1171) 	{
2E2F: 56 01 0A MOV   [X+1],10
2E32: 56 00 00 MOV   [X+0],0
(1172) 		configToggle(RESPONSE_2);
(1173) 	}
2E35: 56 03 02 MOV   [X+3],2
2E38: 56 02 00 MOV   [X+2],0
(1174) 	else if(CHILD == PORT_C)
2E3B: 80 0A    JMP   0x2E46
(1175) 	{
(1176) 		configToggle(RESPONSE_3);
(1177) 	}
(1178) 	else if(CHILD == PORT_D)
2E3D: 62 D0 00 MOV   REG[208],0
2E40: 55 D2 01 MOV   [TIMEOUT+1],1
2E43: 55 D1 00 MOV   [TIMEOUT],0
2E46: 62 D0 00 MOV   REG[208],0
2E49: 3C D1 00 CMP   [TIMEOUT],0
2E4C: B0 06    JNZ   0x2E53
2E4E: 3C D2 00 CMP   [TIMEOUT+1],0
2E51: AF AD    JZ    0x2DFF
2E53: 77 01    INC   [X+1]
2E55: 0F 00 00 ADC   [X+0],0
2E58: 52 01    MOV   A,[X+1]
2E5A: 11 0A    SUB   A,10
2E5C: 52 00    MOV   A,[X+0]
2E5E: 31 80    XOR   A,128
2E60: 19 80    SBB   A,128
2E62: CF 84    JC    0x2DE7
(1179) 	{
(1180) 		configToggle(RESPONSE_4);
(1181) 	}
(1182) 	
(1183) 	// Wait for a response or a timeout.
(1184) 	while((!child_responded) && (!TIMEOUT))
(1185) 	{
(1186) 		if(commandReady())
(1187) 		{
2E64: 3D 06 01 CMP   [X+6],1
2E67: A0 27    JZ    0x2E8F
2E69: 3D 07 00 CMP   [X+7],0
2E6C: B0 22    JNZ   0x2E8F
2E6E: 3D 08 00 CMP   [X+8],0
2E71: B0 1D    JNZ   0x2E8F
(1188) 			child_responded = 1;
(1189) 		}
2E73: 56 08 01 MOV   [X+8],1
2E76: 56 07 00 MOV   [X+7],0
(1190) 	}
(1191) 	
(1192) 	// Stop the right timer.
2E79: 50 01    MOV   A,1
2E7B: 08       PUSH  A
2E7C: 50 10    MOV   A,16
2E7E: 08       PUSH  A
2E7F: 50 03    MOV   A,3
2E81: 08       PUSH  A
2E82: 50 04    MOV   A,4
2E84: 08       PUSH  A
2E85: 62 D0 00 MOV   REG[208],0
2E88: 51 E6    MOV   A,[SERVO_ID]
2E8A: 08       PUSH  A
2E8B: 90 22    CALL  _servoInstruction
2E8D: 38 FB    ADD   SP,251
2E8F: 77 03    INC   [X+3]
2E91: 0F 02 00 ADC   [X+2],0
2E94: 52 03    MOV   A,[X+3]
2E96: 11 02    SUB   A,2
2E98: 52 02    MOV   A,[X+2]
2E9A: 31 80    XOR   A,128
2E9C: 19 80    SBB   A,128
2E9E: CF 42    JC    0x2DE1
(1193) 	if(CHILD == PORT_A)
(1194) 	{
(1195) 		CHILD_1_TIMEOUT_Stop();
(1196) 	}
2EA0: 3D 06 01 CMP   [X+6],1
2EA3: A0 05    JZ    0x2EA9
(1197) 	else if(CHILD == PORT_B)
(1198) 	{
(1199) 		CHILD_2_TIMEOUT_Stop();
2EA5: 8F FF    JMP   0x2EA5
(1200) 	}
(1201) 	else if(CHILD == PORT_C)
(1202) 	{
(1203) 		CHILD_3_TIMEOUT_Stop();
(1204) 	}
(1205) 	else if(CHILD == PORT_D)
2EA7: 8F FF    JMP   0x2EA7
(1206) 	{
(1207) 		CHILD_4_TIMEOUT_Stop();
(1208) 	}
(1209) 	
2EA9: 91 55    CALL  _servoConfigWait
2EAB: 38 F7    ADD   SP,247
2EAD: 20       POP   X
2EAE: 7F       RET   
(1210) 	TIMEOUT = 0;					// Reset the timeout flag.
(1211) 	
(1212) 	configToggle(WAIT);				// Switch back to wait for a master response.
(1213) 	
(1214) 	return child_responded;
(1215) }
_servoInstruction:
  checksum             --> X+0
  value                --> X-8
  address              --> X-7
  instruction          --> X-6
  length               --> X-5
  id                   --> X-4
2EAF: 10       PUSH  X
2EB0: 4F       MOV   X,SP
2EB1: 38 01    ADD   SP,1
(1216) 
(1217) // This function is used to find the servo that is directly connected to this module's controller.
(1218) // After the servo ID is found, the status return level is changed so that packets are only
(1219) // returned for the desired status return level defined at the top of this file.
2EB3: 50 00    MOV   A,0
2EB5: 08       PUSH  A
2EB6: 50 09    MOV   A,9
2EB8: 08       PUSH  A
2EB9: 7C 21 00 LCALL _configToggle
2EBC: 38 FE    ADD   SP,254
(1220) void servoFinder(void)
(1221) {				
(1222) 	// Index variables for incrementing and checking against the maximum servo comm attempts.
2EBE: 62 D0 00 MOV   REG[208],0
2EC1: 52 FB    MOV   A,[X-5]
2EC3: 53 CB    MOV   [__r1],A
2EC5: 55 CC 00 MOV   [__r0],0
2EC8: 52 FC    MOV   A,[X-4]
2ECA: 02 CB    ADD   A,[__r1]
2ECC: 53 CB    MOV   [__r1],A
2ECE: 50 00    MOV   A,0
2ED0: 0A CC    ADC   A,[__r0]
2ED2: 53 CC    MOV   [__r0],A
2ED4: 52 FA    MOV   A,[X-6]
2ED6: 04 CB    ADD   [__r1],A
2ED8: 0E CC 00 ADC   [__r0],0
2EDB: 52 F9    MOV   A,[X-7]
2EDD: 04 CB    ADD   [__r1],A
2EDF: 0E CC 00 ADC   [__r0],0
2EE2: 52 F8    MOV   A,[X-8]
2EE4: 04 CB    ADD   [__r1],A
2EE6: 0E CC 00 ADC   [__r0],0
2EE9: 50 01    MOV   A,1
2EEB: 08       PUSH  A
2EEC: 50 00    MOV   A,0
2EEE: 08       PUSH  A
2EEF: 51 CC    MOV   A,[__r0]
2EF1: 08       PUSH  A
2EF2: 51 CB    MOV   A,[__r1]
2EF4: 08       PUSH  A
2EF5: 7C 31 EC LCALL __divmod_16X16_16
2EF8: 38 FE    ADD   SP,254
2EFA: 18       POP   A
2EFB: 53 CB    MOV   [__r1],A
2EFD: 18       POP   A
2EFE: 50 FF    MOV   A,255
2F00: 12 CB    SUB   A,[__r1]
2F02: 54 00    MOV   [X+0],A
(1223) 	int i = 0;
(1224) 	int j = 0;
(1225) 	
2F04: 3D FA 01 CMP   [X-6],1
2F07: B0 2D    JNZ   0x2F35
(1226) 	int total_attempts = 0;
(1227) 	
2F09: 10       PUSH  X
2F0A: 50 FF    MOV   A,255
2F0C: 7C 10 0D LCALL 0x100D
2F0F: 20       POP   X
(1228) 	// Integer used as a flag so that EEPROM writes aren't done more than once.
2F10: 10       PUSH  X
2F11: 50 FF    MOV   A,255
2F13: 7C 10 0D LCALL 0x100D
2F16: 20       POP   X
(1229) 	int flashWrite = 0;
2F17: 10       PUSH  X
2F18: 52 FC    MOV   A,[X-4]
2F1A: 7C 10 0D LCALL 0x100D
2F1D: 20       POP   X
(1230) 	
2F1E: 10       PUSH  X
2F1F: 52 FB    MOV   A,[X-5]
2F21: 7C 10 0D LCALL 0x100D
2F24: 20       POP   X
(1231) 	// Create a status return level variable and set it to an out of range value initially.
2F25: 10       PUSH  X
2F26: 52 FA    MOV   A,[X-6]
2F28: 7C 10 0D LCALL 0x100D
2F2B: 20       POP   X
(1232) 	char status_return_level = 3;
2F2C: 10       PUSH  X
2F2D: 52 00    MOV   A,[X+0]
2F2F: 7C 10 0D LCALL 0x100D
2F32: 20       POP   X
(1233) 	
2F33: 80 39    JMP   0x2F6D
(1234) 	// Start with a servo ID of 255 (out of valid range).
(1235) 	SERVO_ID = SERVO_START;
(1236) 
2F35: 10       PUSH  X
2F36: 50 FF    MOV   A,255
2F38: 7C 10 0D LCALL 0x100D
2F3B: 20       POP   X
(1237) 	// This for loop will loop SERVO_COMM_LOOPS number of times and ping the servo SERVO_COMM_ATTEMPTS
2F3C: 10       PUSH  X
2F3D: 50 FF    MOV   A,255
2F3F: 7C 10 0D LCALL 0x100D
2F42: 20       POP   X
(1238) 	// number of times in each loop (unless stopped short due to early success).  If this fails for the
2F43: 10       PUSH  X
2F44: 52 FC    MOV   A,[X-4]
2F46: 7C 10 0D LCALL 0x100D
2F49: 20       POP   X
(1239) 	// first round of pings, a broadcast reset will be performed to reset the servo.  This is done
2F4A: 10       PUSH  X
2F4B: 52 FB    MOV   A,[X-5]
2F4D: 7C 10 0D LCALL 0x100D
2F50: 20       POP   X
(1240) 	// because we assume that the baud rate is matching up, but the servo's return delay time is too
2F51: 10       PUSH  X
2F52: 52 FA    MOV   A,[X-6]
2F54: 7C 10 0D LCALL 0x100D
2F57: 20       POP   X
(1241) 	// fast for the controller to switch into receive mode to read the response.  The default return
2F58: 10       PUSH  X
2F59: 52 F9    MOV   A,[X-7]
2F5B: 7C 10 0D LCALL 0x100D
2F5E: 20       POP   X
(1242) 	// delay time is 500 microseconds. If we loop for SERVO_COMM_LOOPS number of times and still don't
2F5F: 10       PUSH  X
2F60: 52 F8    MOV   A,[X-8]
2F62: 7C 10 0D LCALL 0x100D
2F65: 20       POP   X
(1243) 	// see anything, we assume that there is something is too wrong for us to fix.
2F66: 10       PUSH  X
2F67: 52 00    MOV   A,[X+0]
2F69: 7C 10 0D LCALL 0x100D
2F6C: 20       POP   X
(1244) 	for(j = 0; j < SERVO_COMM_LOOPS; j++)
(1245) 	{	
(1246) 		// Ping SERVO_COMM_ATTEMPTS times to try and extract the servo ID.
(1247) 		for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
2F6D: 10       PUSH  X
2F6E: 7C 0F E0 LCALL 0x0FE0
2F71: 62 D0 00 MOV   REG[208],0
2F74: 20       POP   X
2F75: 53 CC    MOV   [__r0],A
2F77: 47 CC 20 TST   [__r0],32
2F7A: AF F2    JZ    0x2F6D
(1248) 		{
(1249) 			// Send a ping out for any servo connected to me (will only be one).
(1250) 			servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
2F7C: 90 0F    CALL  _xmitWait
(1251) 			
(1252) 			total_attempts++;
(1253) 			
2F7E: 50 00    MOV   A,0
2F80: 08       PUSH  A
2F81: 50 08    MOV   A,8
2F83: 08       PUSH  A
2F84: 7C 21 00 LCALL _configToggle
2F87: 38 FE    ADD   SP,254
2F89: 38 FF    ADD   SP,255
2F8B: 20       POP   X
2F8C: 7F       RET   
(1254) 			// Wait for either a timeout or a valid servo ID (which will trigger a timeout).
(1255) 			while(!TIMEOUT)
(1256) 			{	
(1257) 				if(commandReady())
_xmitWait:
  i                    --> X+0
2F8D: 10       PUSH  X
2F8E: 4F       MOV   X,SP
2F8F: 38 02    ADD   SP,2
(1258) 				{
(1259) 					// If we read a source ID within the range, exit the loop.
(1260) 					if((COMMAND_SOURCE >= SERVO_ID_MIN) && (COMMAND_SOURCE <= SERVO_ID_MAX))
2F91: 56 01 00 MOV   [X+1],0
2F94: 56 00 00 MOV   [X+0],0
2F97: 77 01    INC   [X+1]
2F99: 0F 00 00 ADC   [X+0],0
2F9C: 52 01    MOV   A,[X+1]
2F9E: 11 19    SUB   A,25
2FA0: 52 00    MOV   A,[X+0]
2FA2: 31 80    XOR   A,128
2FA4: 19 80    SBB   A,128
2FA6: CF F0    JC    0x2F97
2FA8: 38 FE    ADD   SP,254
2FAA: 20       POP   X
2FAB: 7F       RET   
(1261) 					{	
(1262) 						// Exit this while loop by setting the timeout flag.
(1263) 						TIMEOUT = 1;
(1264) 						// Set the servo ID variable to where the ping came from.
(1265) 						SERVO_ID = COMMAND_SOURCE;
(1266) 						// Set the index variable such that the for loop exits.
(1267) 						i = SERVO_COMM_ATTEMPTS;
(1268) 						// Set the outer index variable to 2 to not attempt again for no reason.
(1269) 						j = SERVO_COMM_LOOPS;
(1270) 					}
_servoBootWait:
  i                    --> X+0
2FAC: 10       PUSH  X
2FAD: 4F       MOV   X,SP
2FAE: 38 02    ADD   SP,2
(1271) 					else
2FB0: 56 01 00 MOV   [X+1],0
2FB3: 56 00 00 MOV   [X+0],0
(1272) 					{
(1273) 						// Exit this while loop and try to ping again.
2FB6: 50 00    MOV   A,0
2FB8: 08       PUSH  A
2FB9: 50 08    MOV   A,8
2FBB: 08       PUSH  A
2FBC: 7C 21 00 LCALL _configToggle
2FBF: 38 FE    ADD   SP,254
(1274) 						TIMEOUT = 1;
(1275) 					}
(1276) 				}
2FC1: 56 01 00 MOV   [X+1],0
2FC4: 56 00 00 MOV   [X+0],0
(1277) 			}
(1278) 		}
2FC7: 62 D0 00 MOV   REG[208],0
2FCA: 3C D1 00 CMP   [TIMEOUT],0
2FCD: B0 06    JNZ   0x2FD4
2FCF: 3C D2 00 CMP   [TIMEOUT+1],0
2FD2: AF F4    JZ    0x2FC7
(1279) 		
2FD4: 62 D0 00 MOV   REG[208],0
2FD7: 55 D2 00 MOV   [TIMEOUT+1],0
2FDA: 55 D1 00 MOV   [TIMEOUT],0
2FDD: 77 01    INC   [X+1]
2FDF: 0F 00 00 ADC   [X+0],0
2FE2: 52 01    MOV   A,[X+1]
2FE4: 11 4B    SUB   A,75
2FE6: 52 00    MOV   A,[X+0]
2FE8: 31 80    XOR   A,128
2FEA: 19 80    SBB   A,128
2FEC: CF DA    JC    0x2FC7
(1280) 		// If we didn't get a response and haven't written to the flash of the
(1281) 		// servo (first time through), send out a broadcast reset.
(1282) 		if((SERVO_ID == SERVO_START) && (!flashWrite))
2FEE: 10       PUSH  X
2FEF: 7C 11 F7 LCALL 0x11F7
2FF2: 20       POP   X
(1283) 		{
2FF3: 62 D0 00 MOV   REG[208],0
2FF6: 55 D2 00 MOV   [TIMEOUT+1],0
2FF9: 55 D1 00 MOV   [TIMEOUT],0
2FFC: 38 FE    ADD   SP,254
2FFE: 20       POP   X
2FFF: 7F       RET   
(1284) 			// Set the flash write flag so that we only do this once per power cycle.
(1285) 			flashWrite = 1;
(1286) 			
(1287) 			// Send out a broadcast reset so that we know that the response time interval
(1288) 			// is large enough (default delay time for a servo is 500 microseconds).
(1289) 			servoInstruction(BROADCAST, RESET_LENGTH, RESET_SERVO, 0, 0);
_servoConfigWait:
  i                    --> X+0
3000: 10       PUSH  X
3001: 4F       MOV   X,SP
3002: 38 02    ADD   SP,2
(1290) 		}
3004: 56 01 00 MOV   [X+1],0
3007: 56 00 00 MOV   [X+0],0
(1291) 	}
(1292) 
300A: 50 00    MOV   A,0
300C: 08       PUSH  A
300D: 50 08    MOV   A,8
300F: 08       PUSH  A
3010: 7C 21 00 LCALL _configToggle
3013: 38 FE    ADD   SP,254
(1293) 	// Reset flash write flag.
(1294) 	flashWrite = 0;
(1295) 	
(1296) 	// If we have a valid servo ID, set the status return level.  If we don't, just skip this
(1297) 	// because all hope is lost.
3015: 56 01 00 MOV   [X+1],0
3018: 56 00 00 MOV   [X+0],0
(1298) 	if(SERVO_ID < BROADCAST)
(1299) 	{
301B: 62 D0 00 MOV   REG[208],0
301E: 3C D1 00 CMP   [TIMEOUT],0
3021: B0 06    JNZ   0x3028
3023: 3C D2 00 CMP   [TIMEOUT+1],0
3026: AF F4    JZ    0x301B
(1300) 		// This for loop will loop SERVO_COMM_LOOPS number of times and poll for the servo's status
3028: 62 D0 00 MOV   REG[208],0
302B: 55 D2 00 MOV   [TIMEOUT+1],0
302E: 55 D1 00 MOV   [TIMEOUT],0
3031: 77 01    INC   [X+1]
3033: 0F 00 00 ADC   [X+0],0
3036: 52 01    MOV   A,[X+1]
3038: 11 14    SUB   A,20
303A: 52 00    MOV   A,[X+0]
303C: 31 80    XOR   A,128
303E: 19 80    SBB   A,128
3040: CF DA    JC    0x301B
(1301) 		// return level SERVO_COMM_ATTEMPTS number of times in each loop (unless stopped short due
(1302) 		// to early success).  If this fails for the first iteration, or we read a status return level
(1303) 		// other than what we want, we will attempt to write the desired status return level onto the servo.
3042: 10       PUSH  X
3043: 7C 11 F7 LCALL 0x11F7
3046: 20       POP   X
(1304) 		for(j = 0; j < SERVO_COMM_LOOPS; j++)
3047: 62 D0 00 MOV   REG[208],0
304A: 55 D2 00 MOV   [TIMEOUT+1],0
304D: 55 D1 00 MOV   [TIMEOUT],0
(1305) 		{
(1306) 			// Attempt to read the status return level for the defined number of attempts.
3050: 50 00    MOV   A,0
3052: 08       PUSH  A
3053: 50 01    MOV   A,1
3055: 08       PUSH  A
3056: 7C 21 00 LCALL _configToggle
3059: 38 FE    ADD   SP,254
305B: 38 FE    ADD   SP,254
305D: 20       POP   X
305E: 7F       RET   
(1307) 			for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
(1308) 			{
(1309) 				// Send a request for the servo's status return level.
(1310) 				servoInstruction(SERVO_ID, READ_LENGTH, READ_SERVO, STATUS_RET_ADDRESS, 1);
(1311) 				
(1312) 				// Wait for either a timeout or an indication that we want to exit the loop.
(1313) 				while(!TIMEOUT)
(1314) 				{
_TX_01234_TIMEOUT_ISR:
305F: 71 C0    OR    F,192
3061: 08       PUSH  A
3062: 5D D0    MOV   A,REG[208]
3064: 08       PUSH  A
(1315) 					// If a valid command is ready, interpret it.
3065: 62 D0 00 MOV   REG[208],0
3068: 55 D2 01 MOV   [TIMEOUT+1],1
306B: 55 D1 00 MOV   [TIMEOUT],0
(1316) 					if(commandReady())
306E: 62 DA FD MOV   REG[218],253
3071: 18       POP   A
3072: 60 D0    MOV   REG[208],A
3074: 18       POP   A
3075: 7E       RETI  
(1317) 					{
(1318) 						if(!COMMAND_ERROR)
(1319) 						{
(1320) 							// If the return level is equal to what is desired, store it.
(1321) 							if(COMMAND_PARAM == STATUS_RET_LEVEL)
_HELLO_TIMEOUT_ISR:
3076: 71 C0    OR    F,192
3078: 08       PUSH  A
3079: 5D D0    MOV   A,REG[208]
307B: 08       PUSH  A
(1322) 							{
307C: 62 D0 00 MOV   REG[208],0
307F: 55 D2 01 MOV   [TIMEOUT+1],1
3082: 55 D1 00 MOV   [TIMEOUT],0
(1323) 								// Set the timeout flag to exit the loop.
3085: 62 DA FD MOV   REG[218],253
3088: 18       POP   A
3089: 60 D0    MOV   REG[208],A
308B: 18       POP   A
308C: 7E       RETI  
(1324) 								TIMEOUT = 1;
(1325) 								// Store the status return level.
(1326) 								status_return_level = COMMAND_PARAM;
(1327) 								// Set i so that we exit the for loop.
(1328) 								i = SERVO_COMM_ATTEMPTS;
_CHILD_1_TIMEOUT_ISR:
308D: 71 C0    OR    F,192
308F: 08       PUSH  A
3090: 5D D0    MOV   A,REG[208]
3092: 08       PUSH  A
(1329) 								// Set the outer loop's variable so that we don't loop again.
3093: 62 D0 00 MOV   REG[208],0
3096: 55 D2 01 MOV   [TIMEOUT+1],1
3099: 55 D1 00 MOV   [TIMEOUT],0
(1330) 								j = SERVO_COMM_LOOPS;
309C: 62 DA FD MOV   REG[218],253
309F: 18       POP   A
30A0: 60 D0    MOV   REG[208],A
30A2: 18       POP   A
30A3: 7E       RETI  
(1331) 							}
(1332) 							else
(1333) 							{	
(1334) 								// Set the timeout flag to exit the loop.
_CHILD_2_TIMEOUT_ISR:
30A4: 71 C0    OR    F,192
30A6: 08       PUSH  A
30A7: 5D D0    MOV   A,REG[208]
30A9: 08       PUSH  A
(1335) 								TIMEOUT = 1;
30AA: 62 D0 00 MOV   REG[208],0
30AD: 55 D2 01 MOV   [TIMEOUT+1],1
30B0: 55 D1 00 MOV   [TIMEOUT],0
(1336) 							}
30B3: 62 DA FD MOV   REG[218],253
30B6: 18       POP   A
30B7: 60 D0    MOV   REG[208],A
30B9: 18       POP   A
30BA: 7E       RETI  
(1337) 						}
(1338) 					}
(1339) 				}
(1340) 			}
_CHILD_3_TIMEOUT_ISR:
30BB: 71 C0    OR    F,192
30BD: 08       PUSH  A
30BE: 5D D0    MOV   A,REG[208]
30C0: 08       PUSH  A
(1341) 		
30C1: 62 D0 00 MOV   REG[208],0
30C4: 55 D2 01 MOV   [TIMEOUT+1],1
30C7: 55 D1 00 MOV   [TIMEOUT],0
(1342) 			// If we didn't get a good response and haven't written to the flash of the servo,
30CA: 62 DA FD MOV   REG[218],253
30CD: 18       POP   A
30CE: 60 D0    MOV   REG[208],A
30D0: 18       POP   A
30D1: 7E       RETI  
(1343) 			// force a change in the status return level with an EEPROM write.
(1344) 			if((status_return_level != STATUS_RET_LEVEL) && (!flashWrite))
(1345) 			{	
(1346) 				flashWrite = 1;
_CHILD_4_TIMEOUT_ISR:
30D2: 71 C0    OR    F,192
30D4: 08       PUSH  A
30D5: 5D D0    MOV   A,REG[208]
30D7: 08       PUSH  A
(1347) 				
30D8: 62 D0 00 MOV   REG[208],0
30DB: 55 D2 01 MOV   [TIMEOUT+1],1
30DE: 55 D1 00 MOV   [TIMEOUT],0
(1348) 				// Try to force the return status to what we want.
30E1: 62 DA FD MOV   REG[218],253
30E4: 18       POP   A
30E5: 60 D0    MOV   REG[208],A
30E7: 18       POP   A
30E8: 7E       RETI  
(1349) 				servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, STATUS_RET_ADDRESS, STATUS_RET_LEVEL);
(1350) 			}
(1351) 		}
(1352) 		
_INIT_TIMEOUT_ISR:
30E9: 71 C0    OR    F,192
30EB: 08       PUSH  A
30EC: 5D D0    MOV   A,REG[208]
30EE: 08       PUSH  A
(1353) 		if(status_return_level != STATUS_RET_LEVEL)
30EF: 62 D0 00 MOV   REG[208],0
30F2: 55 D2 01 MOV   [TIMEOUT+1],1
30F5: 55 D1 00 MOV   [TIMEOUT],0
(1354) 		{
30F8: 62 DA FD MOV   REG[218],253
30FB: 18       POP   A
30FC: 60 D0    MOV   REG[208],A
30FE: 18       POP   A
30FF: 7E       RETI  

FILE: lib\psocdynamicint.asm
                                   (0001) ; Generated by PSoC Designer 5.0.985.0
                                   (0002) ;
                                   (0003) ;
                                   (0004) ;  thesis_revoluteINT.asm
                                   (0005) ;
                                   (0006) ;  Data: 29 October, 2001
                                   (0007) ;  Copyright Cypress MicroSystems 2001
                                   (0008) ;
                                   (0009) ;  This file is generated by the Device Editor on Application Generation.
                                   (0010) ;  It contains dispatch code that ensures that interrupt vectors are 
                                   (0011) ;  serviced by the appropriate ISR depending on the currently active
                                   (0012) ;  configuration.
                                   (0013) ;  
                                   (0014) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0015) ;  Edits to this file will not be preserved.
                                   (0016) ;
                                   (0017) include "PSoCDynamic.inc"
                                   (0018) include "m8c.inc"
                                   (0019) export	Dispatch_INTERRUPT_10
                                   (0020) export	Dispatch_INTERRUPT_11
                                   (0021) export	Dispatch_INTERRUPT_9
                                   (0022) 
                                   (0023) 
                                   (0024) Dispatch_INTERRUPT_10:
3100: 08       PUSH  A             (0025) 	push	a
3101: 50 00    MOV   A,0           (0026) 	mov		a,0
3103: 47 04 02 TST   [4],2         (0027) 	tst		[ACTIVE_CONFIG_STATUS+hello_ADDR_OFF], hello_BIT
3106: B0 3D    JNZ   0x3144        (0028) 	jnz		Dispatch_INTERRUPT_10_END
3108: 50 04    MOV   A,4           (0029) 	mov		a,4
310A: 47 04 04 TST   [4],4         (0030) 	tst		[ACTIVE_CONFIG_STATUS+initial_ADDR_OFF], initial_BIT
310D: B0 36    JNZ   0x3144        (0031) 	jnz		Dispatch_INTERRUPT_10_END
310F: 50 08    MOV   A,8           (0032) 	mov		a,8
3111: 47 04 08 TST   [4],8         (0033) 	tst		[ACTIVE_CONFIG_STATUS+my_response_ADDR_OFF], my_response_BIT
3114: B0 2F    JNZ   0x3144        (0034) 	jnz		Dispatch_INTERRUPT_10_END
3116: 50 0C    MOV   A,12          (0035) 	mov		a,12
3118: 47 04 10 TST   [4],16        (0036) 	tst		[ACTIVE_CONFIG_STATUS+response1_ADDR_OFF], response1_BIT
311B: B0 28    JNZ   0x3144        (0037) 	jnz		Dispatch_INTERRUPT_10_END
311D: 50 10    MOV   A,16          (0038) 	mov		a,16
311F: 47 04 20 TST   [4],32        (0039) 	tst		[ACTIVE_CONFIG_STATUS+response2_ADDR_OFF], response2_BIT
3122: B0 21    JNZ   0x3144        (0040) 	jnz		Dispatch_INTERRUPT_10_END
3124: 50 14    MOV   A,20          (0041) 	mov		a,20
3126: 47 04 40 TST   [4],64        (0042) 	tst		[ACTIVE_CONFIG_STATUS+response3_ADDR_OFF], response3_BIT
3129: B0 1A    JNZ   0x3144        (0043) 	jnz		Dispatch_INTERRUPT_10_END
312B: 50 18    MOV   A,24          (0044) 	mov		a,24
312D: 47 04 80 TST   [4],128       (0045) 	tst		[ACTIVE_CONFIG_STATUS+response4_ADDR_OFF], response4_BIT
3130: B0 13    JNZ   0x3144        (0046) 	jnz		Dispatch_INTERRUPT_10_END
3132: 50 1C    MOV   A,28          (0047) 	mov		a,28
3134: 47 05 01 TST   [5],1         (0048) 	tst		[ACTIVE_CONFIG_STATUS+servo_transmit_ADDR_OFF], servo_transmit_BIT
3137: B0 0C    JNZ   0x3144        (0049) 	jnz		Dispatch_INTERRUPT_10_END
3139: 50 20    MOV   A,32          (0050) 	mov		a,32
313B: 47 04 01 TST   [4],1         (0051) 	tst		[ACTIVE_CONFIG_STATUS+waiting_ADDR_OFF], waiting_BIT
313E: B0 05    JNZ   0x3144        (0052) 	jnz		Dispatch_INTERRUPT_10_END
3140: 18       POP   A             (0053) 	pop		a
3141: 7E       RETI                (0054) 	reti
                                   (0055) ; Stop Code Compressor from breaking table alignment
                                   (0056) ; The next instruction does not get executed.
3142: 71 00    OR    F,0           (0057) 	Suspend_CodeCompressor
                                   (0058) Dispatch_INTERRUPT_10_END:
3144: E0 01    JACC  0x3146        (0059) 	jacc	Dispatch_INTERRUPT_10_TBL
                                   (0060) Dispatch_INTERRUPT_10_TBL:
3146: 18       POP   A             (0061) 	pop		a
3147: 7D 18 0F LJMP  0x180F        (0062) 	ljmp	_HELLO_1_ISR
314A: 18       POP   A             (0063) 	pop		a
314B: 7D 12 4B LJMP  0x124B        (0064) 	ljmp	_INIT_RX_ISR
314E: 18       POP   A             (0065) 	pop		a
314F: 7D 0E 80 LJMP  0x0E80        (0066) 	ljmp	_TX_014_ISR
3152: 18       POP   A             (0067) 	pop		a
3153: 7D 1E 93 LJMP  0x1E93        (0068) 	ljmp	_CHILD_1_ISR
3156: 18       POP   A             (0069) 	pop		a
3157: 7D 1C DA LJMP  0x1CDA        (0070) 	ljmp	_CHILD_2_ISR
315A: 18       POP   A             (0071) 	pop		a
315B: 7D 1B 21 LJMP  0x1B21        (0072) 	ljmp	_CHILD_3_ISR
315E: 18       POP   A             (0073) 	pop		a
315F: 7D 19 68 LJMP  0x1968        (0074) 	ljmp	_CHILD_4_ISR
3162: 18       POP   A             (0075) 	pop		a
3163: 7D 0F B9 LJMP  0x0FB9        (0076) 	ljmp	_SERVO_TX_ISR
3166: 18       POP   A             (0077) 	pop		a
3167: 7D 0C 4E LJMP  0x0C4E        (0078) 	ljmp	_WAIT_RECV_ISR
                                   (0079) ; Resume Code Compressor.
                                   (0080) ; The next instruction does not get executed.
316A: 38 00    ADD   SP,0          (0081) 	Resume_CodeCompressor
                                   (0082) 
                                   (0083) Dispatch_INTERRUPT_11:
316C: 08       PUSH  A             (0084) 	push	a
316D: 50 00    MOV   A,0           (0085) 	mov		a,0
316F: 47 04 02 TST   [4],2         (0086) 	tst		[ACTIVE_CONFIG_STATUS+hello_ADDR_OFF], hello_BIT
3172: B0 13    JNZ   0x3186        (0087) 	jnz		Dispatch_INTERRUPT_11_END
3174: 50 04    MOV   A,4           (0088) 	mov		a,4
3176: 47 04 08 TST   [4],8         (0089) 	tst		[ACTIVE_CONFIG_STATUS+my_response_ADDR_OFF], my_response_BIT
3179: B0 0C    JNZ   0x3186        (0090) 	jnz		Dispatch_INTERRUPT_11_END
317B: 50 08    MOV   A,8           (0091) 	mov		a,8
317D: 47 04 01 TST   [4],1         (0092) 	tst		[ACTIVE_CONFIG_STATUS+waiting_ADDR_OFF], waiting_BIT
3180: B0 05    JNZ   0x3186        (0093) 	jnz		Dispatch_INTERRUPT_11_END
3182: 18       POP   A             (0094) 	pop		a
3183: 7E       RETI                (0095) 	reti
                                   (0096) ; Stop Code Compressor from breaking table alignment
                                   (0097) ; The next instruction does not get executed.
3184: 71 00    OR    F,0           (0098) 	Suspend_CodeCompressor
                                   (0099) Dispatch_INTERRUPT_11_END:
3186: E0 01    JACC  0x3188        (0100) 	jacc	Dispatch_INTERRUPT_11_TBL
                                   (0101) Dispatch_INTERRUPT_11_TBL:
3188: 18       POP   A             (0102) 	pop		a
3189: 7D 16 B6 LJMP  0x16B6        (0103) 	ljmp	_HELLO_2_ISR
318C: 18       POP   A             (0104) 	pop		a
318D: 7D 0D A7 LJMP  0x0DA7        (0105) 	ljmp	_TX_23_ISR
3190: 18       POP   A             (0106) 	pop		a
3191: 7D 10 92 LJMP  0x1092        (0107) 	ljmp	_RX8_2_ISR
                                   (0108) ; Resume Code Compressor.
                                   (0109) ; The next instruction does not get executed.
3194: 38 00    ADD   SP,0          (0110) 	Resume_CodeCompressor
                                   (0111) 
                                   (0112) Dispatch_INTERRUPT_9:
3196: 08       PUSH  A             (0113) 	push	a
3197: 50 00    MOV   A,0           (0114) 	mov		a,0
3199: 47 04 02 TST   [4],2         (0115) 	tst		[ACTIVE_CONFIG_STATUS+hello_ADDR_OFF], hello_BIT
319C: B0 2F    JNZ   0x31CC        (0116) 	jnz		Dispatch_INTERRUPT_9_END
319E: 50 04    MOV   A,4           (0117) 	mov		a,4
31A0: 47 04 04 TST   [4],4         (0118) 	tst		[ACTIVE_CONFIG_STATUS+initial_ADDR_OFF], initial_BIT
31A3: B0 28    JNZ   0x31CC        (0119) 	jnz		Dispatch_INTERRUPT_9_END
31A5: 50 08    MOV   A,8           (0120) 	mov		a,8
31A7: 47 04 08 TST   [4],8         (0121) 	tst		[ACTIVE_CONFIG_STATUS+my_response_ADDR_OFF], my_response_BIT
31AA: B0 21    JNZ   0x31CC        (0122) 	jnz		Dispatch_INTERRUPT_9_END
31AC: 50 0C    MOV   A,12          (0123) 	mov		a,12
31AE: 47 04 10 TST   [4],16        (0124) 	tst		[ACTIVE_CONFIG_STATUS+response1_ADDR_OFF], response1_BIT
31B1: B0 1A    JNZ   0x31CC        (0125) 	jnz		Dispatch_INTERRUPT_9_END
31B3: 50 10    MOV   A,16          (0126) 	mov		a,16
31B5: 47 04 20 TST   [4],32        (0127) 	tst		[ACTIVE_CONFIG_STATUS+response2_ADDR_OFF], response2_BIT
31B8: B0 13    JNZ   0x31CC        (0128) 	jnz		Dispatch_INTERRUPT_9_END
31BA: 50 14    MOV   A,20          (0129) 	mov		a,20
31BC: 47 04 40 TST   [4],64        (0130) 	tst		[ACTIVE_CONFIG_STATUS+response3_ADDR_OFF], response3_BIT
31BF: B0 0C    JNZ   0x31CC        (0131) 	jnz		Dispatch_INTERRUPT_9_END
31C1: 50 18    MOV   A,24          (0132) 	mov		a,24
31C3: 47 04 80 TST   [4],128       (0133) 	tst		[ACTIVE_CONFIG_STATUS+response4_ADDR_OFF], response4_BIT
31C6: B0 05    JNZ   0x31CC        (0134) 	jnz		Dispatch_INTERRUPT_9_END
31C8: 18       POP   A             (0135) 	pop		a
31C9: 7E       RETI                (0136) 	reti
                                   (0137) ; Stop Code Compressor from breaking table alignment
                                   (0138) ; The next instruction does not get executed.
31CA: 71 00    OR    F,0           (0139) 	Suspend_CodeCompressor
                                   (0140) Dispatch_INTERRUPT_9_END:
31CC: E0 01    JACC  0x31CE        (0141) 	jacc	Dispatch_INTERRUPT_9_TBL
                                   (0142) Dispatch_INTERRUPT_9_TBL:
31CE: 18       POP   A             (0143) 	pop		a
31CF: 7D 30 76 LJMP  _HELLO_TIMEOUT_ISR(0144) 	ljmp	_HELLO_TIMEOUT_ISR
31D2: 18       POP   A             (0145) 	pop		a
31D3: 7D 30 E9 LJMP  _INIT_TIMEOUT_ISR(0146) 	ljmp	_INIT_TIMEOUT_ISR
31D6: 18       POP   A             (0147) 	pop		a
31D7: 7D 30 5F LJMP  _TX_01234_TIMEOUT_ISR(0148) 	ljmp	_TX_01234_TIMEOUT_ISR
31DA: 18       POP   A             (0149) 	pop		a
31DB: 7D 30 8D LJMP  _CHILD_1_TIMEOUT_ISR(0150) 	ljmp	_CHILD_1_TIMEOUT_ISR
31DE: 18       POP   A             (0151) 	pop		a
31DF: 7D 30 A4 LJMP  _CHILD_2_TIMEOUT_ISR(0152) 	ljmp	_CHILD_2_TIMEOUT_ISR
31E2: 18       POP   A             (0153) 	pop		a
31E3: 7D 30 BB LJMP  _CHILD_3_TIMEOUT_ISR(0154) 	ljmp	_CHILD_3_TIMEOUT_ISR
31E6: 18       POP   A             (0155) 	pop		a
31E7: 7D 30 D2 LJMP  _CHILD_4_TIMEOUT_ISR(0156) 	ljmp	_CHILD_4_TIMEOUT_ISR
                                   (0157) ; Resume Code Compressor.
                                   (0158) ; The next instruction does not get executed.
                                   (0159) 	Resume_CodeCompressor

FILE: <library>
--------------------------------------------------------------------------------


PSoC Designer Version: 5.0.985.0

Copyright (C) 1994 - 2009 ImageCraft Creations Inc.
ImageCraft, 706 Colorado Ave., Suite 10-88, Palo Alto, CA 94303
info@imagecraft.com, phone (650) 493-9326 FAX (650) 493-9329
http://www.imagecraft.com
lcc source code (C) 1995, by David R. Hanson and AT&T. Reproduced by permission.
Release version 7.01
