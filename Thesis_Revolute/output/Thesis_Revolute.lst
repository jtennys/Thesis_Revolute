0000: 80 7F    JMP   0x0080
0002: 30       HALT  
0003: 30       HALT  

FILE: .\boot.asm
                                   (0117) ; Generated by PSoC Designer 5.0.985.0
                                   (0118) ;
                                   (0119) ;@Id: boot.tpl#884 @
0004: 30       HALT                (0120) ;=============================================================================
0005: 30       HALT  
0006: 30       HALT  
0007: 30       HALT  
                                   (0121) ;  FILENAME:   boot.asm
                                   (0122) ;  VERSION:    1.00
                                   (0123) ;  DATE:       05 March 2009
0008: 7E       RETI                (0124) ;
0009: 30       HALT  
000A: 30       HALT  
000B: 30       HALT  
                                   (0125) ;  DESCRIPTION:
                                   (0126) ;  M8C Boot Code for CY8C28xxx microcontroller devices.
                                   (0127) ;
000C: 7E       RETI                (0128) ;  Copyright (C) Cypress Semiconductors 2009. All rights reserved.
000D: 30       HALT  
000E: 30       HALT  
000F: 30       HALT  
                                   (0129) ;
                                   (0130) ; NOTES:
                                   (0131) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
0010: 7E       RETI                (0132) ; the project's root directory to create BOOT.ASM. Any changes made to
0011: 30       HALT  
0012: 30       HALT  
0013: 30       HALT  
                                   (0133) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                   (0134) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                   (0135) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
0014: 7E       RETI                (0136) ; are not accidentally modified.
0015: 30       HALT  
0016: 30       HALT  
0017: 30       HALT  
                                   (0137) ;
                                   (0138) ;=============================================================================
                                   (0139) 
0018: 7E       RETI                (0140) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
0019: 30       HALT  
001A: 30       HALT  
001B: 30       HALT  
                                   (0141) include "m8c.inc"			;Part specific file
                                   (0142) include "m8ssc.inc"			;Part specific file
                                   (0143) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
001C: 7E       RETI                (0144) 
001D: 30       HALT  
001E: 30       HALT  
001F: 30       HALT  
                                   (0145) ;--------------------------------------
                                   (0146) ; Export Declarations
                                   (0147) ;--------------------------------------
0020: 7E       RETI                (0148) 
0021: 30       HALT  
0022: 30       HALT  
0023: 30       HALT  
                                   (0149) export __Start
                                   (0150) IF	(TOOLCHAIN & HITECH)
0024: 7D 31 C9 LJMP  Dispatch_INTERRUPT_9(0151) ELSE
0027: 7E       RETI                (0152) export __bss_start
                                   (0153) export __data_start
                                   (0154) export __idata_start
0028: 7D 31 33 LJMP  Dispatch_INTERRUPT_10(0155) export __func_lit_start
002B: 7E       RETI                (0156) export __text_start
                                   (0157) ENDIF
                                   (0158) export  _bGetPowerSetting
002C: 7D 31 9F LJMP  Dispatch_INTERRUPT_11(0159) export   bGetPowerSetting	
002F: 7E       RETI                (0160) 
                                   (0161) 
                                   (0162) ;--------------------------------------
                                   (0163) ; Optimization flags
0030: 7E       RETI                (0164) ;--------------------------------------
0031: 30       HALT  
0032: 30       HALT  
0033: 30       HALT  
                                   (0165) ;
                                   (0166) ; To change the value of these flags, modify the file boot.tpl, not
                                   (0167) ; boot.asm. See the notes in the banner comment at the beginning of
0034: 7E       RETI                (0168) ; this file.
0035: 30       HALT  
0036: 30       HALT  
0037: 30       HALT  
                                   (0169) 
                                   (0170) ; Optimization for Assembly language (only) projects and C-language projects
0038: 7D 15 5D LJMP  0x155D        (0171) ; that do not depend on the C compiler to initialize the values of RAM variables.
003B: 7E       RETI                (0172) ;   Set to 1: Support for C Run-time Environment initialization
                                   (0173) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                   (0174) ;
003C: 7D 14 04 LJMP  0x1404        (0175) IF	(TOOLCHAIN & HITECH)
003F: 7E       RETI                (0176) ; The C compiler will customize the startup code - it's not required here
                                   (0177) 
                                   (0178) C_LANGUAGE_SUPPORT:              equ 0
                                   (0179) ELSE
0040: 7E       RETI                (0180) C_LANGUAGE_SUPPORT:              equ 1
0041: 30       HALT  
0042: 30       HALT  
0043: 30       HALT  
                                   (0181) ENDIF
                                   (0182) 
                                   (0183) 
0044: 7E       RETI                (0184) ; The following equate is required for proper operation. Reseting its value
0045: 30       HALT  
0046: 30       HALT  
0047: 30       HALT  
                                   (0185) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
                                   (0186) ; selected.  If the designer chooses to not wait then stabilization of the ECO
                                   (0187) ; and PLL_Lock must take place within user code. See the family data sheet for
0048: 7E       RETI                (0188) ; the requirements of starting the ECO and PLL lock mode.
0049: 30       HALT  
004A: 30       HALT  
004B: 30       HALT  
                                   (0189) ;
                                   (0190) ;   Set to 1: Wait for XTAL (& PLL if selected) to stabilize before
                                   (0191) ;                invoking main
004C: 7E       RETI                (0192) ;   Set to 0: Boot code does not wait; clock may not have stabilized by
004D: 30       HALT  
004E: 30       HALT  
004F: 30       HALT  
0050: 30       HALT  
0051: 30       HALT  
0052: 30       HALT  
0053: 30       HALT  
0054: 30       HALT  
0055: 30       HALT  
0056: 30       HALT  
0057: 30       HALT  
0058: 30       HALT  
0059: 30       HALT  
005A: 30       HALT  
005B: 30       HALT  
005C: 30       HALT  
005D: 30       HALT  
005E: 30       HALT  
005F: 30       HALT  
                                   (0193) ;               the time code in main starts executing.
                                   (0194) ;
                                   (0195) WAIT_FOR_32K:                    equ 1
0060: 7E       RETI                (0196) 
0061: 30       HALT  
0062: 30       HALT  
0063: 30       HALT  
                                   (0197) 
                                   (0198) 
                                   (0199) ; For historical reasons, by default the boot code uses an lcall instruction
0064: 7E       RETI                (0200) ; to invoke the user's _main code. If _main executes a return instruction,
0065: 30       HALT  
0066: 30       HALT  
0067: 30       HALT  
                                   (0201) ; boot provides an infinite loop. By changing the following equate from zero
                                   (0202) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                   (0203) ; bytes on the stack which are otherwise required for the return address. If
0068: 7E       RETI                (0204) ; this option is enabled, _main must not return. (Beginning with the 4.2
0069: 30       HALT  
006A: 30       HALT  
006B: 30       HALT  
                                   (0205) ; release, the C compiler automatically places an infinite loop at the end
                                   (0206) ; of main, rather than a return instruction.)
                                   (0207) ;
006C: 7E       RETI                (0208) ENABLE_LJMP_TO_MAIN:             equ 0
006D: 30       HALT  
006E: 30       HALT  
006F: 30       HALT  
                                   (0209) 
                                   (0210) 
                                   (0211) ;-----------------------------------------------------------------------------
0070: 7E       RETI                (0212) ; Interrupt Vector Table
0071: 30       HALT  
0072: 30       HALT  
0073: 30       HALT  
                                   (0213) ;-----------------------------------------------------------------------------
                                   (0214) ;
                                   (0215) ; Interrupt vector table entries are 4 bytes long.  Each one contains
0074: 7E       RETI                (0216) ; a jump instruction to an ISR (Interrupt Service Routine), although
0075: 30       HALT  
0076: 30       HALT  
0077: 30       HALT  
0078: 30       HALT  
0079: 30       HALT  
007A: 30       HALT  
007B: 30       HALT  
                                   (0217) ; very short ISRs could be encoded within the table itself. Normally,
                                   (0218) ; vector jump targets are modified automatically according to the user
                                   (0219) ; modules selected. This occurs when the 'Generate Application' opera-
007C: 7E       RETI                (0220) ; tion is run causing PSoC Designer to create boot.asm and the other
007D: 30       HALT  
007E: 30       HALT  
007F: 30       HALT  
                                   (0221) ; configuration files. If you need to hard code a vector, update the
                                   (0222) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                   (0223) ; of this file.
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) 
                                   (0226)     AREA TOP (ROM, ABS, CON)
                                   (0227) 
                                   (0228)     org   0                        ;Reset Interrupt Vector
                                   (0229) IF	(TOOLCHAIN & HITECH)
                                   (0230) ;   jmp   __Start                  ;C compiler fills in this vector
                                   (0231) ELSE
                                   (0232)     jmp   __Start                  ;First instruction executed following a Reset
                                   (0233) ENDIF
                                   (0234) 
                                   (0235)     org   04h                      ;Supply Monitor Interrupt Vector
                                   (0236)     halt                           ;Stop execution if power falls too low
                                   (0237) 
                                   (0238)     org   08h                      ;Analog Column 0 / Decimator 0 Interrupt Vector
                                   (0239)     // call	void_handler
0080: 71 10    OR    F,16          (0240)     reti
0082: 62 E3 87 MOV   REG[227],135  (0241) 
0085: 70 EF    AND   F,239         (0242)     org   0Ch                      ;Analog Column 1 / Decimator 1 Interrupt Vector
                                   (0243)     // call	void_handler
                                   (0244)     reti
                                   (0245) 
                                   (0246)     org   10h                      ;Analog Column 2 / Decimator 2 Interrupt Vector
                                   (0247)     // call	void_handler
                                   (0248)     reti
                                   (0249) 
                                   (0250)     org   14h                      ;Analog Column 3 / Decimator 3 Interrupt Vector
0087: 41 FE FB AND   REG[254],251  (0251)     // call	void_handler
                                   (0252)     reti
                                   (0253)     
                                   (0254)     org   18h                      ;VC3 Interrupt Vector
                                   (0255)     // call	void_handler
                                   (0256)     reti
                                   (0257) 
                                   (0258)     org   1Ch                      ;GPIO Interrupt Vector
                                   (0259)     // call	void_handler
                                   (0260)     reti
008A: 50 80    MOV   A,128         (0261) 
008C: 4E       SWAP  SP,A          (0262)     org   20h                      ;PSoC Block DBC00 Interrupt Vector
                                   (0263)     // call	void_handler
                                   (0264)     reti
                                   (0265) 
                                   (0266)     org   24h                      ;PSoC Block DBC01 Interrupt Vector
                                   (0267)     ljmp	Dispatch_INTERRUPT_9
                                   (0268)     reti
                                   (0269) 
                                   (0270)     org   28h                      ;PSoC Block DCC02 Interrupt Vector
                                   (0271)     ljmp	Dispatch_INTERRUPT_10
                                   (0272)     reti
                                   (0273) 
                                   (0274)     org   2Ch                      ;PSoC Block DCC03 Interrupt Vector
                                   (0275)     ljmp	Dispatch_INTERRUPT_11
                                   (0276)     reti
                                   (0277)     
                                   (0278)     org   30h                      ;PSoC Block DBC10 Interrupt Vector
                                   (0279)     // call	void_handler
                                   (0280)     reti
                                   (0281) 
                                   (0282)     org   34h                      ;PSoC Block DBC11 Interrupt Vector
                                   (0283)     // call	void_handler
                                   (0284)     reti
                                   (0285) 
                                   (0286)     org   38h                      ;PSoC Block DCC12 Interrupt Vector
                                   (0287)     ljmp	_HELLO_3_ISR
                                   (0288)     reti
                                   (0289) 
                                   (0290)     org   3Ch                      ;PSoC Block DCC13 Interrupt Vector
                                   (0291)     ljmp	_HELLO_4_ISR
                                   (0292)     reti
                                   (0293) 
008D: 55 F8 00 MOV   [248],0       (0294) 	org   40h                      ;PSoC Block DBC20 Interrupt Vector
0090: 55 F9 00 MOV   [249],0       (0295)     // call	void_handler
                                   (0296)     reti
                                   (0297) 	
                                   (0298) 	org   44h                      ;PSoC Block DBC21 Interrupt Vector
                                   (0299)     // call	void_handler
                                   (0300)     reti
                                   (0301) 	
                                   (0302) 	org   48h                      ;PSoC Block DCC22 Interrupt Vector
                                   (0303)     // call	void_handler
                                   (0304)     reti
                                   (0305) 	
                                   (0306) 	org   4Ch                      ;PSoC Block DCC23 Interrupt Vector
                                   (0307)     // call	void_handler
                                   (0308)     reti
                                   (0309) 	 
                                   (0310)     org   60h                      ;PSoC I2C0 Interrupt Vector
                                   (0311)     // call	void_handler
                                   (0312)     reti
                                   (0313) 
                                   (0314) 	org   64h                      ;PSoC I2C1 Interrupt Vector
                                   (0315)     // call	void_handler
                                   (0316)     reti
                                   (0317) 	
0093: 71 10    OR    F,16          (0318) 	org   68h                      ;PSoC SARADC Interrupt Vector
0095: 62 E0 02 MOV   REG[224],2    (0319)     // call	void_handler
0098: 70 EF    AND   F,239         (0320)     reti
009A: 62 E3 38 MOV   REG[227],56   (0321) 	
                                   (0322) 	org   6Ch                      ;PSoC RTC Interrupt Vector
                                   (0323)     // call	void_handler
                                   (0324)     reti
                                   (0325) 	
                                   (0326) 	org   70h                      ;Analog Column 4 Interrupt Vector
                                   (0327)     // call	void_handler
                                   (0328)     reti
                                   (0329) 	
                                   (0330) 	org   74h                      ;Analog Column 5 Interrupt Vector
                                   (0331)     // call	void_handler
                                   (0332)     reti
                                   (0333) 	
                                   (0334)     org   7Ch                      ;Sleep Timer Interrupt Vector
                                   (0335)     // call	void_handler
                                   (0336)     reti
                                   (0337) 
                                   (0338) ;-----------------------------------------------------------------------------
                                   (0339) ;  Start of Execution.
                                   (0340) ;-----------------------------------------------------------------------------
                                   (0341) ;  The Supervisory ROM SWBootReset function has already completed the
                                   (0342) ;  calibrate1 process, loading trim values for 5 volt operation.
                                   (0343) ;
                                   (0344) 
                                   (0345) IF	(TOOLCHAIN & HITECH)
                                   (0346)  	AREA PD_startup(CODE, REL, CON)
                                   (0347) ELSE
                                   (0348)     org 80h
                                   (0349) ENDIF
                                   (0350) __Start:
                                   (0351) 
009D: 62 71 05 MOV   REG[113],5    (0352)     ; initialize SMP values for voltage stabilization, if required,
00A0: 62 72 05 MOV   REG[114],5    (0353)     ; leaving power-on reset (POR) level at the default (low) level, at
00A3: 62 73 05 MOV   REG[115],5    (0354)     ; least for now. 
00A6: 62 74 05 MOV   REG[116],5    (0355)     ;
                                   (0356)     M8C_SetBank1
                                   (0357)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
                                   (0358)     M8C_SetBank0
                                   (0359) 
                                   (0360) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                   (0361)     M8C_EnableWatchDog
                                   (0362) ENDIF
                                   (0363) 
                                   (0364) IF ( SELECT_32K )
                                   (0365)     or   reg[CPU_SCR1],  CPU_SCR1_ECO_ALLOWED  ; ECO will be used in this project
                                   (0366) ELSE
                                   (0367)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                   (0368) ENDIF
                                   (0369) 
                                   (0370)     ;---------------------------
                                   (0371)     ; Set up the Temporary stack
                                   (0372)     ;---------------------------
                                   (0373)     ; A temporary stack is set up for the SSC instructions.
                                   (0374)     ; The real stack start will be assigned later.
                                   (0375)     ;
                                   (0376) _stack_start:          equ 80h
                                   (0377)     mov   A, _stack_start          ; Set top of stack to end of used RAM
                                   (0378)     swap  SP, A                    ; This is only temporary if going to LMM
                                   (0379) 
                                   (0380)     ;------------------------
                                   (0381)     ; Set Power-related Trim 
                                   (0382)     ;------------------------
                                   (0383) 
00A9: 62 D1 03 MOV   REG[209],3    (0384) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
00AC: 50 00    MOV   A,0           (0385)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
00AE: 4E       SWAP  SP,A          (0386)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
00AF: 62 D3 03 MOV   REG[211],3    (0387)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
00B2: 62 D0 00 MOV   REG[208],0    (0388) ELSE
00B5: 62 D5 00 MOV   REG[213],0    (0389) 	IF ( AGND_BYPASS )
00B8: 62 D4 00 MOV   REG[212],0    (0390)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0391)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                   (0392)     ; bit in the write-only BDG_TR register. Recalculate the register
00BB: 71 C0    OR    F,192         (0393)     ; value using the proper trim values.
                                   (0394)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0395)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                   (0396)   ENDIF
                                   (0397)  ENDIF
                                   (0398) ENDIF ; 5.0 V Operation
                                   (0399) 
                                   (0400) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                   (0401)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                   (0402)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                   (0403)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                   (0404)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                   (0405)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                   (0406)  ENDIF
                                   (0407) ENDIF ; 3.3 Volt Operation
                                   (0408) 
                                   (0409) 
                                   (0410)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
00BD: 7C 06 92 LCALL 0x0692        (0411)     mov  [bSSC_KEYSP], 0
00C0: 70 EF    AND   F,239         (0412) 
                                   (0413)     ;---------------------------------------
                                   (0414)     ; Initialize Crystal Oscillator and PLL
                                   (0415)     ;---------------------------------------
                                   (0416) IF ( SELECT_32K & WAIT_FOR_32K )
                                   (0417)     ; If the user has requested the External Crystal Oscillator (ECO) then turn it
                                   (0418)     ; on and wait for it to stabilize and the system to switch over to it. The PLL
                                   (0419)     ; is left off.  The SleepTimer period is set to 1 sec to time the wait for
                                   (0420)     ; the ECO to stabilize.
                                   (0421)     ;
                                   (0422)     M8C_SetBank1
                                   (0423)     mov   reg[OSC_CR0], (SELECT_32K_JUST | OSC_CR0_SLEEP_1Hz | OSC_CR0_CPU_12MHz)
                                   (0424)     M8C_SetBank0
                                   (0425)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get a full second
                                   (0426)     or    reg[INT_MSK0], INT_MSK0_SLEEP   ; Enable latching of SleepTimer interrupt
                                   (0427)     mov   reg[INT_VC],   0                ; Clear all pending interrupts
                                   (0428) .WaitFor1s:
                                   (0429)     tst   reg[INT_CLR0], INT_MSK0_SLEEP   ; Test the SleepTimer Interrupt Status
                                   (0430)     jz   .WaitFor1s                       ; Interrupt will latch but will not dispatch
                                   (0431)                                           ;  since interrupts are not globally enabled
                                   (0432) ELSE ; !( SELECT_32K & WAIT_FOR_32K )
                                   (0433)     ; Either no ECO, or waiting for stable clock is to be done in main
                                   (0434)     M8C_SetBank1
                                   (0435)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
                                   (0436)     M8C_SetBank0
                                   (0437)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                   (0438) 
                                   (0439) ENDIF ;( SELECT_32K & WAIT_FOR_32K )
                                   (0440) 
                                   (0441) IF ( PLL_MODE )
                                   (0442)     ; Crystal is now fully operational (assuming WAIT_FOR_32K was enabled).
                                   (0443)     ; Now start up PLL if selected, and wait 16 msec for it to stabilize.
00C2: 62 D0 00 MOV   REG[208],0    (0444)     ;
                                   (0445)     M8C_SetBank1
                                   (0446)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_3MHz)
                                   (0447)     M8C_SetBank0
                                   (0448)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get full period
                                   (0449)     mov   reg[INT_VC], 0                  ; Clear all pending interrupts
                                   (0450) 
00C5: 50 06    MOV   A,6           (0451) .WaitFor16ms:
00C7: 57 90    MOV   X,144         (0452)     tst   reg[INT_CLR0],INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
00C9: 08       PUSH  A             (0453)     jz   .WaitFor16ms
00CA: 28       ROMX                (0454)     M8C_SetBank1                          ; continue boot at CPU Speed of SYSCLK/2
00CB: 53 CD    MOV   [__r0],A      (0455)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_12MHz)
00CD: 18       POP   A             (0456)     M8C_SetBank0
00CE: 75       INC   X             (0457) 
00CF: 09 00    ADC   A,0           (0458) IF      ( WAIT_FOR_32K )
00D1: 28       ROMX                (0459) ELSE ; !( WAIT_FOR_32K )
00D2: 4B       SWAP  A,X           (0460)     ; Option settings (PLL-Yes, ECO-No) are incompatible - force a syntax error
00D3: 51 CD    MOV   A,[205]       (0461)     ERROR_PSoC Disabling WAIT_FOR_32K requires that the PLL_Lock must be enabled in user code.
                                   (0462) ENDIF ;(WAIT_FOR_32K)
00D5: 80 04    JMP   0x00DA        (0463) ENDIF ;(PLL_MODE)
                                   (0464) 
                                   (0465)     ;------------------------
                                   (0466)     ; Close CT leakage path.
                                   (0467)     ;------------------------
                                   (0468)     mov   reg[0x71], 05h
                                   (0469)     mov   reg[0x72], 05h
                                   (0470)     mov   reg[0x73], 05h
                                   (0471)     mov   reg[0x74], 05h
                                   (0472) 
                                   (0473) 
                                   (0474) 
                                   (0475) IF	(TOOLCHAIN & HITECH)
                                   (0476)     ;---------------------------------------------
                                   (0477)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                   (0478)     ;---------------------------------------------
                                   (0479) 	global		__Lstackps
                                   (0480) 	mov     a,low __Lstackps
00D7: 75       INC   X             (0481) 	swap    a,sp
00D8: 09 00    ADC   A,0           (0482) 
                                   (0483) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                   (0484)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                   (0485)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                   (0486)     RAM_SETPAGE_CUR 0
00DA: 62 E3 00 MOV   REG[227],0    (0487)     RAM_SETPAGE_MVW 0
00DD: 08       PUSH  A             (0488)     RAM_SETPAGE_MVR 0
00DE: 28       ROMX                (0489)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
00DF: 60 D5    MOV   REG[213],A    (0490)       or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
00E1: 74       INC   A             (0491)     ELSE
00E2: A0 4B    JZ    0x012E        (0492)       or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
00E4: 18       POP   A             (0493)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
00E5: 75       INC   X             (0494) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
00E6: 09 00    ADC   A,0           (0495) ELSE
00E8: 08       PUSH  A             (0496)     ;---------------------------------------------
00E9: 28       ROMX                (0497)     ; ImageCraft Enter the Large Memory Model, if applicable
00EA: 53 CD    MOV   [__r0],A      (0498)     ;---------------------------------------------
00EC: 18       POP   A             (0499) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00ED: 75       INC   X             (0500)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
00EE: 09 00    ADC   A,0           (0501)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
00F0: 08       PUSH  A             (0502)     swap  A, SP
00F1: 28       ROMX                (0503)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
00F2: A0 1C    JZ    0x010F        (0504)     RAM_SETPAGE_CUR 0
00F4: 53 CC    MOV   [__r1],A      (0505)     RAM_SETPAGE_MVW 0
00F6: 18       POP   A             (0506)     RAM_SETPAGE_MVR 0
                                   (0507) 
                                   (0508)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                   (0509)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                   (0510)   ELSE
                                   (0511)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                   (0512)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                   (0513) ELSE
00F7: 75       INC   X             (0514)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
00F8: 09 00    ADC   A,0           (0515)     swap  SP, A
00FA: 08       PUSH  A             (0516) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
00FB: 28       ROMX                (0517) ENDIF ;	TOOLCHAIN
00FC: 3F CD    MVI   [__r0],A      (0518) 
00FE: 47 CD FF TST   [205],255     (0519)     ;-------------------------
0101: B0 06    JNZ   0x0108        (0520)     ; Load Base Configuration
0103: 5D D5    MOV   A,REG[213]    (0521)     ;-------------------------
0105: 74       INC   A             (0522)     ; Load global parameter settings and load the user modules in the
0106: 60 D5    MOV   REG[213],A    (0523)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                   (0524)     ; to minimize start up time; (2) We may still need to play with the
0108: 18       POP   A             (0525)     ; Sleep Timer.
0109: 7A CC    DEC   [__r1]        (0526)     ;
010B: BF EB    JNZ   0x00F7        (0527)     lcall LoadConfigInit
010D: 8F C9    JMP   0x00D7        (0528)     M8C_SetBank0
                                   (0529) 
                                   (0530)     ;-----------------------------------
010F: 18       POP   A             (0531)     ; Initialize C Run-Time Environment
0110: 75       INC   X             (0532)     ;-----------------------------------
0111: 09 00    ADC   A,0           (0533) IF ( C_LANGUAGE_SUPPORT )
0113: 08       PUSH  A             (0534) IF ( SYSTEM_SMALL_MEMORY_MODEL )
0114: 28       ROMX                (0535)     mov  A,0                           ; clear the 'bss' segment to zero
0115: 53 CC    MOV   [__r1],A      (0536)     mov  [__r0],<__bss_start
0117: 50 00    MOV   A,0           (0537) BssLoop:
                                   (0538)     cmp  [__r0],<__bss_end
                                   (0539)     jz   BssDone
                                   (0540)     mvi  [__r0],A
                                   (0541)     jmp  BssLoop
                                   (0542) BssDone:
0119: 3F CD    MVI   [__r0],A      (0543)     mov  A,>__idata_start              ; copy idata to data segment
011B: 47 CD FF TST   [205],255     (0544)     mov  X,<__idata_start
011E: B0 08    JNZ   0x0127        (0545)     mov  [__r0],<__data_start
0120: 5D D5    MOV   A,REG[213]    (0546) IDataLoop:
0122: 74       INC   A             (0547)     cmp  [__r0],<__data_end
0123: 60 D5    MOV   REG[213],A    (0548)     jz   C_RTE_Done
0125: 50 00    MOV   A,0           (0549)     push A
                                   (0550)     romx
0127: 7A CC    DEC   [__r1]        (0551)     mvi  [__r0],A
0129: BF EF    JNZ   0x0119        (0552)     pop  A
012B: 18       POP   A             (0553)     inc  X
012C: 8F AA    JMP   0x00D7        (0554)     adc  A,0
                                   (0555)     jmp  IDataLoop
                                   (0556) 
012E: 18       POP   A             (0557) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                   (0558) 
                                   (0559) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                   (0560)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                   (0561)                                        ; to use the Virtual Register page.
                                   (0562) 
                                   (0563)     ; Dereference the constant (flash) pointer pXIData to access the start
                                   (0564)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                   (0565)     ; text segment and may have been relocated by the Code Compressor.
                                   (0566)     ;
                                   (0567)     mov   A, >__pXIData                ; Get the address of the flash
                                   (0568)     mov   X, <__pXIData                ;   pointer to the xidata area.
                                   (0569)     push  A
                                   (0570)     romx                               ; get the MSB of xidata's address
                                   (0571)     mov   [__r0], A
                                   (0572)     pop   A
                                   (0573)     inc   X
                                   (0574)     adc   A, 0
                                   (0575)     romx                               ; get the LSB of xidata's address
                                   (0576)     swap  A, X
                                   (0577)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                   (0578)                                        ;   XIData structure list in flash
                                   (0579)     jmp   .AccessStruct
                                   (0580) 
                                   (0581)     ; Unpack one element in the xidata "structure list" that specifies the
                                   (0582)     ; values of C variables. Each structure contains 3 member elements.
                                   (0583)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                   (0584)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                   (0585)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                   (0586)     ; contains 0xFF. There are two formats for the struct depending on the
                                   (0587)     ; value in the second member element, an unsigned byte:
                                   (0588)     ; (1) If the value of the second element is non-zero, it represents
                                   (0589)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                   (0590)     ; third member of the struct is an array of bytes of length 'size' and
                                   (0591)     ; the bytes are copied to the block of RAM.
                                   (0592)     ; (2) If the value of the second element is zero, the block of RAM is
                                   (0593)     ; to be cleared to zero. In this case, the third member of the struct
                                   (0594)     ; is an unsigned byte containing the number of bytes to clear.
                                   (0595) 
                                   (0596) .AccessNextStructLoop:
                                   (0597)     inc   X                            ; pXIData++
                                   (0598)     adc   A, 0
                                   (0599) .AccessStruct:                         ; Entry point for first block
                                   (0600)     ;
                                   (0601)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                   (0602)     ;
                                   (0603)     M8C_ClearWDT                       ; Clear the watchdog for long inits
                                   (0604)     push  A
                                   (0605)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
                                   (0606)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
                                   (0607)     inc   A                            ; End of Struct List? (MSB==0xFF?)
                                   (0608)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
                                   (0609)     pop   A                            ; restore pXIData to [A,X]
                                   (0610)     inc   X                            ; pXIData++
                                   (0611)     adc   A, 0
012F: 71 10    OR    F,16          (0612)     push  A
                                   (0613)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
                                   (0614)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
                                   (0615)     pop   A                            ; restore pXIData to [A,X]
                                   (0616)     inc   X                            ; pXIData++ (point to size)
                                   (0617)     adc   A, 0
                                   (0618)     push  A
                                   (0619)     romx                               ; Get the size (CPU.A <- *pXIData)
0131: 43 E3 20 OR    REG[227],32   (0620)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
                                   (0621)     mov   [__r1], A                    ;             else downcount in __r1
                                   (0622)     pop   A                            ; restore pXIData to [A,X]
                                   (0623) 
                                   (0624) .CopyNextByteLoop:
0134: 70 EF    AND   F,239         (0625)     ; For each byte in the structure's array member, copy from flash to RAM.
                                   (0626)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                   (0627)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                   (0628)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                   (0629)     ;
                                   (0630)     inc   X                            ; pXIData++ (point to next data byte)
                                   (0631)     adc   A, 0
                                   (0632)     push  A
                                   (0633)     romx                               ; Get the data value (CPU.A <- *pXIData)
0136: 62 E0 00 MOV   REG[224],0    (0634)     mvi   [__r0], A                    ; Transfer the data to RAM
                                   (0635)     tst   [__r0], 0xff                 ; Check for page crossing
                                   (0636)     jnz   .CopyLoopTail                ;   No crossing, keep going
                                   (0637)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
0139: 71 10    OR    F,16          (0638)     inc   A
013B: 62 E0 03 MOV   REG[224],3    (0639)     mov   reg[ MVW_PP], A
013E: 43 E2 00 OR    REG[226],0    (0640) .CopyLoopTail:
0141: 70 EF    AND   F,239         (0641)     pop   A                            ; restore pXIData to [A,X]
                                   (0642)     dec   [__r1]                       ; End of this array in flash?
                                   (0643)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
                                   (0644)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                   (0645) 
                                   (0646) .ClearRAMBlockToZero:
0143: 62 E2 00 MOV   REG[226],0    (0647)     pop   A                            ; restore pXIData to [A,X]
                                   (0648)     inc   X                            ; pXIData++ (point to next data byte)
                                   (0649)     adc   A, 0
                                   (0650)     push  A
                                   (0651)     romx                               ; Get the run length (CPU.A <- *pXIData)
                                   (0652)     mov   [__r1], A                    ; Initialize downcounter
                                   (0653)     mov   A, 0                         ; Initialize source data
                                   (0654) 
0146: 7C 20 4C LCALL _main         (0655) .ClearRAMBlockLoop:
                                   (0656)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
0149: 8F FF    JMP   0x0149        (0657)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                   (0658)     ;
                                   (0659)     mvi   [__r0], A                    ; Clear a byte
                                   (0660)     tst   [__r0], 0xff                 ; Check for page crossing
                                   (0661)     jnz   .ClearLoopTail               ;   No crossing, keep going
                                   (0662)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
                                   (0663)     inc   A
                                   (0664)     mov   reg[ MVW_PP], A
                                   (0665)     mov   A, 0                         ; Restore the zero used for clearing
                                   (0666) .ClearLoopTail:
                                   (0667)     dec   [__r1]                       ; Was this the last byte?
                                   (0668)     jnz   .ClearRAMBlockLoop           ;   No,  continue
                                   (0669)     pop   A                            ;   Yes, restore pXIData to [A,X] and
                                   (0670)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                   (0671) 
                                   (0672) .C_RTE_WrapUp:
014B: 50 10    MOV   A,16          (0673)     pop   A                            ; balance stack
                                   (0674) 
0530: 71 10    OR    F,16          (0675) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL

FILE: lib\psocconfigtbl.asm
0532: 62 00 1E MOV   REG[0],30     (0812) ; Generated by PSoC Designer 5.0.985.0
0535: 62 01 E1 MOV   REG[1],225    (0813) ;
0538: 70 EF    AND   F,239         (0814) include "m8c.inc"
053A: 62 03 E0 MOV   REG[3],224    (0815) ;  Personalization tables 
053D: 62 02 1F MOV   REG[2],31     (0816) export LoadConfigTBL_waiting_Bank1
0540: 71 10    OR    F,16          (0817) export LoadConfigTBL_waiting_Bank0
0542: 62 02 00 MOV   REG[2],0      (0818) export LoadConfigTBL_waiting_Ordered
0545: 62 03 00 MOV   REG[3],0      (0819) export UnloadConfigTBL_waiting_Bank1
0548: 70 EF    AND   F,239         (0820) export UnloadConfigTBL_waiting_Bank0
054A: 62 01 00 MOV   REG[1],0      (0821) export ReloadConfigTBL_waiting_Bank1
054D: 71 10    OR    F,16          (0822) export ReloadConfigTBL_waiting_Bank0
054F: 62 04 00 MOV   REG[4],0      (0823) export LoadConfigTBL_hello_Bank1
0552: 62 05 FF MOV   REG[5],255    (0824) export LoadConfigTBL_hello_Bank0
0555: 70 EF    AND   F,239         (0825) export UnloadConfigTBL_hello_Bank1
0557: 62 07 FF MOV   REG[7],255    (0826) export UnloadConfigTBL_hello_Bank0
055A: 62 06 00 MOV   REG[6],0      (0827) export LoadConfigTBL_initial_Bank1
055D: 71 10    OR    F,16          (0828) export LoadConfigTBL_initial_Bank0
055F: 62 06 00 MOV   REG[6],0      (0829) export UnloadConfigTBL_initial_Bank1
0562: 62 07 00 MOV   REG[7],0      (0830) export UnloadConfigTBL_initial_Bank0
0565: 70 EF    AND   F,239         (0831) export LoadConfigTBL_my_response_Bank1
0567: 62 05 00 MOV   REG[5],0      (0832) export LoadConfigTBL_my_response_Bank0
056A: 71 10    OR    F,16          (0833) export UnloadConfigTBL_my_response_Bank1
056C: 62 08 01 MOV   REG[8],1      (0834) export UnloadConfigTBL_my_response_Bank0
056F: 62 09 FE MOV   REG[9],254    (0835) export LoadConfigTBL_response1_Bank1
0572: 70 EF    AND   F,239         (0836) export LoadConfigTBL_response1_Bank0
0574: 62 0B FE MOV   REG[11],254   (0837) export UnloadConfigTBL_response1_Bank1
0577: 62 0A 00 MOV   REG[10],0     (0838) export UnloadConfigTBL_response1_Bank0
057A: 71 10    OR    F,16          (0839) export LoadConfigTBL_response2_Bank1
057C: 62 0A 00 MOV   REG[10],0     (0840) export LoadConfigTBL_response2_Bank0
057F: 62 0B 00 MOV   REG[11],0     (0841) export UnloadConfigTBL_response2_Bank1
0582: 70 EF    AND   F,239         (0842) export UnloadConfigTBL_response2_Bank0
0584: 62 09 00 MOV   REG[9],0      (0843) export LoadConfigTBL_response3_Bank1
0587: 71 10    OR    F,16          (0844) export LoadConfigTBL_response3_Bank0
0589: 62 0C 00 MOV   REG[12],0     (0845) export UnloadConfigTBL_response3_Bank1
058C: 62 0D 00 MOV   REG[13],0     (0846) export UnloadConfigTBL_response3_Bank0
058F: 70 EF    AND   F,239         (0847) export LoadConfigTBL_response4_Bank1
0591: 62 0F 00 MOV   REG[15],0     (0848) export LoadConfigTBL_response4_Bank0
0594: 62 0E 00 MOV   REG[14],0     (0849) export UnloadConfigTBL_response4_Bank1
0597: 71 10    OR    F,16          (0850) export UnloadConfigTBL_response4_Bank0
0599: 62 0E 00 MOV   REG[14],0     (0851) export LoadConfigTBL_servo_transmit_Bank1
059C: 62 0F 00 MOV   REG[15],0     (0852) export LoadConfigTBL_servo_transmit_Bank0
059F: 70 EF    AND   F,239         (0853) export UnloadConfigTBL_servo_transmit_Bank1
05A1: 62 0D 00 MOV   REG[13],0     (0854) export UnloadConfigTBL_servo_transmit_Bank0
05A4: 71 10    OR    F,16          (0855) export UnloadConfigTBL_Total_Bank1
05A6: 62 10 00 MOV   REG[16],0     (0856) export UnloadConfigTBL_Total_Bank0
05A9: 62 11 00 MOV   REG[17],0     (0857) AREA lit(rom, rel)
05AC: 70 EF    AND   F,239         (0858) LoadConfigTBL_hello_Bank0:
05AE: 62 13 00 MOV   REG[19],0     (0859) ;  Instance name HELLO_1, User Module RX8
05B1: 62 12 00 MOV   REG[18],0     (0860) ;       Instance name HELLO_1, Block Name RX8(DCC02)
05B4: 71 10    OR    F,16          (0861) 	db		2bh, 00h		;HELLO_1_CONTROL_REG  (DCC02CR0)
05B6: 62 12 00 MOV   REG[18],0     (0862) 	db		29h, 00h		;HELLO_1_(DCC02DR1)
05B9: 62 13 00 MOV   REG[19],0     (0863) 	db		2ah, 00h		;HELLO_1_RX_BUFFER_REG(DCC02DR2)
05BC: 70 EF    AND   F,239         (0864) ;  Instance name HELLO_2, User Module RX8
05BE: 62 11 00 MOV   REG[17],0     (0865) ;       Instance name HELLO_2, Block Name RX8(DCC03)
05C1: 62 15 00 MOV   REG[21],0     (0866) 	db		2fh, 00h		;HELLO_2_CONTROL_REG  (DCC03CR0)
05C4: 62 16 00 MOV   REG[22],0     (0867) 	db		2dh, 00h		;HELLO_2_(DCC03DR1)
05C7: 62 17 00 MOV   REG[23],0     (0868) 	db		2eh, 00h		;HELLO_2_RX_BUFFER_REG(DCC03DR2)
05CA: 71 10    OR    F,16          (0869) ;  Instance name HELLO_3, User Module RX8
05CC: 62 15 00 MOV   REG[21],0     (0870) ;       Instance name HELLO_3, Block Name RX8(DCC12)
05CF: 62 14 00 MOV   REG[20],0     (0871) 	db		3bh, 00h		;HELLO_3_CONTROL_REG  (DCC12CR0)
05D2: 62 16 00 MOV   REG[22],0     (0872) 	db		39h, 00h		;HELLO_3_(DCC12DR1)
05D5: 62 17 00 MOV   REG[23],0     (0873) 	db		3ah, 00h		;HELLO_3_RX_BUFFER_REG(DCC12DR2)
0692: 62 D0 00 MOV   REG[208],0    (0874) ;  Instance name HELLO_4, User Module RX8

FILE: lib\psocconfig.asm
0695: 55 04 00 MOV   [4],0         (0098) ; Generated by PSoC Designer 5.0.985.0
0698: 55 05 00 MOV   [5],0         (0099) ;
                                   (0100) INCLUDE "PSoCDynamic.inc"
069B: 7C 06 A2 LCALL 0x06A2        (0101) ;==========================================================================
069E: 7C 05 30 LCALL 0x0530        (0102) ;  PSoCConfig.asm
                                   (0103) ;  @PSOC_VERSION
                                   (0104) ;
                                   (0105) ;  Version: 0.85
06A1: 7F       RET                 (0106) ;  Revised: June 22, 2004
                                   (0107) ;  Copyright Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0108) ;
                                   (0109) ;  This file is generated by the Device Editor on Application Generation.
                                   (0110) ;  It contains code which loads the configuration data table generated in
                                   (0111) ;  the file PSoCConfigTBL.asm
                                   (0112) ;
                                   (0113) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0114) ;  Edits to this file will not be preserved.
                                   (0115) ;==========================================================================
                                   (0116) ;
                                   (0117) include "m8c.inc"
                                   (0118) include "memory.inc"
                                   (0119) include "GlobalParams.inc"
                                   (0120) 
                                   (0121) export LoadConfigInit
                                   (0122) export _LoadConfigInit
                                   (0123) export LoadConfig_waiting
                                   (0124) export _LoadConfig_waiting
                                   (0125) export UnloadConfig_waiting
                                   (0126) export _UnloadConfig_waiting
                                   (0127) export ReloadConfig_waiting
                                   (0128) export _ReloadConfig_waiting
                                   (0129) export LoadConfig_hello
06A2: 71 10    OR    F,16          (0130) export _LoadConfig_hello
                                   (0131) export UnloadConfig_hello
06A4: 10       PUSH  X             (0132) export _UnloadConfig_hello
06A5: 70 EF    AND   F,239         (0133) export LoadConfig_initial
06A7: 50 00    MOV   A,0           (0134) export _LoadConfig_initial
06A9: 67       ASR   A             (0135) export UnloadConfig_initial
                                   (0136) export _UnloadConfig_initial
06AA: 50 04    MOV   A,4           (0137) export LoadConfig_my_response
06AC: 57 28    MOV   X,40          (0138) export _LoadConfig_my_response
06AE: 7C 0C 0E LCALL 0x0C0E        (0139) export UnloadConfig_my_response
                                   (0140) export _UnloadConfig_my_response
06B1: 50 01    MOV   A,1           (0141) export LoadConfig_response1
06B3: 67       ASR   A             (0142) export _LoadConfig_response1
                                   (0143) export UnloadConfig_response1
06B4: 50 04    MOV   A,4           (0144) export _UnloadConfig_response1
06B6: 57 97    MOV   X,151         (0145) export LoadConfig_response2
06B8: 7C 0C 0E LCALL 0x0C0E        (0146) export _LoadConfig_response2
                                   (0147) export UnloadConfig_response2
06BB: 62 D0 00 MOV   REG[208],0    (0148) export _UnloadConfig_response2
                                   (0149) export LoadConfig_response3
06BE: 2E 04 01 OR    [4],1         (0150) export _LoadConfig_response3
06C1: 70 EF    AND   F,239         (0151) export UnloadConfig_response3
06C3: 20       POP   X             (0152) export _UnloadConfig_response3
                                   (0153) export LoadConfig_response4
                                   (0154) export _LoadConfig_response4
06C4: 7F       RET                 (0155) export UnloadConfig_response4
                                   (0156) export _UnloadConfig_response4
                                   (0157) export LoadConfig_servo_transmit
                                   (0158) export _LoadConfig_servo_transmit
                                   (0159) export UnloadConfig_servo_transmit
                                   (0160) export _UnloadConfig_servo_transmit
                                   (0161) export UnloadConfig_Total
                                   (0162) export _UnloadConfig_Total
                                   (0163) export ACTIVE_CONFIG_STATUS
                                   (0164) 
                                   (0165) export NO_SHADOW
                                   (0166) export _NO_SHADOW
                                   (0167) 
                                   (0168) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                   (0169) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                   (0170) 
                                   (0171) AREA psoc_config(rom, rel)
                                   (0172) 
                                   (0173) ;---------------------------------------------------------------------------
                                   (0174) ; LoadConfigInit - Establish the start-up configuration (except for a few
                                   (0175) ;                  parameters handled by boot code, like CPU speed). This
                                   (0176) ;                  function can be called from user code, but typically it
                                   (0177) ;                  is only called from boot.
                                   (0178) ;
                                   (0179) ;       INPUTS: None.
06C5: 10       PUSH  X             (0180) ;      RETURNS: Nothing.
06C6: 70 EF    AND   F,239         (0181) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
06C8: 50 00    MOV   A,0           (0182) ;               In the large memory model currently only the page
06CA: 67       ASR   A             (0183) ;               pointer registers listed below are modified.  This does
                                   (0184) ;               not guarantee that in future implementations of this
06CB: 50 05    MOV   A,5           (0185) ;               function other page pointer registers will not be
06CD: 57 D9    MOV   X,217         (0186) ;               modified.
06CF: 7C 0C 0E LCALL 0x0C0E        (0187) ;          
                                   (0188) ;               Page Pointer Registers Modified: 
06D2: 50 01    MOV   A,1           (0189) ;               CUR_PP
06D4: 67       ASR   A             (0190) ;
                                   (0191) _LoadConfigInit:
06D5: 50 05    MOV   A,5           (0192)  LoadConfigInit:
06D7: 57 E6    MOV   X,230         (0193)     RAM_PROLOGUE RAM_USE_CLASS_4
06D9: 7C 0C 0E LCALL 0x0C0E        (0194)     RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0195) 	mov		[ACTIVE_CONFIG_STATUS], 0
                                   (0196) 	mov		[ACTIVE_CONFIG_STATUS+1], 0
06DC: 62 D0 00 MOV   REG[208],0    (0197) 
06DF: 2E 04 01 OR    [4],1         (0198) 	lcall	LoadConfig_waiting
06E2: 70 EF    AND   F,239         (0199) 	lcall	LoadConfigTBL_waiting_Ordered
06E4: 20       POP   X             (0200) 
                                   (0201) 
                                   (0202)     RAM_EPILOGUE RAM_USE_CLASS_4
06E5: 7F       RET                 (0203)     ret
                                   (0204) 
                                   (0205) ;---------------------------------------------------------------------------
                                   (0206) ; Load Configuration waiting
                                   (0207) ;
                                   (0208) ;    Load configuration registers for waiting.
                                   (0209) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0210) ;
                                   (0211) ;       INPUTS: None.
                                   (0212) ;      RETURNS: Nothing.
                                   (0213) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0214) ;               modified as may the Page Pointer registers!
                                   (0215) ;               In the large memory model currently only the page
                                   (0216) ;               pointer registers listed below are modified.  This does
                                   (0217) ;               not guarantee that in future implementations of this
                                   (0218) ;               function other page pointer registers will not be
                                   (0219) ;               modified.
                                   (0220) ;          
                                   (0221) ;               Page Pointer Registers Modified: 
                                   (0222) ;               CUR_PP
                                   (0223) ;
                                   (0224) _LoadConfig_waiting:
                                   (0225)  LoadConfig_waiting:
                                   (0226)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0227) 	M8C_SetBank1
                                   (0228) 
06E6: 10       PUSH  X             (0229) 	push	x
06E7: 70 EF    AND   F,239         (0230)     M8C_SetBank0                    ; Force bank 0
06E9: 50 00    MOV   A,0           (0231)     mov     a, 0                    ; Specify bank 0
06EB: 67       ASR   A             (0232)     asr     a                       ; Store in carry flag
                                   (0233)                                     ; Load bank 0 table:
06EC: 50 05    MOV   A,5           (0234)     mov     A, >LoadConfigTBL_waiting_Bank0
06EE: 57 F7    MOV   X,247         (0235)     mov     X, <LoadConfigTBL_waiting_Bank0
06F0: 7C 0C 0E LCALL 0x0C0E        (0236)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0237) 
06F3: 50 01    MOV   A,1           (0238)     mov     a, 1                    ; Specify bank 1
06F5: 67       ASR   A             (0239)     asr     a                       ; Store in carry flag
                                   (0240)                                     ; Load bank 1 table:
06F6: 50 05    MOV   A,5           (0241)     mov     A, >LoadConfigTBL_waiting_Bank1
06F8: 57 FC    MOV   X,252         (0242)     mov     X, <LoadConfigTBL_waiting_Bank1
06FA: 7C 0C 0E LCALL 0x0C0E        (0243)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0244) 
06FD: 70 EF    AND   F,239         (0245) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0246) ; set config active bit
06FF: 62 D0 00 MOV   REG[208],0    (0247) 	or		[ACTIVE_CONFIG_STATUS+waiting_ADDR_OFF], waiting_BIT
0702: 26 04 FE AND   [4],254       (0248)     M8C_SetBank0                    ; Force return to bank 0
0705: 70 EF    AND   F,239         (0249) 	pop		x
0707: 20       POP   X             (0250) 
                                   (0251)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0252)     ret
0708: 7F       RET                 (0253) 
                                   (0254) ;---------------------------------------------------------------------------
                                   (0255) ; Reload Configuration waiting
                                   (0256) ;
                                   (0257) ;    Reload configuration registers for waiting.
                                   (0258) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0259) ;
                                   (0260) ;       INPUTS: None.
                                   (0261) ;      RETURNS: Nothing.
                                   (0262) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0263) ;               modified as may the Page Pointer registers!
                                   (0264) ;               In the large memory model currently only the page
                                   (0265) ;               pointer registers listed below are modified.  This does
                                   (0266) ;               not guarantee that in future implementations of this
                                   (0267) ;               function other page pointer registers will not be
                                   (0268) ;               modified.
                                   (0269) ;          
                                   (0270) ;               Page Pointer Registers Modified: 
                                   (0271) ;               CUR_PP
                                   (0272) ;
                                   (0273) _ReloadConfig_waiting:
                                   (0274)  ReloadConfig_waiting:
                                   (0275)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0276) 
0709: 71 10    OR    F,16          (0277) 	push	x
                                   (0278)     M8C_SetBank0                    ; Force bank 0
070B: 41 00 E1 AND   REG[0],225    (0279)     mov     a, 0                    ; Specify bank 0
                                   (0280)     asr     a                       ; Store in carry flag
070E: 41 01 E1 AND   REG[1],225    (0281)                                     ; Bank 0 table address:
0711: 43 01 1E OR    REG[1],30     (0282)     mov     A, >ReloadConfigTBL_waiting_Bank0
                                   (0283)     mov     X, <ReloadConfigTBL_waiting_Bank0
0714: 70 EF    AND   F,239         (0284)     lcall   LoadConfig              ; Reload the bank 0 values
0716: 41 03 FE AND   REG[3],254    (0285) 
0719: 43 03 01 OR    REG[3],1      (0286)     mov     a, 1                    ; Specify bank 1
                                   (0287)     asr     a                       ; Store in carry flag
071C: 41 02 FE AND   REG[2],254    (0288)                                     ; Bank 1 table address:
                                   (0289)     mov     A, >ReloadConfigTBL_waiting_Bank1
071F: 41 B3 F0 AND   REG[179],240  (0290)     mov     X, <ReloadConfigTBL_waiting_Bank1
0722: 43 B3 03 OR    REG[179],3    (0291)     lcall   LoadConfig              ; Reload the bank 1 values
                                   (0292) 
0725: 41 B4 F0 AND   REG[180],240  (0293) ; set config active bit
0728: 43 B4 03 OR    REG[180],3    (0294) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0295) 	or		[ACTIVE_CONFIG_STATUS+waiting_ADDR_OFF], waiting_BIT
072B: 41 B5 ED AND   REG[181],237  (0296)     M8C_SetBank0                    ; Force return to bank 0
                                   (0297) 	pop		x
072E: 41 B6 EE AND   REG[182],238  (0298) 
                                   (0299)     RAM_EPILOGUE RAM_USE_CLASS_4
0731: 41 B8 3F AND   REG[184],63   (0300)     ret
                                   (0301) 
0734: 10       PUSH  X             (0302) ;---------------------------------------------------------------------------
0735: 70 EF    AND   F,239         (0303) ; Unload Configuration waiting
0737: 50 00    MOV   A,0           (0304) ;
0739: 67       ASR   A             (0305) ;    Reset configuration registers for waiting
                                   (0306) ;    to their values as initially configured.
073A: 50 01    MOV   A,1           (0307) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
073C: 57 90    MOV   X,144         (0308) ;
073E: 7C 0C 0E LCALL 0x0C0E        (0309) ;       INPUTS: None.
                                   (0310) ;      RETURNS: Nothing.
0741: 50 01    MOV   A,1           (0311) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0743: 67       ASR   A             (0312) ;               modified as may the Page Pointer registers!
                                   (0313) ;               In the large memory model currently only the page
0744: 50 01    MOV   A,1           (0314) ;               pointer registers listed below are modified.  This does
0746: 57 B5    MOV   X,181         (0315) ;               not guarantee that in future implementations of this
0748: 7C 0C 0E LCALL 0x0C0E        (0316) ;               function other page pointer registers will not be
                                   (0317) ;               modified.
074B: 62 D0 00 MOV   REG[208],0    (0318) ;          
                                   (0319) ;               Page Pointer Registers Modified: 
074E: 2E 04 02 OR    [4],2         (0320) ;               CUR_PP
0751: 70 EF    AND   F,239         (0321) ;
0753: 20       POP   X             (0322) _UnloadConfig_waiting:
                                   (0323)  UnloadConfig_waiting:
                                   (0324)     RAM_PROLOGUE RAM_USE_CLASS_4
0754: 7F       RET                 (0325) 
                                   (0326) 	push	x
                                   (0327)     M8C_SetBank0                    ; Force bank 0
                                   (0328)     mov     a, 0                    ; Specify bank 0
                                   (0329)     asr     a                       ; Store in carry flag
                                   (0330)                                     ; Bank 0 table address:
                                   (0331)     mov     A, >UnloadConfigTBL_waiting_Bank0
                                   (0332)     mov     X, <UnloadConfigTBL_waiting_Bank0
                                   (0333)     lcall   LoadConfig              ; Unload the bank 0 values
                                   (0334) 
                                   (0335)     mov     a, 1                    ; Specify bank 1
                                   (0336)     asr     a                       ; Store in carry flag
                                   (0337)                                     ; Bank 1 table address:
                                   (0338)     mov     A, >UnloadConfigTBL_waiting_Bank1
                                   (0339)     mov     X, <UnloadConfigTBL_waiting_Bank1
                                   (0340)     lcall   LoadConfig              ; Unload the bank 1 values
                                   (0341) 
                                   (0342) 	M8C_SetBank0
                                   (0343) ; clear config active bit
                                   (0344) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0345) 	and		[ACTIVE_CONFIG_STATUS+waiting_ADDR_OFF], ~waiting_BIT
                                   (0346)     M8C_SetBank0                    ; Force return to bank 0
                                   (0347) 	pop		x
                                   (0348) 
                                   (0349)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0350)     ret
0755: 10       PUSH  X             (0351) 
0756: 70 EF    AND   F,239         (0352) ;---------------------------------------------------------------------------
0758: 50 00    MOV   A,0           (0353) ; Load Configuration hello
075A: 67       ASR   A             (0354) ;
                                   (0355) ;    Load configuration registers for hello.
075B: 50 01    MOV   A,1           (0356) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
075D: 57 E6    MOV   X,230         (0357) ;
075F: 7C 0C 0E LCALL 0x0C0E        (0358) ;       INPUTS: None.
                                   (0359) ;      RETURNS: Nothing.
0762: 50 01    MOV   A,1           (0360) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0764: 67       ASR   A             (0361) ;               modified as may the Page Pointer registers!
                                   (0362) ;               In the large memory model currently only the page
0765: 50 01    MOV   A,1           (0363) ;               pointer registers listed below are modified.  This does
0767: 57 F3    MOV   X,243         (0364) ;               not guarantee that in future implementations of this
0769: 7C 0C 0E LCALL 0x0C0E        (0365) ;               function other page pointer registers will not be
                                   (0366) ;               modified.
076C: 70 EF    AND   F,239         (0367) ;          
                                   (0368) ;               Page Pointer Registers Modified: 
076E: 41 B3 F0 AND   REG[179],240  (0369) ;               CUR_PP
0771: 43 B3 05 OR    REG[179],5    (0370) ;
                                   (0371) _LoadConfig_hello:
0774: 41 B4 F0 AND   REG[180],240  (0372)  LoadConfig_hello:
0777: 43 B4 05 OR    REG[180],5    (0373)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0374) 	M8C_SetBank1
077A: 41 B5 ED AND   REG[181],237  (0375) ; writing Port_0_DriveMode_0 register
077D: 43 B5 12 OR    REG[181],18   (0376) 	and		reg[ 0h], ~1eh
                                   (0377) ; writing Port_0_DriveMode_1 register
0780: 41 B6 EE AND   REG[182],238  (0378) 	and		reg[ 1h], ~1eh
0783: 43 B6 11 OR    REG[182],17   (0379) 	or		reg[ 1h], 1eh
                                   (0380) ; writing Port_0_DriveMode_2 register
0786: 41 B8 3F AND   REG[184],63   (0381) 	M8C_SetBank0
0789: 43 B8 40 OR    REG[184],64   (0382) 	and		reg[ 3h], ~ 1h
                                   (0383) 	or		reg[ 3h],  1h
078C: 41 02 FE AND   REG[2],254    (0384) ; writing Port_0_GlobalSelect register
078F: 43 02 01 OR    REG[2],1      (0385) 	and		reg[ 2h], ~ 1h
                                   (0386) ; writing Row_0_LogicSelect_0 register
0792: 41 03 FE AND   REG[3],254    (0387) 	and		reg[b3h], ~ fh
                                   (0388) 	or		reg[b3h],  3h
0795: 71 10    OR    F,16          (0389) ; writing Row_0_LogicSelect_1 register
0797: 41 01 E1 AND   REG[1],225    (0390) 	and		reg[b4h], ~ fh
                                   (0391) 	or		reg[b4h],  3h
079A: 41 00 E1 AND   REG[0],225    (0392) ; writing Row_0_OutputDrive_0 register
079D: 43 00 1E OR    REG[0],30     (0393) 	and		reg[b5h], ~12h
07A0: 70 EF    AND   F,239         (0394) ; writing Row_0_OutputDrive_1 register
                                   (0395) 	and		reg[b6h], ~11h
07A2: 62 D0 00 MOV   REG[208],0    (0396) ; writing Row_1_InputMux register
07A5: 26 04 FD AND   [4],253       (0397) 	and		reg[b8h], ~c0h
07A8: 70 EF    AND   F,239         (0398) 
07AA: 20       POP   X             (0399) 	push	x
                                   (0400)     M8C_SetBank0                    ; Force bank 0
                                   (0401)     mov     a, 0                    ; Specify bank 0
07AB: 7F       RET                 (0402)     asr     a                       ; Store in carry flag
                                   (0403)                                     ; Load bank 0 table:
                                   (0404)     mov     A, >LoadConfigTBL_hello_Bank0
                                   (0405)     mov     X, <LoadConfigTBL_hello_Bank0
                                   (0406)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0407) 
                                   (0408)     mov     a, 1                    ; Specify bank 1
                                   (0409)     asr     a                       ; Store in carry flag
                                   (0410)                                     ; Load bank 1 table:
                                   (0411)     mov     A, >LoadConfigTBL_hello_Bank1
                                   (0412)     mov     X, <LoadConfigTBL_hello_Bank1
                                   (0413)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0414) 
                                   (0415) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0416) ; set config active bit
                                   (0417) 	or		[ACTIVE_CONFIG_STATUS+hello_ADDR_OFF], hello_BIT
                                   (0418)     M8C_SetBank0                    ; Force return to bank 0
                                   (0419) 	pop		x
                                   (0420) 
                                   (0421)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0422)     ret
                                   (0423) 
                                   (0424) ;---------------------------------------------------------------------------
                                   (0425) ; Unload Configuration hello
07AC: 71 10    OR    F,16          (0426) ;
                                   (0427) ;    Reset configuration registers for hello
07AE: 41 00 E1 AND   REG[0],225    (0428) ;    to their values as initially configured.
                                   (0429) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
07B1: 41 01 E1 AND   REG[1],225    (0430) ;
07B4: 43 01 1E OR    REG[1],30     (0431) ;       INPUTS: None.
                                   (0432) ;      RETURNS: Nothing.
07B7: 70 EF    AND   F,239         (0433) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
07B9: 41 03 E1 AND   REG[3],225    (0434) ;               modified as may the Page Pointer registers!
07BC: 43 03 1E OR    REG[3],30     (0435) ;               In the large memory model currently only the page
                                   (0436) ;               pointer registers listed below are modified.  This does
07BF: 41 02 E1 AND   REG[2],225    (0437) ;               not guarantee that in future implementations of this
                                   (0438) ;               function other page pointer registers will not be
07C2: 41 B3 F0 AND   REG[179],240  (0439) ;               modified.
07C5: 43 B3 03 OR    REG[179],3    (0440) ;          
                                   (0441) ;               Page Pointer Registers Modified: 
07C8: 41 B4 F0 AND   REG[180],240  (0442) ;               CUR_PP
07CB: 43 B4 03 OR    REG[180],3    (0443) ;
                                   (0444) _UnloadConfig_hello:
07CE: 41 B5 ED AND   REG[181],237  (0445)  UnloadConfig_hello:
                                   (0446)     RAM_PROLOGUE RAM_USE_CLASS_4
07D1: 41 B6 EE AND   REG[182],238  (0447) 
                                   (0448) 	push	x
07D4: 10       PUSH  X             (0449)     M8C_SetBank0                    ; Force bank 0
07D5: 70 EF    AND   F,239         (0450)     mov     a, 0                    ; Specify bank 0
07D7: 50 00    MOV   A,0           (0451)     asr     a                       ; Store in carry flag
07D9: 67       ASR   A             (0452)                                     ; Bank 0 table address:
                                   (0453)     mov     A, >UnloadConfigTBL_hello_Bank0
07DA: 50 02    MOV   A,2           (0454)     mov     X, <UnloadConfigTBL_hello_Bank0
07DC: 57 25    MOV   X,37          (0455)     lcall   LoadConfig              ; Unload the bank 0 values
07DE: 7C 0C 0E LCALL 0x0C0E        (0456) 
                                   (0457)     mov     a, 1                    ; Specify bank 1
07E1: 50 01    MOV   A,1           (0458)     asr     a                       ; Store in carry flag
07E3: 67       ASR   A             (0459)                                     ; Bank 1 table address:
                                   (0460)     mov     A, >UnloadConfigTBL_hello_Bank1
07E4: 50 02    MOV   A,2           (0461)     mov     X, <UnloadConfigTBL_hello_Bank1
07E6: 57 38    MOV   X,56          (0462)     lcall   LoadConfig              ; Unload the bank 1 values
07E8: 7C 0C 0E LCALL 0x0C0E        (0463) 
                                   (0464) 	M8C_SetBank0
07EB: 62 D0 00 MOV   REG[208],0    (0465) ; writing Row_0_LogicSelect_0 register
                                   (0466) 	and		reg[b3h], ~ fh
07EE: 2E 04 04 OR    [4],4         (0467) 	or		reg[b3h],  5h
07F1: 70 EF    AND   F,239         (0468) ; writing Row_0_LogicSelect_1 register
07F3: 20       POP   X             (0469) 	and		reg[b4h], ~ fh
                                   (0470) 	or		reg[b4h],  5h
                                   (0471) ; writing Row_0_OutputDrive_0 register
07F4: 7F       RET                 (0472) 	and		reg[b5h], ~12h
                                   (0473) 	or		reg[b5h], 12h
                                   (0474) ; writing Row_0_OutputDrive_1 register
                                   (0475) 	and		reg[b6h], ~11h
                                   (0476) 	or		reg[b6h], 11h
                                   (0477) ; writing Row_1_InputMux register
                                   (0478) 	and		reg[b8h], ~c0h
                                   (0479) 	or		reg[b8h], 40h
                                   (0480) ; writing Port_0_GlobalSelect register
                                   (0481) 	and		reg[ 2h], ~ 1h
                                   (0482) 	or		reg[ 2h],  1h
                                   (0483) ; writing Port_0_DriveMode_2 register
                                   (0484) 	and		reg[ 3h], ~ 1h
                                   (0485) ; writing Port_0_DriveMode_1 register
                                   (0486) 	M8C_SetBank1
                                   (0487) 	and		reg[ 1h], ~1eh
                                   (0488) ; writing Port_0_DriveMode_0 register
                                   (0489) 	and		reg[ 0h], ~1eh
                                   (0490) 	or		reg[ 0h], 1eh
                                   (0491) 	M8C_SetBank0
                                   (0492) ; clear config active bit
                                   (0493) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0494) 	and		[ACTIVE_CONFIG_STATUS+hello_ADDR_OFF], ~hello_BIT
                                   (0495)     M8C_SetBank0                    ; Force return to bank 0
                                   (0496) 	pop		x
                                   (0497) 
07F5: 10       PUSH  X             (0498)     RAM_EPILOGUE RAM_USE_CLASS_4
07F6: 70 EF    AND   F,239         (0499)     ret
07F8: 50 00    MOV   A,0           (0500) 
07FA: 67       ASR   A             (0501) ;---------------------------------------------------------------------------
                                   (0502) ; Load Configuration initial
07FB: 50 02    MOV   A,2           (0503) ;
07FD: 57 51    MOV   X,81          (0504) ;    Load configuration registers for initial.
07FF: 7C 0C 0E LCALL 0x0C0E        (0505) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0506) ;
0802: 50 01    MOV   A,1           (0507) ;       INPUTS: None.
0804: 67       ASR   A             (0508) ;      RETURNS: Nothing.
                                   (0509) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0805: 50 02    MOV   A,2           (0510) ;               modified as may the Page Pointer registers!
0807: 57 58    MOV   X,88          (0511) ;               In the large memory model currently only the page
0809: 7C 0C 0E LCALL 0x0C0E        (0512) ;               pointer registers listed below are modified.  This does
                                   (0513) ;               not guarantee that in future implementations of this
080C: 70 EF    AND   F,239         (0514) ;               function other page pointer registers will not be
                                   (0515) ;               modified.
080E: 41 B3 F0 AND   REG[179],240  (0516) ;          
0811: 43 B3 05 OR    REG[179],5    (0517) ;               Page Pointer Registers Modified: 
                                   (0518) ;               CUR_PP
0814: 41 B4 F0 AND   REG[180],240  (0519) ;
0817: 43 B4 05 OR    REG[180],5    (0520) _LoadConfig_initial:
                                   (0521)  LoadConfig_initial:
081A: 41 B5 ED AND   REG[181],237  (0522)     RAM_PROLOGUE RAM_USE_CLASS_4
081D: 43 B5 12 OR    REG[181],18   (0523) 	M8C_SetBank1
                                   (0524) ; writing Port_0_DriveMode_0 register
0820: 41 B6 EE AND   REG[182],238  (0525) 	and		reg[ 0h], ~1eh
0823: 43 B6 11 OR    REG[182],17   (0526) ; writing Port_0_DriveMode_1 register
                                   (0527) 	and		reg[ 1h], ~1eh
0826: 41 02 E1 AND   REG[2],225    (0528) 	or		reg[ 1h], 1eh
0829: 43 02 1E OR    REG[2],30     (0529) ; writing Port_0_DriveMode_2 register
                                   (0530) 	M8C_SetBank0
082C: 41 03 E1 AND   REG[3],225    (0531) 	and		reg[ 3h], ~1eh
                                   (0532) 	or		reg[ 3h], 1eh
082F: 71 10    OR    F,16          (0533) ; writing Port_0_GlobalSelect register
0831: 41 01 E1 AND   REG[1],225    (0534) 	and		reg[ 2h], ~1eh
                                   (0535) ; writing Row_0_LogicSelect_0 register
0834: 41 00 E1 AND   REG[0],225    (0536) 	and		reg[b3h], ~ fh
0837: 43 00 1E OR    REG[0],30     (0537) 	or		reg[b3h],  3h
083A: 70 EF    AND   F,239         (0538) ; writing Row_0_LogicSelect_1 register
                                   (0539) 	and		reg[b4h], ~ fh
083C: 62 D0 00 MOV   REG[208],0    (0540) 	or		reg[b4h],  3h
083F: 26 04 FB AND   [4],251       (0541) ; writing Row_0_OutputDrive_0 register
0842: 70 EF    AND   F,239         (0542) 	and		reg[b5h], ~12h
0844: 20       POP   X             (0543) ; writing Row_0_OutputDrive_1 register
                                   (0544) 	and		reg[b6h], ~11h
                                   (0545) 
0845: 7F       RET                 (0546) 	push	x
                                   (0547)     M8C_SetBank0                    ; Force bank 0
                                   (0548)     mov     a, 0                    ; Specify bank 0
                                   (0549)     asr     a                       ; Store in carry flag
                                   (0550)                                     ; Load bank 0 table:
                                   (0551)     mov     A, >LoadConfigTBL_initial_Bank0
                                   (0552)     mov     X, <LoadConfigTBL_initial_Bank0
                                   (0553)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0554) 
                                   (0555)     mov     a, 1                    ; Specify bank 1
                                   (0556)     asr     a                       ; Store in carry flag
                                   (0557)                                     ; Load bank 1 table:
                                   (0558)     mov     A, >LoadConfigTBL_initial_Bank1
                                   (0559)     mov     X, <LoadConfigTBL_initial_Bank1
                                   (0560)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0561) 
                                   (0562) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0563) ; set config active bit
                                   (0564) 	or		[ACTIVE_CONFIG_STATUS+initial_ADDR_OFF], initial_BIT
                                   (0565)     M8C_SetBank0                    ; Force return to bank 0
                                   (0566) 	pop		x
                                   (0567) 
                                   (0568)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0569)     ret
0846: 71 10    OR    F,16          (0570) 
                                   (0571) ;---------------------------------------------------------------------------
0848: 41 00 FE AND   REG[0],254    (0572) ; Unload Configuration initial
084B: 43 00 01 OR    REG[0],1      (0573) ;
                                   (0574) ;    Reset configuration registers for initial
084E: 41 01 FE AND   REG[1],254    (0575) ;    to their values as initially configured.
                                   (0576) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0851: 70 EF    AND   F,239         (0577) ;
0853: 41 B5 FE AND   REG[181],254  (0578) ;       INPUTS: None.
0856: 43 B5 01 OR    REG[181],1    (0579) ;      RETURNS: Nothing.
                                   (0580) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0859: 10       PUSH  X             (0581) ;               modified as may the Page Pointer registers!
085A: 70 EF    AND   F,239         (0582) ;               In the large memory model currently only the page
085C: 50 00    MOV   A,0           (0583) ;               pointer registers listed below are modified.  This does
085E: 67       ASR   A             (0584) ;               not guarantee that in future implementations of this
                                   (0585) ;               function other page pointer registers will not be
085F: 50 02    MOV   A,2           (0586) ;               modified.
0861: 57 72    MOV   X,114         (0587) ;          
0863: 7C 0C 0E LCALL 0x0C0E        (0588) ;               Page Pointer Registers Modified: 
                                   (0589) ;               CUR_PP
0866: 50 01    MOV   A,1           (0590) ;
0868: 67       ASR   A             (0591) _UnloadConfig_initial:
                                   (0592)  UnloadConfig_initial:
0869: 50 02    MOV   A,2           (0593)     RAM_PROLOGUE RAM_USE_CLASS_4
086B: 57 8B    MOV   X,139         (0594) 
086D: 7C 0C 0E LCALL 0x0C0E        (0595) 	push	x
                                   (0596)     M8C_SetBank0                    ; Force bank 0
0870: 62 D0 00 MOV   REG[208],0    (0597)     mov     a, 0                    ; Specify bank 0
                                   (0598)     asr     a                       ; Store in carry flag
0873: 2E 04 08 OR    [4],8         (0599)                                     ; Bank 0 table address:
0876: 70 EF    AND   F,239         (0600)     mov     A, >UnloadConfigTBL_initial_Bank0
0878: 20       POP   X             (0601)     mov     X, <UnloadConfigTBL_initial_Bank0
                                   (0602)     lcall   LoadConfig              ; Unload the bank 0 values
                                   (0603) 
0879: 7F       RET                 (0604)     mov     a, 1                    ; Specify bank 1
                                   (0605)     asr     a                       ; Store in carry flag
                                   (0606)                                     ; Bank 1 table address:
                                   (0607)     mov     A, >UnloadConfigTBL_initial_Bank1
                                   (0608)     mov     X, <UnloadConfigTBL_initial_Bank1
                                   (0609)     lcall   LoadConfig              ; Unload the bank 1 values
                                   (0610) 
                                   (0611) 	M8C_SetBank0
                                   (0612) ; writing Row_0_LogicSelect_0 register
                                   (0613) 	and		reg[b3h], ~ fh
                                   (0614) 	or		reg[b3h],  5h
                                   (0615) ; writing Row_0_LogicSelect_1 register
                                   (0616) 	and		reg[b4h], ~ fh
                                   (0617) 	or		reg[b4h],  5h
                                   (0618) ; writing Row_0_OutputDrive_0 register
                                   (0619) 	and		reg[b5h], ~12h
                                   (0620) 	or		reg[b5h], 12h
                                   (0621) ; writing Row_0_OutputDrive_1 register
                                   (0622) 	and		reg[b6h], ~11h
                                   (0623) 	or		reg[b6h], 11h
                                   (0624) ; writing Port_0_GlobalSelect register
                                   (0625) 	and		reg[ 2h], ~1eh
                                   (0626) 	or		reg[ 2h], 1eh
                                   (0627) ; writing Port_0_DriveMode_2 register
                                   (0628) 	and		reg[ 3h], ~1eh
                                   (0629) ; writing Port_0_DriveMode_1 register
087A: 10       PUSH  X             (0630) 	M8C_SetBank1
087B: 70 EF    AND   F,239         (0631) 	and		reg[ 1h], ~1eh
087D: 50 00    MOV   A,0           (0632) ; writing Port_0_DriveMode_0 register
087F: 67       ASR   A             (0633) 	and		reg[ 0h], ~1eh
                                   (0634) 	or		reg[ 0h], 1eh
0880: 50 02    MOV   A,2           (0635) 	M8C_SetBank0
0882: 57 AC    MOV   X,172         (0636) ; clear config active bit
0884: 7C 0C 0E LCALL 0x0C0E        (0637) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0638) 	and		[ACTIVE_CONFIG_STATUS+initial_ADDR_OFF], ~initial_BIT
0887: 50 01    MOV   A,1           (0639)     M8C_SetBank0                    ; Force return to bank 0
0889: 67       ASR   A             (0640) 	pop		x
                                   (0641) 
088A: 50 02    MOV   A,2           (0642)     RAM_EPILOGUE RAM_USE_CLASS_4
088C: 57 B5    MOV   X,181         (0643)     ret
088E: 7C 0C 0E LCALL 0x0C0E        (0644) 
                                   (0645) ;---------------------------------------------------------------------------
0891: 70 EF    AND   F,239         (0646) ; Load Configuration my_response
                                   (0647) ;
0893: 41 B5 FE AND   REG[181],254  (0648) ;    Load configuration registers for my_response.
                                   (0649) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0896: 71 10    OR    F,16          (0650) ;
0898: 41 01 FE AND   REG[1],254    (0651) ;       INPUTS: None.
089B: 43 01 01 OR    REG[1],1      (0652) ;      RETURNS: Nothing.
                                   (0653) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
089E: 41 00 FE AND   REG[0],254    (0654) ;               modified as may the Page Pointer registers!
08A1: 70 EF    AND   F,239         (0655) ;               In the large memory model currently only the page
                                   (0656) ;               pointer registers listed below are modified.  This does
08A3: 62 D0 00 MOV   REG[208],0    (0657) ;               not guarantee that in future implementations of this
08A6: 26 04 F7 AND   [4],247       (0658) ;               function other page pointer registers will not be
08A9: 70 EF    AND   F,239         (0659) ;               modified.
08AB: 20       POP   X             (0660) ;          
                                   (0661) ;               Page Pointer Registers Modified: 
                                   (0662) ;               CUR_PP
08AC: 7F       RET                 (0663) ;
                                   (0664) _LoadConfig_my_response:
                                   (0665)  LoadConfig_my_response:
                                   (0666)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0667) 	M8C_SetBank1
                                   (0668) ; writing Port_0_DriveMode_0 register
                                   (0669) 	and		reg[ 0h], ~ 1h
                                   (0670) 	or		reg[ 0h],  1h
                                   (0671) ; writing Port_0_DriveMode_1 register
                                   (0672) 	and		reg[ 1h], ~ 1h
                                   (0673) ; writing Row_0_OutputDrive_0 register
                                   (0674) 	M8C_SetBank0
                                   (0675) 	and		reg[b5h], ~ 1h
                                   (0676) 	or		reg[b5h],  1h
                                   (0677) 
                                   (0678) 	push	x
                                   (0679)     M8C_SetBank0                    ; Force bank 0
                                   (0680)     mov     a, 0                    ; Specify bank 0
                                   (0681)     asr     a                       ; Store in carry flag
                                   (0682)                                     ; Load bank 0 table:
                                   (0683)     mov     A, >LoadConfigTBL_my_response_Bank0
                                   (0684)     mov     X, <LoadConfigTBL_my_response_Bank0
                                   (0685)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0686) 
08AD: 71 10    OR    F,16          (0687)     mov     a, 1                    ; Specify bank 1
                                   (0688)     asr     a                       ; Store in carry flag
08AF: 41 00 E0 AND   REG[0],224    (0689)                                     ; Load bank 1 table:
08B2: 43 00 01 OR    REG[0],1      (0690)     mov     A, >LoadConfigTBL_my_response_Bank1
                                   (0691)     mov     X, <LoadConfigTBL_my_response_Bank1
08B5: 41 01 E0 AND   REG[1],224    (0692)     lcall   LoadConfig              ; Load the bank 1 values
08B8: 43 01 1E OR    REG[1],30     (0693) 
                                   (0694) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
08BB: 70 EF    AND   F,239         (0695) ; set config active bit
08BD: 41 03 E3 AND   REG[3],227    (0696) 	or		[ACTIVE_CONFIG_STATUS+my_response_ADDR_OFF], my_response_BIT
08C0: 43 03 1C OR    REG[3],28     (0697)     M8C_SetBank0                    ; Force return to bank 0
                                   (0698) 	pop		x
08C3: 41 02 E3 AND   REG[2],227    (0699) 
                                   (0700)     RAM_EPILOGUE RAM_USE_CLASS_4
08C6: 41 B3 F0 AND   REG[179],240  (0701)     ret
08C9: 43 B3 03 OR    REG[179],3    (0702) 
                                   (0703) ;---------------------------------------------------------------------------
08CC: 41 B4 F0 AND   REG[180],240  (0704) ; Unload Configuration my_response
08CF: 43 B4 03 OR    REG[180],3    (0705) ;
                                   (0706) ;    Reset configuration registers for my_response
08D2: 41 B5 EC AND   REG[181],236  (0707) ;    to their values as initially configured.
08D5: 43 B5 01 OR    REG[181],1    (0708) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0709) ;
08D8: 41 B6 EE AND   REG[182],238  (0710) ;       INPUTS: None.
                                   (0711) ;      RETURNS: Nothing.
08DB: 10       PUSH  X             (0712) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
08DC: 70 EF    AND   F,239         (0713) ;               modified as may the Page Pointer registers!
08DE: 50 00    MOV   A,0           (0714) ;               In the large memory model currently only the page
08E0: 67       ASR   A             (0715) ;               pointer registers listed below are modified.  This does
                                   (0716) ;               not guarantee that in future implementations of this
08E1: 50 02    MOV   A,2           (0717) ;               function other page pointer registers will not be
08E3: 57 D7    MOV   X,215         (0718) ;               modified.
08E5: 7C 0C 0E LCALL 0x0C0E        (0719) ;          
                                   (0720) ;               Page Pointer Registers Modified: 
08E8: 50 01    MOV   A,1           (0721) ;               CUR_PP
08EA: 67       ASR   A             (0722) ;
                                   (0723) _UnloadConfig_my_response:
08EB: 50 02    MOV   A,2           (0724)  UnloadConfig_my_response:
08ED: 57 EA    MOV   X,234         (0725)     RAM_PROLOGUE RAM_USE_CLASS_4
08EF: 7C 0C 0E LCALL 0x0C0E        (0726) 
                                   (0727) 	push	x
08F2: 62 D0 00 MOV   REG[208],0    (0728)     M8C_SetBank0                    ; Force bank 0
                                   (0729)     mov     a, 0                    ; Specify bank 0
08F5: 2E 04 10 OR    [4],16        (0730)     asr     a                       ; Store in carry flag
08F8: 70 EF    AND   F,239         (0731)                                     ; Bank 0 table address:
08FA: 20       POP   X             (0732)     mov     A, >UnloadConfigTBL_my_response_Bank0
                                   (0733)     mov     X, <UnloadConfigTBL_my_response_Bank0
                                   (0734)     lcall   LoadConfig              ; Unload the bank 0 values
08FB: 7F       RET                 (0735) 
                                   (0736)     mov     a, 1                    ; Specify bank 1
                                   (0737)     asr     a                       ; Store in carry flag
                                   (0738)                                     ; Bank 1 table address:
                                   (0739)     mov     A, >UnloadConfigTBL_my_response_Bank1
                                   (0740)     mov     X, <UnloadConfigTBL_my_response_Bank1
                                   (0741)     lcall   LoadConfig              ; Unload the bank 1 values
                                   (0742) 
                                   (0743) 	M8C_SetBank0
                                   (0744) ; writing Row_0_OutputDrive_0 register
                                   (0745) 	and		reg[b5h], ~ 1h
                                   (0746) ; writing Port_0_DriveMode_1 register
                                   (0747) 	M8C_SetBank1
                                   (0748) 	and		reg[ 1h], ~ 1h
                                   (0749) 	or		reg[ 1h],  1h
                                   (0750) ; writing Port_0_DriveMode_0 register
                                   (0751) 	and		reg[ 0h], ~ 1h
                                   (0752) 	M8C_SetBank0
                                   (0753) ; clear config active bit
                                   (0754) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0755) 	and		[ACTIVE_CONFIG_STATUS+my_response_ADDR_OFF], ~my_response_BIT
                                   (0756)     M8C_SetBank0                    ; Force return to bank 0
                                   (0757) 	pop		x
                                   (0758) 
                                   (0759)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0760)     ret
08FC: 10       PUSH  X             (0761) 
08FD: 70 EF    AND   F,239         (0762) ;---------------------------------------------------------------------------
08FF: 50 00    MOV   A,0           (0763) ; Load Configuration response1
0901: 67       ASR   A             (0764) ;
                                   (0765) ;    Load configuration registers for response1.
0902: 50 03    MOV   A,3           (0766) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0904: 57 03    MOV   X,3           (0767) ;
0906: 7C 0C 0E LCALL 0x0C0E        (0768) ;       INPUTS: None.
                                   (0769) ;      RETURNS: Nothing.
0909: 50 01    MOV   A,1           (0770) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
090B: 67       ASR   A             (0771) ;               modified as may the Page Pointer registers!
                                   (0772) ;               In the large memory model currently only the page
090C: 50 03    MOV   A,3           (0773) ;               pointer registers listed below are modified.  This does
090E: 57 0A    MOV   X,10          (0774) ;               not guarantee that in future implementations of this
0910: 7C 0C 0E LCALL 0x0C0E        (0775) ;               function other page pointer registers will not be
                                   (0776) ;               modified.
0913: 70 EF    AND   F,239         (0777) ;          
                                   (0778) ;               Page Pointer Registers Modified: 
0915: 41 B3 F0 AND   REG[179],240  (0779) ;               CUR_PP
0918: 43 B3 05 OR    REG[179],5    (0780) ;
                                   (0781) _LoadConfig_response1:
091B: 41 B4 F0 AND   REG[180],240  (0782)  LoadConfig_response1:
091E: 43 B4 05 OR    REG[180],5    (0783)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0784) 	M8C_SetBank1
0921: 41 B5 EC AND   REG[181],236  (0785) ; writing Port_0_DriveMode_0 register
0924: 43 B5 12 OR    REG[181],18   (0786) 	and		reg[ 0h], ~1fh
                                   (0787) 	or		reg[ 0h],  1h
0927: 41 B6 EE AND   REG[182],238  (0788) ; writing Port_0_DriveMode_1 register
092A: 43 B6 11 OR    REG[182],17   (0789) 	and		reg[ 1h], ~1fh
                                   (0790) 	or		reg[ 1h], 1eh
092D: 41 02 E3 AND   REG[2],227    (0791) ; writing Port_0_DriveMode_2 register
0930: 43 02 1C OR    REG[2],28     (0792) 	M8C_SetBank0
                                   (0793) 	and		reg[ 3h], ~1ch
0933: 41 03 E3 AND   REG[3],227    (0794) 	or		reg[ 3h], 1ch
                                   (0795) ; writing Port_0_GlobalSelect register
0936: 71 10    OR    F,16          (0796) 	and		reg[ 2h], ~1ch
0938: 41 01 E0 AND   REG[1],224    (0797) ; writing Row_0_LogicSelect_0 register
093B: 43 01 01 OR    REG[1],1      (0798) 	and		reg[b3h], ~ fh
                                   (0799) 	or		reg[b3h],  3h
093E: 41 00 E0 AND   REG[0],224    (0800) ; writing Row_0_LogicSelect_1 register
0941: 43 00 1E OR    REG[0],30     (0801) 	and		reg[b4h], ~ fh
0944: 70 EF    AND   F,239         (0802) 	or		reg[b4h],  3h
                                   (0803) ; writing Row_0_OutputDrive_0 register
0946: 62 D0 00 MOV   REG[208],0    (0804) 	and		reg[b5h], ~13h
0949: 26 04 EF AND   [4],239       (0805) 	or		reg[b5h],  1h
094C: 70 EF    AND   F,239         (0806) ; writing Row_0_OutputDrive_1 register
094E: 20       POP   X             (0807) 	and		reg[b6h], ~11h
                                   (0808) 
                                   (0809) 	push	x
094F: 7F       RET                 (0810)     M8C_SetBank0                    ; Force bank 0
                                   (0811)     mov     a, 0                    ; Specify bank 0
                                   (0812)     asr     a                       ; Store in carry flag
                                   (0813)                                     ; Load bank 0 table:
                                   (0814)     mov     A, >LoadConfigTBL_response1_Bank0
                                   (0815)     mov     X, <LoadConfigTBL_response1_Bank0
                                   (0816)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0817) 
                                   (0818)     mov     a, 1                    ; Specify bank 1
                                   (0819)     asr     a                       ; Store in carry flag
                                   (0820)                                     ; Load bank 1 table:
                                   (0821)     mov     A, >LoadConfigTBL_response1_Bank1
                                   (0822)     mov     X, <LoadConfigTBL_response1_Bank1
                                   (0823)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0824) 
                                   (0825) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0826) ; set config active bit
                                   (0827) 	or		[ACTIVE_CONFIG_STATUS+response1_ADDR_OFF], response1_BIT
                                   (0828)     M8C_SetBank0                    ; Force return to bank 0
                                   (0829) 	pop		x
                                   (0830) 
                                   (0831)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0832)     ret
                                   (0833) 
0950: 71 10    OR    F,16          (0834) ;---------------------------------------------------------------------------
                                   (0835) ; Unload Configuration response1
0952: 41 00 E0 AND   REG[0],224    (0836) ;
0955: 43 00 01 OR    REG[0],1      (0837) ;    Reset configuration registers for response1
                                   (0838) ;    to their values as initially configured.
0958: 41 01 E0 AND   REG[1],224    (0839) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
095B: 43 01 1E OR    REG[1],30     (0840) ;
                                   (0841) ;       INPUTS: None.
095E: 70 EF    AND   F,239         (0842) ;      RETURNS: Nothing.
0960: 41 03 E5 AND   REG[3],229    (0843) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0963: 43 03 1A OR    REG[3],26     (0844) ;               modified as may the Page Pointer registers!
                                   (0845) ;               In the large memory model currently only the page
0966: 41 02 E5 AND   REG[2],229    (0846) ;               pointer registers listed below are modified.  This does
                                   (0847) ;               not guarantee that in future implementations of this
0969: 41 B3 F0 AND   REG[179],240  (0848) ;               function other page pointer registers will not be
096C: 43 B3 03 OR    REG[179],3    (0849) ;               modified.
                                   (0850) ;          
096F: 41 B4 F0 AND   REG[180],240  (0851) ;               Page Pointer Registers Modified: 
0972: 43 B4 03 OR    REG[180],3    (0852) ;               CUR_PP
                                   (0853) ;
0975: 41 B5 EC AND   REG[181],236  (0854) _UnloadConfig_response1:
0978: 43 B5 01 OR    REG[181],1    (0855)  UnloadConfig_response1:
                                   (0856)     RAM_PROLOGUE RAM_USE_CLASS_4
097B: 41 B6 EE AND   REG[182],238  (0857) 
                                   (0858) 	push	x
097E: 10       PUSH  X             (0859)     M8C_SetBank0                    ; Force bank 0
097F: 70 EF    AND   F,239         (0860)     mov     a, 0                    ; Specify bank 0
0981: 50 00    MOV   A,0           (0861)     asr     a                       ; Store in carry flag
0983: 67       ASR   A             (0862)                                     ; Bank 0 table address:
                                   (0863)     mov     A, >UnloadConfigTBL_response1_Bank0
0984: 50 03    MOV   A,3           (0864)     mov     X, <UnloadConfigTBL_response1_Bank0
0986: 57 24    MOV   X,36          (0865)     lcall   LoadConfig              ; Unload the bank 0 values
0988: 7C 0C 0E LCALL 0x0C0E        (0866) 
                                   (0867)     mov     a, 1                    ; Specify bank 1
098B: 50 01    MOV   A,1           (0868)     asr     a                       ; Store in carry flag
098D: 67       ASR   A             (0869)                                     ; Bank 1 table address:
                                   (0870)     mov     A, >UnloadConfigTBL_response1_Bank1
098E: 50 03    MOV   A,3           (0871)     mov     X, <UnloadConfigTBL_response1_Bank1
0990: 57 37    MOV   X,55          (0872)     lcall   LoadConfig              ; Unload the bank 1 values
0992: 7C 0C 0E LCALL 0x0C0E        (0873) 
                                   (0874) 	M8C_SetBank0
0995: 62 D0 00 MOV   REG[208],0    (0875) ; writing Row_0_LogicSelect_0 register
                                   (0876) 	and		reg[b3h], ~ fh
0998: 2E 04 20 OR    [4],32        (0877) 	or		reg[b3h],  5h
099B: 70 EF    AND   F,239         (0878) ; writing Row_0_LogicSelect_1 register
099D: 20       POP   X             (0879) 	and		reg[b4h], ~ fh
                                   (0880) 	or		reg[b4h],  5h
                                   (0881) ; writing Row_0_OutputDrive_0 register
099E: 7F       RET                 (0882) 	and		reg[b5h], ~13h
                                   (0883) 	or		reg[b5h], 12h
                                   (0884) ; writing Row_0_OutputDrive_1 register
                                   (0885) 	and		reg[b6h], ~11h
                                   (0886) 	or		reg[b6h], 11h
                                   (0887) ; writing Port_0_GlobalSelect register
                                   (0888) 	and		reg[ 2h], ~1ch
                                   (0889) 	or		reg[ 2h], 1ch
                                   (0890) ; writing Port_0_DriveMode_2 register
                                   (0891) 	and		reg[ 3h], ~1ch
                                   (0892) ; writing Port_0_DriveMode_1 register
                                   (0893) 	M8C_SetBank1
                                   (0894) 	and		reg[ 1h], ~1fh
                                   (0895) 	or		reg[ 1h],  1h
                                   (0896) ; writing Port_0_DriveMode_0 register
                                   (0897) 	and		reg[ 0h], ~1fh
                                   (0898) 	or		reg[ 0h], 1eh
                                   (0899) 	M8C_SetBank0
                                   (0900) ; clear config active bit
                                   (0901) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0902) 	and		[ACTIVE_CONFIG_STATUS+response1_ADDR_OFF], ~response1_BIT
                                   (0903)     M8C_SetBank0                    ; Force return to bank 0
                                   (0904) 	pop		x
                                   (0905) 
                                   (0906)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0907)     ret
099F: 10       PUSH  X             (0908) 
09A0: 70 EF    AND   F,239         (0909) ;---------------------------------------------------------------------------
09A2: 50 00    MOV   A,0           (0910) ; Load Configuration response2
09A4: 67       ASR   A             (0911) ;
                                   (0912) ;    Load configuration registers for response2.
09A5: 50 03    MOV   A,3           (0913) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
09A7: 57 50    MOV   X,80          (0914) ;
09A9: 7C 0C 0E LCALL 0x0C0E        (0915) ;       INPUTS: None.
                                   (0916) ;      RETURNS: Nothing.
09AC: 50 01    MOV   A,1           (0917) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
09AE: 67       ASR   A             (0918) ;               modified as may the Page Pointer registers!
                                   (0919) ;               In the large memory model currently only the page
09AF: 50 03    MOV   A,3           (0920) ;               pointer registers listed below are modified.  This does
09B1: 57 57    MOV   X,87          (0921) ;               not guarantee that in future implementations of this
09B3: 7C 0C 0E LCALL 0x0C0E        (0922) ;               function other page pointer registers will not be
                                   (0923) ;               modified.
09B6: 70 EF    AND   F,239         (0924) ;          
                                   (0925) ;               Page Pointer Registers Modified: 
09B8: 41 B3 F0 AND   REG[179],240  (0926) ;               CUR_PP
09BB: 43 B3 05 OR    REG[179],5    (0927) ;
                                   (0928) _LoadConfig_response2:
09BE: 41 B4 F0 AND   REG[180],240  (0929)  LoadConfig_response2:
09C1: 43 B4 05 OR    REG[180],5    (0930)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0931) 	M8C_SetBank1
09C4: 41 B5 EC AND   REG[181],236  (0932) ; writing Port_0_DriveMode_0 register
09C7: 43 B5 12 OR    REG[181],18   (0933) 	and		reg[ 0h], ~1fh
                                   (0934) 	or		reg[ 0h],  1h
09CA: 41 B6 EE AND   REG[182],238  (0935) ; writing Port_0_DriveMode_1 register
09CD: 43 B6 11 OR    REG[182],17   (0936) 	and		reg[ 1h], ~1fh
                                   (0937) 	or		reg[ 1h], 1eh
09D0: 41 02 E5 AND   REG[2],229    (0938) ; writing Port_0_DriveMode_2 register
09D3: 43 02 1A OR    REG[2],26     (0939) 	M8C_SetBank0
                                   (0940) 	and		reg[ 3h], ~1ah
09D6: 41 03 E5 AND   REG[3],229    (0941) 	or		reg[ 3h], 1ah
                                   (0942) ; writing Port_0_GlobalSelect register
09D9: 71 10    OR    F,16          (0943) 	and		reg[ 2h], ~1ah
09DB: 41 01 E0 AND   REG[1],224    (0944) ; writing Row_0_LogicSelect_0 register
09DE: 43 01 01 OR    REG[1],1      (0945) 	and		reg[b3h], ~ fh
                                   (0946) 	or		reg[b3h],  3h
09E1: 41 00 E0 AND   REG[0],224    (0947) ; writing Row_0_LogicSelect_1 register
09E4: 43 00 1E OR    REG[0],30     (0948) 	and		reg[b4h], ~ fh
09E7: 70 EF    AND   F,239         (0949) 	or		reg[b4h],  3h
                                   (0950) ; writing Row_0_OutputDrive_0 register
09E9: 62 D0 00 MOV   REG[208],0    (0951) 	and		reg[b5h], ~13h
09EC: 26 04 DF AND   [4],223       (0952) 	or		reg[b5h],  1h
09EF: 70 EF    AND   F,239         (0953) ; writing Row_0_OutputDrive_1 register
09F1: 20       POP   X             (0954) 	and		reg[b6h], ~11h
                                   (0955) 
                                   (0956) 	push	x
09F2: 7F       RET                 (0957)     M8C_SetBank0                    ; Force bank 0
                                   (0958)     mov     a, 0                    ; Specify bank 0
                                   (0959)     asr     a                       ; Store in carry flag
                                   (0960)                                     ; Load bank 0 table:
                                   (0961)     mov     A, >LoadConfigTBL_response2_Bank0
                                   (0962)     mov     X, <LoadConfigTBL_response2_Bank0
                                   (0963)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0964) 
                                   (0965)     mov     a, 1                    ; Specify bank 1
                                   (0966)     asr     a                       ; Store in carry flag
                                   (0967)                                     ; Load bank 1 table:
                                   (0968)     mov     A, >LoadConfigTBL_response2_Bank1
                                   (0969)     mov     X, <LoadConfigTBL_response2_Bank1
                                   (0970)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0971) 
                                   (0972) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0973) ; set config active bit
                                   (0974) 	or		[ACTIVE_CONFIG_STATUS+response2_ADDR_OFF], response2_BIT
                                   (0975)     M8C_SetBank0                    ; Force return to bank 0
                                   (0976) 	pop		x
                                   (0977) 
                                   (0978)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0979)     ret
                                   (0980) 
09F3: 71 10    OR    F,16          (0981) ;---------------------------------------------------------------------------
                                   (0982) ; Unload Configuration response2
09F5: 41 00 E0 AND   REG[0],224    (0983) ;
09F8: 43 00 01 OR    REG[0],1      (0984) ;    Reset configuration registers for response2
                                   (0985) ;    to their values as initially configured.
09FB: 41 01 E0 AND   REG[1],224    (0986) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
09FE: 43 01 1E OR    REG[1],30     (0987) ;
                                   (0988) ;       INPUTS: None.
0A01: 70 EF    AND   F,239         (0989) ;      RETURNS: Nothing.
0A03: 41 03 E9 AND   REG[3],233    (0990) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0A06: 43 03 16 OR    REG[3],22     (0991) ;               modified as may the Page Pointer registers!
                                   (0992) ;               In the large memory model currently only the page
0A09: 41 02 E9 AND   REG[2],233    (0993) ;               pointer registers listed below are modified.  This does
                                   (0994) ;               not guarantee that in future implementations of this
0A0C: 41 B3 F0 AND   REG[179],240  (0995) ;               function other page pointer registers will not be
0A0F: 43 B3 03 OR    REG[179],3    (0996) ;               modified.
                                   (0997) ;          
0A12: 41 B4 F0 AND   REG[180],240  (0998) ;               Page Pointer Registers Modified: 
0A15: 43 B4 03 OR    REG[180],3    (0999) ;               CUR_PP
                                   (1000) ;
0A18: 41 B5 EC AND   REG[181],236  (1001) _UnloadConfig_response2:
0A1B: 43 B5 01 OR    REG[181],1    (1002)  UnloadConfig_response2:
                                   (1003)     RAM_PROLOGUE RAM_USE_CLASS_4
0A1E: 41 B6 EE AND   REG[182],238  (1004) 
                                   (1005) 	push	x
0A21: 10       PUSH  X             (1006)     M8C_SetBank0                    ; Force bank 0
0A22: 70 EF    AND   F,239         (1007)     mov     a, 0                    ; Specify bank 0
0A24: 50 00    MOV   A,0           (1008)     asr     a                       ; Store in carry flag
0A26: 67       ASR   A             (1009)                                     ; Bank 0 table address:
                                   (1010)     mov     A, >UnloadConfigTBL_response2_Bank0
0A27: 50 03    MOV   A,3           (1011)     mov     X, <UnloadConfigTBL_response2_Bank0
0A29: 57 71    MOV   X,113         (1012)     lcall   LoadConfig              ; Unload the bank 0 values
0A2B: 7C 0C 0E LCALL 0x0C0E        (1013) 
                                   (1014)     mov     a, 1                    ; Specify bank 1
0A2E: 50 01    MOV   A,1           (1015)     asr     a                       ; Store in carry flag
0A30: 67       ASR   A             (1016)                                     ; Bank 1 table address:
                                   (1017)     mov     A, >UnloadConfigTBL_response2_Bank1
0A31: 50 03    MOV   A,3           (1018)     mov     X, <UnloadConfigTBL_response2_Bank1
0A33: 57 84    MOV   X,132         (1019)     lcall   LoadConfig              ; Unload the bank 1 values
0A35: 7C 0C 0E LCALL 0x0C0E        (1020) 
                                   (1021) 	M8C_SetBank0
0A38: 62 D0 00 MOV   REG[208],0    (1022) ; writing Row_0_LogicSelect_0 register
                                   (1023) 	and		reg[b3h], ~ fh
0A3B: 2E 04 40 OR    [4],64        (1024) 	or		reg[b3h],  5h
0A3E: 70 EF    AND   F,239         (1025) ; writing Row_0_LogicSelect_1 register
0A40: 20       POP   X             (1026) 	and		reg[b4h], ~ fh
                                   (1027) 	or		reg[b4h],  5h
                                   (1028) ; writing Row_0_OutputDrive_0 register
0A41: 7F       RET                 (1029) 	and		reg[b5h], ~13h
                                   (1030) 	or		reg[b5h], 12h
                                   (1031) ; writing Row_0_OutputDrive_1 register
                                   (1032) 	and		reg[b6h], ~11h
                                   (1033) 	or		reg[b6h], 11h
                                   (1034) ; writing Port_0_GlobalSelect register
                                   (1035) 	and		reg[ 2h], ~1ah
                                   (1036) 	or		reg[ 2h], 1ah
                                   (1037) ; writing Port_0_DriveMode_2 register
                                   (1038) 	and		reg[ 3h], ~1ah
                                   (1039) ; writing Port_0_DriveMode_1 register
                                   (1040) 	M8C_SetBank1
                                   (1041) 	and		reg[ 1h], ~1fh
                                   (1042) 	or		reg[ 1h],  1h
                                   (1043) ; writing Port_0_DriveMode_0 register
                                   (1044) 	and		reg[ 0h], ~1fh
                                   (1045) 	or		reg[ 0h], 1eh
                                   (1046) 	M8C_SetBank0
                                   (1047) ; clear config active bit
                                   (1048) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1049) 	and		[ACTIVE_CONFIG_STATUS+response2_ADDR_OFF], ~response2_BIT
                                   (1050)     M8C_SetBank0                    ; Force return to bank 0
                                   (1051) 	pop		x
                                   (1052) 
                                   (1053)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1054)     ret
0A42: 10       PUSH  X             (1055) 
0A43: 70 EF    AND   F,239         (1056) ;---------------------------------------------------------------------------
0A45: 50 00    MOV   A,0           (1057) ; Load Configuration response3
0A47: 67       ASR   A             (1058) ;
                                   (1059) ;    Load configuration registers for response3.
0A48: 50 03    MOV   A,3           (1060) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0A4A: 57 9D    MOV   X,157         (1061) ;
0A4C: 7C 0C 0E LCALL 0x0C0E        (1062) ;       INPUTS: None.
                                   (1063) ;      RETURNS: Nothing.
0A4F: 50 01    MOV   A,1           (1064) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0A51: 67       ASR   A             (1065) ;               modified as may the Page Pointer registers!
                                   (1066) ;               In the large memory model currently only the page
0A52: 50 03    MOV   A,3           (1067) ;               pointer registers listed below are modified.  This does
0A54: 57 A4    MOV   X,164         (1068) ;               not guarantee that in future implementations of this
0A56: 7C 0C 0E LCALL 0x0C0E        (1069) ;               function other page pointer registers will not be
                                   (1070) ;               modified.
0A59: 70 EF    AND   F,239         (1071) ;          
                                   (1072) ;               Page Pointer Registers Modified: 
0A5B: 41 B3 F0 AND   REG[179],240  (1073) ;               CUR_PP
0A5E: 43 B3 05 OR    REG[179],5    (1074) ;
                                   (1075) _LoadConfig_response3:
0A61: 41 B4 F0 AND   REG[180],240  (1076)  LoadConfig_response3:
0A64: 43 B4 05 OR    REG[180],5    (1077)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1078) 	M8C_SetBank1
0A67: 41 B5 EC AND   REG[181],236  (1079) ; writing Port_0_DriveMode_0 register
0A6A: 43 B5 12 OR    REG[181],18   (1080) 	and		reg[ 0h], ~1fh
                                   (1081) 	or		reg[ 0h],  1h
0A6D: 41 B6 EE AND   REG[182],238  (1082) ; writing Port_0_DriveMode_1 register
0A70: 43 B6 11 OR    REG[182],17   (1083) 	and		reg[ 1h], ~1fh
                                   (1084) 	or		reg[ 1h], 1eh
0A73: 41 02 E9 AND   REG[2],233    (1085) ; writing Port_0_DriveMode_2 register
0A76: 43 02 16 OR    REG[2],22     (1086) 	M8C_SetBank0
                                   (1087) 	and		reg[ 3h], ~16h
0A79: 41 03 E9 AND   REG[3],233    (1088) 	or		reg[ 3h], 16h
                                   (1089) ; writing Port_0_GlobalSelect register
0A7C: 71 10    OR    F,16          (1090) 	and		reg[ 2h], ~16h
0A7E: 41 01 E0 AND   REG[1],224    (1091) ; writing Row_0_LogicSelect_0 register
0A81: 43 01 01 OR    REG[1],1      (1092) 	and		reg[b3h], ~ fh
                                   (1093) 	or		reg[b3h],  3h
0A84: 41 00 E0 AND   REG[0],224    (1094) ; writing Row_0_LogicSelect_1 register
0A87: 43 00 1E OR    REG[0],30     (1095) 	and		reg[b4h], ~ fh
0A8A: 70 EF    AND   F,239         (1096) 	or		reg[b4h],  3h
                                   (1097) ; writing Row_0_OutputDrive_0 register
0A8C: 62 D0 00 MOV   REG[208],0    (1098) 	and		reg[b5h], ~13h
0A8F: 26 04 BF AND   [4],191       (1099) 	or		reg[b5h],  1h
0A92: 70 EF    AND   F,239         (1100) ; writing Row_0_OutputDrive_1 register
0A94: 20       POP   X             (1101) 	and		reg[b6h], ~11h
                                   (1102) 
                                   (1103) 	push	x
0A95: 7F       RET                 (1104)     M8C_SetBank0                    ; Force bank 0
                                   (1105)     mov     a, 0                    ; Specify bank 0
                                   (1106)     asr     a                       ; Store in carry flag
                                   (1107)                                     ; Load bank 0 table:
                                   (1108)     mov     A, >LoadConfigTBL_response3_Bank0
                                   (1109)     mov     X, <LoadConfigTBL_response3_Bank0
                                   (1110)     lcall   LoadConfig              ; Load the bank 0 values
                                   (1111) 
                                   (1112)     mov     a, 1                    ; Specify bank 1
                                   (1113)     asr     a                       ; Store in carry flag
                                   (1114)                                     ; Load bank 1 table:
                                   (1115)     mov     A, >LoadConfigTBL_response3_Bank1
                                   (1116)     mov     X, <LoadConfigTBL_response3_Bank1
                                   (1117)     lcall   LoadConfig              ; Load the bank 1 values
                                   (1118) 
                                   (1119) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1120) ; set config active bit
                                   (1121) 	or		[ACTIVE_CONFIG_STATUS+response3_ADDR_OFF], response3_BIT
                                   (1122)     M8C_SetBank0                    ; Force return to bank 0
                                   (1123) 	pop		x
                                   (1124) 
                                   (1125)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1126)     ret
                                   (1127) 
0A96: 71 10    OR    F,16          (1128) ;---------------------------------------------------------------------------
                                   (1129) ; Unload Configuration response3
0A98: 41 00 E0 AND   REG[0],224    (1130) ;
0A9B: 43 00 01 OR    REG[0],1      (1131) ;    Reset configuration registers for response3
                                   (1132) ;    to their values as initially configured.
0A9E: 41 01 E0 AND   REG[1],224    (1133) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0AA1: 43 01 1E OR    REG[1],30     (1134) ;
                                   (1135) ;       INPUTS: None.
0AA4: 70 EF    AND   F,239         (1136) ;      RETURNS: Nothing.
0AA6: 41 03 F1 AND   REG[3],241    (1137) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0AA9: 43 03 0E OR    REG[3],14     (1138) ;               modified as may the Page Pointer registers!
                                   (1139) ;               In the large memory model currently only the page
0AAC: 41 02 F1 AND   REG[2],241    (1140) ;               pointer registers listed below are modified.  This does
                                   (1141) ;               not guarantee that in future implementations of this
0AAF: 41 B0 FC AND   REG[176],252  (1142) ;               function other page pointer registers will not be
0AB2: 43 B0 01 OR    REG[176],1    (1143) ;               modified.
                                   (1144) ;          
0AB5: 41 B3 F0 AND   REG[179],240  (1145) ;               Page Pointer Registers Modified: 
0AB8: 43 B3 03 OR    REG[179],3    (1146) ;               CUR_PP
                                   (1147) ;
0ABB: 41 B4 F0 AND   REG[180],240  (1148) _UnloadConfig_response3:
0ABE: 43 B4 03 OR    REG[180],3    (1149)  UnloadConfig_response3:
                                   (1150)     RAM_PROLOGUE RAM_USE_CLASS_4
0AC1: 41 B5 EC AND   REG[181],236  (1151) 
0AC4: 43 B5 01 OR    REG[181],1    (1152) 	push	x
                                   (1153)     M8C_SetBank0                    ; Force bank 0
0AC7: 41 B6 EE AND   REG[182],238  (1154)     mov     a, 0                    ; Specify bank 0
                                   (1155)     asr     a                       ; Store in carry flag
0ACA: 10       PUSH  X             (1156)                                     ; Bank 0 table address:
0ACB: 70 EF    AND   F,239         (1157)     mov     A, >UnloadConfigTBL_response3_Bank0
0ACD: 50 00    MOV   A,0           (1158)     mov     X, <UnloadConfigTBL_response3_Bank0
0ACF: 67       ASR   A             (1159)     lcall   LoadConfig              ; Unload the bank 0 values
                                   (1160) 
0AD0: 50 03    MOV   A,3           (1161)     mov     a, 1                    ; Specify bank 1
0AD2: 57 BE    MOV   X,190         (1162)     asr     a                       ; Store in carry flag
0AD4: 7C 0C 0E LCALL 0x0C0E        (1163)                                     ; Bank 1 table address:
                                   (1164)     mov     A, >UnloadConfigTBL_response3_Bank1
0AD7: 50 01    MOV   A,1           (1165)     mov     X, <UnloadConfigTBL_response3_Bank1
0AD9: 67       ASR   A             (1166)     lcall   LoadConfig              ; Unload the bank 1 values
                                   (1167) 
0ADA: 50 03    MOV   A,3           (1168) 	M8C_SetBank0
0ADC: 57 D1    MOV   X,209         (1169) ; writing Row_0_LogicSelect_0 register
0ADE: 7C 0C 0E LCALL 0x0C0E        (1170) 	and		reg[b3h], ~ fh
                                   (1171) 	or		reg[b3h],  5h
0AE1: 62 D0 00 MOV   REG[208],0    (1172) ; writing Row_0_LogicSelect_1 register
                                   (1173) 	and		reg[b4h], ~ fh
0AE4: 2E 04 80 OR    [4],128       (1174) 	or		reg[b4h],  5h
0AE7: 70 EF    AND   F,239         (1175) ; writing Row_0_OutputDrive_0 register
0AE9: 20       POP   X             (1176) 	and		reg[b5h], ~13h
                                   (1177) 	or		reg[b5h], 12h
                                   (1178) ; writing Row_0_OutputDrive_1 register
0AEA: 7F       RET                 (1179) 	and		reg[b6h], ~11h
                                   (1180) 	or		reg[b6h], 11h
                                   (1181) ; writing Port_0_GlobalSelect register
                                   (1182) 	and		reg[ 2h], ~16h
                                   (1183) 	or		reg[ 2h], 16h
                                   (1184) ; writing Port_0_DriveMode_2 register
                                   (1185) 	and		reg[ 3h], ~16h
                                   (1186) ; writing Port_0_DriveMode_1 register
                                   (1187) 	M8C_SetBank1
                                   (1188) 	and		reg[ 1h], ~1fh
                                   (1189) 	or		reg[ 1h],  1h
                                   (1190) ; writing Port_0_DriveMode_0 register
                                   (1191) 	and		reg[ 0h], ~1fh
                                   (1192) 	or		reg[ 0h], 1eh
                                   (1193) 	M8C_SetBank0
                                   (1194) ; clear config active bit
                                   (1195) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1196) 	and		[ACTIVE_CONFIG_STATUS+response3_ADDR_OFF], ~response3_BIT
                                   (1197)     M8C_SetBank0                    ; Force return to bank 0
                                   (1198) 	pop		x
                                   (1199) 
                                   (1200)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1201)     ret
                                   (1202) 
                                   (1203) ;---------------------------------------------------------------------------
                                   (1204) ; Load Configuration response4
0AEB: 10       PUSH  X             (1205) ;
0AEC: 70 EF    AND   F,239         (1206) ;    Load configuration registers for response4.
0AEE: 50 00    MOV   A,0           (1207) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0AF0: 67       ASR   A             (1208) ;
                                   (1209) ;       INPUTS: None.
0AF1: 50 03    MOV   A,3           (1210) ;      RETURNS: Nothing.
0AF3: 57 EA    MOV   X,234         (1211) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0AF5: 7C 0C 0E LCALL 0x0C0E        (1212) ;               modified as may the Page Pointer registers!
                                   (1213) ;               In the large memory model currently only the page
0AF8: 50 01    MOV   A,1           (1214) ;               pointer registers listed below are modified.  This does
0AFA: 67       ASR   A             (1215) ;               not guarantee that in future implementations of this
                                   (1216) ;               function other page pointer registers will not be
0AFB: 50 03    MOV   A,3           (1217) ;               modified.
0AFD: 57 F1    MOV   X,241         (1218) ;          
0AFF: 7C 0C 0E LCALL 0x0C0E        (1219) ;               Page Pointer Registers Modified: 
                                   (1220) ;               CUR_PP
0B02: 70 EF    AND   F,239         (1221) ;
                                   (1222) _LoadConfig_response4:
0B04: 41 B0 FC AND   REG[176],252  (1223)  LoadConfig_response4:
                                   (1224)     RAM_PROLOGUE RAM_USE_CLASS_4
0B07: 41 B3 F0 AND   REG[179],240  (1225) 	M8C_SetBank1
0B0A: 43 B3 05 OR    REG[179],5    (1226) ; writing Port_0_DriveMode_0 register
                                   (1227) 	and		reg[ 0h], ~1fh
0B0D: 41 B4 F0 AND   REG[180],240  (1228) 	or		reg[ 0h],  1h
0B10: 43 B4 05 OR    REG[180],5    (1229) ; writing Port_0_DriveMode_1 register
                                   (1230) 	and		reg[ 1h], ~1fh
0B13: 41 B5 EC AND   REG[181],236  (1231) 	or		reg[ 1h], 1eh
0B16: 43 B5 12 OR    REG[181],18   (1232) ; writing Port_0_DriveMode_2 register
                                   (1233) 	M8C_SetBank0
0B19: 41 B6 EE AND   REG[182],238  (1234) 	and		reg[ 3h], ~ eh
0B1C: 43 B6 11 OR    REG[182],17   (1235) 	or		reg[ 3h],  eh
                                   (1236) ; writing Port_0_GlobalSelect register
0B1F: 41 02 F1 AND   REG[2],241    (1237) 	and		reg[ 2h], ~ eh
0B22: 43 02 0E OR    REG[2],14     (1238) ; writing Row_0_InputMux register
                                   (1239) 	and		reg[b0h], ~ 3h
0B25: 41 03 F1 AND   REG[3],241    (1240) 	or		reg[b0h],  1h
                                   (1241) ; writing Row_0_LogicSelect_0 register
0B28: 71 10    OR    F,16          (1242) 	and		reg[b3h], ~ fh
0B2A: 41 01 E0 AND   REG[1],224    (1243) 	or		reg[b3h],  3h
0B2D: 43 01 01 OR    REG[1],1      (1244) ; writing Row_0_LogicSelect_1 register
                                   (1245) 	and		reg[b4h], ~ fh
0B30: 41 00 E0 AND   REG[0],224    (1246) 	or		reg[b4h],  3h
0B33: 43 00 1E OR    REG[0],30     (1247) ; writing Row_0_OutputDrive_0 register
0B36: 70 EF    AND   F,239         (1248) 	and		reg[b5h], ~13h
                                   (1249) 	or		reg[b5h],  1h
0B38: 62 D0 00 MOV   REG[208],0    (1250) ; writing Row_0_OutputDrive_1 register
0B3B: 26 04 7F AND   [4],127       (1251) 	and		reg[b6h], ~11h
0B3E: 70 EF    AND   F,239         (1252) 
0B40: 20       POP   X             (1253) 	push	x
                                   (1254)     M8C_SetBank0                    ; Force bank 0
                                   (1255)     mov     a, 0                    ; Specify bank 0
0B41: 7F       RET                 (1256)     asr     a                       ; Store in carry flag
                                   (1257)                                     ; Load bank 0 table:
                                   (1258)     mov     A, >LoadConfigTBL_response4_Bank0
                                   (1259)     mov     X, <LoadConfigTBL_response4_Bank0
                                   (1260)     lcall   LoadConfig              ; Load the bank 0 values
                                   (1261) 
                                   (1262)     mov     a, 1                    ; Specify bank 1
                                   (1263)     asr     a                       ; Store in carry flag
                                   (1264)                                     ; Load bank 1 table:
                                   (1265)     mov     A, >LoadConfigTBL_response4_Bank1
                                   (1266)     mov     X, <LoadConfigTBL_response4_Bank1
                                   (1267)     lcall   LoadConfig              ; Load the bank 1 values
                                   (1268) 
                                   (1269) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1270) ; set config active bit
                                   (1271) 	or		[ACTIVE_CONFIG_STATUS+response4_ADDR_OFF], response4_BIT
                                   (1272)     M8C_SetBank0                    ; Force return to bank 0
                                   (1273) 	pop		x
                                   (1274) 
                                   (1275)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1276)     ret
                                   (1277) 
                                   (1278) ;---------------------------------------------------------------------------
                                   (1279) ; Unload Configuration response4
0B42: 71 10    OR    F,16          (1280) ;
                                   (1281) ;    Reset configuration registers for response4
0B44: 41 00 E0 AND   REG[0],224    (1282) ;    to their values as initially configured.
0B47: 43 00 01 OR    REG[0],1      (1283) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (1284) ;
0B4A: 41 01 E0 AND   REG[1],224    (1285) ;       INPUTS: None.
0B4D: 43 01 1E OR    REG[1],30     (1286) ;      RETURNS: Nothing.
                                   (1287) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0B50: 70 EF    AND   F,239         (1288) ;               modified as may the Page Pointer registers!
0B52: 41 03 E1 AND   REG[3],225    (1289) ;               In the large memory model currently only the page
0B55: 43 03 1E OR    REG[3],30     (1290) ;               pointer registers listed below are modified.  This does
                                   (1291) ;               not guarantee that in future implementations of this
0B58: 41 02 E1 AND   REG[2],225    (1292) ;               function other page pointer registers will not be
                                   (1293) ;               modified.
0B5B: 41 B3 F0 AND   REG[179],240  (1294) ;          
0B5E: 43 B3 03 OR    REG[179],3    (1295) ;               Page Pointer Registers Modified: 
                                   (1296) ;               CUR_PP
0B61: 41 B4 F0 AND   REG[180],240  (1297) ;
0B64: 43 B4 03 OR    REG[180],3    (1298) _UnloadConfig_response4:
                                   (1299)  UnloadConfig_response4:
0B67: 41 B5 EC AND   REG[181],236  (1300)     RAM_PROLOGUE RAM_USE_CLASS_4
0B6A: 43 B5 01 OR    REG[181],1    (1301) 
                                   (1302) 	push	x
0B6D: 41 B6 EE AND   REG[182],238  (1303)     M8C_SetBank0                    ; Force bank 0
                                   (1304)     mov     a, 0                    ; Specify bank 0
0B70: 10       PUSH  X             (1305)     asr     a                       ; Store in carry flag
0B71: 70 EF    AND   F,239         (1306)                                     ; Bank 0 table address:
0B73: 50 00    MOV   A,0           (1307)     mov     A, >UnloadConfigTBL_response4_Bank0
0B75: 67       ASR   A             (1308)     mov     X, <UnloadConfigTBL_response4_Bank0
                                   (1309)     lcall   LoadConfig              ; Unload the bank 0 values
0B76: 50 04    MOV   A,4           (1310) 
0B78: 57 0B    MOV   X,11          (1311)     mov     a, 1                    ; Specify bank 1
0B7A: 7C 0C 0E LCALL 0x0C0E        (1312)     asr     a                       ; Store in carry flag
                                   (1313)                                     ; Bank 1 table address:
0B7D: 50 01    MOV   A,1           (1314)     mov     A, >UnloadConfigTBL_response4_Bank1
0B7F: 67       ASR   A             (1315)     mov     X, <UnloadConfigTBL_response4_Bank1
                                   (1316)     lcall   LoadConfig              ; Unload the bank 1 values
0B80: 50 04    MOV   A,4           (1317) 
0B82: 57 12    MOV   X,18          (1318) 	M8C_SetBank0
0B84: 7C 0C 0E LCALL 0x0C0E        (1319) ; writing Row_0_InputMux register
                                   (1320) 	and		reg[b0h], ~ 3h
0B87: 62 D0 00 MOV   REG[208],0    (1321) ; writing Row_0_LogicSelect_0 register
                                   (1322) 	and		reg[b3h], ~ fh
0B8A: 2E 05 01 OR    [5],1         (1323) 	or		reg[b3h],  5h
0B8D: 70 EF    AND   F,239         (1324) ; writing Row_0_LogicSelect_1 register
0B8F: 20       POP   X             (1325) 	and		reg[b4h], ~ fh
                                   (1326) 	or		reg[b4h],  5h
                                   (1327) ; writing Row_0_OutputDrive_0 register
0B90: 7F       RET                 (1328) 	and		reg[b5h], ~13h
                                   (1329) 	or		reg[b5h], 12h
                                   (1330) ; writing Row_0_OutputDrive_1 register
                                   (1331) 	and		reg[b6h], ~11h
                                   (1332) 	or		reg[b6h], 11h
                                   (1333) ; writing Port_0_GlobalSelect register
                                   (1334) 	and		reg[ 2h], ~ eh
                                   (1335) 	or		reg[ 2h],  eh
                                   (1336) ; writing Port_0_DriveMode_2 register
                                   (1337) 	and		reg[ 3h], ~ eh
                                   (1338) ; writing Port_0_DriveMode_1 register
                                   (1339) 	M8C_SetBank1
                                   (1340) 	and		reg[ 1h], ~1fh
                                   (1341) 	or		reg[ 1h],  1h
                                   (1342) ; writing Port_0_DriveMode_0 register
                                   (1343) 	and		reg[ 0h], ~1fh
                                   (1344) 	or		reg[ 0h], 1eh
                                   (1345) 	M8C_SetBank0
                                   (1346) ; clear config active bit
                                   (1347) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1348) 	and		[ACTIVE_CONFIG_STATUS+response4_ADDR_OFF], ~response4_BIT
                                   (1349)     M8C_SetBank0                    ; Force return to bank 0
                                   (1350) 	pop		x
                                   (1351) 
                                   (1352)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1353)     ret
0B91: 10       PUSH  X             (1354) 
0B92: 70 EF    AND   F,239         (1355) ;---------------------------------------------------------------------------
0B94: 50 00    MOV   A,0           (1356) ; Load Configuration servo_transmit
0B96: 67       ASR   A             (1357) ;
                                   (1358) ;    Load configuration registers for servo_transmit.
0B97: 50 04    MOV   A,4           (1359) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0B99: 57 1B    MOV   X,27          (1360) ;
0B9B: 7C 0C 0E LCALL 0x0C0E        (1361) ;       INPUTS: None.
                                   (1362) ;      RETURNS: Nothing.
0B9E: 50 01    MOV   A,1           (1363) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0BA0: 67       ASR   A             (1364) ;               modified as may the Page Pointer registers!
                                   (1365) ;               In the large memory model currently only the page
0BA1: 50 04    MOV   A,4           (1366) ;               pointer registers listed below are modified.  This does
0BA3: 57 1E    MOV   X,30          (1367) ;               not guarantee that in future implementations of this
0BA5: 7C 0C 0E LCALL 0x0C0E        (1368) ;               function other page pointer registers will not be
                                   (1369) ;               modified.
0BA8: 70 EF    AND   F,239         (1370) ;          
                                   (1371) ;               Page Pointer Registers Modified: 
0BAA: 41 B3 F0 AND   REG[179],240  (1372) ;               CUR_PP
0BAD: 43 B3 05 OR    REG[179],5    (1373) ;
                                   (1374) _LoadConfig_servo_transmit:
0BB0: 41 B4 F0 AND   REG[180],240  (1375)  LoadConfig_servo_transmit:
0BB3: 43 B4 05 OR    REG[180],5    (1376)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1377) 	M8C_SetBank1
0BB6: 41 B5 EC AND   REG[181],236  (1378) ; writing Port_0_DriveMode_0 register
0BB9: 43 B5 12 OR    REG[181],18   (1379) 	and		reg[ 0h], ~1fh
                                   (1380) 	or		reg[ 0h],  1h
0BBC: 41 B6 EE AND   REG[182],238  (1381) ; writing Port_0_DriveMode_1 register
0BBF: 43 B6 11 OR    REG[182],17   (1382) 	and		reg[ 1h], ~1fh
                                   (1383) 	or		reg[ 1h], 1eh
0BC2: 41 02 E1 AND   REG[2],225    (1384) ; writing Port_0_DriveMode_2 register
0BC5: 43 02 1E OR    REG[2],30     (1385) 	M8C_SetBank0
                                   (1386) 	and		reg[ 3h], ~1eh
0BC8: 41 03 E1 AND   REG[3],225    (1387) 	or		reg[ 3h], 1eh
                                   (1388) ; writing Port_0_GlobalSelect register
0BCB: 71 10    OR    F,16          (1389) 	and		reg[ 2h], ~1eh
0BCD: 41 01 E0 AND   REG[1],224    (1390) ; writing Row_0_LogicSelect_0 register
0BD0: 43 01 01 OR    REG[1],1      (1391) 	and		reg[b3h], ~ fh
                                   (1392) 	or		reg[b3h],  3h
0BD3: 41 00 E0 AND   REG[0],224    (1393) ; writing Row_0_LogicSelect_1 register
0BD6: 43 00 1E OR    REG[0],30     (1394) 	and		reg[b4h], ~ fh
0BD9: 70 EF    AND   F,239         (1395) 	or		reg[b4h],  3h
                                   (1396) ; writing Row_0_OutputDrive_0 register
0BDB: 62 D0 00 MOV   REG[208],0    (1397) 	and		reg[b5h], ~13h
0BDE: 26 05 FE AND   [5],254       (1398) 	or		reg[b5h],  1h
0BE1: 70 EF    AND   F,239         (1399) ; writing Row_0_OutputDrive_1 register
0BE3: 20       POP   X             (1400) 	and		reg[b6h], ~11h
                                   (1401) 
                                   (1402) 	push	x
0BE4: 7F       RET                 (1403)     M8C_SetBank0                    ; Force bank 0
                                   (1404)     mov     a, 0                    ; Specify bank 0
                                   (1405)     asr     a                       ; Store in carry flag
                                   (1406)                                     ; Load bank 0 table:
                                   (1407)     mov     A, >LoadConfigTBL_servo_transmit_Bank0
                                   (1408)     mov     X, <LoadConfigTBL_servo_transmit_Bank0
                                   (1409)     lcall   LoadConfig              ; Load the bank 0 values
                                   (1410) 
                                   (1411)     mov     a, 1                    ; Specify bank 1
                                   (1412)     asr     a                       ; Store in carry flag
                                   (1413)                                     ; Load bank 1 table:
                                   (1414)     mov     A, >LoadConfigTBL_servo_transmit_Bank1
                                   (1415)     mov     X, <LoadConfigTBL_servo_transmit_Bank1
                                   (1416)     lcall   LoadConfig              ; Load the bank 1 values
                                   (1417) 
                                   (1418) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (1419) ; set config active bit
                                   (1420) 	or		[ACTIVE_CONFIG_STATUS+servo_transmit_ADDR_OFF], servo_transmit_BIT
                                   (1421)     M8C_SetBank0                    ; Force return to bank 0
                                   (1422) 	pop		x
                                   (1423) 
                                   (1424)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1425)     ret
                                   (1426) 
                                   (1427) ;---------------------------------------------------------------------------
                                   (1428) ; Unload Configuration servo_transmit
0BE5: 10       PUSH  X             (1429) ;
0BE6: 70 EF    AND   F,239         (1430) ;    Reset configuration registers for servo_transmit
0BE8: 50 00    MOV   A,0           (1431) ;    to their values as initially configured.
0BEA: 67       ASR   A             (1432) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (1433) ;
0BEB: 50 06    MOV   A,6           (1434) ;       INPUTS: None.
0BED: 57 0E    MOV   X,14          (1435) ;      RETURNS: Nothing.
0BEF: 7C 0C 0E LCALL 0x0C0E        (1436) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (1437) ;               modified as may the Page Pointer registers!
0BF2: 50 01    MOV   A,1           (1438) ;               In the large memory model currently only the page
0BF4: 67       ASR   A             (1439) ;               pointer registers listed below are modified.  This does
                                   (1440) ;               not guarantee that in future implementations of this
0BF5: 50 06    MOV   A,6           (1441) ;               function other page pointer registers will not be
0BF7: 57 2F    MOV   X,47          (1442) ;               modified.
0BF9: 7C 0C 0E LCALL 0x0C0E        (1443) ;          
                                   (1444) ;               Page Pointer Registers Modified: 
0BFC: 70 EF    AND   F,239         (1445) ;               CUR_PP
                                   (1446) ;
0BFE: 62 D0 00 MOV   REG[208],0    (1447) _UnloadConfig_servo_transmit:
0C01: 55 04 00 MOV   [4],0         (1448)  UnloadConfig_servo_transmit:
0C04: 62 D0 00 MOV   REG[208],0    (1449)     RAM_PROLOGUE RAM_USE_CLASS_4
0C07: 55 05 00 MOV   [5],0         (1450) 
0C0A: 70 EF    AND   F,239         (1451) 	push	x
0C0C: 20       POP   X             (1452)     M8C_SetBank0                    ; Force bank 0
                                   (1453)     mov     a, 0                    ; Specify bank 0
                                   (1454)     asr     a                       ; Store in carry flag
0C0D: 7F       RET                 (1455)                                     ; Bank 0 table address:
                                   (1456)     mov     A, >UnloadConfigTBL_servo_transmit_Bank0
                                   (1457)     mov     X, <UnloadConfigTBL_servo_transmit_Bank0
                                   (1458)     lcall   LoadConfig              ; Unload the bank 0 values
                                   (1459) 
                                   (1460)     mov     a, 1                    ; Specify bank 1
                                   (1461)     asr     a                       ; Store in carry flag
                                   (1462)                                     ; Bank 1 table address:
                                   (1463)     mov     A, >UnloadConfigTBL_servo_transmit_Bank1
                                   (1464)     mov     X, <UnloadConfigTBL_servo_transmit_Bank1
                                   (1465)     lcall   LoadConfig              ; Unload the bank 1 values
                                   (1466) 
                                   (1467) 	M8C_SetBank0
                                   (1468) ; writing Row_0_LogicSelect_0 register
                                   (1469) 	and		reg[b3h], ~ fh
                                   (1470) 	or		reg[b3h],  5h
                                   (1471) ; writing Row_0_LogicSelect_1 register
                                   (1472) 	and		reg[b4h], ~ fh
                                   (1473) 	or		reg[b4h],  5h
                                   (1474) ; writing Row_0_OutputDrive_0 register
                                   (1475) 	and		reg[b5h], ~13h
                                   (1476) 	or		reg[b5h], 12h
0C0E: 38 02    ADD   SP,2          (1477) ; writing Row_0_OutputDrive_1 register
0C10: 10       PUSH  X             (1478) 	and		reg[b6h], ~11h
0C11: 08       PUSH  A             (1479) 	or		reg[b6h], 11h
0C12: 4F       MOV   X,SP          (1480) ; writing Port_0_GlobalSelect register
0C13: 56 FC 00 MOV   [X-4],0       (1481) 	and		reg[ 2h], ~1eh
0C16: D0 04    JNC   0x0C1B        (1482) 	or		reg[ 2h], 1eh
0C18: 56 FC 01 MOV   [X-4],1       (1483) ; writing Port_0_DriveMode_2 register
                                   (1484) 	and		reg[ 3h], ~1eh
0C1B: 18       POP   A             (1485) ; writing Port_0_DriveMode_1 register
0C1C: 20       POP   X             (1486) 	M8C_SetBank1
                                   (1487) 	and		reg[ 1h], ~1fh
                                   (1488) 	or		reg[ 1h],  1h
0C1D: 70 EF    AND   F,239         (1489) ; writing Port_0_DriveMode_0 register
0C1F: 62 E3 00 MOV   REG[227],0    (1490) 	and		reg[ 0h], ~1fh
0C22: 10       PUSH  X             (1491) 	or		reg[ 0h], 1eh
0C23: 08       PUSH  A             (1492) 	M8C_SetBank0
0C24: 28       ROMX                (1493) ; clear config active bit
0C25: 39 FF    CMP   A,255         (1494) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
0C27: A0 1F    JZ    0x0C47        (1495) 	and		[ACTIVE_CONFIG_STATUS+servo_transmit_ADDR_OFF], ~servo_transmit_BIT
0C29: 4F       MOV   X,SP          (1496)     M8C_SetBank0                    ; Force return to bank 0
0C2A: 48 FC 01 TST   [X-4],1       (1497) 	pop		x
0C2D: A0 03    JZ    0x0C31        (1498) 
0C2F: 71 10    OR    F,16          (1499)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1500)     ret
0C31: 54 FD    MOV   [X-3],A       (1501) 
0C33: 18       POP   A             (1502) ;---------------------------------------------------------------------------
0C34: 20       POP   X             (1503) ; Unload Configuration Total
0C35: 75       INC   X             (1504) ;
0C36: 09 00    ADC   A,0           (1505) ;    Reset configuration registers for Total
0C38: 10       PUSH  X             (1506) ;    to their values as initially configured.
0C39: 08       PUSH  A             (1507) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0C3A: 28       ROMX                (1508) ;
0C3B: 4F       MOV   X,SP          (1509) ;       INPUTS: None.
0C3C: 59 FD    MOV   X,[X-3]       (1510) ;      RETURNS: Nothing.
0C3E: 61 00    MOV   REG[X+0],A    (1511) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0C40: 18       POP   A             (1512) ;               modified as may the Page Pointer registers!
0C41: 20       POP   X             (1513) ;               In the large memory model currently only the page
0C42: 75       INC   X             (1514) ;               pointer registers listed below are modified.  This does
0C43: 09 00    ADC   A,0           (1515) ;               not guarantee that in future implementations of this
0C45: 8F D7    JMP   0x0C1D        (1516) ;               function other page pointer registers will not be
                                   (1517) ;               modified.
0C47: 38 FC    ADD   SP,252        (1518) ;          
0C49: 70 3F    AND   F,63
0C4B: 71 C0    OR    F,192         (1519) ;               Page Pointer Registers Modified: 
0C4E: 08       PUSH  A             (1520) ;               CUR_PP

FILE: lib\wait_recvint.asm
0C4F: 10       PUSH  X             (0104) ;;*****************************************************************************
0C50: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: WAIT_RECVINT.asm
0C52: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
0C53: 58 01    MOV   X,[1]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
0C55: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
0C57: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
0C58: 21 08    AND   A,8           (0114) ;;*****************************************************************************
0C5A: B0 04    JNZ   0x0C5F        (0115) 
0C5C: 18       POP   A             (0116) include "m8c.inc"
0C5D: 80 5E    JMP   0x0CBC        (0117) include "memory.inc"
                                   (0118) include "WAIT_RECV.inc"
                                   (0119) 
                                   (0120) 
0C5F: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
0C60: 21 E0    AND   A,224         (0124) export  _WAIT_RECV_ISR
0C62: A0 12    JZ    0x0C75        (0125) 
                                   (0126) 
0C64: 2C 00    OR    [0],A         (0127) IF (WAIT_RECV_RXBUF_ENABLE)
                                   (0128) export  WAIT_RECV_aRxBuffer
0C66: 49 2A 00 TST   REG[42],0     (0129) export _WAIT_RECV_aRxBuffer
                                   (0130) export  WAIT_RECV_bRxCnt
0C69: 21 20    AND   A,32          (0131) export _WAIT_RECV_bRxCnt
0C6B: A0 50    JZ    0x0CBC        (0132) export  WAIT_RECV_fStatus
                                   (0133) export _WAIT_RECV_fStatus
                                   (0134) ENDIF
                                   (0135) 
0C6D: 41 2B FE AND   REG[43],254   (0136) 
0C70: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
0C73: 80 48    JMP   0x0CBC        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (WAIT_RECV_RXBUF_ENABLE)
0C75: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  WAIT_RECV_fStatus:
                                   (0144) _WAIT_RECV_fStatus:      BLK  1
0C77: 47 00 01 TST   [0],1         (0145)  WAIT_RECV_bRxCnt:
0C7A: B0 41    JNZ   0x0CBC        (0146) _WAIT_RECV_bRxCnt:       BLK  1
                                   (0147) AREA WAIT_RECV_RAM(RAM,REL,CON)
0C7C: 39 00    CMP   A,0           (0148)  WAIT_RECV_aRxBuffer:    
0C7E: B0 14    JNZ   0x0C93        (0149) _WAIT_RECV_aRxBuffer:    BLK WAIT_RECV_RX_BUFFER_SIZE
0C80: 2E 00 01 OR    [0],1         (0150) ENDIF
                                   (0151) 
0C83: 62 D3 00 MOV   REG[211],0    (0152) 
0C86: 70 3F    AND   F,63
0C88: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
0C8A: 56 68 00 MOV   [X+104],0     (0154) 
0C8D: 70 3F    AND   F,63
0C8F: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
0C91: 80 2A    JMP   0x0CBC        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
0C93: 3C 01 0F CMP   [1],15        (0167) ;------------------------
0C96: C0 14    JC    0x0CAB        (0168) 
0C98: 2E 00 10 OR    [0],16        (0169) 
                                   (0170) ;------------------------
0C9B: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
0C9E: 70 3F    AND   F,63
0CA0: 71 80    OR    F,128         (0172) ;------------------------
0CA2: 56 68 00 MOV   [X+104],0     (0173) 
0CA5: 70 3F    AND   F,63
0CA7: 71 00    OR    F,0           (0174) 
0CA9: 80 12    JMP   0x0CBC        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
0CAB: 75       INC   X             (0179) 
0CAC: 5A 01    MOV   [1],X         (0180) 
0CAE: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
0CAF: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
0CB2: 70 3F    AND   F,63
0CB4: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _WAIT_RECV_ISR
0CB6: 54 68    MOV   [X+104],A     (0185) ;
0CB8: 70 3F    AND   F,63
0CBA: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
0CBC: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
0CBD: 60 D3    MOV   REG[211],A    (0191) _WAIT_RECV_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
0CBF: 20       POP   X             (0195)    ; Insert your custom code below this banner
0CC0: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
0CC2: 43 E1 04 OR    REG[225],4    (0201)    ; Insert your custom code above this banner

FILE: lib\wait_recv.asm
                                   (0121) ;;*****************************************************************************
0CC5: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: WAIT_RECV.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "WAIT_RECV.inc"
0CC6: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
0CC9: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   WAIT_RECV_EnableInt
                                   (0155) export  _WAIT_RECV_EnableInt
                                   (0156) export   WAIT_RECV_DisableInt
                                   (0157) export  _WAIT_RECV_DisableInt
                                   (0158) export   WAIT_RECV_Start
                                   (0159) export  _WAIT_RECV_Start
                                   (0160) export   WAIT_RECV_Stop
                                   (0161) export  _WAIT_RECV_Stop
                                   (0162) export   WAIT_RECV_bReadRxData
                                   (0163) export  _WAIT_RECV_bReadRxData
                                   (0164) export   WAIT_RECV_bReadRxStatus
                                   (0165) export  _WAIT_RECV_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bWAIT_RECV_ReadRxData
                                   (0170) export _bWAIT_RECV_ReadRxData
                                   (0171) export  bWAIT_RECV_ReadRxStatus
                                   (0172) export _bWAIT_RECV_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  WAIT_RECV_cGetChar
0CCA: 29 01    OR    A,1           (0179) export _WAIT_RECV_cGetChar
0CCC: 60 2B    MOV   REG[43],A     (0180) export  WAIT_RECV_cReadChar
                                   (0181) export _WAIT_RECV_cReadChar
0CCE: 7F       RET                 (0182) export  WAIT_RECV_iReadChar
                                   (0183) export _WAIT_RECV_iReadChar
                                   (0184) 
                                   (0185) IF (WAIT_RECV_RXBUF_ENABLE)
                                   (0186) export  WAIT_RECV_CmdReset
                                   (0187) export _WAIT_RECV_CmdReset
                                   (0188) export  WAIT_RECV_bCmdCheck
                                   (0189) export _WAIT_RECV_bCmdCheck
                                   (0190) export  WAIT_RECV_bCmdLength
                                   (0191) export _WAIT_RECV_bCmdLength
                                   (0192) export  WAIT_RECV_bErrCheck
                                   (0193) export _WAIT_RECV_bErrCheck
                                   (0194) 
                                   (0195) export  WAIT_RECV_szGetParam
                                   (0196) export _WAIT_RECV_szGetParam
                                   (0197) export  WAIT_RECV_szGetRestOfParams
                                   (0198) export _WAIT_RECV_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA WAIT_RECV_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
0CCF: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
0CD2: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: WAIT_RECV_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  WAIT_RECV_EnableInt:
                                   (0238) _WAIT_RECV_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
0CD3: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask WAIT_RECV_INT_REG, WAIT_RECV_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
0CD5: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: WAIT_RECV_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  WAIT_RECV_DisableInt:
                                   (0267) _WAIT_RECV_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask WAIT_RECV_INT_REG, WAIT_RECV_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
0CD6: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
0CD8: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: WAIT_RECV_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  WAIT_RECV_Start:
                                   (0297) _WAIT_RECV_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[WAIT_RECV_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: WAIT_RECV_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
0CD9: 49 2B 08 TST   REG[43],8     (0311) ;
0CDC: AF FC    JZ    0x0CD9        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
0CDE: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
0CE0: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  WAIT_RECV_Stop:
                                   (0326) _WAIT_RECV_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[WAIT_RECV_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: WAIT_RECV_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
0CE1: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
0CE3: 08       PUSH  A             (0347) ;
0CE4: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
0CE6: B0 04    JNZ   0x0CEB        (0349) ;    The A and X registers may be modified by this or future implementations
0CE8: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
0CE9: 80 0B    JMP   0x0CF5        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
0CEB: 5D 2A    MOV   A,REG[42]     (0354) ;
0CED: 4B       SWAP  A,X           (0355)  WAIT_RECV_bReadRxData:
                                   (0356) _WAIT_RECV_bReadRxData:
0CEE: 18       POP   A             (0357)  bWAIT_RECV_ReadRxData:
0CEF: 21 A0    AND   A,160         (0358) _bWAIT_RECV_ReadRxData:
0CF1: B0 03    JNZ   0x0CF5        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
0CF3: 4B       SWAP  A,X           (0360)    mov A, REG[WAIT_RECV_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
0CF4: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
0CF5: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: WAIT_RECV_bReadRxStatus
                                   (0368) ;
0CF7: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  WAIT_RECV_bReadRxStatus:
                                   (0388) _WAIT_RECV_bReadRxStatus:
                                   (0389)  bWAIT_RECV_ReadRxStatus:
                                   (0390) _bWAIT_RECV_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[WAIT_RECV_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: WAIT_RECV_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
0CF8: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
0CFA: 21 E8    AND   A,232         (0408) ;
0CFC: 08       PUSH  A             (0409) ;  ARGUMENTS:
0CFD: 21 08    AND   A,8           (0410) ;      none
0CFF: B0 07    JNZ   0x0D07        (0411) ;
0D01: 18       POP   A             (0412) ;  RETURNS:
0D02: 29 01    OR    A,1           (0413) ;     char that is returned from UART
0D04: 4B       SWAP  A,X           (0414) ;
0D05: 80 07    JMP   0x0D0D        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
0D07: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
0D08: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
0D0A: 4B       SWAP  A,X           (0420) ;    functions.
0D0B: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
0D0D: 7F       RET                 (0426)  WAIT_RECV_cGetChar:
                                   (0427) _WAIT_RECV_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[WAIT_RECV_CONTROL_REG],WAIT_RECV_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[WAIT_RECV_RX_BUFFER_REG]           ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: WAIT_RECV_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  WAIT_RECV_cReadChar:
                                   (0463) _WAIT_RECV_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[WAIT_RECV_CONTROL_REG]                       ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,WAIT_RECV_RX_COMPLETE                            ; Check if a character is ready
0D0E: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
0D11: 55 68 00 MOV   [104],0       (0470)    pop  A
0D14: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
0D17: 55 E6 00 MOV   [ID+1],0      (0472) 
0D1A: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
0D1D: 55 01 00 MOV   [1],0         (0474)    mov  A,REG[WAIT_RECV_RX_BUFFER_REG]                     ; Read data first, then
0D20: 26 00 00 AND   [0],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
0D23: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(WAIT_RECV_RX_PARITY_ERROR | WAIT_RECV_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_WAIT_RECV_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: WAIT_RECV_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
0D24: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
0D27: 51 00    MOV   A,[0]         (0511) ;        0x40CC    Overrun Error
0D29: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
0D2B: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  WAIT_RECV_iReadChar:
                                   (0523) _WAIT_RECV_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[WAIT_RECV_CONTROL_REG]                       ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(WAIT_RECV_RX_ERROR|WAIT_RECV_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,WAIT_RECV_RX_COMPLETE                            ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,WAIT_RECV_RX_NO_DATA                             ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_WAIT_RECV_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,WAIT_RECV_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[WAIT_RECV_RX_BUFFER_REG]                     ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_WAIT_RECV_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (WAIT_RECV_RXBUF_ENABLE)
                                   (0552) .SECTION
0D2C: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
0D2F: 51 00    MOV   A,[0]         (0554) ;-----------------------------------------------------------------------------
0D31: 21 F0    AND   A,240         (0555) ;
0D33: 26 00 0F AND   [0],15        (0556) ;     Command Buffer commands
                                   (0557) ;
0D36: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: WAIT_RECV_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  WAIT_RECV_CmdReset:
0D37: 62 D0 00 MOV   REG[208],0    (0587) _WAIT_RECV_CmdReset:
0D3A: 51 01    MOV   A,[1]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >WAIT_RECV_aRxBuffer
0D3C: 7F       RET                 (0590)    mov [WAIT_RECV_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >WAIT_RECV_bRxCnt
                                   (0594)    mov [WAIT_RECV_bRxCnt], 0x00
                                   (0595)    and [WAIT_RECV_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: WAIT_RECV_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  WAIT_RECV_bCmdCheck:
                                   (0628) _WAIT_RECV_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >WAIT_RECV_fStatus
                                   (0631)    mov A,  [WAIT_RECV_fStatus]
                                   (0632)    and A, WAIT_RECV_RX_BUF_CMDTERM               ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: WAIT_RECV_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
0D3D: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
0D3F: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
0D42: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
0D45: 50 68    MOV   A,104         (0648) ;     BYTE  fStatus - Status of command receive buffer.
0D47: 02 E6    ADD   A,[ID+1]      (0649) ;                     Returns non-zero value in A if command is valid.
0D49: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
0D4A: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
0D4C: B0 04    JNZ   0x0D51        (0653) ;           0x10 => Software Buffer OverRun
0D4E: 10       PUSH  X             (0654) ;
0D4F: 80 33    JMP   0x0D83        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
0D51: 39 00    CMP   A,0           (0660) ;    functions.
0D53: B0 11    JNZ   0x0D65        (0661) ;          
0D55: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
0D56: 76 E6    INC   [ID+1]        (0663) ;          CUR_PP
0D58: 52 00    MOV   A,[X+0]       (0664) ;
0D5A: 3C E6 0F CMP   [ID+1],15     (0665) ;     Error Status is clear when read.
0D5D: BF F3    JNZ   0x0D51        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
0D5F: 10       PUSH  X             (0669) ;
                                   (0670)  WAIT_RECV_bErrCheck:
0D60: 56 00 00 MOV   [X+0],0       (0671) _WAIT_RECV_bErrCheck:
0D63: 80 1F    JMP   0x0D83        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >WAIT_RECV_fStatus
                                   (0674)    mov A,  [WAIT_RECV_fStatus]
0D65: 10       PUSH  X             (0675)    and A, WAIT_RECV_RX_BUF_ERROR                 ; Mask off Error status
                                   (0676)    and [WAIT_RECV_fStatus], ~WAIT_RECV_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
0D66: 75       INC   X             (0679) .ENDSECTION
0D67: 76 E6    INC   [ID+1]        (0680) 
0D69: 3C E6 0F CMP   [ID+1],15     (0681) .SECTION
0D6C: AF F3    JZ    0x0D60        (0682) ;-----------------------------------------------------------------------------
0D6E: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: WAIT_RECV_bCmdLength
0D70: A0 12    JZ    0x0D83        (0684) ;
0D72: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
0D74: BF F1    JNZ   0x0D66        (0686) ;     Get length of command string
                                   (0687) ;
0D76: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
0D79: 76 E6    INC   [ID+1]        (0689) ;     none.
0D7B: 3C E6 0F CMP   [ID+1],15     (0690) ;
0D7E: B0 04    JNZ   0x0D83        (0691) ;  RETURNS:
0D80: 55 E6 0F MOV   [ID+1],15     (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
0D83: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
0D84: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
0D85: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
0D88: B0 0B    JNZ   0x0D94        (0699) ;    functions.
0D8A: 20       POP   X             (0700) ;          
0D8B: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
0D8D: 50 00    MOV   A,0           (0702) ;          CUR_PP
0D8F: 70 3F    AND   F,63
0D91: 71 C0    OR    F,192         (0703) ;
                                   (0704)  WAIT_RECV_bCmdLength:
0D93: 7F       RET                 (0705) _WAIT_RECV_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >WAIT_RECV_bRxCnt
0D94: 20       POP   X             (0708)    mov A,  [WAIT_RECV_bRxCnt]
0D95: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
0D97: 70 3F    AND   F,63
0D99: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
0D9B: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: WAIT_RECV_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
0D9C: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
0D9F: 50 68    MOV   A,104         (0744) ;     each lexically distinct element into a null-terminated string by replacing
0DA1: 02 E6    ADD   A,[ID+1]      (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
0DA3: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
0DA4: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     WAIT_RECV_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, WAIT_RECV_szGetParam, is
0DA8: 43 E1 08 OR    REG[225],8    (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\tx_23.asm
                                   (0109) ;;*****************************************************************************
0DAB: 7F       RET                 (0110) ;;*****************************************************************************
                                   (0111) ;;  FILENAME: TX_23.asm
                                   (0112) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:51
                                   (0113) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0114) ;;
                                   (0115) ;;  DESCRIPTION: TX8 User Module software implementation file
                                   (0116) ;;               for 22/24/25/26/27xxx PSoc family of devices.
                                   (0117) ;;
                                   (0118) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0119) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0120) ;;        This means it is the caller's responsibility to preserve any values
                                   (0121) ;;        in the X and A registers that are still needed after the API functions
                                   (0122) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0123) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0124) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0125) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0126) ;;-----------------------------------------------------------------------------
                                   (0127) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0128) ;;*****************************************************************************
                                   (0129) ;;*****************************************************************************
                                   (0130) 
                                   (0131) ;-----------------------------------------------
                                   (0132) ; include instance specific register definitions
                                   (0133) ;-----------------------------------------------
                                   (0134) include "m8c.inc"
                                   (0135) include "memory.inc"
                                   (0136) include "TX_23.inc"
0DAC: 41 E1 F7 AND   REG[225],247  (0137) 
                                   (0138) area UserModules (ROM, REL)
0DAF: 7F       RET                 (0139) ;-----------------------------------------------
                                   (0140) ;  Global Symbols
                                   (0141) ;-----------------------------------------------
                                   (0142) export   TX_23_SetTxIntMode
                                   (0143) export  _TX_23_SetTxIntMode
                                   (0144) export   TX_23_EnableInt
                                   (0145) export  _TX_23_EnableInt
                                   (0146) export   TX_23_DisableInt
                                   (0147) export  _TX_23_DisableInt
                                   (0148) export   TX_23_Start
                                   (0149) export  _TX_23_Start
                                   (0150) export   TX_23_Stop
                                   (0151) export  _TX_23_Stop
                                   (0152) export   TX_23_SendData
                                   (0153) export  _TX_23_SendData
                                   (0154) export   TX_23_bReadTxStatus
                                   (0155) export  _TX_23_bReadTxStatus
                                   (0156) 
                                   (0157) // Old labels, will be removed in future release
                                   (0158) // Do Not Use.
                                   (0159) export   bTX_23_ReadTxStatus
                                   (0160) export  _bTX_23_ReadTxStatus
                                   (0161) 
                                   (0162) ;-----------------------------------------------
                                   (0163) ;  High Level TX functions
                                   (0164) ;-----------------------------------------------
                                   (0165) export  TX_23_PutSHexByte
                                   (0166) export _TX_23_PutSHexByte
                                   (0167) export  TX_23_PutSHexInt
                                   (0168) export _TX_23_PutSHexInt
                                   (0169) 
0DB0: 71 10    OR    F,16          (0170) export  TX_23_CPutString
0DB2: 21 01    AND   A,1           (0171) export _TX_23_CPutString
0DB4: A0 07    JZ    0x0DBC        (0172) export  TX_23_PutString
0DB6: 43 2C 10 OR    REG[44],16    (0173) export _TX_23_PutString
0DB9: 70 EF    AND   F,239         (0174) export  TX_23_PutChar
                                   (0175) export _TX_23_PutChar
0DBB: 7F       RET                 (0176) export  TX_23_Write
                                   (0177) export _TX_23_Write
                                   (0178) export  TX_23_CWrite
0DBC: 41 2C EF AND   REG[44],239   (0179) export _TX_23_CWrite
0DBF: 70 EF    AND   F,239         (0180) export  TX_23_PutCRLF
                                   (0181) export _TX_23_PutCRLF 
0DC1: 7F       RET                 (0182) 
                                   (0183) ;-----------------------------------------------
                                   (0184) ;  EQUATES
                                   (0185) ;-----------------------------------------------
                                   (0186) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0187) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                   (0188) 
                                   (0189) AREA UserModules (ROM, REL)
                                   (0190) 
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: TX_23_EnableInt
                                   (0194) ;
                                   (0195) ;  DESCRIPTION:
                                   (0196) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                   (0197) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0198) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0199) ;
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201) ;
                                   (0202) ;  ARGUMENTS: none
                                   (0203) ;
                                   (0204) ;  RETURNS: none
                                   (0205) ;
                                   (0206) ;  SIDE EFFECTS:
                                   (0207) ;    The A and X registers may be modified by this or future implementations
                                   (0208) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0210) ;    responsibility to perserve their values across calls to fastcall16 
0DC2: 29 01    OR    A,1           (0211) ;    functions.
0DC4: 60 2F    MOV   REG[47],A     (0212) ;
                                   (0213)  TX_23_EnableInt:
0DC6: 7F       RET                 (0214) _TX_23_EnableInt:
                                   (0215)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0216)    M8C_EnableIntMask  TX_23_INT_REG, TX_23_bINT_MASK
                                   (0217)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0218)    ret
                                   (0219) .ENDSECTION
                                   (0220) 
                                   (0221) .SECTION
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) ;  FUNCTION NAME: TX_23_DisableInt
                                   (0224) ;
                                   (0225) ;  DESCRIPTION:
                                   (0226) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                   (0227) ;     associated with this User Module.
                                   (0228) ;
                                   (0229) ;-----------------------------------------------------------------------------
                                   (0230) ;
                                   (0231) ;  ARGUMENTS:  none
                                   (0232) ;
                                   (0233) ;  RETURNS:  none
                                   (0234) ;
                                   (0235) ;  SIDE EFFECTS:
                                   (0236) ;    The A and X registers may be modified by this or future implementations
                                   (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0239) ;    responsibility to perserve their values across calls to fastcall16 
0DC7: 41 2F FE AND   REG[47],254   (0240) ;    functions.
                                   (0241) ;
0DCA: 7F       RET                 (0242)  TX_23_DisableInt:
                                   (0243) _TX_23_DisableInt:
                                   (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0245)    M8C_DisableIntMask TX_23_INT_REG, TX_23_bINT_MASK
                                   (0246)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0247)    ret
                                   (0248) .ENDSECTION
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: TX_23_SetTxIntMode(BYTE bTxIntMode)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0256) ;
                                   (0257) ;  ARGUMENTS:
                                   (0258) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0259) ;        Passed in the A register
                                   (0260) ;
                                   (0261) ;  RETURNS:
                                   (0262) ;     none.
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    The A and X registers may be modified by this or future implementations
                                   (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0268) ;    responsibility to perserve their values across calls to fastcall16 
0DCB: 60 2D    MOV   REG[45],A     (0269) ;    functions.
                                   (0270) ;
0DCD: 7F       RET                 (0271) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0272) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0273) ;     on TX register empty or TX transmit complete
                                   (0274) ;
                                   (0275)  TX_23_SetTxIntMode:
                                   (0276) _TX_23_SetTxIntMode:
                                   (0277)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0278)    M8C_SetBank1
                                   (0279)    and   A, TX_23_INT_MODE_TX_COMPLETE
                                   (0280)    jz    .SetModeRegEmpty
                                   (0281)    or    REG[TX_23_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0282)    M8C_SetBank0
                                   (0283)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0284)    ret
                                   (0285) 
                                   (0286) .SetModeRegEmpty:
                                   (0287)    and   REG[TX_23_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0288)    M8C_SetBank0
                                   (0289)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0290)    ret
                                   (0291) .ENDSECTION
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_23_Start(BYTE bParity)
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0299) ;     The transmitter will begin transmitting if a byte has been written into the
                                   (0300) ;     transmit buffer.
0DCE: 5D 2F    MOV   A,REG[47]     (0301) ;
                                   (0302) ;-----------------------------------------------------------------------------
0DD0: 7F       RET                 (0303) ;
0DD1: 30       HALT  
0DD2: 31 32    XOR   A,50
0DD4: 33 34    XOR   A,[X+52]
0DD6: 35 36    XOR   [X+54],A
0DD8: 37 38 39 XOR   [X+56],57
0DDB: 41 42 43 AND   REG[66],67
0DDE: 44 45 46 OR    REG[X+69],70
                                   (0304) ;  ARGUMENTS:
                                   (0305) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                   (0306) ;
                                   (0307) ;  RETURNS:  none
                                   (0308) ;
                                   (0309) ;  SIDE EFFECTS:
                                   (0310) ;    The A and X registers may be modified by this or future implementations
                                   (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0314) ;    functions.
                                   (0315) ;
                                   (0316)  TX_23_Start:
                                   (0317) _TX_23_Start:
                                   (0318)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0319)    or    A, bfCONTROL_REG_START_BIT
                                   (0320)    mov   REG[TX_23_CONTROL_REG], A
                                   (0321)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0322)    ret
                                   (0323) .ENDSECTION
                                   (0324) 
                                   (0325) .SECTION
                                   (0326) ;-----------------------------------------------------------------------------
                                   (0327) ;  FUNCTION NAME: TX_23_Stop
                                   (0328) ;
                                   (0329) ;  DESCRIPTION:
                                   (0330) ;     Disables TX8 operation.
                                   (0331) ;
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:  none
0DE1: 08       PUSH  A             (0335) ;
0DE2: 67       ASR   A             (0336) ;  RETURNS:  none
0DE3: 67       ASR   A             (0337) ;
0DE4: 67       ASR   A             (0338) ;  SIDE EFFECTS:
0DE5: 67       ASR   A             (0339) ;    The A and X registers may be modified by this or future implementations
0DE6: 21 0F    AND   A,15          (0340) ;    of this function.  The same is true for all RAM page pointer registers in
0DE8: FF E7    INDEX 0x0DD1        (0341) ;    the Large Memory Model.  When necessary, it is the calling function's
0DEA: 90 0F    CALL  0x0DFB        (0342) ;    responsibility to perserve their values across calls to fastcall16 
0DEC: 18       POP   A             (0343) ;    functions.
0DED: 21 0F    AND   A,15          (0344) ;
0DEF: FF E0    INDEX 0x0DD1        (0345)  TX_23_Stop:
0DF1: 90 08    CALL  0x0DFB        (0346) _TX_23_Stop:
                                   (0347)    RAM_PROLOGUE RAM_USE_CLASS_1
0DF3: 7F       RET                 (0348)    and   REG[TX_23_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0349)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0350)    ret
                                   (0351) .ENDSECTION
                                   (0352) 
                                   (0353) .SECTION
                                   (0354) ;-----------------------------------------------------------------------------
                                   (0355) ;  FUNCTION NAME: TX_23_SendData
                                   (0356) ;
                                   (0357) ;  DESCRIPTION:
                                   (0358) ;     Sends one byte through serial port.
                                   (0359) ;
                                   (0360) ;-----------------------------------------------------------------------------
                                   (0361) ;
                                   (0362) ;  ARGUMENTS:
                                   (0363) ;     BYTE  TxData - data to transmit.
                                   (0364) ;
                                   (0365) ;  RETURNS:
                                   (0366) ;
                                   (0367) ;  SIDE EFFECTS:
                                   (0368) ;    The A and X registers may be modified by this or future implementations
                                   (0369) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0370) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0371) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0372) ;    functions.
                                   (0373) ;
                                   (0374)  TX_23_SendData:
                                   (0375) _TX_23_SendData:
0DF4: 4B       SWAP  A,X           (0376)    RAM_PROLOGUE RAM_USE_CLASS_1
0DF5: 9F EA    CALL  0x0DE1        (0377)    mov REG[TX_23_TX_BUFFER_REG], A
0DF7: 5B       MOV   A,X           (0378)    RAM_EPILOGUE RAM_USE_CLASS_1
0DF8: 9F E7    CALL  0x0DE1        (0379)    ret
                                   (0380) .ENDSECTION
0DFA: 7F       RET                 (0381) 
0DFB: 49 2F 10 TST   REG[47],16
                                   (0382) .SECTION
                                   (0383) ;-----------------------------------------------------------------------------
                                   (0384) ;  FUNCTION NAME: TX_23_bReadTxStatus
                                   (0385) ;
                                   (0386) ;  DESCRIPTION:
                                   (0387) ;     Reads the Tx Status bits in the Control/Status register.
                                   (0388) ;
                                   (0389) ;-----------------------------------------------------------------------------
                                   (0390) ;
                                   (0391) ;  ARGUMENTS:
                                   (0392) ;
                                   (0393) ;  RETURNS:
                                   (0394) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                   (0395) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;
                                   (0404)  TX_23_bReadTxStatus:
                                   (0405) _TX_23_bReadTxStatus:
                                   (0406)  bTX_23_ReadTxStatus:
                                   (0407) _bTX_23_ReadTxStatus:
                                   (0408)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0409)    mov A,  REG[TX_23_CONTROL_REG]
                                   (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0411)    ret
                                   (0412) 
                                   (0413) .ENDSECTION
                                   (0414) 
                                   (0415) ;-----------------------------------------------------------------------------
0DFE: AF FC    JZ    0x0DFB        (0416) ;  FUNCTION NAME: TX_23_PutSHexByte
0E00: 60 2D    MOV   REG[45],A
                                   (0417) ;
0E02: 7F       RET                 (0418) ;  DESCRIPTION:
                                   (0419) ;     Print a byte in Hex (two characters) to the UART Tx
                                   (0420) ;
                                   (0421) ;  ARGUMENTS:
                                   (0422) ;     A  => (BYTE) Data/char to be printed
                                   (0423) ;
                                   (0424) ;  RETURNS:
                                   (0425) ;     none.
                                   (0426) ;
                                   (0427) ;  SIDE EFFECTS:
                                   (0428) ;    The A and X registers may be modified by this or future implementations
                                   (0429) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0430) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0431) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0432) ;    functions.
                                   (0433) ;
                                   (0434) .LITERAL
                                   (0435) TX_23_HEX_STR:
                                   (0436)      DS    "0123456789ABCDEF"
                                   (0437) .ENDLITERAL
                                   (0438) 
                                   (0439) .SECTION
                                   (0440)  TX_23_PutSHexByte:
                                   (0441) _TX_23_PutSHexByte:
                                   (0442)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0443)     push  A                            ; Save lower nibble
                                   (0444)     asr   A                            ; Shift high nibble to right
                                   (0445)     asr   A
                                   (0446)     asr   A
                                   (0447)     asr   A
                                   (0448)     and   A,0Fh                        ; Mask off nibble
                                   (0449)     index TX_23_HEX_STR                ; Get Hex value
                                   (0450)     call  TX_23_PutChar                ; Write data to screen
                                   (0451)     pop   A                            ; Restore value
                                   (0452)     and   A,0Fh                        ; Mask off lower nibble
                                   (0453)     index TX_23_HEX_STR                ; Get Hex value
                                   (0454)     call  TX_23_PutChar                ; Write data to screen
                                   (0455)     RAM_EPILOGUE RAM_USE_CLASS_1
0E03: 70 BF    AND   F,191         (0456)     ret
0E05: 60 D3    MOV   REG[211],A    (0457) .ENDSECTION
                                   (0458) 
0E07: 52 00    MOV   A,[X+0]       (0459) .SECTION
0E09: A0 06    JZ    0x0E10        (0460) ;-----------------------------------------------------------------------------
0E0B: 9F EE    CALL  0x0DFB        (0461) ;  FUNCTION NAME: TX_23_PutSHexInt
0E0D: 75       INC   X             (0462) ;
0E0E: 8F F8    JMP   0x0E07        (0463) ;  DESCRIPTION:
0E10: 70 3F    AND   F,63
                                   (0464) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0465) ;
0E12: 71 C0    OR    F,192         (0466) ;  ARGUMENTS:
0E14: 7F       RET                 (0467) ;     Pointer to string
                                   (0468) ;     A  => ASB of Int
                                   (0469) ;     X  => MSB of Int
                                   (0470) ;
                                   (0471) ;  RETURNS:
                                   (0472) ;     none.
                                   (0473) ;
                                   (0474) ;  SIDE EFFECTS:
                                   (0475) ;    The A and X registers may be modified by this or future implementations
                                   (0476) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0477) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0478) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0479) ;    functions.
                                   (0480) ;
                                   (0481)  TX_23_PutSHexInt:
                                   (0482) _TX_23_PutSHexInt:
                                   (0483)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0484)     swap  A,X
                                   (0485)     call  TX_23_PutSHexByte            ; Print MSB
                                   (0486)     mov   A,X                          ; Move LSB into position
                                   (0487)     call  TX_23_PutSHexByte            ; Print LSB
                                   (0488)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)     ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: TX_23_PutChar
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Send character out through UART TX port.
                                   (0498) ;
                                   (0499) ;
                                   (0500) ;  ARGUMENTS:
                                   (0501) ;     A has Character to send to UART Tx Port
                                   (0502) ;
0E15: 70 BF    AND   F,191         (0503) ;  RETURNS:
0E17: 62 D3 03 MOV   REG[211],3    (0504) ;     none
0E1A: 4F       MOV   X,SP          (0505) ;
                                   (0506) ;  SIDE EFFECTS:
                                   (0507) ;    The A and X registers may be modified by this or future implementations
0E1B: 52 FB    MOV   A,[X-5]       (0508) ;    of this function.  The same is true for all RAM page pointer registers in
0E1D: A0 1A    JZ    0x0E38        (0509) ;    the Large Memory Model.  When necessary, it is the calling function's
0E1F: 7B FB    DEC   [X-5]         (0510) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0511) ;    functions.
                                   (0512) ;
0E21: 52 FC    MOV   A,[X-4]       (0513)    macro InLinePutChar( Source )
                                   (0514) .BufEmptyWaitLoop:
                                   (0515)    tst REG[TX_23_CONTROL_REG], TX_23_TX_BUFFER_EMPTY    ; Check Tx Status
0E23: 59 FD    MOV   X,[X-3]       (0516)    jz  .BufEmptyWaitLoop
0E25: 60 D3    MOV   REG[211],A    (0517)    mov REG[TX_23_TX_BUFFER_REG], @Source    ; Write data to Tx Port
0E27: 52 00    MOV   A,[X+0]       (0518)    endm
0E29: 49 2F 10 TST   REG[47],16
0E2C: AF FC    JZ    0x0E29        (0519) 
0E2E: 60 2D    MOV   REG[45],A
0E30: 4F       MOV   X,SP          (0520) 
0E31: 62 D3 03 MOV   REG[211],3    (0521)  TX_23_PutChar:
0E34: 77 FD    INC   [X-3]         (0522) _TX_23_PutChar:
0E36: 8F E4    JMP   0x0E1B        (0523)    RAM_PROLOGUE RAM_USE_CLASS_1
0E38: 70 3F    AND   F,63
                                   (0524)    InLinePutChar A
                                   (0525)    RAM_EPILOGUE RAM_USE_CLASS_1
0E3A: 71 C0    OR    F,192         (0526)    ret
0E3C: 7F       RET                 (0527) 
                                   (0528) .ENDSECTION
                                   (0529) 
                                   (0530) 
                                   (0531) ;-----------------------------------------------
                                   (0532) ;  High Level TX functions
                                   (0533) ;-----------------------------------------------
                                   (0534) 
                                   (0535) 
                                   (0536) .SECTION
                                   (0537) ;-----------------------------------------------------------------------------
                                   (0538) ;  FUNCTION NAME: TX_23_PutString
                                   (0539) ;
                                   (0540) ;  DESCRIPTION:
                                   (0541) ;     Send String out through UART TX port.
                                   (0542) ;
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;     Pointer to String
                                   (0546) ;     A has MSB of string address
                                   (0547) ;     X has LSB of string address
                                   (0548) ;
                                   (0549) ;  RETURNS:
                                   (0550) ;     none
                                   (0551) ;
                                   (0552) ;  SIDE EFFECTS:
                                   (0553) ;    The A and X registers may be modified by this or future implementations
                                   (0554) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0555) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0556) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0557) ;    functions.
                                   (0558) ;          
                                   (0559) ;    Currently only the page pointer registers listed below are modified: 
                                   (0560) ;          IDX_PP
                                   (0561) ;
                                   (0562)  TX_23_PutString:
                                   (0563) _TX_23_PutString:
0E3D: 4F       MOV   X,SP          (0564)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0565)    RAM_SETPAGE_IDX A
                                   (0566) .PutStringLoop:
                                   (0567)    mov   A,[X]                             ; Get value pointed to by X
0E3E: 3D FA 00 CMP   [X-6],0       (0568)    jz    End_PutString                     ; Check for end of string
0E41: B0 06    JNZ   0x0E48        (0569)    call  TX_23_PutChar                      ; Send character to Tx port
0E43: 3D FB 00 CMP   [X-5],0       (0570)    inc   X                                 ; Advance pointer to next character
0E46: A0 1D    JZ    0x0E64        (0571)    jmp   .PutStringLoop                     ; Get next character
                                   (0572) 
                                   (0573) End_PutString:
0E48: 10       PUSH  X             (0574)    RAM_EPILOGUE RAM_USE_CLASS_3
0E49: 52 FC    MOV   A,[X-4]       (0575)    ret
0E4B: 59 FD    MOV   X,[X-3]       (0576) .ENDSECTION
0E4D: 28       ROMX                (0577) 
0E4E: 49 2F 10 TST   REG[47],16
0E51: AF FC    JZ    0x0E4E        (0578) .SECTION
0E53: 60 2D    MOV   REG[45],A
0E55: 20       POP   X             (0579) ;-----------------------------------------------------------------------------
                                   (0580) ;  FUNCTION NAME: TX_23_Write
0E56: 07 FD 01 ADD   [X-3],1       (0581) ;
0E59: 0F FC 00 ADC   [X-4],0       (0582) ;  DESCRIPTION:
                                   (0583) ;     Send String of length X to serial port
                                   (0584) ;
0E5C: 17 FB 01 SUB   [X-5],1       (0585) ;
0E5F: 1F FA 00 SBB   [X-6],0       (0586) ;  ARGUMENTS:
                                   (0587) ;     Pointer to String
0E62: 8F DB    JMP   0x0E3E        (0588) ;     [SP-5] Count of characters to send
                                   (0589) ;     [SP-4] has MSB of string address
                                   (0590) ;     [SP-3] has LSB of string address
                                   (0591) ;
0E64: 7F       RET                 (0592) ;  RETURNS:
                                   (0593) ;     none
                                   (0594) ;
                                   (0595) ;  SIDE EFFECTS:
                                   (0596) ;    The A and X registers may be modified by this or future implementations
                                   (0597) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0598) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0599) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0600) ;    functions.
                                   (0601) ;          
                                   (0602) ;    Currently only the page pointer registers listed below are modified: 
                                   (0603) ;          IDX_PP
                                   (0604) ;
                                   (0605) CNT_LEN:    equ -5           ; Length of data to send
                                   (0606) STR_MSB:    equ -4           ; MSB pointer of string
                                   (0607) STR_LSB:    equ -3           ; LSB pointer of string
                                   (0608) 
                                   (0609)  TX_23_Write:
                                   (0610) _TX_23_Write:
                                   (0611)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0612)    RAM_SETPAGE_IDX2STK
                                   (0613)    mov   X, SP
                                   (0614) 
                                   (0615) .NextByteLoop:
                                   (0616)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
                                   (0617)    jz    .End_Write
                                   (0618)    dec   [X+CNT_LEN]                       ; Decrement counter
                                   (0619) 
                                   (0620)    IF SYSTEM_LARGE_MEMORY_MODEL
0E65: 08       PUSH  A             (0621)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
0E66: 10       PUSH  X             (0622)    ENDIF
0E67: 28       ROMX                (0623) 
0E68: A0 0B    JZ    0x0E74        (0624)    mov   X,[X+STR_LSB]                     ; Get character to send
0E6A: 9F 8F    CALL  0x0DFB        (0625)    RAM_SETPAGE_IDX A                        ; switch index pages
0E6C: 20       POP   X             (0626)    mov   A,[X]
0E6D: 18       POP   A             (0627)    InLinePutChar A                          ; Send character to UART
0E6E: 75       INC   X             (0628)    mov   X, SP
0E6F: DF F5    JNC   0x0E65        (0629)    RAM_SETPAGE_IDX2STK
0E71: 74       INC   A             (0630)    inc   [X+STR_LSB]
0E72: 8F F2    JMP   0x0E65        (0631)    jmp   .NextByteLoop
                                   (0632) 
                                   (0633) .End_Write:
                                   (0634)    RAM_EPILOGUE RAM_USE_CLASS_3
0E74: 38 FE    ADD   SP,254        (0635)    ret
                                   (0636) .ENDSECTION
0E76: 7F       RET                 (0637) 
                                   (0638) .SECTION
                                   (0639) ;-----------------------------------------------------------------------------
                                   (0640) ;  FUNCTION NAME: TX_23_CWrite
                                   (0641) ;
                                   (0642) ;             WARNING WARNING NOT COMPLETE
                                   (0643) ;
                                   (0644) ;  DESCRIPTION:
                                   (0645) ;     Send String of length X to serial port
                                   (0646) ;
                                   (0647) ;  ARGUMENTS:
                                   (0648) ;     Pointer to String
                                   (0649) ;     [SP-6] MSB of Count of character to send
                                   (0650) ;     [SP-5] LSB of Count of character to send
                                   (0651) ;     [SP-4] has MSB of string address
                                   (0652) ;     [SP-3] has LSB of string address
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
0E77: 50 0D    MOV   A,13          (0663) ;
0E79: 9F 80    CALL  0x0DFB        (0664) CLEN_MSB:   equ -6           ; MSB Length of data to send
0E7B: 50 0A    MOV   A,10          (0665) CLEN_LSB:   equ -5           ; LSB Length of data to send
0E7D: 9F 7C    CALL  0x0DFB        (0666) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (0667) CSTR_LSB:   equ -3           ; LSB pointer of string
0E81: 43 E1 04 OR    REG[225],4    (0668) 

FILE: lib\tx_014.asm
                                   (0109) ;;*****************************************************************************
0E84: 7F       RET                 (0110) ;;*****************************************************************************
                                   (0111) ;;  FILENAME: TX_014.asm
                                   (0112) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:51
                                   (0113) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0114) ;;
                                   (0115) ;;  DESCRIPTION: TX8 User Module software implementation file
                                   (0116) ;;               for 22/24/25/26/27xxx PSoc family of devices.
                                   (0117) ;;
                                   (0118) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0119) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0120) ;;        This means it is the caller's responsibility to preserve any values
                                   (0121) ;;        in the X and A registers that are still needed after the API functions
                                   (0122) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0123) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0124) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0125) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0126) ;;-----------------------------------------------------------------------------
                                   (0127) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0128) ;;*****************************************************************************
                                   (0129) ;;*****************************************************************************
                                   (0130) 
                                   (0131) ;-----------------------------------------------
                                   (0132) ; include instance specific register definitions
                                   (0133) ;-----------------------------------------------
                                   (0134) include "m8c.inc"
                                   (0135) include "memory.inc"
                                   (0136) include "TX_014.inc"
0E85: 41 E1 FB AND   REG[225],251  (0137) 
                                   (0138) area UserModules (ROM, REL)
0E88: 7F       RET                 (0139) ;-----------------------------------------------
                                   (0140) ;  Global Symbols
                                   (0141) ;-----------------------------------------------
                                   (0142) export   TX_014_SetTxIntMode
                                   (0143) export  _TX_014_SetTxIntMode
                                   (0144) export   TX_014_EnableInt
                                   (0145) export  _TX_014_EnableInt
                                   (0146) export   TX_014_DisableInt
                                   (0147) export  _TX_014_DisableInt
                                   (0148) export   TX_014_Start
                                   (0149) export  _TX_014_Start
                                   (0150) export   TX_014_Stop
                                   (0151) export  _TX_014_Stop
                                   (0152) export   TX_014_SendData
                                   (0153) export  _TX_014_SendData
                                   (0154) export   TX_014_bReadTxStatus
                                   (0155) export  _TX_014_bReadTxStatus
                                   (0156) 
                                   (0157) // Old labels, will be removed in future release
                                   (0158) // Do Not Use.
                                   (0159) export   bTX_014_ReadTxStatus
                                   (0160) export  _bTX_014_ReadTxStatus
                                   (0161) 
                                   (0162) ;-----------------------------------------------
                                   (0163) ;  High Level TX functions
                                   (0164) ;-----------------------------------------------
                                   (0165) export  TX_014_PutSHexByte
                                   (0166) export _TX_014_PutSHexByte
                                   (0167) export  TX_014_PutSHexInt
                                   (0168) export _TX_014_PutSHexInt
                                   (0169) 
0E89: 71 10    OR    F,16          (0170) export  TX_014_CPutString
0E8B: 21 01    AND   A,1           (0171) export _TX_014_CPutString
0E8D: A0 07    JZ    0x0E95        (0172) export  TX_014_PutString
0E8F: 43 28 10 OR    REG[40],16    (0173) export _TX_014_PutString
0E92: 70 EF    AND   F,239         (0174) export  TX_014_PutChar
                                   (0175) export _TX_014_PutChar
0E94: 7F       RET                 (0176) export  TX_014_Write
                                   (0177) export _TX_014_Write
                                   (0178) export  TX_014_CWrite
0E95: 41 28 EF AND   REG[40],239   (0179) export _TX_014_CWrite
0E98: 70 EF    AND   F,239         (0180) export  TX_014_PutCRLF
                                   (0181) export _TX_014_PutCRLF 
0E9A: 7F       RET                 (0182) 
                                   (0183) ;-----------------------------------------------
                                   (0184) ;  EQUATES
                                   (0185) ;-----------------------------------------------
                                   (0186) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0187) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                   (0188) 
                                   (0189) AREA UserModules (ROM, REL)
                                   (0190) 
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: TX_014_EnableInt
                                   (0194) ;
                                   (0195) ;  DESCRIPTION:
                                   (0196) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                   (0197) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0198) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0199) ;
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201) ;
                                   (0202) ;  ARGUMENTS: none
                                   (0203) ;
                                   (0204) ;  RETURNS: none
                                   (0205) ;
                                   (0206) ;  SIDE EFFECTS:
                                   (0207) ;    The A and X registers may be modified by this or future implementations
                                   (0208) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0210) ;    responsibility to perserve their values across calls to fastcall16 
0E9B: 29 01    OR    A,1           (0211) ;    functions.
0E9D: 60 2B    MOV   REG[43],A     (0212) ;
                                   (0213)  TX_014_EnableInt:
0E9F: 7F       RET                 (0214) _TX_014_EnableInt:
                                   (0215)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0216)    M8C_EnableIntMask  TX_014_INT_REG, TX_014_bINT_MASK
                                   (0217)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0218)    ret
                                   (0219) .ENDSECTION
                                   (0220) 
                                   (0221) .SECTION
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) ;  FUNCTION NAME: TX_014_DisableInt
                                   (0224) ;
                                   (0225) ;  DESCRIPTION:
                                   (0226) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                   (0227) ;     associated with this User Module.
                                   (0228) ;
                                   (0229) ;-----------------------------------------------------------------------------
                                   (0230) ;
                                   (0231) ;  ARGUMENTS:  none
                                   (0232) ;
                                   (0233) ;  RETURNS:  none
                                   (0234) ;
                                   (0235) ;  SIDE EFFECTS:
                                   (0236) ;    The A and X registers may be modified by this or future implementations
                                   (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0239) ;    responsibility to perserve their values across calls to fastcall16 
0EA0: 41 2B FE AND   REG[43],254   (0240) ;    functions.
                                   (0241) ;
0EA3: 7F       RET                 (0242)  TX_014_DisableInt:
                                   (0243) _TX_014_DisableInt:
                                   (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0245)    M8C_DisableIntMask TX_014_INT_REG, TX_014_bINT_MASK
                                   (0246)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0247)    ret
                                   (0248) .ENDSECTION
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: TX_014_SetTxIntMode(BYTE bTxIntMode)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0256) ;
                                   (0257) ;  ARGUMENTS:
                                   (0258) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0259) ;        Passed in the A register
                                   (0260) ;
                                   (0261) ;  RETURNS:
                                   (0262) ;     none.
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    The A and X registers may be modified by this or future implementations
                                   (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0268) ;    responsibility to perserve their values across calls to fastcall16 
0EA4: 60 29    MOV   REG[41],A     (0269) ;    functions.
                                   (0270) ;
0EA6: 7F       RET                 (0271) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0272) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0273) ;     on TX register empty or TX transmit complete
                                   (0274) ;
                                   (0275)  TX_014_SetTxIntMode:
                                   (0276) _TX_014_SetTxIntMode:
                                   (0277)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0278)    M8C_SetBank1
                                   (0279)    and   A, TX_014_INT_MODE_TX_COMPLETE
                                   (0280)    jz    .SetModeRegEmpty
                                   (0281)    or    REG[TX_014_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0282)    M8C_SetBank0
                                   (0283)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0284)    ret
                                   (0285) 
                                   (0286) .SetModeRegEmpty:
                                   (0287)    and   REG[TX_014_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0288)    M8C_SetBank0
                                   (0289)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0290)    ret
                                   (0291) .ENDSECTION
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_014_Start(BYTE bParity)
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0299) ;     The transmitter will begin transmitting if a byte has been written into the
                                   (0300) ;     transmit buffer.
0EA7: 5D 2B    MOV   A,REG[43]     (0301) ;
                                   (0302) ;-----------------------------------------------------------------------------
0EA9: 7F       RET                 (0303) ;
0EAA: 30       HALT  
0EAB: 31 32    XOR   A,50
0EAD: 33 34    XOR   A,[X+52]
0EAF: 35 36    XOR   [X+54],A
0EB1: 37 38 39 XOR   [X+56],57
0EB4: 41 42 43 AND   REG[66],67
0EB7: 44 45 46 OR    REG[X+69],70
                                   (0304) ;  ARGUMENTS:
                                   (0305) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                   (0306) ;
                                   (0307) ;  RETURNS:  none
                                   (0308) ;
                                   (0309) ;  SIDE EFFECTS:
                                   (0310) ;    The A and X registers may be modified by this or future implementations
                                   (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0314) ;    functions.
                                   (0315) ;
                                   (0316)  TX_014_Start:
                                   (0317) _TX_014_Start:
                                   (0318)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0319)    or    A, bfCONTROL_REG_START_BIT
                                   (0320)    mov   REG[TX_014_CONTROL_REG], A
                                   (0321)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0322)    ret
                                   (0323) .ENDSECTION
                                   (0324) 
                                   (0325) .SECTION
                                   (0326) ;-----------------------------------------------------------------------------
                                   (0327) ;  FUNCTION NAME: TX_014_Stop
                                   (0328) ;
                                   (0329) ;  DESCRIPTION:
                                   (0330) ;     Disables TX8 operation.
                                   (0331) ;
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:  none
0EBA: 08       PUSH  A             (0335) ;
0EBB: 67       ASR   A             (0336) ;  RETURNS:  none
0EBC: 67       ASR   A             (0337) ;
0EBD: 67       ASR   A             (0338) ;  SIDE EFFECTS:
0EBE: 67       ASR   A             (0339) ;    The A and X registers may be modified by this or future implementations
0EBF: 21 0F    AND   A,15          (0340) ;    of this function.  The same is true for all RAM page pointer registers in
0EC1: FF E7    INDEX 0x0EAA        (0341) ;    the Large Memory Model.  When necessary, it is the calling function's
0EC3: 90 0F    CALL  0x0ED4        (0342) ;    responsibility to perserve their values across calls to fastcall16 
0EC5: 18       POP   A             (0343) ;    functions.
0EC6: 21 0F    AND   A,15          (0344) ;
0EC8: FF E0    INDEX 0x0EAA        (0345)  TX_014_Stop:
0ECA: 90 08    CALL  0x0ED4        (0346) _TX_014_Stop:
                                   (0347)    RAM_PROLOGUE RAM_USE_CLASS_1
0ECC: 7F       RET                 (0348)    and   REG[TX_014_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0349)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0350)    ret
                                   (0351) .ENDSECTION
                                   (0352) 
                                   (0353) .SECTION
                                   (0354) ;-----------------------------------------------------------------------------
                                   (0355) ;  FUNCTION NAME: TX_014_SendData
                                   (0356) ;
                                   (0357) ;  DESCRIPTION:
                                   (0358) ;     Sends one byte through serial port.
                                   (0359) ;
                                   (0360) ;-----------------------------------------------------------------------------
                                   (0361) ;
                                   (0362) ;  ARGUMENTS:
                                   (0363) ;     BYTE  TxData - data to transmit.
                                   (0364) ;
                                   (0365) ;  RETURNS:
                                   (0366) ;
                                   (0367) ;  SIDE EFFECTS:
                                   (0368) ;    The A and X registers may be modified by this or future implementations
                                   (0369) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0370) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0371) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0372) ;    functions.
                                   (0373) ;
                                   (0374)  TX_014_SendData:
                                   (0375) _TX_014_SendData:
0ECD: 4B       SWAP  A,X           (0376)    RAM_PROLOGUE RAM_USE_CLASS_1
0ECE: 9F EA    CALL  0x0EBA        (0377)    mov REG[TX_014_TX_BUFFER_REG], A
0ED0: 5B       MOV   A,X           (0378)    RAM_EPILOGUE RAM_USE_CLASS_1
0ED1: 9F E7    CALL  0x0EBA        (0379)    ret
                                   (0380) .ENDSECTION
0ED3: 7F       RET                 (0381) 
0ED4: 49 2B 10 TST   REG[43],16
                                   (0382) .SECTION
                                   (0383) ;-----------------------------------------------------------------------------
                                   (0384) ;  FUNCTION NAME: TX_014_bReadTxStatus
                                   (0385) ;
                                   (0386) ;  DESCRIPTION:
                                   (0387) ;     Reads the Tx Status bits in the Control/Status register.
                                   (0388) ;
                                   (0389) ;-----------------------------------------------------------------------------
                                   (0390) ;
                                   (0391) ;  ARGUMENTS:
                                   (0392) ;
                                   (0393) ;  RETURNS:
                                   (0394) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                   (0395) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;
                                   (0404)  TX_014_bReadTxStatus:
                                   (0405) _TX_014_bReadTxStatus:
                                   (0406)  bTX_014_ReadTxStatus:
                                   (0407) _bTX_014_ReadTxStatus:
                                   (0408)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0409)    mov A,  REG[TX_014_CONTROL_REG]
                                   (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0411)    ret
                                   (0412) 
                                   (0413) .ENDSECTION
                                   (0414) 
                                   (0415) ;-----------------------------------------------------------------------------
0ED7: AF FC    JZ    0x0ED4        (0416) ;  FUNCTION NAME: TX_014_PutSHexByte
0ED9: 60 29    MOV   REG[41],A
                                   (0417) ;
0EDB: 7F       RET                 (0418) ;  DESCRIPTION:
                                   (0419) ;     Print a byte in Hex (two characters) to the UART Tx
                                   (0420) ;
                                   (0421) ;  ARGUMENTS:
                                   (0422) ;     A  => (BYTE) Data/char to be printed
                                   (0423) ;
                                   (0424) ;  RETURNS:
                                   (0425) ;     none.
                                   (0426) ;
                                   (0427) ;  SIDE EFFECTS:
                                   (0428) ;    The A and X registers may be modified by this or future implementations
                                   (0429) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0430) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0431) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0432) ;    functions.
                                   (0433) ;
                                   (0434) .LITERAL
                                   (0435) TX_014_HEX_STR:
                                   (0436)      DS    "0123456789ABCDEF"
                                   (0437) .ENDLITERAL
                                   (0438) 
                                   (0439) .SECTION
                                   (0440)  TX_014_PutSHexByte:
                                   (0441) _TX_014_PutSHexByte:
                                   (0442)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0443)     push  A                            ; Save lower nibble
                                   (0444)     asr   A                            ; Shift high nibble to right
                                   (0445)     asr   A
                                   (0446)     asr   A
                                   (0447)     asr   A
                                   (0448)     and   A,0Fh                        ; Mask off nibble
                                   (0449)     index TX_014_HEX_STR               ; Get Hex value
                                   (0450)     call  TX_014_PutChar               ; Write data to screen
                                   (0451)     pop   A                            ; Restore value
                                   (0452)     and   A,0Fh                        ; Mask off lower nibble
                                   (0453)     index TX_014_HEX_STR               ; Get Hex value
                                   (0454)     call  TX_014_PutChar               ; Write data to screen
                                   (0455)     RAM_EPILOGUE RAM_USE_CLASS_1
0EDC: 70 BF    AND   F,191         (0456)     ret
0EDE: 60 D3    MOV   REG[211],A    (0457) .ENDSECTION
                                   (0458) 
0EE0: 52 00    MOV   A,[X+0]       (0459) .SECTION
0EE2: A0 06    JZ    0x0EE9        (0460) ;-----------------------------------------------------------------------------
0EE4: 9F EE    CALL  0x0ED4        (0461) ;  FUNCTION NAME: TX_014_PutSHexInt
0EE6: 75       INC   X             (0462) ;
0EE7: 8F F8    JMP   0x0EE0        (0463) ;  DESCRIPTION:
0EE9: 70 3F    AND   F,63
                                   (0464) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0465) ;
0EEB: 71 C0    OR    F,192         (0466) ;  ARGUMENTS:
0EED: 7F       RET                 (0467) ;     Pointer to string
                                   (0468) ;     A  => ASB of Int
                                   (0469) ;     X  => MSB of Int
                                   (0470) ;
                                   (0471) ;  RETURNS:
                                   (0472) ;     none.
                                   (0473) ;
                                   (0474) ;  SIDE EFFECTS:
                                   (0475) ;    The A and X registers may be modified by this or future implementations
                                   (0476) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0477) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0478) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0479) ;    functions.
                                   (0480) ;
                                   (0481)  TX_014_PutSHexInt:
                                   (0482) _TX_014_PutSHexInt:
                                   (0483)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0484)     swap  A,X
                                   (0485)     call  TX_014_PutSHexByte           ; Print MSB
                                   (0486)     mov   A,X                          ; Move LSB into position
                                   (0487)     call  TX_014_PutSHexByte           ; Print LSB
                                   (0488)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)     ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: TX_014_PutChar
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Send character out through UART TX port.
                                   (0498) ;
                                   (0499) ;
                                   (0500) ;  ARGUMENTS:
                                   (0501) ;     A has Character to send to UART Tx Port
                                   (0502) ;
0EEE: 70 BF    AND   F,191         (0503) ;  RETURNS:
0EF0: 62 D3 03 MOV   REG[211],3    (0504) ;     none
0EF3: 4F       MOV   X,SP          (0505) ;
                                   (0506) ;  SIDE EFFECTS:
                                   (0507) ;    The A and X registers may be modified by this or future implementations
0EF4: 52 FB    MOV   A,[X-5]       (0508) ;    of this function.  The same is true for all RAM page pointer registers in
0EF6: A0 1A    JZ    0x0F11        (0509) ;    the Large Memory Model.  When necessary, it is the calling function's
0EF8: 7B FB    DEC   [X-5]         (0510) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0511) ;    functions.
                                   (0512) ;
0EFA: 52 FC    MOV   A,[X-4]       (0513)    macro InLinePutChar( Source )
                                   (0514) .BufEmptyWaitLoop:
                                   (0515)    tst REG[TX_014_CONTROL_REG], TX_014_TX_BUFFER_EMPTY    ; Check Tx Status
0EFC: 59 FD    MOV   X,[X-3]       (0516)    jz  .BufEmptyWaitLoop
0EFE: 60 D3    MOV   REG[211],A    (0517)    mov REG[TX_014_TX_BUFFER_REG], @Source    ; Write data to Tx Port
0F00: 52 00    MOV   A,[X+0]       (0518)    endm
0F02: 49 2B 10 TST   REG[43],16
0F05: AF FC    JZ    0x0F02        (0519) 
0F07: 60 29    MOV   REG[41],A
0F09: 4F       MOV   X,SP          (0520) 
0F0A: 62 D3 03 MOV   REG[211],3    (0521)  TX_014_PutChar:
0F0D: 77 FD    INC   [X-3]         (0522) _TX_014_PutChar:
0F0F: 8F E4    JMP   0x0EF4        (0523)    RAM_PROLOGUE RAM_USE_CLASS_1
0F11: 70 3F    AND   F,63
                                   (0524)    InLinePutChar A
                                   (0525)    RAM_EPILOGUE RAM_USE_CLASS_1
0F13: 71 C0    OR    F,192         (0526)    ret
0F15: 7F       RET                 (0527) 
                                   (0528) .ENDSECTION
                                   (0529) 
                                   (0530) 
                                   (0531) ;-----------------------------------------------
                                   (0532) ;  High Level TX functions
                                   (0533) ;-----------------------------------------------
                                   (0534) 
                                   (0535) 
                                   (0536) .SECTION
                                   (0537) ;-----------------------------------------------------------------------------
                                   (0538) ;  FUNCTION NAME: TX_014_PutString
                                   (0539) ;
                                   (0540) ;  DESCRIPTION:
                                   (0541) ;     Send String out through UART TX port.
                                   (0542) ;
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;     Pointer to String
                                   (0546) ;     A has MSB of string address
                                   (0547) ;     X has LSB of string address
                                   (0548) ;
                                   (0549) ;  RETURNS:
                                   (0550) ;     none
                                   (0551) ;
                                   (0552) ;  SIDE EFFECTS:
                                   (0553) ;    The A and X registers may be modified by this or future implementations
                                   (0554) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0555) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0556) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0557) ;    functions.
                                   (0558) ;          
                                   (0559) ;    Currently only the page pointer registers listed below are modified: 
                                   (0560) ;          IDX_PP
                                   (0561) ;
                                   (0562)  TX_014_PutString:
                                   (0563) _TX_014_PutString:
0F16: 4F       MOV   X,SP          (0564)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0565)    RAM_SETPAGE_IDX A
                                   (0566) .PutStringLoop:
                                   (0567)    mov   A,[X]                             ; Get value pointed to by X
0F17: 3D FA 00 CMP   [X-6],0       (0568)    jz    End_PutString                     ; Check for end of string
0F1A: B0 06    JNZ   0x0F21        (0569)    call  TX_014_PutChar                     ; Send character to Tx port
0F1C: 3D FB 00 CMP   [X-5],0       (0570)    inc   X                                 ; Advance pointer to next character
0F1F: A0 1D    JZ    0x0F3D        (0571)    jmp   .PutStringLoop                     ; Get next character
                                   (0572) 
                                   (0573) End_PutString:
0F21: 10       PUSH  X             (0574)    RAM_EPILOGUE RAM_USE_CLASS_3
0F22: 52 FC    MOV   A,[X-4]       (0575)    ret
0F24: 59 FD    MOV   X,[X-3]       (0576) .ENDSECTION
0F26: 28       ROMX                (0577) 
0F27: 49 2B 10 TST   REG[43],16
0F2A: AF FC    JZ    0x0F27        (0578) .SECTION
0F2C: 60 29    MOV   REG[41],A
0F2E: 20       POP   X             (0579) ;-----------------------------------------------------------------------------
                                   (0580) ;  FUNCTION NAME: TX_014_Write
0F2F: 07 FD 01 ADD   [X-3],1       (0581) ;
0F32: 0F FC 00 ADC   [X-4],0       (0582) ;  DESCRIPTION:
                                   (0583) ;     Send String of length X to serial port
                                   (0584) ;
0F35: 17 FB 01 SUB   [X-5],1       (0585) ;
0F38: 1F FA 00 SBB   [X-6],0       (0586) ;  ARGUMENTS:
                                   (0587) ;     Pointer to String
0F3B: 8F DB    JMP   0x0F17        (0588) ;     [SP-5] Count of characters to send
                                   (0589) ;     [SP-4] has MSB of string address
                                   (0590) ;     [SP-3] has LSB of string address
                                   (0591) ;
0F3D: 7F       RET                 (0592) ;  RETURNS:
                                   (0593) ;     none
                                   (0594) ;
                                   (0595) ;  SIDE EFFECTS:
                                   (0596) ;    The A and X registers may be modified by this or future implementations
                                   (0597) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0598) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0599) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0600) ;    functions.
                                   (0601) ;          
                                   (0602) ;    Currently only the page pointer registers listed below are modified: 
                                   (0603) ;          IDX_PP
                                   (0604) ;
                                   (0605) CNT_LEN:    equ -5           ; Length of data to send
                                   (0606) STR_MSB:    equ -4           ; MSB pointer of string
                                   (0607) STR_LSB:    equ -3           ; LSB pointer of string
                                   (0608) 
                                   (0609)  TX_014_Write:
                                   (0610) _TX_014_Write:
                                   (0611)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0612)    RAM_SETPAGE_IDX2STK
                                   (0613)    mov   X, SP
                                   (0614) 
                                   (0615) .NextByteLoop:
                                   (0616)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
                                   (0617)    jz    .End_Write
                                   (0618)    dec   [X+CNT_LEN]                       ; Decrement counter
                                   (0619) 
                                   (0620)    IF SYSTEM_LARGE_MEMORY_MODEL
0F3E: 08       PUSH  A             (0621)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
0F3F: 10       PUSH  X             (0622)    ENDIF
0F40: 28       ROMX                (0623) 
0F41: A0 0B    JZ    0x0F4D        (0624)    mov   X,[X+STR_LSB]                     ; Get character to send
0F43: 9F 8F    CALL  0x0ED4        (0625)    RAM_SETPAGE_IDX A                        ; switch index pages
0F45: 20       POP   X             (0626)    mov   A,[X]
0F46: 18       POP   A             (0627)    InLinePutChar A                          ; Send character to UART
0F47: 75       INC   X             (0628)    mov   X, SP
0F48: DF F5    JNC   0x0F3E        (0629)    RAM_SETPAGE_IDX2STK
0F4A: 74       INC   A             (0630)    inc   [X+STR_LSB]
0F4B: 8F F2    JMP   0x0F3E        (0631)    jmp   .NextByteLoop
                                   (0632) 
                                   (0633) .End_Write:
                                   (0634)    RAM_EPILOGUE RAM_USE_CLASS_3
0F4D: 38 FE    ADD   SP,254        (0635)    ret
                                   (0636) .ENDSECTION
0F4F: 7F       RET                 (0637) 
                                   (0638) .SECTION
                                   (0639) ;-----------------------------------------------------------------------------
                                   (0640) ;  FUNCTION NAME: TX_014_CWrite
                                   (0641) ;
                                   (0642) ;             WARNING WARNING NOT COMPLETE
                                   (0643) ;
                                   (0644) ;  DESCRIPTION:
                                   (0645) ;     Send String of length X to serial port
                                   (0646) ;
                                   (0647) ;  ARGUMENTS:
                                   (0648) ;     Pointer to String
                                   (0649) ;     [SP-6] MSB of Count of character to send
                                   (0650) ;     [SP-5] LSB of Count of character to send
                                   (0651) ;     [SP-4] has MSB of string address
                                   (0652) ;     [SP-3] has LSB of string address
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
0F50: 50 0D    MOV   A,13          (0663) ;
0F52: 9F 80    CALL  0x0ED4        (0664) CLEN_MSB:   equ -6           ; MSB Length of data to send
0F54: 50 0A    MOV   A,10          (0665) CLEN_LSB:   equ -5           ; LSB Length of data to send
0F56: 9F 7C    CALL  0x0ED4        (0666) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (0667) CSTR_LSB:   equ -3           ; LSB pointer of string
0F59: 43 E1 02 OR    REG[225],2    (0668) 

FILE: lib\tx_01234_timeout.asm
                                   (0102) ;;*****************************************************************************
0F5C: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: TX_01234_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "TX_01234_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
0F5D: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
0F60: 7F       RET                 (0131) export  TX_01234_TIMEOUT_EnableInt
                                   (0132) export _TX_01234_TIMEOUT_EnableInt
                                   (0133) export  TX_01234_TIMEOUT_DisableInt
                                   (0134) export _TX_01234_TIMEOUT_DisableInt
                                   (0135) export  TX_01234_TIMEOUT_Start
                                   (0136) export _TX_01234_TIMEOUT_Start
                                   (0137) export  TX_01234_TIMEOUT_Stop
                                   (0138) export _TX_01234_TIMEOUT_Stop
                                   (0139) export  TX_01234_TIMEOUT_WritePeriod
                                   (0140) export _TX_01234_TIMEOUT_WritePeriod
                                   (0141) export  TX_01234_TIMEOUT_WriteCompareValue
                                   (0142) export _TX_01234_TIMEOUT_WriteCompareValue
                                   (0143) export  TX_01234_TIMEOUT_wReadCompareValue
                                   (0144) export _TX_01234_TIMEOUT_wReadCompareValue
                                   (0145) export  TX_01234_TIMEOUT_wReadTimer
                                   (0146) export _TX_01234_TIMEOUT_wReadTimer
                                   (0147) export  TX_01234_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _TX_01234_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wTX_01234_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wTX_01234_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wTX_01234_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wTX_01234_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wTX_01234_TIMEOUT_ReadTimerSaveCV   ; deprecated
0F61: 43 23 01 OR    REG[35],1     (0157) export _wTX_01234_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
0F64: 7F       RET                 (0159) export  wTX_01234_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wTX_01234_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wTX_01234_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wTX_01234_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA my_response_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: TX_01234_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
0F65: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
0F68: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  TX_01234_TIMEOUT_EnableInt:
                                   (0200) _TX_01234_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    TX_01234_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: TX_01234_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
0F69: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
0F6B: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
0F6C: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
0F6E: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  TX_01234_TIMEOUT_DisableInt:
                                   (0228) _TX_01234_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    TX_01234_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: TX_01234_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
0F6F: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
0F71: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
0F72: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
0F74: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  TX_01234_TIMEOUT_Start:
                                   (0256) _TX_01234_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    TX_01234_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: TX_01234_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
0F75: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
0F77: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
0F78: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
0F7A: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  TX_01234_TIMEOUT_Stop:
                                   (0284) _TX_01234_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    TX_01234_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_01234_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  TX_01234_TIMEOUT_WritePeriod:
                                   (0313) _TX_01234_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[TX_01234_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[TX_01234_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: TX_01234_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call TX_01234_TIMEOUT_Stop to disable).
0F7B: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
0F7C: 38 03    ADD   SP,3          (0334) ;
0F7E: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
0F80: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
0F81: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
0F83: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
0F84: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
0F86: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
0F87: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
0F89: 5D 26    MOV   A,REG[38]     (0343) ;
0F8B: 54 01    MOV   [X+1],A       (0344)  TX_01234_TIMEOUT_WriteCompareValue:
0F8D: 5D 22    MOV   A,REG[34]     (0345) _TX_01234_TIMEOUT_WriteCompareValue:
0F8F: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
0F91: 50 00    MOV   A,0           (0347)    mov   reg[TX_01234_TIMEOUT_COMPARE_LSB_REG], A
0F93: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
0F96: A0 03    JZ    0x0F9A        (0349)    mov   reg[TX_01234_TIMEOUT_COMPARE_MSB_REG], A
0F98: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
0F9A: 54 00    MOV   [X+0],A       (0352) 
0F9C: 70 FE    AND   F,254         (0353) .ENDSECTION
0F9E: 41 23 FE AND   REG[35],254   (0354) 
0FA1: 18       POP   A             (0355) 
0FA2: 60 26    MOV   REG[38],A     (0356) .SECTION
0FA4: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
0FA5: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: TX_01234_TIMEOUT_wReadCompareValue
0FA7: 18       POP   A             (0359) ;
0FA8: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
0FAA: 18       POP   A             (0361) ;     Reads the Compare registers.
0FAB: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
0FAC: 70 3F    AND   F,63
0FAE: 71 C0    OR    F,192         (0363) ;
0FB0: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  TX_01234_TIMEOUT_wReadCompareValue:
                                   (0374) _TX_01234_TIMEOUT_wReadCompareValue:
                                   (0375)  wTX_01234_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wTX_01234_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[TX_01234_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[TX_01234_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: TX_01234_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
0FB1: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
0FB3: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
0FB5: 5C       MOV   X,A           (0409) ;
0FB6: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
0FBA: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\servo_tx.asm
                                   (0109) ;;*****************************************************************************
0FBD: 7F       RET                 (0110) ;;*****************************************************************************
                                   (0111) ;;  FILENAME: SERVO_TX.asm
                                   (0112) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:51
                                   (0113) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0114) ;;
                                   (0115) ;;  DESCRIPTION: TX8 User Module software implementation file
                                   (0116) ;;               for 22/24/25/26/27xxx PSoc family of devices.
                                   (0117) ;;
                                   (0118) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0119) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0120) ;;        This means it is the caller's responsibility to preserve any values
                                   (0121) ;;        in the X and A registers that are still needed after the API functions
                                   (0122) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0123) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0124) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0125) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0126) ;;-----------------------------------------------------------------------------
                                   (0127) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0128) ;;*****************************************************************************
                                   (0129) ;;*****************************************************************************
                                   (0130) 
                                   (0131) ;-----------------------------------------------
                                   (0132) ; include instance specific register definitions
                                   (0133) ;-----------------------------------------------
                                   (0134) include "m8c.inc"
                                   (0135) include "memory.inc"
                                   (0136) include "SERVO_TX.inc"
0FBE: 41 E1 FB AND   REG[225],251  (0137) 
                                   (0138) area UserModules (ROM, REL)
0FC1: 7F       RET                 (0139) ;-----------------------------------------------
                                   (0140) ;  Global Symbols
                                   (0141) ;-----------------------------------------------
                                   (0142) export   SERVO_TX_SetTxIntMode
                                   (0143) export  _SERVO_TX_SetTxIntMode
                                   (0144) export   SERVO_TX_EnableInt
                                   (0145) export  _SERVO_TX_EnableInt
                                   (0146) export   SERVO_TX_DisableInt
                                   (0147) export  _SERVO_TX_DisableInt
                                   (0148) export   SERVO_TX_Start
                                   (0149) export  _SERVO_TX_Start
                                   (0150) export   SERVO_TX_Stop
                                   (0151) export  _SERVO_TX_Stop
                                   (0152) export   SERVO_TX_SendData
                                   (0153) export  _SERVO_TX_SendData
                                   (0154) export   SERVO_TX_bReadTxStatus
                                   (0155) export  _SERVO_TX_bReadTxStatus
                                   (0156) 
                                   (0157) // Old labels, will be removed in future release
                                   (0158) // Do Not Use.
                                   (0159) export   bSERVO_TX_ReadTxStatus
                                   (0160) export  _bSERVO_TX_ReadTxStatus
                                   (0161) 
                                   (0162) ;-----------------------------------------------
                                   (0163) ;  High Level TX functions
                                   (0164) ;-----------------------------------------------
                                   (0165) export  SERVO_TX_PutSHexByte
                                   (0166) export _SERVO_TX_PutSHexByte
                                   (0167) export  SERVO_TX_PutSHexInt
                                   (0168) export _SERVO_TX_PutSHexInt
                                   (0169) 
0FC2: 71 10    OR    F,16          (0170) export  SERVO_TX_CPutString
0FC4: 21 01    AND   A,1           (0171) export _SERVO_TX_CPutString
0FC6: A0 07    JZ    0x0FCE        (0172) export  SERVO_TX_PutString
0FC8: 43 28 10 OR    REG[40],16    (0173) export _SERVO_TX_PutString
0FCB: 70 EF    AND   F,239         (0174) export  SERVO_TX_PutChar
                                   (0175) export _SERVO_TX_PutChar
0FCD: 7F       RET                 (0176) export  SERVO_TX_Write
                                   (0177) export _SERVO_TX_Write
                                   (0178) export  SERVO_TX_CWrite
0FCE: 41 28 EF AND   REG[40],239   (0179) export _SERVO_TX_CWrite
0FD1: 70 EF    AND   F,239         (0180) export  SERVO_TX_PutCRLF
                                   (0181) export _SERVO_TX_PutCRLF 
0FD3: 7F       RET                 (0182) 
                                   (0183) ;-----------------------------------------------
                                   (0184) ;  EQUATES
                                   (0185) ;-----------------------------------------------
                                   (0186) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0187) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                   (0188) 
                                   (0189) AREA UserModules (ROM, REL)
                                   (0190) 
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: SERVO_TX_EnableInt
                                   (0194) ;
                                   (0195) ;  DESCRIPTION:
                                   (0196) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                   (0197) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0198) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0199) ;
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201) ;
                                   (0202) ;  ARGUMENTS: none
                                   (0203) ;
                                   (0204) ;  RETURNS: none
                                   (0205) ;
                                   (0206) ;  SIDE EFFECTS:
                                   (0207) ;    The A and X registers may be modified by this or future implementations
                                   (0208) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0210) ;    responsibility to perserve their values across calls to fastcall16 
0FD4: 29 01    OR    A,1           (0211) ;    functions.
0FD6: 60 2B    MOV   REG[43],A     (0212) ;
                                   (0213)  SERVO_TX_EnableInt:
0FD8: 7F       RET                 (0214) _SERVO_TX_EnableInt:
                                   (0215)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0216)    M8C_EnableIntMask  SERVO_TX_INT_REG, SERVO_TX_bINT_MASK
                                   (0217)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0218)    ret
                                   (0219) .ENDSECTION
                                   (0220) 
                                   (0221) .SECTION
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) ;  FUNCTION NAME: SERVO_TX_DisableInt
                                   (0224) ;
                                   (0225) ;  DESCRIPTION:
                                   (0226) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                   (0227) ;     associated with this User Module.
                                   (0228) ;
                                   (0229) ;-----------------------------------------------------------------------------
                                   (0230) ;
                                   (0231) ;  ARGUMENTS:  none
                                   (0232) ;
                                   (0233) ;  RETURNS:  none
                                   (0234) ;
                                   (0235) ;  SIDE EFFECTS:
                                   (0236) ;    The A and X registers may be modified by this or future implementations
                                   (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0239) ;    responsibility to perserve their values across calls to fastcall16 
0FD9: 41 2B FE AND   REG[43],254   (0240) ;    functions.
                                   (0241) ;
0FDC: 7F       RET                 (0242)  SERVO_TX_DisableInt:
                                   (0243) _SERVO_TX_DisableInt:
                                   (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0245)    M8C_DisableIntMask SERVO_TX_INT_REG, SERVO_TX_bINT_MASK
                                   (0246)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0247)    ret
                                   (0248) .ENDSECTION
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: SERVO_TX_SetTxIntMode(BYTE bTxIntMode)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0256) ;
                                   (0257) ;  ARGUMENTS:
                                   (0258) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0259) ;        Passed in the A register
                                   (0260) ;
                                   (0261) ;  RETURNS:
                                   (0262) ;     none.
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    The A and X registers may be modified by this or future implementations
                                   (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0268) ;    responsibility to perserve their values across calls to fastcall16 
0FDD: 60 29    MOV   REG[41],A     (0269) ;    functions.
                                   (0270) ;
0FDF: 7F       RET                 (0271) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0272) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0273) ;     on TX register empty or TX transmit complete
                                   (0274) ;
                                   (0275)  SERVO_TX_SetTxIntMode:
                                   (0276) _SERVO_TX_SetTxIntMode:
                                   (0277)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0278)    M8C_SetBank1
                                   (0279)    and   A, SERVO_TX_INT_MODE_TX_COMPLETE
                                   (0280)    jz    .SetModeRegEmpty
                                   (0281)    or    REG[SERVO_TX_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0282)    M8C_SetBank0
                                   (0283)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0284)    ret
                                   (0285) 
                                   (0286) .SetModeRegEmpty:
                                   (0287)    and   REG[SERVO_TX_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0288)    M8C_SetBank0
                                   (0289)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0290)    ret
                                   (0291) .ENDSECTION
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: SERVO_TX_Start(BYTE bParity)
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0299) ;     The transmitter will begin transmitting if a byte has been written into the
                                   (0300) ;     transmit buffer.
0FE0: 5D 2B    MOV   A,REG[43]     (0301) ;
                                   (0302) ;-----------------------------------------------------------------------------
0FE2: 7F       RET                 (0303) ;
0FE3: 30       HALT  
0FE4: 31 32    XOR   A,50
0FE6: 33 34    XOR   A,[X+52]
0FE8: 35 36    XOR   [X+54],A
0FEA: 37 38 39 XOR   [X+56],57
0FED: 41 42 43 AND   REG[66],67
0FF0: 44 45 46 OR    REG[X+69],70
                                   (0304) ;  ARGUMENTS:
                                   (0305) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                   (0306) ;
                                   (0307) ;  RETURNS:  none
                                   (0308) ;
                                   (0309) ;  SIDE EFFECTS:
                                   (0310) ;    The A and X registers may be modified by this or future implementations
                                   (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0314) ;    functions.
                                   (0315) ;
                                   (0316)  SERVO_TX_Start:
                                   (0317) _SERVO_TX_Start:
                                   (0318)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0319)    or    A, bfCONTROL_REG_START_BIT
                                   (0320)    mov   REG[SERVO_TX_CONTROL_REG], A
                                   (0321)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0322)    ret
                                   (0323) .ENDSECTION
                                   (0324) 
                                   (0325) .SECTION
                                   (0326) ;-----------------------------------------------------------------------------
                                   (0327) ;  FUNCTION NAME: SERVO_TX_Stop
                                   (0328) ;
                                   (0329) ;  DESCRIPTION:
                                   (0330) ;     Disables TX8 operation.
                                   (0331) ;
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:  none
0FF3: 08       PUSH  A             (0335) ;
0FF4: 67       ASR   A             (0336) ;  RETURNS:  none
0FF5: 67       ASR   A             (0337) ;
0FF6: 67       ASR   A             (0338) ;  SIDE EFFECTS:
0FF7: 67       ASR   A             (0339) ;    The A and X registers may be modified by this or future implementations
0FF8: 21 0F    AND   A,15          (0340) ;    of this function.  The same is true for all RAM page pointer registers in
0FFA: FF E7    INDEX 0x0FE3        (0341) ;    the Large Memory Model.  When necessary, it is the calling function's
0FFC: 90 0F    CALL  0x100D        (0342) ;    responsibility to perserve their values across calls to fastcall16 
0FFE: 18       POP   A             (0343) ;    functions.
0FFF: 21 0F    AND   A,15          (0344) ;
1001: FF E0    INDEX 0x0FE3        (0345)  SERVO_TX_Stop:
1003: 90 08    CALL  0x100D        (0346) _SERVO_TX_Stop:
                                   (0347)    RAM_PROLOGUE RAM_USE_CLASS_1
1005: 7F       RET                 (0348)    and   REG[SERVO_TX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0349)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0350)    ret
                                   (0351) .ENDSECTION
                                   (0352) 
                                   (0353) .SECTION
                                   (0354) ;-----------------------------------------------------------------------------
                                   (0355) ;  FUNCTION NAME: SERVO_TX_SendData
                                   (0356) ;
                                   (0357) ;  DESCRIPTION:
                                   (0358) ;     Sends one byte through serial port.
                                   (0359) ;
                                   (0360) ;-----------------------------------------------------------------------------
                                   (0361) ;
                                   (0362) ;  ARGUMENTS:
                                   (0363) ;     BYTE  TxData - data to transmit.
                                   (0364) ;
                                   (0365) ;  RETURNS:
                                   (0366) ;
                                   (0367) ;  SIDE EFFECTS:
                                   (0368) ;    The A and X registers may be modified by this or future implementations
                                   (0369) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0370) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0371) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0372) ;    functions.
                                   (0373) ;
                                   (0374)  SERVO_TX_SendData:
                                   (0375) _SERVO_TX_SendData:
1006: 4B       SWAP  A,X           (0376)    RAM_PROLOGUE RAM_USE_CLASS_1
1007: 9F EA    CALL  0x0FF3        (0377)    mov REG[SERVO_TX_TX_BUFFER_REG], A
1009: 5B       MOV   A,X           (0378)    RAM_EPILOGUE RAM_USE_CLASS_1
100A: 9F E7    CALL  0x0FF3        (0379)    ret
                                   (0380) .ENDSECTION
100C: 7F       RET                 (0381) 
100D: 49 2B 10 TST   REG[43],16
                                   (0382) .SECTION
                                   (0383) ;-----------------------------------------------------------------------------
                                   (0384) ;  FUNCTION NAME: SERVO_TX_bReadTxStatus
                                   (0385) ;
                                   (0386) ;  DESCRIPTION:
                                   (0387) ;     Reads the Tx Status bits in the Control/Status register.
                                   (0388) ;
                                   (0389) ;-----------------------------------------------------------------------------
                                   (0390) ;
                                   (0391) ;  ARGUMENTS:
                                   (0392) ;
                                   (0393) ;  RETURNS:
                                   (0394) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                   (0395) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;
                                   (0404)  SERVO_TX_bReadTxStatus:
                                   (0405) _SERVO_TX_bReadTxStatus:
                                   (0406)  bSERVO_TX_ReadTxStatus:
                                   (0407) _bSERVO_TX_ReadTxStatus:
                                   (0408)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0409)    mov A,  REG[SERVO_TX_CONTROL_REG]
                                   (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0411)    ret
                                   (0412) 
                                   (0413) .ENDSECTION
                                   (0414) 
                                   (0415) ;-----------------------------------------------------------------------------
1010: AF FC    JZ    0x100D        (0416) ;  FUNCTION NAME: SERVO_TX_PutSHexByte
1012: 60 29    MOV   REG[41],A
                                   (0417) ;
1014: 7F       RET                 (0418) ;  DESCRIPTION:
                                   (0419) ;     Print a byte in Hex (two characters) to the UART Tx
                                   (0420) ;
                                   (0421) ;  ARGUMENTS:
                                   (0422) ;     A  => (BYTE) Data/char to be printed
                                   (0423) ;
                                   (0424) ;  RETURNS:
                                   (0425) ;     none.
                                   (0426) ;
                                   (0427) ;  SIDE EFFECTS:
                                   (0428) ;    The A and X registers may be modified by this or future implementations
                                   (0429) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0430) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0431) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0432) ;    functions.
                                   (0433) ;
                                   (0434) .LITERAL
                                   (0435) SERVO_TX_HEX_STR:
                                   (0436)      DS    "0123456789ABCDEF"
                                   (0437) .ENDLITERAL
                                   (0438) 
                                   (0439) .SECTION
                                   (0440)  SERVO_TX_PutSHexByte:
                                   (0441) _SERVO_TX_PutSHexByte:
                                   (0442)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0443)     push  A                            ; Save lower nibble
                                   (0444)     asr   A                            ; Shift high nibble to right
                                   (0445)     asr   A
                                   (0446)     asr   A
                                   (0447)     asr   A
                                   (0448)     and   A,0Fh                        ; Mask off nibble
                                   (0449)     index SERVO_TX_HEX_STR             ; Get Hex value
                                   (0450)     call  SERVO_TX_PutChar             ; Write data to screen
                                   (0451)     pop   A                            ; Restore value
                                   (0452)     and   A,0Fh                        ; Mask off lower nibble
                                   (0453)     index SERVO_TX_HEX_STR             ; Get Hex value
                                   (0454)     call  SERVO_TX_PutChar             ; Write data to screen
                                   (0455)     RAM_EPILOGUE RAM_USE_CLASS_1
1015: 70 BF    AND   F,191         (0456)     ret
1017: 60 D3    MOV   REG[211],A    (0457) .ENDSECTION
                                   (0458) 
1019: 52 00    MOV   A,[X+0]       (0459) .SECTION
101B: A0 06    JZ    0x1022        (0460) ;-----------------------------------------------------------------------------
101D: 9F EE    CALL  0x100D        (0461) ;  FUNCTION NAME: SERVO_TX_PutSHexInt
101F: 75       INC   X             (0462) ;
1020: 8F F8    JMP   0x1019        (0463) ;  DESCRIPTION:
1022: 70 3F    AND   F,63
                                   (0464) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0465) ;
1024: 71 C0    OR    F,192         (0466) ;  ARGUMENTS:
1026: 7F       RET                 (0467) ;     Pointer to string
                                   (0468) ;     A  => ASB of Int
                                   (0469) ;     X  => MSB of Int
                                   (0470) ;
                                   (0471) ;  RETURNS:
                                   (0472) ;     none.
                                   (0473) ;
                                   (0474) ;  SIDE EFFECTS:
                                   (0475) ;    The A and X registers may be modified by this or future implementations
                                   (0476) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0477) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0478) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0479) ;    functions.
                                   (0480) ;
                                   (0481)  SERVO_TX_PutSHexInt:
                                   (0482) _SERVO_TX_PutSHexInt:
                                   (0483)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0484)     swap  A,X
                                   (0485)     call  SERVO_TX_PutSHexByte         ; Print MSB
                                   (0486)     mov   A,X                          ; Move LSB into position
                                   (0487)     call  SERVO_TX_PutSHexByte         ; Print LSB
                                   (0488)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)     ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: SERVO_TX_PutChar
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Send character out through UART TX port.
                                   (0498) ;
                                   (0499) ;
                                   (0500) ;  ARGUMENTS:
                                   (0501) ;     A has Character to send to UART Tx Port
                                   (0502) ;
1027: 70 BF    AND   F,191         (0503) ;  RETURNS:
1029: 62 D3 03 MOV   REG[211],3    (0504) ;     none
102C: 4F       MOV   X,SP          (0505) ;
                                   (0506) ;  SIDE EFFECTS:
                                   (0507) ;    The A and X registers may be modified by this or future implementations
102D: 52 FB    MOV   A,[X-5]       (0508) ;    of this function.  The same is true for all RAM page pointer registers in
102F: A0 1A    JZ    0x104A        (0509) ;    the Large Memory Model.  When necessary, it is the calling function's
1031: 7B FB    DEC   [X-5]         (0510) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0511) ;    functions.
                                   (0512) ;
1033: 52 FC    MOV   A,[X-4]       (0513)    macro InLinePutChar( Source )
                                   (0514) .BufEmptyWaitLoop:
                                   (0515)    tst REG[SERVO_TX_CONTROL_REG], SERVO_TX_TX_BUFFER_EMPTY    ; Check Tx Status
1035: 59 FD    MOV   X,[X-3]       (0516)    jz  .BufEmptyWaitLoop
1037: 60 D3    MOV   REG[211],A    (0517)    mov REG[SERVO_TX_TX_BUFFER_REG], @Source    ; Write data to Tx Port
1039: 52 00    MOV   A,[X+0]       (0518)    endm
103B: 49 2B 10 TST   REG[43],16
103E: AF FC    JZ    0x103B        (0519) 
1040: 60 29    MOV   REG[41],A
1042: 4F       MOV   X,SP          (0520) 
1043: 62 D3 03 MOV   REG[211],3    (0521)  SERVO_TX_PutChar:
1046: 77 FD    INC   [X-3]         (0522) _SERVO_TX_PutChar:
1048: 8F E4    JMP   0x102D        (0523)    RAM_PROLOGUE RAM_USE_CLASS_1
104A: 70 3F    AND   F,63
                                   (0524)    InLinePutChar A
                                   (0525)    RAM_EPILOGUE RAM_USE_CLASS_1
104C: 71 C0    OR    F,192         (0526)    ret
104E: 7F       RET                 (0527) 
                                   (0528) .ENDSECTION
                                   (0529) 
                                   (0530) 
                                   (0531) ;-----------------------------------------------
                                   (0532) ;  High Level TX functions
                                   (0533) ;-----------------------------------------------
                                   (0534) 
                                   (0535) 
                                   (0536) .SECTION
                                   (0537) ;-----------------------------------------------------------------------------
                                   (0538) ;  FUNCTION NAME: SERVO_TX_PutString
                                   (0539) ;
                                   (0540) ;  DESCRIPTION:
                                   (0541) ;     Send String out through UART TX port.
                                   (0542) ;
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;     Pointer to String
                                   (0546) ;     A has MSB of string address
                                   (0547) ;     X has LSB of string address
                                   (0548) ;
                                   (0549) ;  RETURNS:
                                   (0550) ;     none
                                   (0551) ;
                                   (0552) ;  SIDE EFFECTS:
                                   (0553) ;    The A and X registers may be modified by this or future implementations
                                   (0554) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0555) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0556) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0557) ;    functions.
                                   (0558) ;          
                                   (0559) ;    Currently only the page pointer registers listed below are modified: 
                                   (0560) ;          IDX_PP
                                   (0561) ;
                                   (0562)  SERVO_TX_PutString:
                                   (0563) _SERVO_TX_PutString:
104F: 4F       MOV   X,SP          (0564)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0565)    RAM_SETPAGE_IDX A
                                   (0566) .PutStringLoop:
                                   (0567)    mov   A,[X]                             ; Get value pointed to by X
1050: 3D FA 00 CMP   [X-6],0       (0568)    jz    End_PutString                     ; Check for end of string
1053: B0 06    JNZ   0x105A        (0569)    call  SERVO_TX_PutChar                   ; Send character to Tx port
1055: 3D FB 00 CMP   [X-5],0       (0570)    inc   X                                 ; Advance pointer to next character
1058: A0 1D    JZ    0x1076        (0571)    jmp   .PutStringLoop                     ; Get next character
                                   (0572) 
                                   (0573) End_PutString:
105A: 10       PUSH  X             (0574)    RAM_EPILOGUE RAM_USE_CLASS_3
105B: 52 FC    MOV   A,[X-4]       (0575)    ret
105D: 59 FD    MOV   X,[X-3]       (0576) .ENDSECTION
105F: 28       ROMX                (0577) 
1060: 49 2B 10 TST   REG[43],16
1063: AF FC    JZ    0x1060        (0578) .SECTION
1065: 60 29    MOV   REG[41],A
1067: 20       POP   X             (0579) ;-----------------------------------------------------------------------------
                                   (0580) ;  FUNCTION NAME: SERVO_TX_Write
1068: 07 FD 01 ADD   [X-3],1       (0581) ;
106B: 0F FC 00 ADC   [X-4],0       (0582) ;  DESCRIPTION:
                                   (0583) ;     Send String of length X to serial port
                                   (0584) ;
106E: 17 FB 01 SUB   [X-5],1       (0585) ;
1071: 1F FA 00 SBB   [X-6],0       (0586) ;  ARGUMENTS:
                                   (0587) ;     Pointer to String
1074: 8F DB    JMP   0x1050        (0588) ;     [SP-5] Count of characters to send
                                   (0589) ;     [SP-4] has MSB of string address
                                   (0590) ;     [SP-3] has LSB of string address
                                   (0591) ;
1076: 7F       RET                 (0592) ;  RETURNS:
                                   (0593) ;     none
                                   (0594) ;
                                   (0595) ;  SIDE EFFECTS:
                                   (0596) ;    The A and X registers may be modified by this or future implementations
                                   (0597) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0598) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0599) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0600) ;    functions.
                                   (0601) ;          
                                   (0602) ;    Currently only the page pointer registers listed below are modified: 
                                   (0603) ;          IDX_PP
                                   (0604) ;
                                   (0605) CNT_LEN:    equ -5           ; Length of data to send
                                   (0606) STR_MSB:    equ -4           ; MSB pointer of string
                                   (0607) STR_LSB:    equ -3           ; LSB pointer of string
                                   (0608) 
                                   (0609)  SERVO_TX_Write:
                                   (0610) _SERVO_TX_Write:
                                   (0611)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0612)    RAM_SETPAGE_IDX2STK
                                   (0613)    mov   X, SP
                                   (0614) 
                                   (0615) .NextByteLoop:
                                   (0616)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
                                   (0617)    jz    .End_Write
                                   (0618)    dec   [X+CNT_LEN]                       ; Decrement counter
                                   (0619) 
                                   (0620)    IF SYSTEM_LARGE_MEMORY_MODEL
1077: 08       PUSH  A             (0621)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
1078: 10       PUSH  X             (0622)    ENDIF
1079: 28       ROMX                (0623) 
107A: A0 0B    JZ    0x1086        (0624)    mov   X,[X+STR_LSB]                     ; Get character to send
107C: 9F 8F    CALL  0x100D        (0625)    RAM_SETPAGE_IDX A                        ; switch index pages
107E: 20       POP   X             (0626)    mov   A,[X]
107F: 18       POP   A             (0627)    InLinePutChar A                          ; Send character to UART
1080: 75       INC   X             (0628)    mov   X, SP
1081: DF F5    JNC   0x1077        (0629)    RAM_SETPAGE_IDX2STK
1083: 74       INC   A             (0630)    inc   [X+STR_LSB]
1084: 8F F2    JMP   0x1077        (0631)    jmp   .NextByteLoop
                                   (0632) 
                                   (0633) .End_Write:
                                   (0634)    RAM_EPILOGUE RAM_USE_CLASS_3
1086: 38 FE    ADD   SP,254        (0635)    ret
                                   (0636) .ENDSECTION
1088: 7F       RET                 (0637) 
                                   (0638) .SECTION
                                   (0639) ;-----------------------------------------------------------------------------
                                   (0640) ;  FUNCTION NAME: SERVO_TX_CWrite
                                   (0641) ;
                                   (0642) ;             WARNING WARNING NOT COMPLETE
                                   (0643) ;
                                   (0644) ;  DESCRIPTION:
                                   (0645) ;     Send String of length X to serial port
                                   (0646) ;
                                   (0647) ;  ARGUMENTS:
                                   (0648) ;     Pointer to String
                                   (0649) ;     [SP-6] MSB of Count of character to send
                                   (0650) ;     [SP-5] LSB of Count of character to send
                                   (0651) ;     [SP-4] has MSB of string address
                                   (0652) ;     [SP-3] has LSB of string address
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
1089: 50 0D    MOV   A,13          (0663) ;
108B: 9F 80    CALL  0x100D        (0664) CLEN_MSB:   equ -6           ; MSB Length of data to send
108D: 50 0A    MOV   A,10          (0665) CLEN_LSB:   equ -5           ; LSB Length of data to send
108F: 9F 7C    CALL  0x100D        (0666) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (0667) CSTR_LSB:   equ -3           ; LSB pointer of string
1092: 08       PUSH  A             (0668) 

FILE: lib\rx8_2int.asm
1093: 10       PUSH  X             (0104) ;;*****************************************************************************
1094: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: RX8_2INT.asm
1096: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1097: 58 03    MOV   X,[3]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1099: 5D 2F    MOV   A,REG[47]     (0111) ;;-----------------------------------------------------------------------------
109B: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
109C: 21 08    AND   A,8           (0114) ;;*****************************************************************************
109E: B0 04    JNZ   0x10A3        (0115) 
10A0: 18       POP   A             (0116) include "m8c.inc"
10A1: 80 5E    JMP   0x1100        (0117) include "memory.inc"
                                   (0118) include "RX8_2.inc"
                                   (0119) 
                                   (0120) 
10A3: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
10A4: 21 E0    AND   A,224         (0124) export  _RX8_2_ISR
10A6: A0 12    JZ    0x10B9        (0125) 
                                   (0126) 
10A8: 2C 02    OR    [2],A         (0127) IF (RX8_2_RXBUF_ENABLE)
                                   (0128) export  RX8_2_aRxBuffer
10AA: 49 2E 00 TST   REG[46],0     (0129) export _RX8_2_aRxBuffer
                                   (0130) export  RX8_2_bRxCnt
10AD: 21 20    AND   A,32          (0131) export _RX8_2_bRxCnt
10AF: A0 50    JZ    0x1100        (0132) export  RX8_2_fStatus
                                   (0133) export _RX8_2_fStatus
                                   (0134) ENDIF
                                   (0135) 
10B1: 41 2F FE AND   REG[47],254   (0136) 
10B4: 43 2F 01 OR    REG[47],1     (0137) ;-----------------------------------------------
10B7: 80 48    JMP   0x1100        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (RX8_2_RXBUF_ENABLE)
10B9: 5D 2E    MOV   A,REG[46]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  RX8_2_fStatus:
                                   (0144) _RX8_2_fStatus:      BLK  1
10BB: 47 02 01 TST   [2],1         (0145)  RX8_2_bRxCnt:
10BE: B0 41    JNZ   0x1100        (0146) _RX8_2_bRxCnt:       BLK  1
                                   (0147) AREA RX8_2_RAM(RAM,REL,CON)
10C0: 39 00    CMP   A,0           (0148)  RX8_2_aRxBuffer:    
10C2: B0 14    JNZ   0x10D7        (0149) _RX8_2_aRxBuffer:    BLK RX8_2_RX_BUFFER_SIZE
10C4: 2E 02 01 OR    [2],1         (0150) ENDIF
                                   (0151) 
10C7: 62 D3 00 MOV   REG[211],0    (0152) 
10CA: 70 3F    AND   F,63
10CC: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
10CE: 56 58 00 MOV   [X+88],0      (0154) 
10D1: 70 3F    AND   F,63
10D3: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
10D5: 80 2A    JMP   0x1100        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
10D7: 3C 03 0F CMP   [3],15        (0167) ;------------------------
10DA: C0 14    JC    0x10EF        (0168) 
10DC: 2E 02 10 OR    [2],16        (0169) 
                                   (0170) ;------------------------
10DF: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
10E2: 70 3F    AND   F,63
10E4: 71 80    OR    F,128         (0172) ;------------------------
10E6: 56 58 00 MOV   [X+88],0      (0173) 
10E9: 70 3F    AND   F,63
10EB: 71 00    OR    F,0           (0174) 
10ED: 80 12    JMP   0x1100        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
10EF: 75       INC   X             (0179) 
10F0: 5A 03    MOV   [3],X         (0180) 
10F2: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
10F3: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
10F6: 70 3F    AND   F,63
10F8: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _RX8_2_ISR
10FA: 54 58    MOV   [X+88],A      (0185) ;
10FC: 70 3F    AND   F,63
10FE: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1100: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1101: 60 D3    MOV   REG[211],A    (0191) _RX8_2_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1103: 20       POP   X             (0195)    ; Insert your custom code below this banner
1104: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1106: 43 E1 08 OR    REG[225],8    (0201)    ; Insert your custom code above this banner

FILE: lib\rx8_2.asm
                                   (0121) ;;*****************************************************************************
1109: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: RX8_2.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "RX8_2.inc"
110A: 41 E1 F7 AND   REG[225],247  (0149) 
                                   (0150) 
110D: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   RX8_2_EnableInt
                                   (0155) export  _RX8_2_EnableInt
                                   (0156) export   RX8_2_DisableInt
                                   (0157) export  _RX8_2_DisableInt
                                   (0158) export   RX8_2_Start
                                   (0159) export  _RX8_2_Start
                                   (0160) export   RX8_2_Stop
                                   (0161) export  _RX8_2_Stop
                                   (0162) export   RX8_2_bReadRxData
                                   (0163) export  _RX8_2_bReadRxData
                                   (0164) export   RX8_2_bReadRxStatus
                                   (0165) export  _RX8_2_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bRX8_2_ReadRxData
                                   (0170) export _bRX8_2_ReadRxData
                                   (0171) export  bRX8_2_ReadRxStatus
                                   (0172) export _bRX8_2_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  RX8_2_cGetChar
110E: 29 01    OR    A,1           (0179) export _RX8_2_cGetChar
1110: 60 2F    MOV   REG[47],A     (0180) export  RX8_2_cReadChar
                                   (0181) export _RX8_2_cReadChar
1112: 7F       RET                 (0182) export  RX8_2_iReadChar
                                   (0183) export _RX8_2_iReadChar
                                   (0184) 
                                   (0185) IF (RX8_2_RXBUF_ENABLE)
                                   (0186) export  RX8_2_CmdReset
                                   (0187) export _RX8_2_CmdReset
                                   (0188) export  RX8_2_bCmdCheck
                                   (0189) export _RX8_2_bCmdCheck
                                   (0190) export  RX8_2_bCmdLength
                                   (0191) export _RX8_2_bCmdLength
                                   (0192) export  RX8_2_bErrCheck
                                   (0193) export _RX8_2_bErrCheck
                                   (0194) 
                                   (0195) export  RX8_2_szGetParam
                                   (0196) export _RX8_2_szGetParam
                                   (0197) export  RX8_2_szGetRestOfParams
                                   (0198) export _RX8_2_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA RX8_2_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1113: 41 2F FE AND   REG[47],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1116: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: RX8_2_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  RX8_2_EnableInt:
                                   (0238) _RX8_2_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1117: 5D 2E    MOV   A,REG[46]     (0240)    M8C_EnableIntMask RX8_2_INT_REG, RX8_2_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1119: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: RX8_2_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  RX8_2_DisableInt:
                                   (0267) _RX8_2_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask RX8_2_INT_REG, RX8_2_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
111A: 5D 2F    MOV   A,REG[47]     (0272) .ENDSECTION
                                   (0273) 
111C: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: RX8_2_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  RX8_2_Start:
                                   (0297) _RX8_2_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[RX8_2_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: RX8_2_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
111D: 49 2F 08 TST   REG[47],8     (0311) ;
1120: AF FC    JZ    0x111D        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1122: 5D 2E    MOV   A,REG[46]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1124: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  RX8_2_Stop:
                                   (0326) _RX8_2_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[RX8_2_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: RX8_2_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1125: 5D 2F    MOV   A,REG[47]     (0346) ;    bRxData - returned in A.
1127: 08       PUSH  A             (0347) ;
1128: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
112A: B0 04    JNZ   0x112F        (0349) ;    The A and X registers may be modified by this or future implementations
112C: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
112D: 80 0B    JMP   0x1139        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
112F: 5D 2E    MOV   A,REG[46]     (0354) ;
1131: 4B       SWAP  A,X           (0355)  RX8_2_bReadRxData:
                                   (0356) _RX8_2_bReadRxData:
1132: 18       POP   A             (0357)  bRX8_2_ReadRxData:
1133: 21 A0    AND   A,160         (0358) _bRX8_2_ReadRxData:
1135: B0 03    JNZ   0x1139        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1137: 4B       SWAP  A,X           (0360)    mov A, REG[RX8_2_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1138: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1139: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: RX8_2_bReadRxStatus
                                   (0368) ;
113B: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  RX8_2_bReadRxStatus:
                                   (0388) _RX8_2_bReadRxStatus:
                                   (0389)  bRX8_2_ReadRxStatus:
                                   (0390) _bRX8_2_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[RX8_2_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: RX8_2_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
113C: 5D 2F    MOV   A,REG[47]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
113E: 21 E8    AND   A,232         (0408) ;
1140: 08       PUSH  A             (0409) ;  ARGUMENTS:
1141: 21 08    AND   A,8           (0410) ;      none
1143: B0 07    JNZ   0x114B        (0411) ;
1145: 18       POP   A             (0412) ;  RETURNS:
1146: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1148: 4B       SWAP  A,X           (0414) ;
1149: 80 07    JMP   0x1151        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
114B: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
114C: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
114E: 4B       SWAP  A,X           (0420) ;    functions.
114F: 5D 2E    MOV   A,REG[46]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1151: 7F       RET                 (0426)  RX8_2_cGetChar:
                                   (0427) _RX8_2_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[RX8_2_CONTROL_REG],RX8_2_RX_REG_FULL  ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[RX8_2_RX_BUFFER_REG]               ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: RX8_2_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  RX8_2_cReadChar:
                                   (0463) _RX8_2_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[RX8_2_CONTROL_REG]                           ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,RX8_2_RX_COMPLETE                                ; Check if a character is ready
1152: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1155: 55 58 00 MOV   [88],0        (0470)    pop  A
1158: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
115B: 55 DE 00 MOV   [222],0       (0472) 
115E: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1161: 55 03 00 MOV   [3],0         (0474)    mov  A,REG[RX8_2_RX_BUFFER_REG]                         ; Read data first, then
1164: 26 02 00 AND   [2],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1167: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(RX8_2_RX_PARITY_ERROR | RX8_2_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_RX8_2_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: RX8_2_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1168: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
116B: 51 02    MOV   A,[2]         (0511) ;        0x40CC    Overrun Error
116D: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
116F: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  RX8_2_iReadChar:
                                   (0523) _RX8_2_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[RX8_2_CONTROL_REG]                           ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(RX8_2_RX_ERROR|RX8_2_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,RX8_2_RX_COMPLETE                                ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,RX8_2_RX_NO_DATA                                 ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_RX8_2_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,RX8_2_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[RX8_2_RX_BUFFER_REG]                         ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_RX8_2_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (RX8_2_RXBUF_ENABLE)
                                   (0552) .SECTION
1170: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1173: 51 02    MOV   A,[2]         (0554) ;-----------------------------------------------------------------------------
1175: 21 F0    AND   A,240         (0555) ;
1177: 26 02 0F AND   [2],15        (0556) ;     Command Buffer commands
                                   (0557) ;
117A: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: RX8_2_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  RX8_2_CmdReset:
117B: 62 D0 00 MOV   REG[208],0    (0587) _RX8_2_CmdReset:
117E: 51 03    MOV   A,[3]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >RX8_2_aRxBuffer
1180: 7F       RET                 (0590)    mov [RX8_2_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >RX8_2_bRxCnt
                                   (0594)    mov [RX8_2_bRxCnt], 0x00
                                   (0595)    and [RX8_2_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: RX8_2_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  RX8_2_bCmdCheck:
                                   (0628) _RX8_2_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >RX8_2_fStatus
                                   (0631)    mov A,  [RX8_2_fStatus]
                                   (0632)    and A, RX8_2_RX_BUF_CMDTERM                   ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: RX8_2_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1181: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1183: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1186: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1189: 50 58    MOV   A,88          (0648) ;     BYTE  fStatus - Status of command receive buffer.
118B: 02 DE    ADD   A,[222]       (0649) ;                     Returns non-zero value in A if command is valid.
118D: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
118E: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1190: B0 04    JNZ   0x1195        (0653) ;           0x10 => Software Buffer OverRun
1192: 10       PUSH  X             (0654) ;
1193: 80 33    JMP   0x11C7        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1195: 39 00    CMP   A,0           (0660) ;    functions.
1197: B0 11    JNZ   0x11A9        (0661) ;          
1199: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
119A: 76 DE    INC   [222]         (0663) ;          CUR_PP
119C: 52 00    MOV   A,[X+0]       (0664) ;
119E: 3C DE 0F CMP   [222],15      (0665) ;     Error Status is clear when read.
11A1: BF F3    JNZ   0x1195        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
11A3: 10       PUSH  X             (0669) ;
                                   (0670)  RX8_2_bErrCheck:
11A4: 56 00 00 MOV   [X+0],0       (0671) _RX8_2_bErrCheck:
11A7: 80 1F    JMP   0x11C7        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >RX8_2_fStatus
                                   (0674)    mov A,  [RX8_2_fStatus]
11A9: 10       PUSH  X             (0675)    and A, RX8_2_RX_BUF_ERROR                     ; Mask off Error status
                                   (0676)    and [RX8_2_fStatus], ~RX8_2_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
11AA: 75       INC   X             (0679) .ENDSECTION
11AB: 76 DE    INC   [222]         (0680) 
11AD: 3C DE 0F CMP   [222],15      (0681) .SECTION
11B0: AF F3    JZ    0x11A4        (0682) ;-----------------------------------------------------------------------------
11B2: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: RX8_2_bCmdLength
11B4: A0 12    JZ    0x11C7        (0684) ;
11B6: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
11B8: BF F1    JNZ   0x11AA        (0686) ;     Get length of command string
                                   (0687) ;
11BA: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
11BD: 76 DE    INC   [222]         (0689) ;     none.
11BF: 3C DE 0F CMP   [222],15      (0690) ;
11C2: B0 04    JNZ   0x11C7        (0691) ;  RETURNS:
11C4: 55 DE 0F MOV   [222],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
11C7: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
11C8: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
11C9: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
11CC: B0 0B    JNZ   0x11D8        (0699) ;    functions.
11CE: 20       POP   X             (0700) ;          
11CF: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
11D1: 50 00    MOV   A,0           (0702) ;          CUR_PP
11D3: 70 3F    AND   F,63
11D5: 71 C0    OR    F,192         (0703) ;
                                   (0704)  RX8_2_bCmdLength:
11D7: 7F       RET                 (0705) _RX8_2_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >RX8_2_bRxCnt
11D8: 20       POP   X             (0708)    mov A,  [RX8_2_bRxCnt]
11D9: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
11DB: 70 3F    AND   F,63
11DD: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
11DF: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: RX8_2_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
11E0: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
11E3: 50 58    MOV   A,88          (0744) ;     each lexically distinct element into a null-terminated string by replacing
11E5: 02 DE    ADD   A,[222]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
11E7: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
11E8: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     RX8_2_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, RX8_2_szGetParam, is
11EB: 43 E1 02 OR    REG[225],2    (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\init_timeout.asm
                                   (0102) ;;*****************************************************************************
11EE: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: INIT_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "INIT_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
11EF: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
11F2: 7F       RET                 (0131) export  INIT_TIMEOUT_EnableInt
                                   (0132) export _INIT_TIMEOUT_EnableInt
                                   (0133) export  INIT_TIMEOUT_DisableInt
                                   (0134) export _INIT_TIMEOUT_DisableInt
                                   (0135) export  INIT_TIMEOUT_Start
                                   (0136) export _INIT_TIMEOUT_Start
                                   (0137) export  INIT_TIMEOUT_Stop
                                   (0138) export _INIT_TIMEOUT_Stop
                                   (0139) export  INIT_TIMEOUT_WritePeriod
                                   (0140) export _INIT_TIMEOUT_WritePeriod
                                   (0141) export  INIT_TIMEOUT_WriteCompareValue
                                   (0142) export _INIT_TIMEOUT_WriteCompareValue
                                   (0143) export  INIT_TIMEOUT_wReadCompareValue
                                   (0144) export _INIT_TIMEOUT_wReadCompareValue
                                   (0145) export  INIT_TIMEOUT_wReadTimer
                                   (0146) export _INIT_TIMEOUT_wReadTimer
                                   (0147) export  INIT_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _INIT_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wINIT_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wINIT_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wINIT_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wINIT_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wINIT_TIMEOUT_ReadTimerSaveCV   ; deprecated
11F3: 43 23 01 OR    REG[35],1     (0157) export _wINIT_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
11F6: 7F       RET                 (0159) export  wINIT_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wINIT_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wINIT_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wINIT_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA initial_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: INIT_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
11F7: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
11FA: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  INIT_TIMEOUT_EnableInt:
                                   (0200) _INIT_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    INIT_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: INIT_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
11FB: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
11FD: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
11FE: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
1200: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  INIT_TIMEOUT_DisableInt:
                                   (0228) _INIT_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    INIT_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: INIT_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
1201: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
1203: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
1204: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
1206: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  INIT_TIMEOUT_Start:
                                   (0256) _INIT_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    INIT_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: INIT_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
1207: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
1209: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
120A: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
120C: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  INIT_TIMEOUT_Stop:
                                   (0284) _INIT_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    INIT_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: INIT_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  INIT_TIMEOUT_WritePeriod:
                                   (0313) _INIT_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[INIT_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[INIT_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: INIT_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call INIT_TIMEOUT_Stop to disable).
120D: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
120E: 38 03    ADD   SP,3          (0334) ;
1210: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
1212: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
1213: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
1215: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
1216: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
1218: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
1219: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
121B: 5D 26    MOV   A,REG[38]     (0343) ;
121D: 54 01    MOV   [X+1],A       (0344)  INIT_TIMEOUT_WriteCompareValue:
121F: 5D 22    MOV   A,REG[34]     (0345) _INIT_TIMEOUT_WriteCompareValue:
1221: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
1223: 50 00    MOV   A,0           (0347)    mov   reg[INIT_TIMEOUT_COMPARE_LSB_REG], A
1225: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
1228: A0 03    JZ    0x122C        (0349)    mov   reg[INIT_TIMEOUT_COMPARE_MSB_REG], A
122A: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
122C: 54 00    MOV   [X+0],A       (0352) 
122E: 70 FE    AND   F,254         (0353) .ENDSECTION
1230: 41 23 FE AND   REG[35],254   (0354) 
1233: 18       POP   A             (0355) 
1234: 60 26    MOV   REG[38],A     (0356) .SECTION
1236: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
1237: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: INIT_TIMEOUT_wReadCompareValue
1239: 18       POP   A             (0359) ;
123A: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
123C: 18       POP   A             (0361) ;     Reads the Compare registers.
123D: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
123E: 70 3F    AND   F,63
1240: 71 C0    OR    F,192         (0363) ;
1242: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  INIT_TIMEOUT_wReadCompareValue:
                                   (0374) _INIT_TIMEOUT_wReadCompareValue:
                                   (0375)  wINIT_TIMEOUT_ReadCompareValue:                 ; this name deprecated
                                   (0376) _wINIT_TIMEOUT_ReadCompareValue:                 ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[INIT_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[INIT_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: INIT_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
1243: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
1245: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
1247: 5C       MOV   X,A           (0409) ;
1248: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
124B: 08       PUSH  A             (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\init_rxint.asm
124C: 10       PUSH  X             (0104) ;;*****************************************************************************
124D: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: INIT_RXINT.asm
124F: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1250: 58 07    MOV   X,[7]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1252: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
1254: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1255: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1257: B0 04    JNZ   0x125C        (0115) 
1259: 18       POP   A             (0116) include "m8c.inc"
125A: 80 5E    JMP   0x12B9        (0117) include "memory.inc"
                                   (0118) include "INIT_RX.inc"
                                   (0119) 
                                   (0120) 
125C: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
125D: 21 E0    AND   A,224         (0124) export  _INIT_RX_ISR
125F: A0 12    JZ    0x1272        (0125) 
                                   (0126) 
1261: 2C 06    OR    [6],A         (0127) IF (INIT_RX_RXBUF_ENABLE)
                                   (0128) export  INIT_RX_aRxBuffer
1263: 49 2A 00 TST   REG[42],0     (0129) export _INIT_RX_aRxBuffer
                                   (0130) export  INIT_RX_bRxCnt
1266: 21 20    AND   A,32          (0131) export _INIT_RX_bRxCnt
1268: A0 50    JZ    0x12B9        (0132) export  INIT_RX_fStatus
                                   (0133) export _INIT_RX_fStatus
                                   (0134) ENDIF
                                   (0135) 
126A: 41 2B FE AND   REG[43],254   (0136) 
126D: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
1270: 80 48    JMP   0x12B9        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (INIT_RX_RXBUF_ENABLE)
1272: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  INIT_RX_fStatus:
                                   (0144) _INIT_RX_fStatus:      BLK  1
1274: 47 06 01 TST   [6],1         (0145)  INIT_RX_bRxCnt:
1277: B0 41    JNZ   0x12B9        (0146) _INIT_RX_bRxCnt:       BLK  1
                                   (0147) AREA INIT_RX_RAM(RAM,REL,CON)
1279: 39 00    CMP   A,0           (0148)  INIT_RX_aRxBuffer:    
127B: B0 14    JNZ   0x1290        (0149) _INIT_RX_aRxBuffer:    BLK INIT_RX_RX_BUFFER_SIZE
127D: 2E 06 01 OR    [6],1         (0150) ENDIF
                                   (0151) 
1280: 62 D3 00 MOV   REG[211],0    (0152) 
1283: 70 3F    AND   F,63
1285: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1287: 56 48 00 MOV   [X+72],0      (0154) 
128A: 70 3F    AND   F,63
128C: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
128E: 80 2A    JMP   0x12B9        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1290: 3C 07 0F CMP   [7],15        (0167) ;------------------------
1293: C0 14    JC    0x12A8        (0168) 
1295: 2E 06 10 OR    [6],16        (0169) 
                                   (0170) ;------------------------
1298: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
129B: 70 3F    AND   F,63
129D: 71 80    OR    F,128         (0172) ;------------------------
129F: 56 48 00 MOV   [X+72],0      (0173) 
12A2: 70 3F    AND   F,63
12A4: 71 00    OR    F,0           (0174) 
12A6: 80 12    JMP   0x12B9        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
12A8: 75       INC   X             (0179) 
12A9: 5A 07    MOV   [7],X         (0180) 
12AB: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
12AC: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
12AF: 70 3F    AND   F,63
12B1: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _INIT_RX_ISR
12B3: 54 48    MOV   [X+72],A      (0185) ;
12B5: 70 3F    AND   F,63
12B7: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
12B9: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
12BA: 60 D3    MOV   REG[211],A    (0191) _INIT_RX_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
12BC: 20       POP   X             (0195)    ; Insert your custom code below this banner
12BD: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
12BF: 43 E1 04 OR    REG[225],4    (0201)    ; Insert your custom code above this banner

FILE: lib\init_rx.asm
                                   (0121) ;;*****************************************************************************
12C2: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: INIT_RX.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "INIT_RX.inc"
12C3: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
12C6: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   INIT_RX_EnableInt
                                   (0155) export  _INIT_RX_EnableInt
                                   (0156) export   INIT_RX_DisableInt
                                   (0157) export  _INIT_RX_DisableInt
                                   (0158) export   INIT_RX_Start
                                   (0159) export  _INIT_RX_Start
                                   (0160) export   INIT_RX_Stop
                                   (0161) export  _INIT_RX_Stop
                                   (0162) export   INIT_RX_bReadRxData
                                   (0163) export  _INIT_RX_bReadRxData
                                   (0164) export   INIT_RX_bReadRxStatus
                                   (0165) export  _INIT_RX_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bINIT_RX_ReadRxData
                                   (0170) export _bINIT_RX_ReadRxData
                                   (0171) export  bINIT_RX_ReadRxStatus
                                   (0172) export _bINIT_RX_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  INIT_RX_cGetChar
12C7: 29 01    OR    A,1           (0179) export _INIT_RX_cGetChar
12C9: 60 2B    MOV   REG[43],A     (0180) export  INIT_RX_cReadChar
                                   (0181) export _INIT_RX_cReadChar
12CB: 7F       RET                 (0182) export  INIT_RX_iReadChar
                                   (0183) export _INIT_RX_iReadChar
                                   (0184) 
                                   (0185) IF (INIT_RX_RXBUF_ENABLE)
                                   (0186) export  INIT_RX_CmdReset
                                   (0187) export _INIT_RX_CmdReset
                                   (0188) export  INIT_RX_bCmdCheck
                                   (0189) export _INIT_RX_bCmdCheck
                                   (0190) export  INIT_RX_bCmdLength
                                   (0191) export _INIT_RX_bCmdLength
                                   (0192) export  INIT_RX_bErrCheck
                                   (0193) export _INIT_RX_bErrCheck
                                   (0194) 
                                   (0195) export  INIT_RX_szGetParam
                                   (0196) export _INIT_RX_szGetParam
                                   (0197) export  INIT_RX_szGetRestOfParams
                                   (0198) export _INIT_RX_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA INIT_RX_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
12CC: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
12CF: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: INIT_RX_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  INIT_RX_EnableInt:
                                   (0238) _INIT_RX_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
12D0: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask INIT_RX_INT_REG, INIT_RX_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
12D2: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: INIT_RX_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  INIT_RX_DisableInt:
                                   (0267) _INIT_RX_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask INIT_RX_INT_REG, INIT_RX_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
12D3: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
12D5: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: INIT_RX_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  INIT_RX_Start:
                                   (0297) _INIT_RX_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[INIT_RX_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: INIT_RX_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
12D6: 49 2B 08 TST   REG[43],8     (0311) ;
12D9: AF FC    JZ    0x12D6        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
12DB: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
12DD: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  INIT_RX_Stop:
                                   (0326) _INIT_RX_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[INIT_RX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: INIT_RX_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
12DE: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
12E0: 08       PUSH  A             (0347) ;
12E1: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
12E3: B0 04    JNZ   0x12E8        (0349) ;    The A and X registers may be modified by this or future implementations
12E5: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
12E6: 80 0B    JMP   0x12F2        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
12E8: 5D 2A    MOV   A,REG[42]     (0354) ;
12EA: 4B       SWAP  A,X           (0355)  INIT_RX_bReadRxData:
                                   (0356) _INIT_RX_bReadRxData:
12EB: 18       POP   A             (0357)  bINIT_RX_ReadRxData:
12EC: 21 A0    AND   A,160         (0358) _bINIT_RX_ReadRxData:
12EE: B0 03    JNZ   0x12F2        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
12F0: 4B       SWAP  A,X           (0360)    mov A, REG[INIT_RX_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
12F1: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
12F2: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: INIT_RX_bReadRxStatus
                                   (0368) ;
12F4: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  INIT_RX_bReadRxStatus:
                                   (0388) _INIT_RX_bReadRxStatus:
                                   (0389)  bINIT_RX_ReadRxStatus:
                                   (0390) _bINIT_RX_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[INIT_RX_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: INIT_RX_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
12F5: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
12F7: 21 E8    AND   A,232         (0408) ;
12F9: 08       PUSH  A             (0409) ;  ARGUMENTS:
12FA: 21 08    AND   A,8           (0410) ;      none
12FC: B0 07    JNZ   0x1304        (0411) ;
12FE: 18       POP   A             (0412) ;  RETURNS:
12FF: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1301: 4B       SWAP  A,X           (0414) ;
1302: 80 07    JMP   0x130A        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1304: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1305: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1307: 4B       SWAP  A,X           (0420) ;    functions.
1308: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
130A: 7F       RET                 (0426)  INIT_RX_cGetChar:
                                   (0427) _INIT_RX_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[INIT_RX_CONTROL_REG],INIT_RX_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[INIT_RX_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: INIT_RX_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  INIT_RX_cReadChar:
                                   (0463) _INIT_RX_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[INIT_RX_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,INIT_RX_RX_COMPLETE                              ; Check if a character is ready
130B: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
130E: 55 48 00 MOV   [72],0        (0470)    pop  A
1311: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1314: 55 DD 00 MOV   [221],0       (0472) 
1317: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
131A: 55 07 00 MOV   [7],0         (0474)    mov  A,REG[INIT_RX_RX_BUFFER_REG]                       ; Read data first, then
131D: 26 06 00 AND   [6],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1320: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(INIT_RX_RX_PARITY_ERROR | INIT_RX_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_INIT_RX_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: INIT_RX_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1321: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1324: 51 06    MOV   A,[6]         (0511) ;        0x40CC    Overrun Error
1326: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1328: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  INIT_RX_iReadChar:
                                   (0523) _INIT_RX_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[INIT_RX_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(INIT_RX_RX_ERROR|INIT_RX_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,INIT_RX_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,INIT_RX_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_INIT_RX_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,INIT_RX_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[INIT_RX_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_INIT_RX_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (INIT_RX_RXBUF_ENABLE)
                                   (0552) .SECTION
1329: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
132C: 51 06    MOV   A,[6]         (0554) ;-----------------------------------------------------------------------------
132E: 21 F0    AND   A,240         (0555) ;
1330: 26 06 0F AND   [6],15        (0556) ;     Command Buffer commands
                                   (0557) ;
1333: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: INIT_RX_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  INIT_RX_CmdReset:
1334: 62 D0 00 MOV   REG[208],0    (0587) _INIT_RX_CmdReset:
1337: 51 07    MOV   A,[7]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >INIT_RX_aRxBuffer
1339: 7F       RET                 (0590)    mov [INIT_RX_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >INIT_RX_bRxCnt
                                   (0594)    mov [INIT_RX_bRxCnt], 0x00
                                   (0595)    and [INIT_RX_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: INIT_RX_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  INIT_RX_bCmdCheck:
                                   (0628) _INIT_RX_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >INIT_RX_fStatus
                                   (0631)    mov A,  [INIT_RX_fStatus]
                                   (0632)    and A, INIT_RX_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: INIT_RX_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
133A: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
133C: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
133F: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1342: 50 48    MOV   A,72          (0648) ;     BYTE  fStatus - Status of command receive buffer.
1344: 02 DD    ADD   A,[221]       (0649) ;                     Returns non-zero value in A if command is valid.
1346: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1347: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1349: B0 04    JNZ   0x134E        (0653) ;           0x10 => Software Buffer OverRun
134B: 10       PUSH  X             (0654) ;
134C: 80 33    JMP   0x1380        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
134E: 39 00    CMP   A,0           (0660) ;    functions.
1350: B0 11    JNZ   0x1362        (0661) ;          
1352: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1353: 76 DD    INC   [221]         (0663) ;          CUR_PP
1355: 52 00    MOV   A,[X+0]       (0664) ;
1357: 3C DD 0F CMP   [221],15      (0665) ;     Error Status is clear when read.
135A: BF F3    JNZ   0x134E        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
135C: 10       PUSH  X             (0669) ;
                                   (0670)  INIT_RX_bErrCheck:
135D: 56 00 00 MOV   [X+0],0       (0671) _INIT_RX_bErrCheck:
1360: 80 1F    JMP   0x1380        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >INIT_RX_fStatus
                                   (0674)    mov A,  [INIT_RX_fStatus]
1362: 10       PUSH  X             (0675)    and A, INIT_RX_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [INIT_RX_fStatus], ~INIT_RX_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
1363: 75       INC   X             (0679) .ENDSECTION
1364: 76 DD    INC   [221]         (0680) 
1366: 3C DD 0F CMP   [221],15      (0681) .SECTION
1369: AF F3    JZ    0x135D        (0682) ;-----------------------------------------------------------------------------
136B: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: INIT_RX_bCmdLength
136D: A0 12    JZ    0x1380        (0684) ;
136F: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1371: BF F1    JNZ   0x1363        (0686) ;     Get length of command string
                                   (0687) ;
1373: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
1376: 76 DD    INC   [221]         (0689) ;     none.
1378: 3C DD 0F CMP   [221],15      (0690) ;
137B: B0 04    JNZ   0x1380        (0691) ;  RETURNS:
137D: 55 DD 0F MOV   [221],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1380: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1381: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
1382: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1385: B0 0B    JNZ   0x1391        (0699) ;    functions.
1387: 20       POP   X             (0700) ;          
1388: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
138A: 50 00    MOV   A,0           (0702) ;          CUR_PP
138C: 70 3F    AND   F,63
138E: 71 C0    OR    F,192         (0703) ;
                                   (0704)  INIT_RX_bCmdLength:
1390: 7F       RET                 (0705) _INIT_RX_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >INIT_RX_bRxCnt
1391: 20       POP   X             (0708)    mov A,  [INIT_RX_bRxCnt]
1392: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1394: 70 3F    AND   F,63
1396: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1398: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: INIT_RX_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1399: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
139C: 50 48    MOV   A,72          (0744) ;     each lexically distinct element into a null-terminated string by replacing
139E: 02 DD    ADD   A,[221]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
13A0: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
13A1: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     INIT_RX_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, INIT_RX_szGetParam, is
13A4: 43 E1 02 OR    REG[225],2    (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\hello_timeout.asm
                                   (0102) ;;*****************************************************************************
13A7: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: HELLO_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "HELLO_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
13A8: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
13AB: 7F       RET                 (0131) export  HELLO_TIMEOUT_EnableInt
                                   (0132) export _HELLO_TIMEOUT_EnableInt
                                   (0133) export  HELLO_TIMEOUT_DisableInt
                                   (0134) export _HELLO_TIMEOUT_DisableInt
                                   (0135) export  HELLO_TIMEOUT_Start
                                   (0136) export _HELLO_TIMEOUT_Start
                                   (0137) export  HELLO_TIMEOUT_Stop
                                   (0138) export _HELLO_TIMEOUT_Stop
                                   (0139) export  HELLO_TIMEOUT_WritePeriod
                                   (0140) export _HELLO_TIMEOUT_WritePeriod
                                   (0141) export  HELLO_TIMEOUT_WriteCompareValue
                                   (0142) export _HELLO_TIMEOUT_WriteCompareValue
                                   (0143) export  HELLO_TIMEOUT_wReadCompareValue
                                   (0144) export _HELLO_TIMEOUT_wReadCompareValue
                                   (0145) export  HELLO_TIMEOUT_wReadTimer
                                   (0146) export _HELLO_TIMEOUT_wReadTimer
                                   (0147) export  HELLO_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _HELLO_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wHELLO_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wHELLO_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wHELLO_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wHELLO_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wHELLO_TIMEOUT_ReadTimerSaveCV   ; deprecated
13AC: 43 23 01 OR    REG[35],1     (0157) export _wHELLO_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
13AF: 7F       RET                 (0159) export  wHELLO_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wHELLO_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wHELLO_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wHELLO_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA hello_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: HELLO_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
13B0: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
13B3: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  HELLO_TIMEOUT_EnableInt:
                                   (0200) _HELLO_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    HELLO_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: HELLO_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
13B4: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
13B6: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
13B7: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
13B9: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  HELLO_TIMEOUT_DisableInt:
                                   (0228) _HELLO_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    HELLO_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: HELLO_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
13BA: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
13BC: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
13BD: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
13BF: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  HELLO_TIMEOUT_Start:
                                   (0256) _HELLO_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    HELLO_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: HELLO_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
13C0: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
13C2: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
13C3: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
13C5: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  HELLO_TIMEOUT_Stop:
                                   (0284) _HELLO_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    HELLO_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: HELLO_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  HELLO_TIMEOUT_WritePeriod:
                                   (0313) _HELLO_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[HELLO_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[HELLO_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: HELLO_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call HELLO_TIMEOUT_Stop to disable).
13C6: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
13C7: 38 03    ADD   SP,3          (0334) ;
13C9: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
13CB: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
13CC: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
13CE: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
13CF: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
13D1: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
13D2: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
13D4: 5D 26    MOV   A,REG[38]     (0343) ;
13D6: 54 01    MOV   [X+1],A       (0344)  HELLO_TIMEOUT_WriteCompareValue:
13D8: 5D 22    MOV   A,REG[34]     (0345) _HELLO_TIMEOUT_WriteCompareValue:
13DA: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
13DC: 50 00    MOV   A,0           (0347)    mov   reg[HELLO_TIMEOUT_COMPARE_LSB_REG], A
13DE: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
13E1: A0 03    JZ    0x13E5        (0349)    mov   reg[HELLO_TIMEOUT_COMPARE_MSB_REG], A
13E3: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
13E5: 54 00    MOV   [X+0],A       (0352) 
13E7: 70 FE    AND   F,254         (0353) .ENDSECTION
13E9: 41 23 FE AND   REG[35],254   (0354) 
13EC: 18       POP   A             (0355) 
13ED: 60 26    MOV   REG[38],A     (0356) .SECTION
13EF: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
13F0: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: HELLO_TIMEOUT_wReadCompareValue
13F2: 18       POP   A             (0359) ;
13F3: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
13F5: 18       POP   A             (0361) ;     Reads the Compare registers.
13F6: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
13F7: 70 3F    AND   F,63
13F9: 71 C0    OR    F,192         (0363) ;
13FB: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  HELLO_TIMEOUT_wReadCompareValue:
                                   (0374) _HELLO_TIMEOUT_wReadCompareValue:
                                   (0375)  wHELLO_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wHELLO_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[HELLO_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[HELLO_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: HELLO_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
13FC: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
13FE: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
1400: 5C       MOV   X,A           (0409) ;
1401: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
1404: 08       PUSH  A             (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\hello_4int.asm
1405: 10       PUSH  X             (0104) ;;*****************************************************************************
1406: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: HELLO_4INT.asm
1408: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1409: 58 09    MOV   X,[9]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
140B: 5D 3F    MOV   A,REG[63]     (0111) ;;-----------------------------------------------------------------------------
140D: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
140E: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1410: B0 04    JNZ   0x1415        (0115) 
1412: 18       POP   A             (0116) include "m8c.inc"
1413: 80 5E    JMP   0x1472        (0117) include "memory.inc"
                                   (0118) include "HELLO_4.inc"
                                   (0119) 
                                   (0120) 
1415: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1416: 21 E0    AND   A,224         (0124) export  _HELLO_4_ISR
1418: A0 12    JZ    0x142B        (0125) 
                                   (0126) 
141A: 2C 08    OR    [8],A         (0127) IF (HELLO_4_RXBUF_ENABLE)
                                   (0128) export  HELLO_4_aRxBuffer
141C: 49 3E 00 TST   REG[62],0     (0129) export _HELLO_4_aRxBuffer
                                   (0130) export  HELLO_4_bRxCnt
141F: 21 20    AND   A,32          (0131) export _HELLO_4_bRxCnt
1421: A0 50    JZ    0x1472        (0132) export  HELLO_4_fStatus
                                   (0133) export _HELLO_4_fStatus
                                   (0134) ENDIF
                                   (0135) 
1423: 41 3F FE AND   REG[63],254   (0136) 
1426: 43 3F 01 OR    REG[63],1     (0137) ;-----------------------------------------------
1429: 80 48    JMP   0x1472        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (HELLO_4_RXBUF_ENABLE)
142B: 5D 3E    MOV   A,REG[62]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  HELLO_4_fStatus:
                                   (0144) _HELLO_4_fStatus:      BLK  1
142D: 47 08 01 TST   [8],1         (0145)  HELLO_4_bRxCnt:
1430: B0 41    JNZ   0x1472        (0146) _HELLO_4_bRxCnt:       BLK  1
                                   (0147) AREA HELLO_4_RAM(RAM,REL,CON)
1432: 39 00    CMP   A,0           (0148)  HELLO_4_aRxBuffer:    
1434: B0 14    JNZ   0x1449        (0149) _HELLO_4_aRxBuffer:    BLK HELLO_4_RX_BUFFER_SIZE
1436: 2E 08 01 OR    [8],1         (0150) ENDIF
                                   (0151) 
1439: 62 D3 00 MOV   REG[211],0    (0152) 
143C: 70 3F    AND   F,63
143E: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1440: 56 18 00 MOV   [X+24],0      (0154) 
1443: 70 3F    AND   F,63
1445: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
1447: 80 2A    JMP   0x1472        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1449: 3C 09 0F CMP   [9],15        (0167) ;------------------------
144C: C0 14    JC    0x1461        (0168) 
144E: 2E 08 10 OR    [8],16        (0169) 
                                   (0170) ;------------------------
1451: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
1454: 70 3F    AND   F,63
1456: 71 80    OR    F,128         (0172) ;------------------------
1458: 56 18 00 MOV   [X+24],0      (0173) 
145B: 70 3F    AND   F,63
145D: 71 00    OR    F,0           (0174) 
145F: 80 12    JMP   0x1472        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1461: 75       INC   X             (0179) 
1462: 5A 09    MOV   [9],X         (0180) 
1464: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1465: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1468: 70 3F    AND   F,63
146A: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _HELLO_4_ISR
146C: 54 18    MOV   [X+24],A      (0185) ;
146E: 70 3F    AND   F,63
1470: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1472: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1473: 60 D3    MOV   REG[211],A    (0191) _HELLO_4_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1475: 20       POP   X             (0195)    ; Insert your custom code below this banner
1476: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1478: 43 E1 80 OR    REG[225],128  (0201)    ; Insert your custom code above this banner

FILE: lib\hello_4.asm
                                   (0121) ;;*****************************************************************************
147B: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: HELLO_4.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "HELLO_4.inc"
147C: 41 E1 7F AND   REG[225],127  (0149) 
                                   (0150) 
147F: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   HELLO_4_EnableInt
                                   (0155) export  _HELLO_4_EnableInt
                                   (0156) export   HELLO_4_DisableInt
                                   (0157) export  _HELLO_4_DisableInt
                                   (0158) export   HELLO_4_Start
                                   (0159) export  _HELLO_4_Start
                                   (0160) export   HELLO_4_Stop
                                   (0161) export  _HELLO_4_Stop
                                   (0162) export   HELLO_4_bReadRxData
                                   (0163) export  _HELLO_4_bReadRxData
                                   (0164) export   HELLO_4_bReadRxStatus
                                   (0165) export  _HELLO_4_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bHELLO_4_ReadRxData
                                   (0170) export _bHELLO_4_ReadRxData
                                   (0171) export  bHELLO_4_ReadRxStatus
                                   (0172) export _bHELLO_4_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  HELLO_4_cGetChar
1480: 29 01    OR    A,1           (0179) export _HELLO_4_cGetChar
1482: 60 3F    MOV   REG[63],A     (0180) export  HELLO_4_cReadChar
                                   (0181) export _HELLO_4_cReadChar
1484: 7F       RET                 (0182) export  HELLO_4_iReadChar
                                   (0183) export _HELLO_4_iReadChar
                                   (0184) 
                                   (0185) IF (HELLO_4_RXBUF_ENABLE)
                                   (0186) export  HELLO_4_CmdReset
                                   (0187) export _HELLO_4_CmdReset
                                   (0188) export  HELLO_4_bCmdCheck
                                   (0189) export _HELLO_4_bCmdCheck
                                   (0190) export  HELLO_4_bCmdLength
                                   (0191) export _HELLO_4_bCmdLength
                                   (0192) export  HELLO_4_bErrCheck
                                   (0193) export _HELLO_4_bErrCheck
                                   (0194) 
                                   (0195) export  HELLO_4_szGetParam
                                   (0196) export _HELLO_4_szGetParam
                                   (0197) export  HELLO_4_szGetRestOfParams
                                   (0198) export _HELLO_4_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA HELLO_4_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1485: 41 3F FE AND   REG[63],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1488: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: HELLO_4_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  HELLO_4_EnableInt:
                                   (0238) _HELLO_4_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1489: 5D 3E    MOV   A,REG[62]     (0240)    M8C_EnableIntMask HELLO_4_INT_REG, HELLO_4_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
148B: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: HELLO_4_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  HELLO_4_DisableInt:
                                   (0267) _HELLO_4_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask HELLO_4_INT_REG, HELLO_4_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
148C: 5D 3F    MOV   A,REG[63]     (0272) .ENDSECTION
                                   (0273) 
148E: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: HELLO_4_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  HELLO_4_Start:
                                   (0297) _HELLO_4_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[HELLO_4_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: HELLO_4_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
148F: 49 3F 08 TST   REG[63],8     (0311) ;
1492: AF FC    JZ    0x148F        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1494: 5D 3E    MOV   A,REG[62]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1496: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  HELLO_4_Stop:
                                   (0326) _HELLO_4_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[HELLO_4_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: HELLO_4_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1497: 5D 3F    MOV   A,REG[63]     (0346) ;    bRxData - returned in A.
1499: 08       PUSH  A             (0347) ;
149A: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
149C: B0 04    JNZ   0x14A1        (0349) ;    The A and X registers may be modified by this or future implementations
149E: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
149F: 80 0B    JMP   0x14AB        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
14A1: 5D 3E    MOV   A,REG[62]     (0354) ;
14A3: 4B       SWAP  A,X           (0355)  HELLO_4_bReadRxData:
                                   (0356) _HELLO_4_bReadRxData:
14A4: 18       POP   A             (0357)  bHELLO_4_ReadRxData:
14A5: 21 A0    AND   A,160         (0358) _bHELLO_4_ReadRxData:
14A7: B0 03    JNZ   0x14AB        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
14A9: 4B       SWAP  A,X           (0360)    mov A, REG[HELLO_4_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
14AA: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
14AB: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: HELLO_4_bReadRxStatus
                                   (0368) ;
14AD: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  HELLO_4_bReadRxStatus:
                                   (0388) _HELLO_4_bReadRxStatus:
                                   (0389)  bHELLO_4_ReadRxStatus:
                                   (0390) _bHELLO_4_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[HELLO_4_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: HELLO_4_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
14AE: 5D 3F    MOV   A,REG[63]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
14B0: 21 E8    AND   A,232         (0408) ;
14B2: 08       PUSH  A             (0409) ;  ARGUMENTS:
14B3: 21 08    AND   A,8           (0410) ;      none
14B5: B0 07    JNZ   0x14BD        (0411) ;
14B7: 18       POP   A             (0412) ;  RETURNS:
14B8: 29 01    OR    A,1           (0413) ;     char that is returned from UART
14BA: 4B       SWAP  A,X           (0414) ;
14BB: 80 07    JMP   0x14C3        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
14BD: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
14BE: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
14C0: 4B       SWAP  A,X           (0420) ;    functions.
14C1: 5D 3E    MOV   A,REG[62]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
14C3: 7F       RET                 (0426)  HELLO_4_cGetChar:
                                   (0427) _HELLO_4_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[HELLO_4_CONTROL_REG],HELLO_4_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[HELLO_4_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: HELLO_4_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  HELLO_4_cReadChar:
                                   (0463) _HELLO_4_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[HELLO_4_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,HELLO_4_RX_COMPLETE                              ; Check if a character is ready
14C4: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
14C7: 55 18 00 MOV   [24],0        (0470)    pop  A
14CA: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
14CD: 55 DC 00 MOV   [220],0       (0472) 
14D0: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
14D3: 55 09 00 MOV   [9],0         (0474)    mov  A,REG[HELLO_4_RX_BUFFER_REG]                       ; Read data first, then
14D6: 26 08 00 AND   [8],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
14D9: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(HELLO_4_RX_PARITY_ERROR | HELLO_4_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_HELLO_4_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: HELLO_4_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
14DA: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
14DD: 51 08    MOV   A,[8]         (0511) ;        0x40CC    Overrun Error
14DF: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
14E1: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  HELLO_4_iReadChar:
                                   (0523) _HELLO_4_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[HELLO_4_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(HELLO_4_RX_ERROR|HELLO_4_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,HELLO_4_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,HELLO_4_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_HELLO_4_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,HELLO_4_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[HELLO_4_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_HELLO_4_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (HELLO_4_RXBUF_ENABLE)
                                   (0552) .SECTION
14E2: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
14E5: 51 08    MOV   A,[8]         (0554) ;-----------------------------------------------------------------------------
14E7: 21 F0    AND   A,240         (0555) ;
14E9: 26 08 0F AND   [8],15        (0556) ;     Command Buffer commands
                                   (0557) ;
14EC: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: HELLO_4_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  HELLO_4_CmdReset:
14ED: 62 D0 00 MOV   REG[208],0    (0587) _HELLO_4_CmdReset:
14F0: 51 09    MOV   A,[9]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >HELLO_4_aRxBuffer
14F2: 7F       RET                 (0590)    mov [HELLO_4_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >HELLO_4_bRxCnt
                                   (0594)    mov [HELLO_4_bRxCnt], 0x00
                                   (0595)    and [HELLO_4_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: HELLO_4_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  HELLO_4_bCmdCheck:
                                   (0628) _HELLO_4_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >HELLO_4_fStatus
                                   (0631)    mov A,  [HELLO_4_fStatus]
                                   (0632)    and A, HELLO_4_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: HELLO_4_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
14F3: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
14F5: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
14F8: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
14FB: 50 18    MOV   A,24          (0648) ;     BYTE  fStatus - Status of command receive buffer.
14FD: 02 DC    ADD   A,[220]       (0649) ;                     Returns non-zero value in A if command is valid.
14FF: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1500: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1502: B0 04    JNZ   0x1507        (0653) ;           0x10 => Software Buffer OverRun
1504: 10       PUSH  X             (0654) ;
1505: 80 33    JMP   0x1539        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1507: 39 00    CMP   A,0           (0660) ;    functions.
1509: B0 11    JNZ   0x151B        (0661) ;          
150B: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
150C: 76 DC    INC   [220]         (0663) ;          CUR_PP
150E: 52 00    MOV   A,[X+0]       (0664) ;
1510: 3C DC 0F CMP   [220],15      (0665) ;     Error Status is clear when read.
1513: BF F3    JNZ   0x1507        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
1515: 10       PUSH  X             (0669) ;
                                   (0670)  HELLO_4_bErrCheck:
1516: 56 00 00 MOV   [X+0],0       (0671) _HELLO_4_bErrCheck:
1519: 80 1F    JMP   0x1539        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >HELLO_4_fStatus
                                   (0674)    mov A,  [HELLO_4_fStatus]
151B: 10       PUSH  X             (0675)    and A, HELLO_4_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [HELLO_4_fStatus], ~HELLO_4_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
151C: 75       INC   X             (0679) .ENDSECTION
151D: 76 DC    INC   [220]         (0680) 
151F: 3C DC 0F CMP   [220],15      (0681) .SECTION
1522: AF F3    JZ    0x1516        (0682) ;-----------------------------------------------------------------------------
1524: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: HELLO_4_bCmdLength
1526: A0 12    JZ    0x1539        (0684) ;
1528: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
152A: BF F1    JNZ   0x151C        (0686) ;     Get length of command string
                                   (0687) ;
152C: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
152F: 76 DC    INC   [220]         (0689) ;     none.
1531: 3C DC 0F CMP   [220],15      (0690) ;
1534: B0 04    JNZ   0x1539        (0691) ;  RETURNS:
1536: 55 DC 0F MOV   [220],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1539: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
153A: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
153B: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
153E: B0 0B    JNZ   0x154A        (0699) ;    functions.
1540: 20       POP   X             (0700) ;          
1541: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
1543: 50 00    MOV   A,0           (0702) ;          CUR_PP
1545: 70 3F    AND   F,63
1547: 71 C0    OR    F,192         (0703) ;
                                   (0704)  HELLO_4_bCmdLength:
1549: 7F       RET                 (0705) _HELLO_4_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >HELLO_4_bRxCnt
154A: 20       POP   X             (0708)    mov A,  [HELLO_4_bRxCnt]
154B: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
154D: 70 3F    AND   F,63
154F: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1551: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: HELLO_4_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1552: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1555: 50 18    MOV   A,24          (0744) ;     each lexically distinct element into a null-terminated string by replacing
1557: 02 DC    ADD   A,[220]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
1559: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
155A: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     HELLO_4_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, HELLO_4_szGetParam, is
155D: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\hello_3int.asm
155E: 10       PUSH  X             (0104) ;;*****************************************************************************
155F: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: HELLO_3INT.asm
1561: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1562: 58 0B    MOV   X,[11]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1564: 5D 3B    MOV   A,REG[59]     (0111) ;;-----------------------------------------------------------------------------
1566: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1567: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1569: B0 04    JNZ   0x156E        (0115) 
156B: 18       POP   A             (0116) include "m8c.inc"
156C: 80 5E    JMP   0x15CB        (0117) include "memory.inc"
                                   (0118) include "HELLO_3.inc"
                                   (0119) 
                                   (0120) 
156E: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
156F: 21 E0    AND   A,224         (0124) export  _HELLO_3_ISR
1571: A0 12    JZ    0x1584        (0125) 
                                   (0126) 
1573: 2C 0A    OR    [10],A        (0127) IF (HELLO_3_RXBUF_ENABLE)
                                   (0128) export  HELLO_3_aRxBuffer
1575: 49 3A 00 TST   REG[58],0     (0129) export _HELLO_3_aRxBuffer
                                   (0130) export  HELLO_3_bRxCnt
1578: 21 20    AND   A,32          (0131) export _HELLO_3_bRxCnt
157A: A0 50    JZ    0x15CB        (0132) export  HELLO_3_fStatus
                                   (0133) export _HELLO_3_fStatus
                                   (0134) ENDIF
                                   (0135) 
157C: 41 3B FE AND   REG[59],254   (0136) 
157F: 43 3B 01 OR    REG[59],1     (0137) ;-----------------------------------------------
1582: 80 48    JMP   0x15CB        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (HELLO_3_RXBUF_ENABLE)
1584: 5D 3A    MOV   A,REG[58]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  HELLO_3_fStatus:
                                   (0144) _HELLO_3_fStatus:      BLK  1
1586: 47 0A 01 TST   [10],1        (0145)  HELLO_3_bRxCnt:
1589: B0 41    JNZ   0x15CB        (0146) _HELLO_3_bRxCnt:       BLK  1
                                   (0147) AREA HELLO_3_RAM(RAM,REL,CON)
158B: 39 00    CMP   A,0           (0148)  HELLO_3_aRxBuffer:    
158D: B0 14    JNZ   0x15A2        (0149) _HELLO_3_aRxBuffer:    BLK HELLO_3_RX_BUFFER_SIZE
158F: 2E 0A 01 OR    [10],1        (0150) ENDIF
                                   (0151) 
1592: 62 D3 00 MOV   REG[211],0    (0152) 
1595: 70 3F    AND   F,63
1597: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1599: 56 28 00 MOV   [X+40],0      (0154) 
159C: 70 3F    AND   F,63
159E: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
15A0: 80 2A    JMP   0x15CB        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
15A2: 3C 0B 0F CMP   [11],15       (0167) ;------------------------
15A5: C0 14    JC    0x15BA        (0168) 
15A7: 2E 0A 10 OR    [10],16       (0169) 
                                   (0170) ;------------------------
15AA: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
15AD: 70 3F    AND   F,63
15AF: 71 80    OR    F,128         (0172) ;------------------------
15B1: 56 28 00 MOV   [X+40],0      (0173) 
15B4: 70 3F    AND   F,63
15B6: 71 00    OR    F,0           (0174) 
15B8: 80 12    JMP   0x15CB        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
15BA: 75       INC   X             (0179) 
15BB: 5A 0B    MOV   [11],X        (0180) 
15BD: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
15BE: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
15C1: 70 3F    AND   F,63
15C3: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _HELLO_3_ISR
15C5: 54 28    MOV   [X+40],A      (0185) ;
15C7: 70 3F    AND   F,63
15C9: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
15CB: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
15CC: 60 D3    MOV   REG[211],A    (0191) _HELLO_3_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
15CE: 20       POP   X             (0195)    ; Insert your custom code below this banner
15CF: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
15D1: 43 E1 40 OR    REG[225],64   (0201)    ; Insert your custom code above this banner

FILE: lib\hello_3.asm
                                   (0121) ;;*****************************************************************************
15D4: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: HELLO_3.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "HELLO_3.inc"
15D5: 41 E1 BF AND   REG[225],191  (0149) 
                                   (0150) 
15D8: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   HELLO_3_EnableInt
                                   (0155) export  _HELLO_3_EnableInt
                                   (0156) export   HELLO_3_DisableInt
                                   (0157) export  _HELLO_3_DisableInt
                                   (0158) export   HELLO_3_Start
                                   (0159) export  _HELLO_3_Start
                                   (0160) export   HELLO_3_Stop
                                   (0161) export  _HELLO_3_Stop
                                   (0162) export   HELLO_3_bReadRxData
                                   (0163) export  _HELLO_3_bReadRxData
                                   (0164) export   HELLO_3_bReadRxStatus
                                   (0165) export  _HELLO_3_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bHELLO_3_ReadRxData
                                   (0170) export _bHELLO_3_ReadRxData
                                   (0171) export  bHELLO_3_ReadRxStatus
                                   (0172) export _bHELLO_3_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  HELLO_3_cGetChar
15D9: 29 01    OR    A,1           (0179) export _HELLO_3_cGetChar
15DB: 60 3B    MOV   REG[59],A     (0180) export  HELLO_3_cReadChar
                                   (0181) export _HELLO_3_cReadChar
15DD: 7F       RET                 (0182) export  HELLO_3_iReadChar
                                   (0183) export _HELLO_3_iReadChar
                                   (0184) 
                                   (0185) IF (HELLO_3_RXBUF_ENABLE)
                                   (0186) export  HELLO_3_CmdReset
                                   (0187) export _HELLO_3_CmdReset
                                   (0188) export  HELLO_3_bCmdCheck
                                   (0189) export _HELLO_3_bCmdCheck
                                   (0190) export  HELLO_3_bCmdLength
                                   (0191) export _HELLO_3_bCmdLength
                                   (0192) export  HELLO_3_bErrCheck
                                   (0193) export _HELLO_3_bErrCheck
                                   (0194) 
                                   (0195) export  HELLO_3_szGetParam
                                   (0196) export _HELLO_3_szGetParam
                                   (0197) export  HELLO_3_szGetRestOfParams
                                   (0198) export _HELLO_3_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA HELLO_3_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
15DE: 41 3B FE AND   REG[59],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
15E1: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: HELLO_3_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  HELLO_3_EnableInt:
                                   (0238) _HELLO_3_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
15E2: 5D 3A    MOV   A,REG[58]     (0240)    M8C_EnableIntMask HELLO_3_INT_REG, HELLO_3_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
15E4: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: HELLO_3_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  HELLO_3_DisableInt:
                                   (0267) _HELLO_3_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask HELLO_3_INT_REG, HELLO_3_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
15E5: 5D 3B    MOV   A,REG[59]     (0272) .ENDSECTION
                                   (0273) 
15E7: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: HELLO_3_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  HELLO_3_Start:
                                   (0297) _HELLO_3_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[HELLO_3_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: HELLO_3_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
15E8: 49 3B 08 TST   REG[59],8     (0311) ;
15EB: AF FC    JZ    0x15E8        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
15ED: 5D 3A    MOV   A,REG[58]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
15EF: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  HELLO_3_Stop:
                                   (0326) _HELLO_3_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[HELLO_3_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: HELLO_3_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
15F0: 5D 3B    MOV   A,REG[59]     (0346) ;    bRxData - returned in A.
15F2: 08       PUSH  A             (0347) ;
15F3: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
15F5: B0 04    JNZ   0x15FA        (0349) ;    The A and X registers may be modified by this or future implementations
15F7: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
15F8: 80 0B    JMP   0x1604        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
15FA: 5D 3A    MOV   A,REG[58]     (0354) ;
15FC: 4B       SWAP  A,X           (0355)  HELLO_3_bReadRxData:
                                   (0356) _HELLO_3_bReadRxData:
15FD: 18       POP   A             (0357)  bHELLO_3_ReadRxData:
15FE: 21 A0    AND   A,160         (0358) _bHELLO_3_ReadRxData:
1600: B0 03    JNZ   0x1604        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1602: 4B       SWAP  A,X           (0360)    mov A, REG[HELLO_3_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1603: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1604: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: HELLO_3_bReadRxStatus
                                   (0368) ;
1606: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  HELLO_3_bReadRxStatus:
                                   (0388) _HELLO_3_bReadRxStatus:
                                   (0389)  bHELLO_3_ReadRxStatus:
                                   (0390) _bHELLO_3_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[HELLO_3_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: HELLO_3_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1607: 5D 3B    MOV   A,REG[59]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1609: 21 E8    AND   A,232         (0408) ;
160B: 08       PUSH  A             (0409) ;  ARGUMENTS:
160C: 21 08    AND   A,8           (0410) ;      none
160E: B0 07    JNZ   0x1616        (0411) ;
1610: 18       POP   A             (0412) ;  RETURNS:
1611: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1613: 4B       SWAP  A,X           (0414) ;
1614: 80 07    JMP   0x161C        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1616: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1617: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1619: 4B       SWAP  A,X           (0420) ;    functions.
161A: 5D 3A    MOV   A,REG[58]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
161C: 7F       RET                 (0426)  HELLO_3_cGetChar:
                                   (0427) _HELLO_3_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[HELLO_3_CONTROL_REG],HELLO_3_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[HELLO_3_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: HELLO_3_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  HELLO_3_cReadChar:
                                   (0463) _HELLO_3_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[HELLO_3_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,HELLO_3_RX_COMPLETE                              ; Check if a character is ready
161D: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1620: 55 28 00 MOV   [40],0        (0470)    pop  A
1623: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1626: 55 DB 00 MOV   [219],0       (0472) 
1629: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
162C: 55 0B 00 MOV   [11],0        (0474)    mov  A,REG[HELLO_3_RX_BUFFER_REG]                       ; Read data first, then
162F: 26 0A 00 AND   [10],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1632: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(HELLO_3_RX_PARITY_ERROR | HELLO_3_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_HELLO_3_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: HELLO_3_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1633: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1636: 51 0A    MOV   A,[10]        (0511) ;        0x40CC    Overrun Error
1638: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
163A: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  HELLO_3_iReadChar:
                                   (0523) _HELLO_3_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[HELLO_3_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(HELLO_3_RX_ERROR|HELLO_3_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,HELLO_3_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,HELLO_3_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_HELLO_3_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,HELLO_3_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[HELLO_3_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_HELLO_3_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (HELLO_3_RXBUF_ENABLE)
                                   (0552) .SECTION
163B: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
163E: 51 0A    MOV   A,[10]        (0554) ;-----------------------------------------------------------------------------
1640: 21 F0    AND   A,240         (0555) ;
1642: 26 0A 0F AND   [10],15       (0556) ;     Command Buffer commands
                                   (0557) ;
1645: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: HELLO_3_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  HELLO_3_CmdReset:
1646: 62 D0 00 MOV   REG[208],0    (0587) _HELLO_3_CmdReset:
1649: 51 0B    MOV   A,[11]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >HELLO_3_aRxBuffer
164B: 7F       RET                 (0590)    mov [HELLO_3_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >HELLO_3_bRxCnt
                                   (0594)    mov [HELLO_3_bRxCnt], 0x00
                                   (0595)    and [HELLO_3_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: HELLO_3_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  HELLO_3_bCmdCheck:
                                   (0628) _HELLO_3_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >HELLO_3_fStatus
                                   (0631)    mov A,  [HELLO_3_fStatus]
                                   (0632)    and A, HELLO_3_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: HELLO_3_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
164C: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
164E: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1651: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1654: 50 28    MOV   A,40          (0648) ;     BYTE  fStatus - Status of command receive buffer.
1656: 02 DB    ADD   A,[219]       (0649) ;                     Returns non-zero value in A if command is valid.
1658: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1659: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
165B: B0 04    JNZ   0x1660        (0653) ;           0x10 => Software Buffer OverRun
165D: 10       PUSH  X             (0654) ;
165E: 80 33    JMP   0x1692        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1660: 39 00    CMP   A,0           (0660) ;    functions.
1662: B0 11    JNZ   0x1674        (0661) ;          
1664: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1665: 76 DB    INC   [219]         (0663) ;          CUR_PP
1667: 52 00    MOV   A,[X+0]       (0664) ;
1669: 3C DB 0F CMP   [219],15      (0665) ;     Error Status is clear when read.
166C: BF F3    JNZ   0x1660        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
166E: 10       PUSH  X             (0669) ;
                                   (0670)  HELLO_3_bErrCheck:
166F: 56 00 00 MOV   [X+0],0       (0671) _HELLO_3_bErrCheck:
1672: 80 1F    JMP   0x1692        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >HELLO_3_fStatus
                                   (0674)    mov A,  [HELLO_3_fStatus]
1674: 10       PUSH  X             (0675)    and A, HELLO_3_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [HELLO_3_fStatus], ~HELLO_3_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
1675: 75       INC   X             (0679) .ENDSECTION
1676: 76 DB    INC   [219]         (0680) 
1678: 3C DB 0F CMP   [219],15      (0681) .SECTION
167B: AF F3    JZ    0x166F        (0682) ;-----------------------------------------------------------------------------
167D: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: HELLO_3_bCmdLength
167F: A0 12    JZ    0x1692        (0684) ;
1681: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1683: BF F1    JNZ   0x1675        (0686) ;     Get length of command string
                                   (0687) ;
1685: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
1688: 76 DB    INC   [219]         (0689) ;     none.
168A: 3C DB 0F CMP   [219],15      (0690) ;
168D: B0 04    JNZ   0x1692        (0691) ;  RETURNS:
168F: 55 DB 0F MOV   [219],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1692: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1693: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
1694: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1697: B0 0B    JNZ   0x16A3        (0699) ;    functions.
1699: 20       POP   X             (0700) ;          
169A: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
169C: 50 00    MOV   A,0           (0702) ;          CUR_PP
169E: 70 3F    AND   F,63
16A0: 71 C0    OR    F,192         (0703) ;
                                   (0704)  HELLO_3_bCmdLength:
16A2: 7F       RET                 (0705) _HELLO_3_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >HELLO_3_bRxCnt
16A3: 20       POP   X             (0708)    mov A,  [HELLO_3_bRxCnt]
16A4: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
16A6: 70 3F    AND   F,63
16A8: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
16AA: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: HELLO_3_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
16AB: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
16AE: 50 28    MOV   A,40          (0744) ;     each lexically distinct element into a null-terminated string by replacing
16B0: 02 DB    ADD   A,[219]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
16B2: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
16B3: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     HELLO_3_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, HELLO_3_szGetParam, is
16B6: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\hello_2int.asm
16B7: 10       PUSH  X             (0104) ;;*****************************************************************************
16B8: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: HELLO_2INT.asm
16BA: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
16BB: 58 0D    MOV   X,[13]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
16BD: 5D 2F    MOV   A,REG[47]     (0111) ;;-----------------------------------------------------------------------------
16BF: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
16C0: 21 08    AND   A,8           (0114) ;;*****************************************************************************
16C2: B0 04    JNZ   0x16C7        (0115) 
16C4: 18       POP   A             (0116) include "m8c.inc"
16C5: 80 5E    JMP   0x1724        (0117) include "memory.inc"
                                   (0118) include "HELLO_2.inc"
                                   (0119) 
                                   (0120) 
16C7: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
16C8: 21 E0    AND   A,224         (0124) export  _HELLO_2_ISR
16CA: A0 12    JZ    0x16DD        (0125) 
                                   (0126) 
16CC: 2C 0C    OR    [12],A        (0127) IF (HELLO_2_RXBUF_ENABLE)
                                   (0128) export  HELLO_2_aRxBuffer
16CE: 49 2E 00 TST   REG[46],0     (0129) export _HELLO_2_aRxBuffer
                                   (0130) export  HELLO_2_bRxCnt
16D1: 21 20    AND   A,32          (0131) export _HELLO_2_bRxCnt
16D3: A0 50    JZ    0x1724        (0132) export  HELLO_2_fStatus
                                   (0133) export _HELLO_2_fStatus
                                   (0134) ENDIF
                                   (0135) 
16D5: 41 2F FE AND   REG[47],254   (0136) 
16D8: 43 2F 01 OR    REG[47],1     (0137) ;-----------------------------------------------
16DB: 80 48    JMP   0x1724        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (HELLO_2_RXBUF_ENABLE)
16DD: 5D 2E    MOV   A,REG[46]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  HELLO_2_fStatus:
                                   (0144) _HELLO_2_fStatus:      BLK  1
16DF: 47 0C 01 TST   [12],1        (0145)  HELLO_2_bRxCnt:
16E2: B0 41    JNZ   0x1724        (0146) _HELLO_2_bRxCnt:       BLK  1
                                   (0147) AREA HELLO_2_RAM(RAM,REL,CON)
16E4: 39 00    CMP   A,0           (0148)  HELLO_2_aRxBuffer:    
16E6: B0 14    JNZ   0x16FB        (0149) _HELLO_2_aRxBuffer:    BLK HELLO_2_RX_BUFFER_SIZE
16E8: 2E 0C 01 OR    [12],1        (0150) ENDIF
                                   (0151) 
16EB: 62 D3 00 MOV   REG[211],0    (0152) 
16EE: 70 3F    AND   F,63
16F0: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
16F2: 56 B8 00 MOV   [X-72],0      (0154) 
16F5: 70 3F    AND   F,63
16F7: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
16F9: 80 2A    JMP   0x1724        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
16FB: 3C 0D 0F CMP   [13],15       (0167) ;------------------------
16FE: C0 14    JC    0x1713        (0168) 
1700: 2E 0C 10 OR    [12],16       (0169) 
                                   (0170) ;------------------------
1703: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
1706: 70 3F    AND   F,63
1708: 71 80    OR    F,128         (0172) ;------------------------
170A: 56 B8 00 MOV   [X-72],0      (0173) 
170D: 70 3F    AND   F,63
170F: 71 00    OR    F,0           (0174) 
1711: 80 12    JMP   0x1724        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1713: 75       INC   X             (0179) 
1714: 5A 0D    MOV   [13],X        (0180) 
1716: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1717: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
171A: 70 3F    AND   F,63
171C: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _HELLO_2_ISR
171E: 54 B8    MOV   [X-72],A      (0185) ;
1720: 70 3F    AND   F,63
1722: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1724: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1725: 60 D3    MOV   REG[211],A    (0191) _HELLO_2_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1727: 20       POP   X             (0195)    ; Insert your custom code below this banner
1728: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
172A: 43 E1 08 OR    REG[225],8    (0201)    ; Insert your custom code above this banner

FILE: lib\hello_2.asm
                                   (0121) ;;*****************************************************************************
172D: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: HELLO_2.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "HELLO_2.inc"
172E: 41 E1 F7 AND   REG[225],247  (0149) 
                                   (0150) 
1731: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   HELLO_2_EnableInt
                                   (0155) export  _HELLO_2_EnableInt
                                   (0156) export   HELLO_2_DisableInt
                                   (0157) export  _HELLO_2_DisableInt
                                   (0158) export   HELLO_2_Start
                                   (0159) export  _HELLO_2_Start
                                   (0160) export   HELLO_2_Stop
                                   (0161) export  _HELLO_2_Stop
                                   (0162) export   HELLO_2_bReadRxData
                                   (0163) export  _HELLO_2_bReadRxData
                                   (0164) export   HELLO_2_bReadRxStatus
                                   (0165) export  _HELLO_2_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bHELLO_2_ReadRxData
                                   (0170) export _bHELLO_2_ReadRxData
                                   (0171) export  bHELLO_2_ReadRxStatus
                                   (0172) export _bHELLO_2_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  HELLO_2_cGetChar
1732: 29 01    OR    A,1           (0179) export _HELLO_2_cGetChar
1734: 60 2F    MOV   REG[47],A     (0180) export  HELLO_2_cReadChar
                                   (0181) export _HELLO_2_cReadChar
1736: 7F       RET                 (0182) export  HELLO_2_iReadChar
                                   (0183) export _HELLO_2_iReadChar
                                   (0184) 
                                   (0185) IF (HELLO_2_RXBUF_ENABLE)
                                   (0186) export  HELLO_2_CmdReset
                                   (0187) export _HELLO_2_CmdReset
                                   (0188) export  HELLO_2_bCmdCheck
                                   (0189) export _HELLO_2_bCmdCheck
                                   (0190) export  HELLO_2_bCmdLength
                                   (0191) export _HELLO_2_bCmdLength
                                   (0192) export  HELLO_2_bErrCheck
                                   (0193) export _HELLO_2_bErrCheck
                                   (0194) 
                                   (0195) export  HELLO_2_szGetParam
                                   (0196) export _HELLO_2_szGetParam
                                   (0197) export  HELLO_2_szGetRestOfParams
                                   (0198) export _HELLO_2_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA HELLO_2_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1737: 41 2F FE AND   REG[47],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
173A: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: HELLO_2_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  HELLO_2_EnableInt:
                                   (0238) _HELLO_2_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
173B: 5D 2E    MOV   A,REG[46]     (0240)    M8C_EnableIntMask HELLO_2_INT_REG, HELLO_2_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
173D: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: HELLO_2_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  HELLO_2_DisableInt:
                                   (0267) _HELLO_2_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask HELLO_2_INT_REG, HELLO_2_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
173E: 5D 2F    MOV   A,REG[47]     (0272) .ENDSECTION
                                   (0273) 
1740: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: HELLO_2_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  HELLO_2_Start:
                                   (0297) _HELLO_2_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[HELLO_2_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: HELLO_2_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1741: 49 2F 08 TST   REG[47],8     (0311) ;
1744: AF FC    JZ    0x1741        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1746: 5D 2E    MOV   A,REG[46]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1748: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  HELLO_2_Stop:
                                   (0326) _HELLO_2_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[HELLO_2_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: HELLO_2_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1749: 5D 2F    MOV   A,REG[47]     (0346) ;    bRxData - returned in A.
174B: 08       PUSH  A             (0347) ;
174C: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
174E: B0 04    JNZ   0x1753        (0349) ;    The A and X registers may be modified by this or future implementations
1750: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1751: 80 0B    JMP   0x175D        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1753: 5D 2E    MOV   A,REG[46]     (0354) ;
1755: 4B       SWAP  A,X           (0355)  HELLO_2_bReadRxData:
                                   (0356) _HELLO_2_bReadRxData:
1756: 18       POP   A             (0357)  bHELLO_2_ReadRxData:
1757: 21 A0    AND   A,160         (0358) _bHELLO_2_ReadRxData:
1759: B0 03    JNZ   0x175D        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
175B: 4B       SWAP  A,X           (0360)    mov A, REG[HELLO_2_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
175C: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
175D: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: HELLO_2_bReadRxStatus
                                   (0368) ;
175F: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  HELLO_2_bReadRxStatus:
                                   (0388) _HELLO_2_bReadRxStatus:
                                   (0389)  bHELLO_2_ReadRxStatus:
                                   (0390) _bHELLO_2_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[HELLO_2_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: HELLO_2_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1760: 5D 2F    MOV   A,REG[47]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1762: 21 E8    AND   A,232         (0408) ;
1764: 08       PUSH  A             (0409) ;  ARGUMENTS:
1765: 21 08    AND   A,8           (0410) ;      none
1767: B0 07    JNZ   0x176F        (0411) ;
1769: 18       POP   A             (0412) ;  RETURNS:
176A: 29 01    OR    A,1           (0413) ;     char that is returned from UART
176C: 4B       SWAP  A,X           (0414) ;
176D: 80 07    JMP   0x1775        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
176F: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1770: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1772: 4B       SWAP  A,X           (0420) ;    functions.
1773: 5D 2E    MOV   A,REG[46]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1775: 7F       RET                 (0426)  HELLO_2_cGetChar:
                                   (0427) _HELLO_2_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[HELLO_2_CONTROL_REG],HELLO_2_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[HELLO_2_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: HELLO_2_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  HELLO_2_cReadChar:
                                   (0463) _HELLO_2_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[HELLO_2_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,HELLO_2_RX_COMPLETE                              ; Check if a character is ready
1776: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1779: 55 B8 00 MOV   [184],0       (0470)    pop  A
177C: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
177F: 55 DA 00 MOV   [218],0       (0472) 
1782: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1785: 55 0D 00 MOV   [13],0        (0474)    mov  A,REG[HELLO_2_RX_BUFFER_REG]                       ; Read data first, then
1788: 26 0C 00 AND   [12],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
178B: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(HELLO_2_RX_PARITY_ERROR | HELLO_2_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_HELLO_2_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: HELLO_2_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
178C: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
178F: 51 0C    MOV   A,[12]        (0511) ;        0x40CC    Overrun Error
1791: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1793: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  HELLO_2_iReadChar:
                                   (0523) _HELLO_2_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[HELLO_2_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(HELLO_2_RX_ERROR|HELLO_2_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,HELLO_2_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,HELLO_2_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_HELLO_2_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,HELLO_2_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[HELLO_2_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_HELLO_2_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (HELLO_2_RXBUF_ENABLE)
                                   (0552) .SECTION
1794: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1797: 51 0C    MOV   A,[12]        (0554) ;-----------------------------------------------------------------------------
1799: 21 F0    AND   A,240         (0555) ;
179B: 26 0C 0F AND   [12],15       (0556) ;     Command Buffer commands
                                   (0557) ;
179E: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: HELLO_2_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  HELLO_2_CmdReset:
179F: 62 D0 00 MOV   REG[208],0    (0587) _HELLO_2_CmdReset:
17A2: 51 0D    MOV   A,[13]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >HELLO_2_aRxBuffer
17A4: 7F       RET                 (0590)    mov [HELLO_2_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >HELLO_2_bRxCnt
                                   (0594)    mov [HELLO_2_bRxCnt], 0x00
                                   (0595)    and [HELLO_2_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: HELLO_2_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  HELLO_2_bCmdCheck:
                                   (0628) _HELLO_2_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >HELLO_2_fStatus
                                   (0631)    mov A,  [HELLO_2_fStatus]
                                   (0632)    and A, HELLO_2_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: HELLO_2_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
17A5: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
17A7: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
17AA: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
17AD: 50 B8    MOV   A,184         (0648) ;     BYTE  fStatus - Status of command receive buffer.
17AF: 02 DA    ADD   A,[218]       (0649) ;                     Returns non-zero value in A if command is valid.
17B1: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
17B2: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
17B4: B0 04    JNZ   0x17B9        (0653) ;           0x10 => Software Buffer OverRun
17B6: 10       PUSH  X             (0654) ;
17B7: 80 33    JMP   0x17EB        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
17B9: 39 00    CMP   A,0           (0660) ;    functions.
17BB: B0 11    JNZ   0x17CD        (0661) ;          
17BD: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
17BE: 76 DA    INC   [218]         (0663) ;          CUR_PP
17C0: 52 00    MOV   A,[X+0]       (0664) ;
17C2: 3C DA 0F CMP   [218],15      (0665) ;     Error Status is clear when read.
17C5: BF F3    JNZ   0x17B9        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
17C7: 10       PUSH  X             (0669) ;
                                   (0670)  HELLO_2_bErrCheck:
17C8: 56 00 00 MOV   [X+0],0       (0671) _HELLO_2_bErrCheck:
17CB: 80 1F    JMP   0x17EB        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >HELLO_2_fStatus
                                   (0674)    mov A,  [HELLO_2_fStatus]
17CD: 10       PUSH  X             (0675)    and A, HELLO_2_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [HELLO_2_fStatus], ~HELLO_2_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
17CE: 75       INC   X             (0679) .ENDSECTION
17CF: 76 DA    INC   [218]         (0680) 
17D1: 3C DA 0F CMP   [218],15      (0681) .SECTION
17D4: AF F3    JZ    0x17C8        (0682) ;-----------------------------------------------------------------------------
17D6: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: HELLO_2_bCmdLength
17D8: A0 12    JZ    0x17EB        (0684) ;
17DA: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
17DC: BF F1    JNZ   0x17CE        (0686) ;     Get length of command string
                                   (0687) ;
17DE: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
17E1: 76 DA    INC   [218]         (0689) ;     none.
17E3: 3C DA 0F CMP   [218],15      (0690) ;
17E6: B0 04    JNZ   0x17EB        (0691) ;  RETURNS:
17E8: 55 DA 0F MOV   [218],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
17EB: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
17EC: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
17ED: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
17F0: B0 0B    JNZ   0x17FC        (0699) ;    functions.
17F2: 20       POP   X             (0700) ;          
17F3: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
17F5: 50 00    MOV   A,0           (0702) ;          CUR_PP
17F7: 70 3F    AND   F,63
17F9: 71 C0    OR    F,192         (0703) ;
                                   (0704)  HELLO_2_bCmdLength:
17FB: 7F       RET                 (0705) _HELLO_2_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >HELLO_2_bRxCnt
17FC: 20       POP   X             (0708)    mov A,  [HELLO_2_bRxCnt]
17FD: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
17FF: 70 3F    AND   F,63
1801: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1803: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: HELLO_2_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1804: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1807: 50 B8    MOV   A,184         (0744) ;     each lexically distinct element into a null-terminated string by replacing
1809: 02 DA    ADD   A,[218]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
180B: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
180C: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     HELLO_2_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, HELLO_2_szGetParam, is
180F: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\hello_1int.asm
1810: 10       PUSH  X             (0104) ;;*****************************************************************************
1811: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: HELLO_1INT.asm
1813: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1814: 58 0F    MOV   X,[15]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1816: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
1818: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1819: 21 08    AND   A,8           (0114) ;;*****************************************************************************
181B: B0 04    JNZ   0x1820        (0115) 
181D: 18       POP   A             (0116) include "m8c.inc"
181E: 80 5E    JMP   0x187D        (0117) include "memory.inc"
                                   (0118) include "HELLO_1.inc"
                                   (0119) 
                                   (0120) 
1820: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1821: 21 E0    AND   A,224         (0124) export  _HELLO_1_ISR
1823: A0 12    JZ    0x1836        (0125) 
                                   (0126) 
1825: 2C 0E    OR    [14],A        (0127) IF (HELLO_1_RXBUF_ENABLE)
                                   (0128) export  HELLO_1_aRxBuffer
1827: 49 2A 00 TST   REG[42],0     (0129) export _HELLO_1_aRxBuffer
                                   (0130) export  HELLO_1_bRxCnt
182A: 21 20    AND   A,32          (0131) export _HELLO_1_bRxCnt
182C: A0 50    JZ    0x187D        (0132) export  HELLO_1_fStatus
                                   (0133) export _HELLO_1_fStatus
                                   (0134) ENDIF
                                   (0135) 
182E: 41 2B FE AND   REG[43],254   (0136) 
1831: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
1834: 80 48    JMP   0x187D        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (HELLO_1_RXBUF_ENABLE)
1836: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  HELLO_1_fStatus:
                                   (0144) _HELLO_1_fStatus:      BLK  1
1838: 47 0E 01 TST   [14],1        (0145)  HELLO_1_bRxCnt:
183B: B0 41    JNZ   0x187D        (0146) _HELLO_1_bRxCnt:       BLK  1
                                   (0147) AREA HELLO_1_RAM(RAM,REL,CON)
183D: 39 00    CMP   A,0           (0148)  HELLO_1_aRxBuffer:    
183F: B0 14    JNZ   0x1854        (0149) _HELLO_1_aRxBuffer:    BLK HELLO_1_RX_BUFFER_SIZE
1841: 2E 0E 01 OR    [14],1        (0150) ENDIF
                                   (0151) 
1844: 62 D3 00 MOV   REG[211],0    (0152) 
1847: 70 3F    AND   F,63
1849: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
184B: 56 78 00 MOV   [X+120],0     (0154) 
184E: 70 3F    AND   F,63
1850: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
1852: 80 2A    JMP   0x187D        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1854: 3C 0F 0F CMP   [15],15       (0167) ;------------------------
1857: C0 14    JC    0x186C        (0168) 
1859: 2E 0E 10 OR    [14],16       (0169) 
                                   (0170) ;------------------------
185C: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
185F: 70 3F    AND   F,63
1861: 71 80    OR    F,128         (0172) ;------------------------
1863: 56 78 00 MOV   [X+120],0     (0173) 
1866: 70 3F    AND   F,63
1868: 71 00    OR    F,0           (0174) 
186A: 80 12    JMP   0x187D        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
186C: 75       INC   X             (0179) 
186D: 5A 0F    MOV   [15],X        (0180) 
186F: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1870: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1873: 70 3F    AND   F,63
1875: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _HELLO_1_ISR
1877: 54 78    MOV   [X+120],A     (0185) ;
1879: 70 3F    AND   F,63
187B: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
187D: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
187E: 60 D3    MOV   REG[211],A    (0191) _HELLO_1_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1880: 20       POP   X             (0195)    ; Insert your custom code below this banner
1881: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1883: 43 E1 04 OR    REG[225],4    (0201)    ; Insert your custom code above this banner

FILE: lib\hello_1.asm
                                   (0121) ;;*****************************************************************************
1886: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: HELLO_1.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "HELLO_1.inc"
1887: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
188A: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   HELLO_1_EnableInt
                                   (0155) export  _HELLO_1_EnableInt
                                   (0156) export   HELLO_1_DisableInt
                                   (0157) export  _HELLO_1_DisableInt
                                   (0158) export   HELLO_1_Start
                                   (0159) export  _HELLO_1_Start
                                   (0160) export   HELLO_1_Stop
                                   (0161) export  _HELLO_1_Stop
                                   (0162) export   HELLO_1_bReadRxData
                                   (0163) export  _HELLO_1_bReadRxData
                                   (0164) export   HELLO_1_bReadRxStatus
                                   (0165) export  _HELLO_1_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bHELLO_1_ReadRxData
                                   (0170) export _bHELLO_1_ReadRxData
                                   (0171) export  bHELLO_1_ReadRxStatus
                                   (0172) export _bHELLO_1_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  HELLO_1_cGetChar
188B: 29 01    OR    A,1           (0179) export _HELLO_1_cGetChar
188D: 60 2B    MOV   REG[43],A     (0180) export  HELLO_1_cReadChar
                                   (0181) export _HELLO_1_cReadChar
188F: 7F       RET                 (0182) export  HELLO_1_iReadChar
                                   (0183) export _HELLO_1_iReadChar
                                   (0184) 
                                   (0185) IF (HELLO_1_RXBUF_ENABLE)
                                   (0186) export  HELLO_1_CmdReset
                                   (0187) export _HELLO_1_CmdReset
                                   (0188) export  HELLO_1_bCmdCheck
                                   (0189) export _HELLO_1_bCmdCheck
                                   (0190) export  HELLO_1_bCmdLength
                                   (0191) export _HELLO_1_bCmdLength
                                   (0192) export  HELLO_1_bErrCheck
                                   (0193) export _HELLO_1_bErrCheck
                                   (0194) 
                                   (0195) export  HELLO_1_szGetParam
                                   (0196) export _HELLO_1_szGetParam
                                   (0197) export  HELLO_1_szGetRestOfParams
                                   (0198) export _HELLO_1_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA HELLO_1_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1890: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1893: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: HELLO_1_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  HELLO_1_EnableInt:
                                   (0238) _HELLO_1_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1894: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask HELLO_1_INT_REG, HELLO_1_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1896: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: HELLO_1_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  HELLO_1_DisableInt:
                                   (0267) _HELLO_1_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask HELLO_1_INT_REG, HELLO_1_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
1897: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
1899: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: HELLO_1_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  HELLO_1_Start:
                                   (0297) _HELLO_1_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[HELLO_1_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: HELLO_1_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
189A: 49 2B 08 TST   REG[43],8     (0311) ;
189D: AF FC    JZ    0x189A        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
189F: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
18A1: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  HELLO_1_Stop:
                                   (0326) _HELLO_1_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[HELLO_1_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: HELLO_1_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
18A2: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
18A4: 08       PUSH  A             (0347) ;
18A5: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
18A7: B0 04    JNZ   0x18AC        (0349) ;    The A and X registers may be modified by this or future implementations
18A9: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
18AA: 80 0B    JMP   0x18B6        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
18AC: 5D 2A    MOV   A,REG[42]     (0354) ;
18AE: 4B       SWAP  A,X           (0355)  HELLO_1_bReadRxData:
                                   (0356) _HELLO_1_bReadRxData:
18AF: 18       POP   A             (0357)  bHELLO_1_ReadRxData:
18B0: 21 A0    AND   A,160         (0358) _bHELLO_1_ReadRxData:
18B2: B0 03    JNZ   0x18B6        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
18B4: 4B       SWAP  A,X           (0360)    mov A, REG[HELLO_1_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
18B5: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
18B6: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: HELLO_1_bReadRxStatus
                                   (0368) ;
18B8: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  HELLO_1_bReadRxStatus:
                                   (0388) _HELLO_1_bReadRxStatus:
                                   (0389)  bHELLO_1_ReadRxStatus:
                                   (0390) _bHELLO_1_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[HELLO_1_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: HELLO_1_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
18B9: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
18BB: 21 E8    AND   A,232         (0408) ;
18BD: 08       PUSH  A             (0409) ;  ARGUMENTS:
18BE: 21 08    AND   A,8           (0410) ;      none
18C0: B0 07    JNZ   0x18C8        (0411) ;
18C2: 18       POP   A             (0412) ;  RETURNS:
18C3: 29 01    OR    A,1           (0413) ;     char that is returned from UART
18C5: 4B       SWAP  A,X           (0414) ;
18C6: 80 07    JMP   0x18CE        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
18C8: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
18C9: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
18CB: 4B       SWAP  A,X           (0420) ;    functions.
18CC: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
18CE: 7F       RET                 (0426)  HELLO_1_cGetChar:
                                   (0427) _HELLO_1_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[HELLO_1_CONTROL_REG],HELLO_1_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[HELLO_1_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: HELLO_1_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  HELLO_1_cReadChar:
                                   (0463) _HELLO_1_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[HELLO_1_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,HELLO_1_RX_COMPLETE                              ; Check if a character is ready
18CF: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
18D2: 55 78 00 MOV   [120],0       (0470)    pop  A
18D5: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
18D8: 55 D9 00 MOV   [217],0       (0472) 
18DB: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
18DE: 55 0F 00 MOV   [15],0        (0474)    mov  A,REG[HELLO_1_RX_BUFFER_REG]                       ; Read data first, then
18E1: 26 0E 00 AND   [14],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
18E4: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(HELLO_1_RX_PARITY_ERROR | HELLO_1_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_HELLO_1_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: HELLO_1_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
18E5: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
18E8: 51 0E    MOV   A,[14]        (0511) ;        0x40CC    Overrun Error
18EA: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
18EC: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  HELLO_1_iReadChar:
                                   (0523) _HELLO_1_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[HELLO_1_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(HELLO_1_RX_ERROR|HELLO_1_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,HELLO_1_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,HELLO_1_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_HELLO_1_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,HELLO_1_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[HELLO_1_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_HELLO_1_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (HELLO_1_RXBUF_ENABLE)
                                   (0552) .SECTION
18ED: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
18F0: 51 0E    MOV   A,[14]        (0554) ;-----------------------------------------------------------------------------
18F2: 21 F0    AND   A,240         (0555) ;
18F4: 26 0E 0F AND   [14],15       (0556) ;     Command Buffer commands
                                   (0557) ;
18F7: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: HELLO_1_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  HELLO_1_CmdReset:
18F8: 62 D0 00 MOV   REG[208],0    (0587) _HELLO_1_CmdReset:
18FB: 51 0F    MOV   A,[15]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >HELLO_1_aRxBuffer
18FD: 7F       RET                 (0590)    mov [HELLO_1_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >HELLO_1_bRxCnt
                                   (0594)    mov [HELLO_1_bRxCnt], 0x00
                                   (0595)    and [HELLO_1_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: HELLO_1_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  HELLO_1_bCmdCheck:
                                   (0628) _HELLO_1_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >HELLO_1_fStatus
                                   (0631)    mov A,  [HELLO_1_fStatus]
                                   (0632)    and A, HELLO_1_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: HELLO_1_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
18FE: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1900: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1903: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1906: 50 78    MOV   A,120         (0648) ;     BYTE  fStatus - Status of command receive buffer.
1908: 02 D9    ADD   A,[217]       (0649) ;                     Returns non-zero value in A if command is valid.
190A: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
190B: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
190D: B0 04    JNZ   0x1912        (0653) ;           0x10 => Software Buffer OverRun
190F: 10       PUSH  X             (0654) ;
1910: 80 33    JMP   0x1944        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1912: 39 00    CMP   A,0           (0660) ;    functions.
1914: B0 11    JNZ   0x1926        (0661) ;          
1916: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1917: 76 D9    INC   [217]         (0663) ;          CUR_PP
1919: 52 00    MOV   A,[X+0]       (0664) ;
191B: 3C D9 0F CMP   [217],15      (0665) ;     Error Status is clear when read.
191E: BF F3    JNZ   0x1912        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
1920: 10       PUSH  X             (0669) ;
                                   (0670)  HELLO_1_bErrCheck:
1921: 56 00 00 MOV   [X+0],0       (0671) _HELLO_1_bErrCheck:
1924: 80 1F    JMP   0x1944        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >HELLO_1_fStatus
                                   (0674)    mov A,  [HELLO_1_fStatus]
1926: 10       PUSH  X             (0675)    and A, HELLO_1_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [HELLO_1_fStatus], ~HELLO_1_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
1927: 75       INC   X             (0679) .ENDSECTION
1928: 76 D9    INC   [217]         (0680) 
192A: 3C D9 0F CMP   [217],15      (0681) .SECTION
192D: AF F3    JZ    0x1921        (0682) ;-----------------------------------------------------------------------------
192F: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: HELLO_1_bCmdLength
1931: A0 12    JZ    0x1944        (0684) ;
1933: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1935: BF F1    JNZ   0x1927        (0686) ;     Get length of command string
                                   (0687) ;
1937: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
193A: 76 D9    INC   [217]         (0689) ;     none.
193C: 3C D9 0F CMP   [217],15      (0690) ;
193F: B0 04    JNZ   0x1944        (0691) ;  RETURNS:
1941: 55 D9 0F MOV   [217],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1944: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1945: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
1946: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1949: B0 0B    JNZ   0x1955        (0699) ;    functions.
194B: 20       POP   X             (0700) ;          
194C: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
194E: 50 00    MOV   A,0           (0702) ;          CUR_PP
1950: 70 3F    AND   F,63
1952: 71 C0    OR    F,192         (0703) ;
                                   (0704)  HELLO_1_bCmdLength:
1954: 7F       RET                 (0705) _HELLO_1_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >HELLO_1_bRxCnt
1955: 20       POP   X             (0708)    mov A,  [HELLO_1_bRxCnt]
1956: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1958: 70 3F    AND   F,63
195A: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
195C: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: HELLO_1_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
195D: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1960: 50 78    MOV   A,120         (0744) ;     each lexically distinct element into a null-terminated string by replacing
1962: 02 D9    ADD   A,[217]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
1964: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
1965: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     HELLO_1_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, HELLO_1_szGetParam, is
1968: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\child_4int.asm
1969: 10       PUSH  X             (0104) ;;*****************************************************************************
196A: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: CHILD_4INT.asm
196C: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
196D: 58 11    MOV   X,[17]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
196F: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
1971: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1972: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1974: B0 04    JNZ   0x1979        (0115) 
1976: 18       POP   A             (0116) include "m8c.inc"
1977: 80 5E    JMP   0x19D6        (0117) include "memory.inc"
                                   (0118) include "CHILD_4.inc"
                                   (0119) 
                                   (0120) 
1979: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
197A: 21 E0    AND   A,224         (0124) export  _CHILD_4_ISR
197C: A0 12    JZ    0x198F        (0125) 
                                   (0126) 
197E: 2C 10    OR    [16],A        (0127) IF (CHILD_4_RXBUF_ENABLE)
                                   (0128) export  CHILD_4_aRxBuffer
1980: 49 2A 00 TST   REG[42],0     (0129) export _CHILD_4_aRxBuffer
                                   (0130) export  CHILD_4_bRxCnt
1983: 21 20    AND   A,32          (0131) export _CHILD_4_bRxCnt
1985: A0 50    JZ    0x19D6        (0132) export  CHILD_4_fStatus
                                   (0133) export _CHILD_4_fStatus
                                   (0134) ENDIF
                                   (0135) 
1987: 41 2B FE AND   REG[43],254   (0136) 
198A: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
198D: 80 48    JMP   0x19D6        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (CHILD_4_RXBUF_ENABLE)
198F: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  CHILD_4_fStatus:
                                   (0144) _CHILD_4_fStatus:      BLK  1
1991: 47 10 01 TST   [16],1        (0145)  CHILD_4_bRxCnt:
1994: B0 41    JNZ   0x19D6        (0146) _CHILD_4_bRxCnt:       BLK  1
                                   (0147) AREA CHILD_4_RAM(RAM,REL,CON)
1996: 39 00    CMP   A,0           (0148)  CHILD_4_aRxBuffer:    
1998: B0 14    JNZ   0x19AD        (0149) _CHILD_4_aRxBuffer:    BLK CHILD_4_RX_BUFFER_SIZE
199A: 2E 10 01 OR    [16],1        (0150) ENDIF
                                   (0151) 
199D: 62 D3 00 MOV   REG[211],0    (0152) 
19A0: 70 3F    AND   F,63
19A2: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
19A4: 56 88 00 MOV   [X-120],0     (0154) 
19A7: 70 3F    AND   F,63
19A9: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
19AB: 80 2A    JMP   0x19D6        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
19AD: 3C 11 0F CMP   [17],15       (0167) ;------------------------
19B0: C0 14    JC    0x19C5        (0168) 
19B2: 2E 10 10 OR    [16],16       (0169) 
                                   (0170) ;------------------------
19B5: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
19B8: 70 3F    AND   F,63
19BA: 71 80    OR    F,128         (0172) ;------------------------
19BC: 56 88 00 MOV   [X-120],0     (0173) 
19BF: 70 3F    AND   F,63
19C1: 71 00    OR    F,0           (0174) 
19C3: 80 12    JMP   0x19D6        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
19C5: 75       INC   X             (0179) 
19C6: 5A 11    MOV   [17],X        (0180) 
19C8: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
19C9: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
19CC: 70 3F    AND   F,63
19CE: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _CHILD_4_ISR
19D0: 54 88    MOV   [X-120],A     (0185) ;
19D2: 70 3F    AND   F,63
19D4: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
19D6: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
19D7: 60 D3    MOV   REG[211],A    (0191) _CHILD_4_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
19D9: 20       POP   X             (0195)    ; Insert your custom code below this banner
19DA: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
19DC: 43 E1 02 OR    REG[225],2    (0201)    ; Insert your custom code above this banner

FILE: lib\child_4_timeout.asm
                                   (0102) ;;*****************************************************************************
19DF: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: CHILD_4_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "CHILD_4_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
19E0: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
19E3: 7F       RET                 (0131) export  CHILD_4_TIMEOUT_EnableInt
                                   (0132) export _CHILD_4_TIMEOUT_EnableInt
                                   (0133) export  CHILD_4_TIMEOUT_DisableInt
                                   (0134) export _CHILD_4_TIMEOUT_DisableInt
                                   (0135) export  CHILD_4_TIMEOUT_Start
                                   (0136) export _CHILD_4_TIMEOUT_Start
                                   (0137) export  CHILD_4_TIMEOUT_Stop
                                   (0138) export _CHILD_4_TIMEOUT_Stop
                                   (0139) export  CHILD_4_TIMEOUT_WritePeriod
                                   (0140) export _CHILD_4_TIMEOUT_WritePeriod
                                   (0141) export  CHILD_4_TIMEOUT_WriteCompareValue
                                   (0142) export _CHILD_4_TIMEOUT_WriteCompareValue
                                   (0143) export  CHILD_4_TIMEOUT_wReadCompareValue
                                   (0144) export _CHILD_4_TIMEOUT_wReadCompareValue
                                   (0145) export  CHILD_4_TIMEOUT_wReadTimer
                                   (0146) export _CHILD_4_TIMEOUT_wReadTimer
                                   (0147) export  CHILD_4_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _CHILD_4_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wCHILD_4_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wCHILD_4_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wCHILD_4_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wCHILD_4_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wCHILD_4_TIMEOUT_ReadTimerSaveCV   ; deprecated
19E4: 43 23 01 OR    REG[35],1     (0157) export _wCHILD_4_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
19E7: 7F       RET                 (0159) export  wCHILD_4_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wCHILD_4_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wCHILD_4_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wCHILD_4_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA response4_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: CHILD_4_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
19E8: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
19EB: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  CHILD_4_TIMEOUT_EnableInt:
                                   (0200) _CHILD_4_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    CHILD_4_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: CHILD_4_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
19EC: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
19EE: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
19EF: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
19F1: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  CHILD_4_TIMEOUT_DisableInt:
                                   (0228) _CHILD_4_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    CHILD_4_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: CHILD_4_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
19F2: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
19F4: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
19F5: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
19F7: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  CHILD_4_TIMEOUT_Start:
                                   (0256) _CHILD_4_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    CHILD_4_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: CHILD_4_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
19F8: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
19FA: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
19FB: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
19FD: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  CHILD_4_TIMEOUT_Stop:
                                   (0284) _CHILD_4_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    CHILD_4_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: CHILD_4_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  CHILD_4_TIMEOUT_WritePeriod:
                                   (0313) _CHILD_4_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[CHILD_4_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[CHILD_4_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: CHILD_4_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call CHILD_4_TIMEOUT_Stop to disable).
19FE: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
19FF: 38 03    ADD   SP,3          (0334) ;
1A01: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
1A03: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
1A04: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
1A06: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
1A07: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
1A09: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
1A0A: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
1A0C: 5D 26    MOV   A,REG[38]     (0343) ;
1A0E: 54 01    MOV   [X+1],A       (0344)  CHILD_4_TIMEOUT_WriteCompareValue:
1A10: 5D 22    MOV   A,REG[34]     (0345) _CHILD_4_TIMEOUT_WriteCompareValue:
1A12: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
1A14: 50 00    MOV   A,0           (0347)    mov   reg[CHILD_4_TIMEOUT_COMPARE_LSB_REG], A
1A16: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
1A19: A0 03    JZ    0x1A1D        (0349)    mov   reg[CHILD_4_TIMEOUT_COMPARE_MSB_REG], A
1A1B: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
1A1D: 54 00    MOV   [X+0],A       (0352) 
1A1F: 70 FE    AND   F,254         (0353) .ENDSECTION
1A21: 41 23 FE AND   REG[35],254   (0354) 
1A24: 18       POP   A             (0355) 
1A25: 60 26    MOV   REG[38],A     (0356) .SECTION
1A27: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
1A28: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: CHILD_4_TIMEOUT_wReadCompareValue
1A2A: 18       POP   A             (0359) ;
1A2B: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
1A2D: 18       POP   A             (0361) ;     Reads the Compare registers.
1A2E: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
1A2F: 70 3F    AND   F,63
1A31: 71 C0    OR    F,192         (0363) ;
1A33: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  CHILD_4_TIMEOUT_wReadCompareValue:
                                   (0374) _CHILD_4_TIMEOUT_wReadCompareValue:
                                   (0375)  wCHILD_4_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wCHILD_4_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[CHILD_4_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[CHILD_4_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: CHILD_4_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
1A34: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
1A36: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
1A38: 5C       MOV   X,A           (0409) ;
1A39: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
1A3C: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\child_4.asm
                                   (0121) ;;*****************************************************************************
1A3F: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: CHILD_4.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "CHILD_4.inc"
1A40: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
1A43: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   CHILD_4_EnableInt
                                   (0155) export  _CHILD_4_EnableInt
                                   (0156) export   CHILD_4_DisableInt
                                   (0157) export  _CHILD_4_DisableInt
                                   (0158) export   CHILD_4_Start
                                   (0159) export  _CHILD_4_Start
                                   (0160) export   CHILD_4_Stop
                                   (0161) export  _CHILD_4_Stop
                                   (0162) export   CHILD_4_bReadRxData
                                   (0163) export  _CHILD_4_bReadRxData
                                   (0164) export   CHILD_4_bReadRxStatus
                                   (0165) export  _CHILD_4_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bCHILD_4_ReadRxData
                                   (0170) export _bCHILD_4_ReadRxData
                                   (0171) export  bCHILD_4_ReadRxStatus
                                   (0172) export _bCHILD_4_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  CHILD_4_cGetChar
1A44: 29 01    OR    A,1           (0179) export _CHILD_4_cGetChar
1A46: 60 2B    MOV   REG[43],A     (0180) export  CHILD_4_cReadChar
                                   (0181) export _CHILD_4_cReadChar
1A48: 7F       RET                 (0182) export  CHILD_4_iReadChar
                                   (0183) export _CHILD_4_iReadChar
                                   (0184) 
                                   (0185) IF (CHILD_4_RXBUF_ENABLE)
                                   (0186) export  CHILD_4_CmdReset
                                   (0187) export _CHILD_4_CmdReset
                                   (0188) export  CHILD_4_bCmdCheck
                                   (0189) export _CHILD_4_bCmdCheck
                                   (0190) export  CHILD_4_bCmdLength
                                   (0191) export _CHILD_4_bCmdLength
                                   (0192) export  CHILD_4_bErrCheck
                                   (0193) export _CHILD_4_bErrCheck
                                   (0194) 
                                   (0195) export  CHILD_4_szGetParam
                                   (0196) export _CHILD_4_szGetParam
                                   (0197) export  CHILD_4_szGetRestOfParams
                                   (0198) export _CHILD_4_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA CHILD_4_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1A49: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1A4C: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: CHILD_4_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  CHILD_4_EnableInt:
                                   (0238) _CHILD_4_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1A4D: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask CHILD_4_INT_REG, CHILD_4_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1A4F: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: CHILD_4_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  CHILD_4_DisableInt:
                                   (0267) _CHILD_4_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask CHILD_4_INT_REG, CHILD_4_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
1A50: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
1A52: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: CHILD_4_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  CHILD_4_Start:
                                   (0297) _CHILD_4_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[CHILD_4_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: CHILD_4_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1A53: 49 2B 08 TST   REG[43],8     (0311) ;
1A56: AF FC    JZ    0x1A53        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1A58: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1A5A: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  CHILD_4_Stop:
                                   (0326) _CHILD_4_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[CHILD_4_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: CHILD_4_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1A5B: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
1A5D: 08       PUSH  A             (0347) ;
1A5E: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
1A60: B0 04    JNZ   0x1A65        (0349) ;    The A and X registers may be modified by this or future implementations
1A62: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1A63: 80 0B    JMP   0x1A6F        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1A65: 5D 2A    MOV   A,REG[42]     (0354) ;
1A67: 4B       SWAP  A,X           (0355)  CHILD_4_bReadRxData:
                                   (0356) _CHILD_4_bReadRxData:
1A68: 18       POP   A             (0357)  bCHILD_4_ReadRxData:
1A69: 21 A0    AND   A,160         (0358) _bCHILD_4_ReadRxData:
1A6B: B0 03    JNZ   0x1A6F        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1A6D: 4B       SWAP  A,X           (0360)    mov A, REG[CHILD_4_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1A6E: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1A6F: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: CHILD_4_bReadRxStatus
                                   (0368) ;
1A71: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  CHILD_4_bReadRxStatus:
                                   (0388) _CHILD_4_bReadRxStatus:
                                   (0389)  bCHILD_4_ReadRxStatus:
                                   (0390) _bCHILD_4_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[CHILD_4_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: CHILD_4_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1A72: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1A74: 21 E8    AND   A,232         (0408) ;
1A76: 08       PUSH  A             (0409) ;  ARGUMENTS:
1A77: 21 08    AND   A,8           (0410) ;      none
1A79: B0 07    JNZ   0x1A81        (0411) ;
1A7B: 18       POP   A             (0412) ;  RETURNS:
1A7C: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1A7E: 4B       SWAP  A,X           (0414) ;
1A7F: 80 07    JMP   0x1A87        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1A81: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1A82: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1A84: 4B       SWAP  A,X           (0420) ;    functions.
1A85: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1A87: 7F       RET                 (0426)  CHILD_4_cGetChar:
                                   (0427) _CHILD_4_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[CHILD_4_CONTROL_REG],CHILD_4_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[CHILD_4_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: CHILD_4_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  CHILD_4_cReadChar:
                                   (0463) _CHILD_4_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[CHILD_4_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,CHILD_4_RX_COMPLETE                              ; Check if a character is ready
1A88: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1A8B: 55 88 00 MOV   [136],0       (0470)    pop  A
1A8E: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1A91: 55 D8 00 MOV   [216],0       (0472) 
1A94: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1A97: 55 11 00 MOV   [17],0        (0474)    mov  A,REG[CHILD_4_RX_BUFFER_REG]                       ; Read data first, then
1A9A: 26 10 00 AND   [16],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1A9D: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(CHILD_4_RX_PARITY_ERROR | CHILD_4_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_CHILD_4_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: CHILD_4_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1A9E: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1AA1: 51 10    MOV   A,[16]        (0511) ;        0x40CC    Overrun Error
1AA3: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1AA5: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  CHILD_4_iReadChar:
                                   (0523) _CHILD_4_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[CHILD_4_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(CHILD_4_RX_ERROR|CHILD_4_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,CHILD_4_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,CHILD_4_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_CHILD_4_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,CHILD_4_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[CHILD_4_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_CHILD_4_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (CHILD_4_RXBUF_ENABLE)
                                   (0552) .SECTION
1AA6: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1AA9: 51 10    MOV   A,[16]        (0554) ;-----------------------------------------------------------------------------
1AAB: 21 F0    AND   A,240         (0555) ;
1AAD: 26 10 0F AND   [16],15       (0556) ;     Command Buffer commands
                                   (0557) ;
1AB0: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: CHILD_4_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  CHILD_4_CmdReset:
1AB1: 62 D0 00 MOV   REG[208],0    (0587) _CHILD_4_CmdReset:
1AB4: 51 11    MOV   A,[17]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >CHILD_4_aRxBuffer
1AB6: 7F       RET                 (0590)    mov [CHILD_4_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >CHILD_4_bRxCnt
                                   (0594)    mov [CHILD_4_bRxCnt], 0x00
                                   (0595)    and [CHILD_4_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: CHILD_4_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  CHILD_4_bCmdCheck:
                                   (0628) _CHILD_4_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >CHILD_4_fStatus
                                   (0631)    mov A,  [CHILD_4_fStatus]
                                   (0632)    and A, CHILD_4_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: CHILD_4_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1AB7: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1AB9: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1ABC: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1ABF: 50 88    MOV   A,136         (0648) ;     BYTE  fStatus - Status of command receive buffer.
1AC1: 02 D8    ADD   A,[216]       (0649) ;                     Returns non-zero value in A if command is valid.
1AC3: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1AC4: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1AC6: B0 04    JNZ   0x1ACB        (0653) ;           0x10 => Software Buffer OverRun
1AC8: 10       PUSH  X             (0654) ;
1AC9: 80 33    JMP   0x1AFD        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1ACB: 39 00    CMP   A,0           (0660) ;    functions.
1ACD: B0 11    JNZ   0x1ADF        (0661) ;          
1ACF: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1AD0: 76 D8    INC   [216]         (0663) ;          CUR_PP
1AD2: 52 00    MOV   A,[X+0]       (0664) ;
1AD4: 3C D8 0F CMP   [216],15      (0665) ;     Error Status is clear when read.
1AD7: BF F3    JNZ   0x1ACB        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
1AD9: 10       PUSH  X             (0669) ;
                                   (0670)  CHILD_4_bErrCheck:
1ADA: 56 00 00 MOV   [X+0],0       (0671) _CHILD_4_bErrCheck:
1ADD: 80 1F    JMP   0x1AFD        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >CHILD_4_fStatus
                                   (0674)    mov A,  [CHILD_4_fStatus]
1ADF: 10       PUSH  X             (0675)    and A, CHILD_4_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [CHILD_4_fStatus], ~CHILD_4_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
1AE0: 75       INC   X             (0679) .ENDSECTION
1AE1: 76 D8    INC   [216]         (0680) 
1AE3: 3C D8 0F CMP   [216],15      (0681) .SECTION
1AE6: AF F3    JZ    0x1ADA        (0682) ;-----------------------------------------------------------------------------
1AE8: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: CHILD_4_bCmdLength
1AEA: A0 12    JZ    0x1AFD        (0684) ;
1AEC: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1AEE: BF F1    JNZ   0x1AE0        (0686) ;     Get length of command string
                                   (0687) ;
1AF0: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
1AF3: 76 D8    INC   [216]         (0689) ;     none.
1AF5: 3C D8 0F CMP   [216],15      (0690) ;
1AF8: B0 04    JNZ   0x1AFD        (0691) ;  RETURNS:
1AFA: 55 D8 0F MOV   [216],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1AFD: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1AFE: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
1AFF: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1B02: B0 0B    JNZ   0x1B0E        (0699) ;    functions.
1B04: 20       POP   X             (0700) ;          
1B05: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
1B07: 50 00    MOV   A,0           (0702) ;          CUR_PP
1B09: 70 3F    AND   F,63
1B0B: 71 C0    OR    F,192         (0703) ;
                                   (0704)  CHILD_4_bCmdLength:
1B0D: 7F       RET                 (0705) _CHILD_4_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >CHILD_4_bRxCnt
1B0E: 20       POP   X             (0708)    mov A,  [CHILD_4_bRxCnt]
1B0F: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1B11: 70 3F    AND   F,63
1B13: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1B15: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: CHILD_4_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1B16: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1B19: 50 88    MOV   A,136         (0744) ;     each lexically distinct element into a null-terminated string by replacing
1B1B: 02 D8    ADD   A,[216]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
1B1D: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
1B1E: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     CHILD_4_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, CHILD_4_szGetParam, is
1B21: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\child_3int.asm
1B22: 10       PUSH  X             (0104) ;;*****************************************************************************
1B23: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: CHILD_3INT.asm
1B25: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1B26: 58 13    MOV   X,[19]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1B28: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
1B2A: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1B2B: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1B2D: B0 04    JNZ   0x1B32        (0115) 
1B2F: 18       POP   A             (0116) include "m8c.inc"
1B30: 80 5E    JMP   0x1B8F        (0117) include "memory.inc"
                                   (0118) include "CHILD_3.inc"
                                   (0119) 
                                   (0120) 
1B32: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1B33: 21 E0    AND   A,224         (0124) export  _CHILD_3_ISR
1B35: A0 12    JZ    0x1B48        (0125) 
                                   (0126) 
1B37: 2C 12    OR    [18],A        (0127) IF (CHILD_3_RXBUF_ENABLE)
                                   (0128) export  CHILD_3_aRxBuffer
1B39: 49 2A 00 TST   REG[42],0     (0129) export _CHILD_3_aRxBuffer
                                   (0130) export  CHILD_3_bRxCnt
1B3C: 21 20    AND   A,32          (0131) export _CHILD_3_bRxCnt
1B3E: A0 50    JZ    0x1B8F        (0132) export  CHILD_3_fStatus
                                   (0133) export _CHILD_3_fStatus
                                   (0134) ENDIF
                                   (0135) 
1B40: 41 2B FE AND   REG[43],254   (0136) 
1B43: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
1B46: 80 48    JMP   0x1B8F        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (CHILD_3_RXBUF_ENABLE)
1B48: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  CHILD_3_fStatus:
                                   (0144) _CHILD_3_fStatus:      BLK  1
1B4A: 47 12 01 TST   [18],1        (0145)  CHILD_3_bRxCnt:
1B4D: B0 41    JNZ   0x1B8F        (0146) _CHILD_3_bRxCnt:       BLK  1
                                   (0147) AREA CHILD_3_RAM(RAM,REL,CON)
1B4F: 39 00    CMP   A,0           (0148)  CHILD_3_aRxBuffer:    
1B51: B0 14    JNZ   0x1B66        (0149) _CHILD_3_aRxBuffer:    BLK CHILD_3_RX_BUFFER_SIZE
1B53: 2E 12 01 OR    [18],1        (0150) ENDIF
                                   (0151) 
1B56: 62 D3 00 MOV   REG[211],0    (0152) 
1B59: 70 3F    AND   F,63
1B5B: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1B5D: 56 38 00 MOV   [X+56],0      (0154) 
1B60: 70 3F    AND   F,63
1B62: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
1B64: 80 2A    JMP   0x1B8F        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1B66: 3C 13 0F CMP   [19],15       (0167) ;------------------------
1B69: C0 14    JC    0x1B7E        (0168) 
1B6B: 2E 12 10 OR    [18],16       (0169) 
                                   (0170) ;------------------------
1B6E: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
1B71: 70 3F    AND   F,63
1B73: 71 80    OR    F,128         (0172) ;------------------------
1B75: 56 38 00 MOV   [X+56],0      (0173) 
1B78: 70 3F    AND   F,63
1B7A: 71 00    OR    F,0           (0174) 
1B7C: 80 12    JMP   0x1B8F        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1B7E: 75       INC   X             (0179) 
1B7F: 5A 13    MOV   [19],X        (0180) 
1B81: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1B82: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1B85: 70 3F    AND   F,63
1B87: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _CHILD_3_ISR
1B89: 54 38    MOV   [X+56],A      (0185) ;
1B8B: 70 3F    AND   F,63
1B8D: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1B8F: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1B90: 60 D3    MOV   REG[211],A    (0191) _CHILD_3_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1B92: 20       POP   X             (0195)    ; Insert your custom code below this banner
1B93: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1B95: 43 E1 02 OR    REG[225],2    (0201)    ; Insert your custom code above this banner

FILE: lib\child_3_timeout.asm
                                   (0102) ;;*****************************************************************************
1B98: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: CHILD_3_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "CHILD_3_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
1B99: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
1B9C: 7F       RET                 (0131) export  CHILD_3_TIMEOUT_EnableInt
                                   (0132) export _CHILD_3_TIMEOUT_EnableInt
                                   (0133) export  CHILD_3_TIMEOUT_DisableInt
                                   (0134) export _CHILD_3_TIMEOUT_DisableInt
                                   (0135) export  CHILD_3_TIMEOUT_Start
                                   (0136) export _CHILD_3_TIMEOUT_Start
                                   (0137) export  CHILD_3_TIMEOUT_Stop
                                   (0138) export _CHILD_3_TIMEOUT_Stop
                                   (0139) export  CHILD_3_TIMEOUT_WritePeriod
                                   (0140) export _CHILD_3_TIMEOUT_WritePeriod
                                   (0141) export  CHILD_3_TIMEOUT_WriteCompareValue
                                   (0142) export _CHILD_3_TIMEOUT_WriteCompareValue
                                   (0143) export  CHILD_3_TIMEOUT_wReadCompareValue
                                   (0144) export _CHILD_3_TIMEOUT_wReadCompareValue
                                   (0145) export  CHILD_3_TIMEOUT_wReadTimer
                                   (0146) export _CHILD_3_TIMEOUT_wReadTimer
                                   (0147) export  CHILD_3_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _CHILD_3_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wCHILD_3_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wCHILD_3_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wCHILD_3_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wCHILD_3_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wCHILD_3_TIMEOUT_ReadTimerSaveCV   ; deprecated
1B9D: 43 23 01 OR    REG[35],1     (0157) export _wCHILD_3_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
1BA0: 7F       RET                 (0159) export  wCHILD_3_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wCHILD_3_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wCHILD_3_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wCHILD_3_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA response3_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: CHILD_3_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
1BA1: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
1BA4: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  CHILD_3_TIMEOUT_EnableInt:
                                   (0200) _CHILD_3_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    CHILD_3_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: CHILD_3_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
1BA5: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
1BA7: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
1BA8: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
1BAA: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  CHILD_3_TIMEOUT_DisableInt:
                                   (0228) _CHILD_3_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    CHILD_3_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: CHILD_3_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
1BAB: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
1BAD: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
1BAE: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
1BB0: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  CHILD_3_TIMEOUT_Start:
                                   (0256) _CHILD_3_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    CHILD_3_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: CHILD_3_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
1BB1: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
1BB3: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
1BB4: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
1BB6: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  CHILD_3_TIMEOUT_Stop:
                                   (0284) _CHILD_3_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    CHILD_3_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: CHILD_3_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  CHILD_3_TIMEOUT_WritePeriod:
                                   (0313) _CHILD_3_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[CHILD_3_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[CHILD_3_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: CHILD_3_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call CHILD_3_TIMEOUT_Stop to disable).
1BB7: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
1BB8: 38 03    ADD   SP,3          (0334) ;
1BBA: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
1BBC: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
1BBD: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
1BBF: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
1BC0: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
1BC2: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
1BC3: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
1BC5: 5D 26    MOV   A,REG[38]     (0343) ;
1BC7: 54 01    MOV   [X+1],A       (0344)  CHILD_3_TIMEOUT_WriteCompareValue:
1BC9: 5D 22    MOV   A,REG[34]     (0345) _CHILD_3_TIMEOUT_WriteCompareValue:
1BCB: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
1BCD: 50 00    MOV   A,0           (0347)    mov   reg[CHILD_3_TIMEOUT_COMPARE_LSB_REG], A
1BCF: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
1BD2: A0 03    JZ    0x1BD6        (0349)    mov   reg[CHILD_3_TIMEOUT_COMPARE_MSB_REG], A
1BD4: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
1BD6: 54 00    MOV   [X+0],A       (0352) 
1BD8: 70 FE    AND   F,254         (0353) .ENDSECTION
1BDA: 41 23 FE AND   REG[35],254   (0354) 
1BDD: 18       POP   A             (0355) 
1BDE: 60 26    MOV   REG[38],A     (0356) .SECTION
1BE0: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
1BE1: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: CHILD_3_TIMEOUT_wReadCompareValue
1BE3: 18       POP   A             (0359) ;
1BE4: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
1BE6: 18       POP   A             (0361) ;     Reads the Compare registers.
1BE7: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
1BE8: 70 3F    AND   F,63
1BEA: 71 C0    OR    F,192         (0363) ;
1BEC: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  CHILD_3_TIMEOUT_wReadCompareValue:
                                   (0374) _CHILD_3_TIMEOUT_wReadCompareValue:
                                   (0375)  wCHILD_3_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wCHILD_3_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[CHILD_3_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[CHILD_3_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: CHILD_3_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
1BED: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
1BEF: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
1BF1: 5C       MOV   X,A           (0409) ;
1BF2: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
1BF5: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\child_3.asm
                                   (0121) ;;*****************************************************************************
1BF8: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: CHILD_3.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "CHILD_3.inc"
1BF9: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
1BFC: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   CHILD_3_EnableInt
                                   (0155) export  _CHILD_3_EnableInt
                                   (0156) export   CHILD_3_DisableInt
                                   (0157) export  _CHILD_3_DisableInt
                                   (0158) export   CHILD_3_Start
                                   (0159) export  _CHILD_3_Start
                                   (0160) export   CHILD_3_Stop
                                   (0161) export  _CHILD_3_Stop
                                   (0162) export   CHILD_3_bReadRxData
                                   (0163) export  _CHILD_3_bReadRxData
                                   (0164) export   CHILD_3_bReadRxStatus
                                   (0165) export  _CHILD_3_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bCHILD_3_ReadRxData
                                   (0170) export _bCHILD_3_ReadRxData
                                   (0171) export  bCHILD_3_ReadRxStatus
                                   (0172) export _bCHILD_3_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  CHILD_3_cGetChar
1BFD: 29 01    OR    A,1           (0179) export _CHILD_3_cGetChar
1BFF: 60 2B    MOV   REG[43],A     (0180) export  CHILD_3_cReadChar
                                   (0181) export _CHILD_3_cReadChar
1C01: 7F       RET                 (0182) export  CHILD_3_iReadChar
                                   (0183) export _CHILD_3_iReadChar
                                   (0184) 
                                   (0185) IF (CHILD_3_RXBUF_ENABLE)
                                   (0186) export  CHILD_3_CmdReset
                                   (0187) export _CHILD_3_CmdReset
                                   (0188) export  CHILD_3_bCmdCheck
                                   (0189) export _CHILD_3_bCmdCheck
                                   (0190) export  CHILD_3_bCmdLength
                                   (0191) export _CHILD_3_bCmdLength
                                   (0192) export  CHILD_3_bErrCheck
                                   (0193) export _CHILD_3_bErrCheck
                                   (0194) 
                                   (0195) export  CHILD_3_szGetParam
                                   (0196) export _CHILD_3_szGetParam
                                   (0197) export  CHILD_3_szGetRestOfParams
                                   (0198) export _CHILD_3_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA CHILD_3_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1C02: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1C05: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: CHILD_3_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  CHILD_3_EnableInt:
                                   (0238) _CHILD_3_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1C06: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask CHILD_3_INT_REG, CHILD_3_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1C08: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: CHILD_3_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  CHILD_3_DisableInt:
                                   (0267) _CHILD_3_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask CHILD_3_INT_REG, CHILD_3_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
1C09: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
1C0B: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: CHILD_3_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  CHILD_3_Start:
                                   (0297) _CHILD_3_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[CHILD_3_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: CHILD_3_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1C0C: 49 2B 08 TST   REG[43],8     (0311) ;
1C0F: AF FC    JZ    0x1C0C        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1C11: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1C13: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  CHILD_3_Stop:
                                   (0326) _CHILD_3_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[CHILD_3_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: CHILD_3_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1C14: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
1C16: 08       PUSH  A             (0347) ;
1C17: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
1C19: B0 04    JNZ   0x1C1E        (0349) ;    The A and X registers may be modified by this or future implementations
1C1B: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1C1C: 80 0B    JMP   0x1C28        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1C1E: 5D 2A    MOV   A,REG[42]     (0354) ;
1C20: 4B       SWAP  A,X           (0355)  CHILD_3_bReadRxData:
                                   (0356) _CHILD_3_bReadRxData:
1C21: 18       POP   A             (0357)  bCHILD_3_ReadRxData:
1C22: 21 A0    AND   A,160         (0358) _bCHILD_3_ReadRxData:
1C24: B0 03    JNZ   0x1C28        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1C26: 4B       SWAP  A,X           (0360)    mov A, REG[CHILD_3_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1C27: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1C28: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: CHILD_3_bReadRxStatus
                                   (0368) ;
1C2A: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  CHILD_3_bReadRxStatus:
                                   (0388) _CHILD_3_bReadRxStatus:
                                   (0389)  bCHILD_3_ReadRxStatus:
                                   (0390) _bCHILD_3_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[CHILD_3_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: CHILD_3_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1C2B: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1C2D: 21 E8    AND   A,232         (0408) ;
1C2F: 08       PUSH  A             (0409) ;  ARGUMENTS:
1C30: 21 08    AND   A,8           (0410) ;      none
1C32: B0 07    JNZ   0x1C3A        (0411) ;
1C34: 18       POP   A             (0412) ;  RETURNS:
1C35: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1C37: 4B       SWAP  A,X           (0414) ;
1C38: 80 07    JMP   0x1C40        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1C3A: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1C3B: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1C3D: 4B       SWAP  A,X           (0420) ;    functions.
1C3E: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1C40: 7F       RET                 (0426)  CHILD_3_cGetChar:
                                   (0427) _CHILD_3_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[CHILD_3_CONTROL_REG],CHILD_3_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[CHILD_3_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: CHILD_3_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  CHILD_3_cReadChar:
                                   (0463) _CHILD_3_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[CHILD_3_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,CHILD_3_RX_COMPLETE                              ; Check if a character is ready
1C41: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1C44: 55 38 00 MOV   [56],0        (0470)    pop  A
1C47: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1C4A: 55 D7 00 MOV   [CHILD+3],0   (0472) 
1C4D: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1C50: 55 13 00 MOV   [19],0        (0474)    mov  A,REG[CHILD_3_RX_BUFFER_REG]                       ; Read data first, then
1C53: 26 12 00 AND   [18],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1C56: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(CHILD_3_RX_PARITY_ERROR | CHILD_3_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_CHILD_3_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: CHILD_3_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1C57: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1C5A: 51 12    MOV   A,[18]        (0511) ;        0x40CC    Overrun Error
1C5C: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1C5E: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  CHILD_3_iReadChar:
                                   (0523) _CHILD_3_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[CHILD_3_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(CHILD_3_RX_ERROR|CHILD_3_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,CHILD_3_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,CHILD_3_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_CHILD_3_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,CHILD_3_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[CHILD_3_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_CHILD_3_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (CHILD_3_RXBUF_ENABLE)
                                   (0552) .SECTION
1C5F: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1C62: 51 12    MOV   A,[18]        (0554) ;-----------------------------------------------------------------------------
1C64: 21 F0    AND   A,240         (0555) ;
1C66: 26 12 0F AND   [18],15       (0556) ;     Command Buffer commands
                                   (0557) ;
1C69: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: CHILD_3_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  CHILD_3_CmdReset:
1C6A: 62 D0 00 MOV   REG[208],0    (0587) _CHILD_3_CmdReset:
1C6D: 51 13    MOV   A,[19]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >CHILD_3_aRxBuffer
1C6F: 7F       RET                 (0590)    mov [CHILD_3_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >CHILD_3_bRxCnt
                                   (0594)    mov [CHILD_3_bRxCnt], 0x00
                                   (0595)    and [CHILD_3_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: CHILD_3_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  CHILD_3_bCmdCheck:
                                   (0628) _CHILD_3_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >CHILD_3_fStatus
                                   (0631)    mov A,  [CHILD_3_fStatus]
                                   (0632)    and A, CHILD_3_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: CHILD_3_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1C70: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1C72: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1C75: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1C78: 50 38    MOV   A,56          (0648) ;     BYTE  fStatus - Status of command receive buffer.
1C7A: 02 D7    ADD   A,[CHILD+3]   (0649) ;                     Returns non-zero value in A if command is valid.
1C7C: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1C7D: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1C7F: B0 04    JNZ   0x1C84        (0653) ;           0x10 => Software Buffer OverRun
1C81: 10       PUSH  X             (0654) ;
1C82: 80 33    JMP   0x1CB6        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1C84: 39 00    CMP   A,0           (0660) ;    functions.
1C86: B0 11    JNZ   0x1C98        (0661) ;          
1C88: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1C89: 76 D7    INC   [CHILD+3]     (0663) ;          CUR_PP
1C8B: 52 00    MOV   A,[X+0]       (0664) ;
1C8D: 3C D7 0F CMP   [CHILD+3],15  (0665) ;     Error Status is clear when read.
1C90: BF F3    JNZ   0x1C84        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
1C92: 10       PUSH  X             (0669) ;
                                   (0670)  CHILD_3_bErrCheck:
1C93: 56 00 00 MOV   [X+0],0       (0671) _CHILD_3_bErrCheck:
1C96: 80 1F    JMP   0x1CB6        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >CHILD_3_fStatus
                                   (0674)    mov A,  [CHILD_3_fStatus]
1C98: 10       PUSH  X             (0675)    and A, CHILD_3_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [CHILD_3_fStatus], ~CHILD_3_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
1C99: 75       INC   X             (0679) .ENDSECTION
1C9A: 76 D7    INC   [CHILD+3]     (0680) 
1C9C: 3C D7 0F CMP   [CHILD+3],15  (0681) .SECTION
1C9F: AF F3    JZ    0x1C93        (0682) ;-----------------------------------------------------------------------------
1CA1: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: CHILD_3_bCmdLength
1CA3: A0 12    JZ    0x1CB6        (0684) ;
1CA5: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1CA7: BF F1    JNZ   0x1C99        (0686) ;     Get length of command string
                                   (0687) ;
1CA9: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
1CAC: 76 D7    INC   [CHILD+3]     (0689) ;     none.
1CAE: 3C D7 0F CMP   [CHILD+3],15  (0690) ;
1CB1: B0 04    JNZ   0x1CB6        (0691) ;  RETURNS:
1CB3: 55 D7 0F MOV   [CHILD+3],15  (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1CB6: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1CB7: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
1CB8: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1CBB: B0 0B    JNZ   0x1CC7        (0699) ;    functions.
1CBD: 20       POP   X             (0700) ;          
1CBE: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
1CC0: 50 00    MOV   A,0           (0702) ;          CUR_PP
1CC2: 70 3F    AND   F,63
1CC4: 71 C0    OR    F,192         (0703) ;
                                   (0704)  CHILD_3_bCmdLength:
1CC6: 7F       RET                 (0705) _CHILD_3_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >CHILD_3_bRxCnt
1CC7: 20       POP   X             (0708)    mov A,  [CHILD_3_bRxCnt]
1CC8: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1CCA: 70 3F    AND   F,63
1CCC: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1CCE: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: CHILD_3_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1CCF: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1CD2: 50 38    MOV   A,56          (0744) ;     each lexically distinct element into a null-terminated string by replacing
1CD4: 02 D7    ADD   A,[CHILD+3]   (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
1CD6: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
1CD7: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     CHILD_3_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, CHILD_3_szGetParam, is
1CDA: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\child_2int.asm
1CDB: 10       PUSH  X             (0104) ;;*****************************************************************************
1CDC: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: CHILD_2INT.asm
1CDE: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1CDF: 58 15    MOV   X,[21]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1CE1: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
1CE3: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1CE4: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1CE6: B0 04    JNZ   0x1CEB        (0115) 
1CE8: 18       POP   A             (0116) include "m8c.inc"
1CE9: 80 5E    JMP   0x1D48        (0117) include "memory.inc"
                                   (0118) include "CHILD_2.inc"
                                   (0119) 
                                   (0120) 
1CEB: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1CEC: 21 E0    AND   A,224         (0124) export  _CHILD_2_ISR
1CEE: A0 12    JZ    0x1D01        (0125) 
                                   (0126) 
1CF0: 2C 14    OR    [20],A        (0127) IF (CHILD_2_RXBUF_ENABLE)
                                   (0128) export  CHILD_2_aRxBuffer
1CF2: 49 2A 00 TST   REG[42],0     (0129) export _CHILD_2_aRxBuffer
                                   (0130) export  CHILD_2_bRxCnt
1CF5: 21 20    AND   A,32          (0131) export _CHILD_2_bRxCnt
1CF7: A0 50    JZ    0x1D48        (0132) export  CHILD_2_fStatus
                                   (0133) export _CHILD_2_fStatus
                                   (0134) ENDIF
                                   (0135) 
1CF9: 41 2B FE AND   REG[43],254   (0136) 
1CFC: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
1CFF: 80 48    JMP   0x1D48        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (CHILD_2_RXBUF_ENABLE)
1D01: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  CHILD_2_fStatus:
                                   (0144) _CHILD_2_fStatus:      BLK  1
1D03: 47 14 01 TST   [20],1        (0145)  CHILD_2_bRxCnt:
1D06: B0 41    JNZ   0x1D48        (0146) _CHILD_2_bRxCnt:       BLK  1
                                   (0147) AREA CHILD_2_RAM(RAM,REL,CON)
1D08: 39 00    CMP   A,0           (0148)  CHILD_2_aRxBuffer:    
1D0A: B0 14    JNZ   0x1D1F        (0149) _CHILD_2_aRxBuffer:    BLK CHILD_2_RX_BUFFER_SIZE
1D0C: 2E 14 01 OR    [20],1        (0150) ENDIF
                                   (0151) 
1D0F: 62 D3 00 MOV   REG[211],0    (0152) 
1D12: 70 3F    AND   F,63
1D14: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1D16: 56 98 00 MOV   [X-104],0     (0154) 
1D19: 70 3F    AND   F,63
1D1B: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
1D1D: 80 2A    JMP   0x1D48        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1D1F: 3C 15 0F CMP   [21],15       (0167) ;------------------------
1D22: C0 14    JC    0x1D37        (0168) 
1D24: 2E 14 10 OR    [20],16       (0169) 
                                   (0170) ;------------------------
1D27: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
1D2A: 70 3F    AND   F,63
1D2C: 71 80    OR    F,128         (0172) ;------------------------
1D2E: 56 98 00 MOV   [X-104],0     (0173) 
1D31: 70 3F    AND   F,63
1D33: 71 00    OR    F,0           (0174) 
1D35: 80 12    JMP   0x1D48        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1D37: 75       INC   X             (0179) 
1D38: 5A 15    MOV   [21],X        (0180) 
1D3A: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1D3B: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1D3E: 70 3F    AND   F,63
1D40: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _CHILD_2_ISR
1D42: 54 98    MOV   [X-104],A     (0185) ;
1D44: 70 3F    AND   F,63
1D46: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1D48: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1D49: 60 D3    MOV   REG[211],A    (0191) _CHILD_2_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1D4B: 20       POP   X             (0195)    ; Insert your custom code below this banner
1D4C: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1D4E: 43 E1 02 OR    REG[225],2    (0201)    ; Insert your custom code above this banner

FILE: lib\child_2_timeout.asm
                                   (0102) ;;*****************************************************************************
1D51: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: CHILD_2_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "CHILD_2_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
1D52: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
1D55: 7F       RET                 (0131) export  CHILD_2_TIMEOUT_EnableInt
                                   (0132) export _CHILD_2_TIMEOUT_EnableInt
                                   (0133) export  CHILD_2_TIMEOUT_DisableInt
                                   (0134) export _CHILD_2_TIMEOUT_DisableInt
                                   (0135) export  CHILD_2_TIMEOUT_Start
                                   (0136) export _CHILD_2_TIMEOUT_Start
                                   (0137) export  CHILD_2_TIMEOUT_Stop
                                   (0138) export _CHILD_2_TIMEOUT_Stop
                                   (0139) export  CHILD_2_TIMEOUT_WritePeriod
                                   (0140) export _CHILD_2_TIMEOUT_WritePeriod
                                   (0141) export  CHILD_2_TIMEOUT_WriteCompareValue
                                   (0142) export _CHILD_2_TIMEOUT_WriteCompareValue
                                   (0143) export  CHILD_2_TIMEOUT_wReadCompareValue
                                   (0144) export _CHILD_2_TIMEOUT_wReadCompareValue
                                   (0145) export  CHILD_2_TIMEOUT_wReadTimer
                                   (0146) export _CHILD_2_TIMEOUT_wReadTimer
                                   (0147) export  CHILD_2_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _CHILD_2_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wCHILD_2_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wCHILD_2_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wCHILD_2_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wCHILD_2_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wCHILD_2_TIMEOUT_ReadTimerSaveCV   ; deprecated
1D56: 43 23 01 OR    REG[35],1     (0157) export _wCHILD_2_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
1D59: 7F       RET                 (0159) export  wCHILD_2_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wCHILD_2_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wCHILD_2_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wCHILD_2_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA response2_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: CHILD_2_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
1D5A: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
1D5D: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  CHILD_2_TIMEOUT_EnableInt:
                                   (0200) _CHILD_2_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    CHILD_2_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: CHILD_2_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
1D5E: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
1D60: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
1D61: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
1D63: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  CHILD_2_TIMEOUT_DisableInt:
                                   (0228) _CHILD_2_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    CHILD_2_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: CHILD_2_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
1D64: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
1D66: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
1D67: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
1D69: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  CHILD_2_TIMEOUT_Start:
                                   (0256) _CHILD_2_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    CHILD_2_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: CHILD_2_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
1D6A: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
1D6C: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
1D6D: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
1D6F: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  CHILD_2_TIMEOUT_Stop:
                                   (0284) _CHILD_2_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    CHILD_2_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: CHILD_2_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  CHILD_2_TIMEOUT_WritePeriod:
                                   (0313) _CHILD_2_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[CHILD_2_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[CHILD_2_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: CHILD_2_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call CHILD_2_TIMEOUT_Stop to disable).
1D70: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
1D71: 38 03    ADD   SP,3          (0334) ;
1D73: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
1D75: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
1D76: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
1D78: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
1D79: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
1D7B: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
1D7C: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
1D7E: 5D 26    MOV   A,REG[38]     (0343) ;
1D80: 54 01    MOV   [X+1],A       (0344)  CHILD_2_TIMEOUT_WriteCompareValue:
1D82: 5D 22    MOV   A,REG[34]     (0345) _CHILD_2_TIMEOUT_WriteCompareValue:
1D84: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
1D86: 50 00    MOV   A,0           (0347)    mov   reg[CHILD_2_TIMEOUT_COMPARE_LSB_REG], A
1D88: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
1D8B: A0 03    JZ    0x1D8F        (0349)    mov   reg[CHILD_2_TIMEOUT_COMPARE_MSB_REG], A
1D8D: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
1D8F: 54 00    MOV   [X+0],A       (0352) 
1D91: 70 FE    AND   F,254         (0353) .ENDSECTION
1D93: 41 23 FE AND   REG[35],254   (0354) 
1D96: 18       POP   A             (0355) 
1D97: 60 26    MOV   REG[38],A     (0356) .SECTION
1D99: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
1D9A: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: CHILD_2_TIMEOUT_wReadCompareValue
1D9C: 18       POP   A             (0359) ;
1D9D: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
1D9F: 18       POP   A             (0361) ;     Reads the Compare registers.
1DA0: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
1DA1: 70 3F    AND   F,63
1DA3: 71 C0    OR    F,192         (0363) ;
1DA5: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  CHILD_2_TIMEOUT_wReadCompareValue:
                                   (0374) _CHILD_2_TIMEOUT_wReadCompareValue:
                                   (0375)  wCHILD_2_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wCHILD_2_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[CHILD_2_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[CHILD_2_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: CHILD_2_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
1DA6: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
1DA8: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
1DAA: 5C       MOV   X,A           (0409) ;
1DAB: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
1DAE: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\child_2.asm
                                   (0121) ;;*****************************************************************************
1DB1: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: CHILD_2.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "CHILD_2.inc"
1DB2: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
1DB5: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   CHILD_2_EnableInt
                                   (0155) export  _CHILD_2_EnableInt
                                   (0156) export   CHILD_2_DisableInt
                                   (0157) export  _CHILD_2_DisableInt
                                   (0158) export   CHILD_2_Start
                                   (0159) export  _CHILD_2_Start
                                   (0160) export   CHILD_2_Stop
                                   (0161) export  _CHILD_2_Stop
                                   (0162) export   CHILD_2_bReadRxData
                                   (0163) export  _CHILD_2_bReadRxData
                                   (0164) export   CHILD_2_bReadRxStatus
                                   (0165) export  _CHILD_2_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bCHILD_2_ReadRxData
                                   (0170) export _bCHILD_2_ReadRxData
                                   (0171) export  bCHILD_2_ReadRxStatus
                                   (0172) export _bCHILD_2_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  CHILD_2_cGetChar
1DB6: 29 01    OR    A,1           (0179) export _CHILD_2_cGetChar
1DB8: 60 2B    MOV   REG[43],A     (0180) export  CHILD_2_cReadChar
                                   (0181) export _CHILD_2_cReadChar
1DBA: 7F       RET                 (0182) export  CHILD_2_iReadChar
                                   (0183) export _CHILD_2_iReadChar
                                   (0184) 
                                   (0185) IF (CHILD_2_RXBUF_ENABLE)
                                   (0186) export  CHILD_2_CmdReset
                                   (0187) export _CHILD_2_CmdReset
                                   (0188) export  CHILD_2_bCmdCheck
                                   (0189) export _CHILD_2_bCmdCheck
                                   (0190) export  CHILD_2_bCmdLength
                                   (0191) export _CHILD_2_bCmdLength
                                   (0192) export  CHILD_2_bErrCheck
                                   (0193) export _CHILD_2_bErrCheck
                                   (0194) 
                                   (0195) export  CHILD_2_szGetParam
                                   (0196) export _CHILD_2_szGetParam
                                   (0197) export  CHILD_2_szGetRestOfParams
                                   (0198) export _CHILD_2_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA CHILD_2_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1DBB: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1DBE: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: CHILD_2_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  CHILD_2_EnableInt:
                                   (0238) _CHILD_2_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1DBF: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask CHILD_2_INT_REG, CHILD_2_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1DC1: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: CHILD_2_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  CHILD_2_DisableInt:
                                   (0267) _CHILD_2_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask CHILD_2_INT_REG, CHILD_2_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
1DC2: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
1DC4: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: CHILD_2_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  CHILD_2_Start:
                                   (0297) _CHILD_2_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[CHILD_2_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: CHILD_2_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1DC5: 49 2B 08 TST   REG[43],8     (0311) ;
1DC8: AF FC    JZ    0x1DC5        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1DCA: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1DCC: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  CHILD_2_Stop:
                                   (0326) _CHILD_2_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[CHILD_2_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: CHILD_2_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1DCD: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
1DCF: 08       PUSH  A             (0347) ;
1DD0: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
1DD2: B0 04    JNZ   0x1DD7        (0349) ;    The A and X registers may be modified by this or future implementations
1DD4: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1DD5: 80 0B    JMP   0x1DE1        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1DD7: 5D 2A    MOV   A,REG[42]     (0354) ;
1DD9: 4B       SWAP  A,X           (0355)  CHILD_2_bReadRxData:
                                   (0356) _CHILD_2_bReadRxData:
1DDA: 18       POP   A             (0357)  bCHILD_2_ReadRxData:
1DDB: 21 A0    AND   A,160         (0358) _bCHILD_2_ReadRxData:
1DDD: B0 03    JNZ   0x1DE1        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1DDF: 4B       SWAP  A,X           (0360)    mov A, REG[CHILD_2_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1DE0: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1DE1: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: CHILD_2_bReadRxStatus
                                   (0368) ;
1DE3: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  CHILD_2_bReadRxStatus:
                                   (0388) _CHILD_2_bReadRxStatus:
                                   (0389)  bCHILD_2_ReadRxStatus:
                                   (0390) _bCHILD_2_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[CHILD_2_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: CHILD_2_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1DE4: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1DE6: 21 E8    AND   A,232         (0408) ;
1DE8: 08       PUSH  A             (0409) ;  ARGUMENTS:
1DE9: 21 08    AND   A,8           (0410) ;      none
1DEB: B0 07    JNZ   0x1DF3        (0411) ;
1DED: 18       POP   A             (0412) ;  RETURNS:
1DEE: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1DF0: 4B       SWAP  A,X           (0414) ;
1DF1: 80 07    JMP   0x1DF9        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1DF3: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1DF4: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1DF6: 4B       SWAP  A,X           (0420) ;    functions.
1DF7: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1DF9: 7F       RET                 (0426)  CHILD_2_cGetChar:
                                   (0427) _CHILD_2_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[CHILD_2_CONTROL_REG],CHILD_2_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[CHILD_2_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: CHILD_2_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  CHILD_2_cReadChar:
                                   (0463) _CHILD_2_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[CHILD_2_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,CHILD_2_RX_COMPLETE                              ; Check if a character is ready
1DFA: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1DFD: 55 98 00 MOV   [152],0       (0470)    pop  A
1E00: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1E03: 55 D6 00 MOV   [CHILD+2],0   (0472) 
1E06: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1E09: 55 15 00 MOV   [21],0        (0474)    mov  A,REG[CHILD_2_RX_BUFFER_REG]                       ; Read data first, then
1E0C: 26 14 00 AND   [20],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1E0F: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(CHILD_2_RX_PARITY_ERROR | CHILD_2_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_CHILD_2_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: CHILD_2_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1E10: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1E13: 51 14    MOV   A,[20]        (0511) ;        0x40CC    Overrun Error
1E15: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1E17: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  CHILD_2_iReadChar:
                                   (0523) _CHILD_2_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[CHILD_2_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(CHILD_2_RX_ERROR|CHILD_2_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,CHILD_2_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,CHILD_2_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_CHILD_2_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,CHILD_2_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[CHILD_2_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_CHILD_2_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (CHILD_2_RXBUF_ENABLE)
                                   (0552) .SECTION
1E18: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1E1B: 51 14    MOV   A,[20]        (0554) ;-----------------------------------------------------------------------------
1E1D: 21 F0    AND   A,240         (0555) ;
1E1F: 26 14 0F AND   [20],15       (0556) ;     Command Buffer commands
                                   (0557) ;
1E22: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: CHILD_2_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  CHILD_2_CmdReset:
1E23: 62 D0 00 MOV   REG[208],0    (0587) _CHILD_2_CmdReset:
1E26: 51 15    MOV   A,[21]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >CHILD_2_aRxBuffer
1E28: 7F       RET                 (0590)    mov [CHILD_2_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >CHILD_2_bRxCnt
                                   (0594)    mov [CHILD_2_bRxCnt], 0x00
                                   (0595)    and [CHILD_2_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: CHILD_2_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  CHILD_2_bCmdCheck:
                                   (0628) _CHILD_2_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >CHILD_2_fStatus
                                   (0631)    mov A,  [CHILD_2_fStatus]
                                   (0632)    and A, CHILD_2_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: CHILD_2_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1E29: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1E2B: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1E2E: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1E31: 50 98    MOV   A,152         (0648) ;     BYTE  fStatus - Status of command receive buffer.
1E33: 02 D6    ADD   A,[CHILD+2]   (0649) ;                     Returns non-zero value in A if command is valid.
1E35: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1E36: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1E38: B0 04    JNZ   0x1E3D        (0653) ;           0x10 => Software Buffer OverRun
1E3A: 10       PUSH  X             (0654) ;
1E3B: 80 33    JMP   0x1E6F        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1E3D: 39 00    CMP   A,0           (0660) ;    functions.
1E3F: B0 11    JNZ   0x1E51        (0661) ;          
1E41: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1E42: 76 D6    INC   [CHILD+2]     (0663) ;          CUR_PP
1E44: 52 00    MOV   A,[X+0]       (0664) ;
1E46: 3C D6 0F CMP   [CHILD+2],15  (0665) ;     Error Status is clear when read.
1E49: BF F3    JNZ   0x1E3D        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
1E4B: 10       PUSH  X             (0669) ;
                                   (0670)  CHILD_2_bErrCheck:
1E4C: 56 00 00 MOV   [X+0],0       (0671) _CHILD_2_bErrCheck:
1E4F: 80 1F    JMP   0x1E6F        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >CHILD_2_fStatus
                                   (0674)    mov A,  [CHILD_2_fStatus]
1E51: 10       PUSH  X             (0675)    and A, CHILD_2_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [CHILD_2_fStatus], ~CHILD_2_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
1E52: 75       INC   X             (0679) .ENDSECTION
1E53: 76 D6    INC   [CHILD+2]     (0680) 
1E55: 3C D6 0F CMP   [CHILD+2],15  (0681) .SECTION
1E58: AF F3    JZ    0x1E4C        (0682) ;-----------------------------------------------------------------------------
1E5A: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: CHILD_2_bCmdLength
1E5C: A0 12    JZ    0x1E6F        (0684) ;
1E5E: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
1E60: BF F1    JNZ   0x1E52        (0686) ;     Get length of command string
                                   (0687) ;
1E62: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
1E65: 76 D6    INC   [CHILD+2]     (0689) ;     none.
1E67: 3C D6 0F CMP   [CHILD+2],15  (0690) ;
1E6A: B0 04    JNZ   0x1E6F        (0691) ;  RETURNS:
1E6C: 55 D6 0F MOV   [CHILD+2],15  (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
1E6F: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
1E70: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
1E71: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
1E74: B0 0B    JNZ   0x1E80        (0699) ;    functions.
1E76: 20       POP   X             (0700) ;          
1E77: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
1E79: 50 00    MOV   A,0           (0702) ;          CUR_PP
1E7B: 70 3F    AND   F,63
1E7D: 71 C0    OR    F,192         (0703) ;
                                   (0704)  CHILD_2_bCmdLength:
1E7F: 7F       RET                 (0705) _CHILD_2_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >CHILD_2_bRxCnt
1E80: 20       POP   X             (0708)    mov A,  [CHILD_2_bRxCnt]
1E81: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
1E83: 70 3F    AND   F,63
1E85: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
1E87: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: CHILD_2_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
1E88: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
1E8B: 50 98    MOV   A,152         (0744) ;     each lexically distinct element into a null-terminated string by replacing
1E8D: 02 D6    ADD   A,[CHILD+2]   (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
1E8F: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
1E90: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     CHILD_2_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, CHILD_2_szGetParam, is
1E93: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\child_1int.asm
1E94: 10       PUSH  X             (0104) ;;*****************************************************************************
1E95: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: CHILD_1INT.asm
1E97: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
1E98: 58 17    MOV   X,[23]        (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
1E9A: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
1E9C: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
1E9D: 21 08    AND   A,8           (0114) ;;*****************************************************************************
1E9F: B0 04    JNZ   0x1EA4        (0115) 
1EA1: 18       POP   A             (0116) include "m8c.inc"
1EA2: 80 5E    JMP   0x1F01        (0117) include "memory.inc"
                                   (0118) include "CHILD_1.inc"
                                   (0119) 
                                   (0120) 
1EA4: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
1EA5: 21 E0    AND   A,224         (0124) export  _CHILD_1_ISR
1EA7: A0 12    JZ    0x1EBA        (0125) 
                                   (0126) 
1EA9: 2C 16    OR    [22],A        (0127) IF (CHILD_1_RXBUF_ENABLE)
                                   (0128) export  CHILD_1_aRxBuffer
1EAB: 49 2A 00 TST   REG[42],0     (0129) export _CHILD_1_aRxBuffer
                                   (0130) export  CHILD_1_bRxCnt
1EAE: 21 20    AND   A,32          (0131) export _CHILD_1_bRxCnt
1EB0: A0 50    JZ    0x1F01        (0132) export  CHILD_1_fStatus
                                   (0133) export _CHILD_1_fStatus
                                   (0134) ENDIF
                                   (0135) 
1EB2: 41 2B FE AND   REG[43],254   (0136) 
1EB5: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
1EB8: 80 48    JMP   0x1F01        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (CHILD_1_RXBUF_ENABLE)
1EBA: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  CHILD_1_fStatus:
                                   (0144) _CHILD_1_fStatus:      BLK  1
1EBC: 47 16 01 TST   [22],1        (0145)  CHILD_1_bRxCnt:
1EBF: B0 41    JNZ   0x1F01        (0146) _CHILD_1_bRxCnt:       BLK  1
                                   (0147) AREA CHILD_1_RAM(RAM,REL,CON)
1EC1: 39 00    CMP   A,0           (0148)  CHILD_1_aRxBuffer:    
1EC3: B0 14    JNZ   0x1ED8        (0149) _CHILD_1_aRxBuffer:    BLK CHILD_1_RX_BUFFER_SIZE
1EC5: 2E 16 01 OR    [22],1        (0150) ENDIF
                                   (0151) 
1EC8: 62 D3 00 MOV   REG[211],0    (0152) 
1ECB: 70 3F    AND   F,63
1ECD: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
1ECF: 56 A8 00 MOV   [X-88],0      (0154) 
1ED2: 70 3F    AND   F,63
1ED4: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
1ED6: 80 2A    JMP   0x1F01        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
1ED8: 3C 17 0F CMP   [23],15       (0167) ;------------------------
1EDB: C0 14    JC    0x1EF0        (0168) 
1EDD: 2E 16 10 OR    [22],16       (0169) 
                                   (0170) ;------------------------
1EE0: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
1EE3: 70 3F    AND   F,63
1EE5: 71 80    OR    F,128         (0172) ;------------------------
1EE7: 56 A8 00 MOV   [X-88],0      (0173) 
1EEA: 70 3F    AND   F,63
1EEC: 71 00    OR    F,0           (0174) 
1EEE: 80 12    JMP   0x1F01        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
1EF0: 75       INC   X             (0179) 
1EF1: 5A 17    MOV   [23],X        (0180) 
1EF3: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
1EF4: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
1EF7: 70 3F    AND   F,63
1EF9: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _CHILD_1_ISR
1EFB: 54 A8    MOV   [X-88],A      (0185) ;
1EFD: 70 3F    AND   F,63
1EFF: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
1F01: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
1F02: 60 D3    MOV   REG[211],A    (0191) _CHILD_1_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
1F04: 20       POP   X             (0195)    ; Insert your custom code below this banner
1F05: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
1F07: 43 E1 02 OR    REG[225],2    (0201)    ; Insert your custom code above this banner

FILE: lib\child_1_timeout.asm
                                   (0102) ;;*****************************************************************************
1F0A: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: CHILD_1_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "CHILD_1_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
1F0B: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
1F0E: 7F       RET                 (0131) export  CHILD_1_TIMEOUT_EnableInt
                                   (0132) export _CHILD_1_TIMEOUT_EnableInt
                                   (0133) export  CHILD_1_TIMEOUT_DisableInt
                                   (0134) export _CHILD_1_TIMEOUT_DisableInt
                                   (0135) export  CHILD_1_TIMEOUT_Start
                                   (0136) export _CHILD_1_TIMEOUT_Start
                                   (0137) export  CHILD_1_TIMEOUT_Stop
                                   (0138) export _CHILD_1_TIMEOUT_Stop
                                   (0139) export  CHILD_1_TIMEOUT_WritePeriod
                                   (0140) export _CHILD_1_TIMEOUT_WritePeriod
                                   (0141) export  CHILD_1_TIMEOUT_WriteCompareValue
                                   (0142) export _CHILD_1_TIMEOUT_WriteCompareValue
                                   (0143) export  CHILD_1_TIMEOUT_wReadCompareValue
                                   (0144) export _CHILD_1_TIMEOUT_wReadCompareValue
                                   (0145) export  CHILD_1_TIMEOUT_wReadTimer
                                   (0146) export _CHILD_1_TIMEOUT_wReadTimer
                                   (0147) export  CHILD_1_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _CHILD_1_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wCHILD_1_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wCHILD_1_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wCHILD_1_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wCHILD_1_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wCHILD_1_TIMEOUT_ReadTimerSaveCV   ; deprecated
1F0F: 43 23 01 OR    REG[35],1     (0157) export _wCHILD_1_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
1F12: 7F       RET                 (0159) export  wCHILD_1_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wCHILD_1_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wCHILD_1_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wCHILD_1_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA response1_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: CHILD_1_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
1F13: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
1F16: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  CHILD_1_TIMEOUT_EnableInt:
                                   (0200) _CHILD_1_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    CHILD_1_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: CHILD_1_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
1F17: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
1F19: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
1F1A: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
1F1C: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  CHILD_1_TIMEOUT_DisableInt:
                                   (0228) _CHILD_1_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    CHILD_1_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: CHILD_1_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
1F1D: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
1F1F: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
1F20: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
1F22: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  CHILD_1_TIMEOUT_Start:
                                   (0256) _CHILD_1_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    CHILD_1_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: CHILD_1_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
1F23: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
1F25: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
1F26: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
1F28: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  CHILD_1_TIMEOUT_Stop:
                                   (0284) _CHILD_1_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    CHILD_1_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: CHILD_1_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  CHILD_1_TIMEOUT_WritePeriod:
                                   (0313) _CHILD_1_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[CHILD_1_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[CHILD_1_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: CHILD_1_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call CHILD_1_TIMEOUT_Stop to disable).
1F29: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
1F2A: 38 03    ADD   SP,3          (0334) ;
1F2C: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
1F2E: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
1F2F: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
1F31: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
1F32: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
1F34: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
1F35: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
1F37: 5D 26    MOV   A,REG[38]     (0343) ;
1F39: 54 01    MOV   [X+1],A       (0344)  CHILD_1_TIMEOUT_WriteCompareValue:
1F3B: 5D 22    MOV   A,REG[34]     (0345) _CHILD_1_TIMEOUT_WriteCompareValue:
1F3D: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
1F3F: 50 00    MOV   A,0           (0347)    mov   reg[CHILD_1_TIMEOUT_COMPARE_LSB_REG], A
1F41: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
1F44: A0 03    JZ    0x1F48        (0349)    mov   reg[CHILD_1_TIMEOUT_COMPARE_MSB_REG], A
1F46: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
1F48: 54 00    MOV   [X+0],A       (0352) 
1F4A: 70 FE    AND   F,254         (0353) .ENDSECTION
1F4C: 41 23 FE AND   REG[35],254   (0354) 
1F4F: 18       POP   A             (0355) 
1F50: 60 26    MOV   REG[38],A     (0356) .SECTION
1F52: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
1F53: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: CHILD_1_TIMEOUT_wReadCompareValue
1F55: 18       POP   A             (0359) ;
1F56: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
1F58: 18       POP   A             (0361) ;     Reads the Compare registers.
1F59: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
1F5A: 70 3F    AND   F,63
1F5C: 71 C0    OR    F,192         (0363) ;
1F5E: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  CHILD_1_TIMEOUT_wReadCompareValue:
                                   (0374) _CHILD_1_TIMEOUT_wReadCompareValue:
                                   (0375)  wCHILD_1_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0376) _wCHILD_1_TIMEOUT_ReadCompareValue:                ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[CHILD_1_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[CHILD_1_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: CHILD_1_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
1F5F: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
1F61: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
1F63: 5C       MOV   X,A           (0409) ;
1F64: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
1F67: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\child_1.asm
                                   (0121) ;;*****************************************************************************
1F6A: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: CHILD_1.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "CHILD_1.inc"
1F6B: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
1F6E: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   CHILD_1_EnableInt
                                   (0155) export  _CHILD_1_EnableInt
                                   (0156) export   CHILD_1_DisableInt
                                   (0157) export  _CHILD_1_DisableInt
                                   (0158) export   CHILD_1_Start
                                   (0159) export  _CHILD_1_Start
                                   (0160) export   CHILD_1_Stop
                                   (0161) export  _CHILD_1_Stop
                                   (0162) export   CHILD_1_bReadRxData
                                   (0163) export  _CHILD_1_bReadRxData
                                   (0164) export   CHILD_1_bReadRxStatus
                                   (0165) export  _CHILD_1_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bCHILD_1_ReadRxData
                                   (0170) export _bCHILD_1_ReadRxData
                                   (0171) export  bCHILD_1_ReadRxStatus
                                   (0172) export _bCHILD_1_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  CHILD_1_cGetChar
1F6F: 29 01    OR    A,1           (0179) export _CHILD_1_cGetChar
1F71: 60 2B    MOV   REG[43],A     (0180) export  CHILD_1_cReadChar
                                   (0181) export _CHILD_1_cReadChar
1F73: 7F       RET                 (0182) export  CHILD_1_iReadChar
                                   (0183) export _CHILD_1_iReadChar
                                   (0184) 
                                   (0185) IF (CHILD_1_RXBUF_ENABLE)
                                   (0186) export  CHILD_1_CmdReset
                                   (0187) export _CHILD_1_CmdReset
                                   (0188) export  CHILD_1_bCmdCheck
                                   (0189) export _CHILD_1_bCmdCheck
                                   (0190) export  CHILD_1_bCmdLength
                                   (0191) export _CHILD_1_bCmdLength
                                   (0192) export  CHILD_1_bErrCheck
                                   (0193) export _CHILD_1_bErrCheck
                                   (0194) 
                                   (0195) export  CHILD_1_szGetParam
                                   (0196) export _CHILD_1_szGetParam
                                   (0197) export  CHILD_1_szGetRestOfParams
                                   (0198) export _CHILD_1_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA CHILD_1_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
1F74: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
1F77: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: CHILD_1_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  CHILD_1_EnableInt:
                                   (0238) _CHILD_1_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
1F78: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask CHILD_1_INT_REG, CHILD_1_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
1F7A: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: CHILD_1_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  CHILD_1_DisableInt:
                                   (0267) _CHILD_1_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask CHILD_1_INT_REG, CHILD_1_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
1F7B: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
1F7D: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: CHILD_1_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  CHILD_1_Start:
                                   (0297) _CHILD_1_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[CHILD_1_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: CHILD_1_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
1F7E: 49 2B 08 TST   REG[43],8     (0311) ;
1F81: AF FC    JZ    0x1F7E        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
1F83: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
1F85: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  CHILD_1_Stop:
                                   (0326) _CHILD_1_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[CHILD_1_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: CHILD_1_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
1F86: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
1F88: 08       PUSH  A             (0347) ;
1F89: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
1F8B: B0 04    JNZ   0x1F90        (0349) ;    The A and X registers may be modified by this or future implementations
1F8D: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
1F8E: 80 0B    JMP   0x1F9A        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
1F90: 5D 2A    MOV   A,REG[42]     (0354) ;
1F92: 4B       SWAP  A,X           (0355)  CHILD_1_bReadRxData:
                                   (0356) _CHILD_1_bReadRxData:
1F93: 18       POP   A             (0357)  bCHILD_1_ReadRxData:
1F94: 21 A0    AND   A,160         (0358) _bCHILD_1_ReadRxData:
1F96: B0 03    JNZ   0x1F9A        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
1F98: 4B       SWAP  A,X           (0360)    mov A, REG[CHILD_1_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
1F99: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
1F9A: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: CHILD_1_bReadRxStatus
                                   (0368) ;
1F9C: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  CHILD_1_bReadRxStatus:
                                   (0388) _CHILD_1_bReadRxStatus:
                                   (0389)  bCHILD_1_ReadRxStatus:
                                   (0390) _bCHILD_1_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[CHILD_1_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: CHILD_1_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
1F9D: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
1F9F: 21 E8    AND   A,232         (0408) ;
1FA1: 08       PUSH  A             (0409) ;  ARGUMENTS:
1FA2: 21 08    AND   A,8           (0410) ;      none
1FA4: B0 07    JNZ   0x1FAC        (0411) ;
1FA6: 18       POP   A             (0412) ;  RETURNS:
1FA7: 29 01    OR    A,1           (0413) ;     char that is returned from UART
1FA9: 4B       SWAP  A,X           (0414) ;
1FAA: 80 07    JMP   0x1FB2        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
1FAC: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
1FAD: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
1FAF: 4B       SWAP  A,X           (0420) ;    functions.
1FB0: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
1FB2: 7F       RET                 (0426)  CHILD_1_cGetChar:
                                   (0427) _CHILD_1_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[CHILD_1_CONTROL_REG],CHILD_1_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[CHILD_1_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: CHILD_1_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  CHILD_1_cReadChar:
                                   (0463) _CHILD_1_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[CHILD_1_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,CHILD_1_RX_COMPLETE                              ; Check if a character is ready
1FB3: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
1FB6: 55 A8 00 MOV   [168],0       (0470)    pop  A
1FB9: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
1FBC: 55 D5 00 MOV   [CHILD+1],0   (0472) 
1FBF: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
1FC2: 55 17 00 MOV   [23],0        (0474)    mov  A,REG[CHILD_1_RX_BUFFER_REG]                       ; Read data first, then
1FC5: 26 16 00 AND   [22],0        (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
1FC8: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(CHILD_1_RX_PARITY_ERROR | CHILD_1_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_CHILD_1_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: CHILD_1_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
1FC9: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
1FCC: 51 16    MOV   A,[22]        (0511) ;        0x40CC    Overrun Error
1FCE: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
1FD0: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  CHILD_1_iReadChar:
                                   (0523) _CHILD_1_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[CHILD_1_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(CHILD_1_RX_ERROR|CHILD_1_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,CHILD_1_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,CHILD_1_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_CHILD_1_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,CHILD_1_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[CHILD_1_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_CHILD_1_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (CHILD_1_RXBUF_ENABLE)
                                   (0552) .SECTION
1FD1: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
1FD4: 51 16    MOV   A,[22]        (0554) ;-----------------------------------------------------------------------------
1FD6: 21 F0    AND   A,240         (0555) ;
1FD8: 26 16 0F AND   [22],15       (0556) ;     Command Buffer commands
                                   (0557) ;
1FDB: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: CHILD_1_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  CHILD_1_CmdReset:
1FDC: 62 D0 00 MOV   REG[208],0    (0587) _CHILD_1_CmdReset:
1FDF: 51 17    MOV   A,[23]        (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >CHILD_1_aRxBuffer
1FE1: 7F       RET                 (0590)    mov [CHILD_1_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >CHILD_1_bRxCnt
                                   (0594)    mov [CHILD_1_bRxCnt], 0x00
                                   (0595)    and [CHILD_1_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: CHILD_1_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  CHILD_1_bCmdCheck:
                                   (0628) _CHILD_1_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >CHILD_1_fStatus
                                   (0631)    mov A,  [CHILD_1_fStatus]
                                   (0632)    and A, CHILD_1_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: CHILD_1_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
1FE2: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
1FE4: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
1FE7: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
1FEA: 50 A8    MOV   A,168         (0648) ;     BYTE  fStatus - Status of command receive buffer.
1FEC: 02 D5    ADD   A,[CHILD+1]   (0649) ;                     Returns non-zero value in A if command is valid.
1FEE: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
1FEF: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
1FF1: B0 04    JNZ   0x1FF6        (0653) ;           0x10 => Software Buffer OverRun
1FF3: 10       PUSH  X             (0654) ;
1FF4: 80 33    JMP   0x2028        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
1FF6: 39 00    CMP   A,0           (0660) ;    functions.
1FF8: B0 11    JNZ   0x200A        (0661) ;          
1FFA: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
1FFB: 76 D5    INC   [CHILD+1]     (0663) ;          CUR_PP
1FFD: 52 00    MOV   A,[X+0]       (0664) ;
1FFF: 3C D5 0F CMP   [CHILD+1],15  (0665) ;     Error Status is clear when read.
2002: BF F3    JNZ   0x1FF6        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
2004: 10       PUSH  X             (0669) ;
                                   (0670)  CHILD_1_bErrCheck:
2005: 56 00 00 MOV   [X+0],0       (0671) _CHILD_1_bErrCheck:
2008: 80 1F    JMP   0x2028        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >CHILD_1_fStatus
                                   (0674)    mov A,  [CHILD_1_fStatus]
200A: 10       PUSH  X             (0675)    and A, CHILD_1_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [CHILD_1_fStatus], ~CHILD_1_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
200B: 75       INC   X             (0679) .ENDSECTION
200C: 76 D5    INC   [CHILD+1]     (0680) 
200E: 3C D5 0F CMP   [CHILD+1],15  (0681) .SECTION
2011: AF F3    JZ    0x2005        (0682) ;-----------------------------------------------------------------------------
2013: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: CHILD_1_bCmdLength
2015: A0 12    JZ    0x2028        (0684) ;
2017: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
2019: BF F1    JNZ   0x200B        (0686) ;     Get length of command string
                                   (0687) ;
201B: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
201E: 76 D5    INC   [CHILD+1]     (0689) ;     none.
2020: 3C D5 0F CMP   [CHILD+1],15  (0690) ;
2023: B0 04    JNZ   0x2028        (0691) ;  RETURNS:
2025: 55 D5 0F MOV   [CHILD+1],15  (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
2028: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
2029: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
202A: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
202D: B0 0B    JNZ   0x2039        (0699) ;    functions.
202F: 20       POP   X             (0700) ;          
2030: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
2032: 50 00    MOV   A,0           (0702) ;          CUR_PP
2034: 70 3F    AND   F,63
2036: 71 C0    OR    F,192         (0703) ;
                                   (0704)  CHILD_1_bCmdLength:
2038: 7F       RET                 (0705) _CHILD_1_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >CHILD_1_bRxCnt
2039: 20       POP   X             (0708)    mov A,  [CHILD_1_bRxCnt]
203A: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
203C: 70 3F    AND   F,63
203E: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
2040: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: CHILD_1_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
2041: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
2044: 50 A8    MOV   A,168         (0744) ;     each lexically distinct element into a null-terminated string by replacing
2046: 02 D5    ADD   A,[CHILD+1]   (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
2048: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
2049: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     CHILD_1_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, CHILD_1_szGetParam, is
_main:
__text_start:
204C: 62 D0 00 MOV   REG[208],0    (0750) ;     not called until the buffer has been loaded with an entire command
204F: 55 D4 00 MOV   [CHILD],0

FILE: C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
(0162) // Author: Jason Tennyson
2052: 62 D0 00 MOV   REG[208],0
2055: 55 CF 00 MOV   [CONFIGURED+1],0
2058: 55 CE 00 MOV   [CONFIGURED],0
(0163) // Date: 7-10-11
205B: 62 D0 00 MOV   REG[208],0
205E: 55 D3 00 MOV   [TIMEOUT+1],0
2061: 55 D2 00 MOV   [TIMEOUT],0
(0164) // File: main.c
2064: 62 D0 00 MOV   REG[208],0
2067: 55 E1 00 MOV   [COMMAND_PARAM],0
(0165) //
206A: 62 D0 00 MOV   REG[208],0
206D: 55 D1 00 MOV   [STATE+1],0
2070: 55 D0 00 MOV   [STATE],0
(0166) // This is the design for the revolute modules of Jason Tennyson's Thesis.
2073: 62 D0 00 MOV   REG[208],0
2076: 55 E5 FB MOV   [ID],251
(0167) // This design is made for a PSoC CY8C28433-24PVXI.
(0168) //
2079: 43 E0 20 OR    REG[224],32
(0169) // Controller Packet Structure (each field is a byte)
(0170) // -----------------------------------------------------
207C: 71 01    OR    F,1
(0171) // All Packets:
(0172) // START BYTE/START BYTE/SOURCE ID/DESTINATION ID/COMMAND TYPE/PARAM 1/.../PARAM N/END TRANSMIT
(0173) //
207E: 7C 2F DF LCALL _servoBootWait
(0174) // Servo Packet Structure (each field is a byte)
(0175) // -----------------------------------------------------
(0176) // Source Packets:
2081: 7C 2D 28 LCALL _servoFinder
2084: 80 13    JMP   0x2098
(0177) // START BYTE/START BYTE/DESTINATION ID/LENGTH/COMMAND TYPE/PARAM 1/.../PARAM N/CHECKSUM
(0178) //
(0179) // Return Packets:
(0180) // START BYTE/START BYTE/SOURCE ID/LENGTH/ERROR/PARAM1/.../PARAM N/CHECKSUM
(0181) 
2086: 92 83    CALL  _commandReady
2088: 62 D0 00 MOV   REG[208],0
208B: 3C CD 00 CMP   [__r0],0
208E: B0 06    JNZ   0x2095
2090: 3C CC 00 CMP   [__r1],0
2093: A0 04    JZ    0x2098
(0182) #include <m8c.h>        	// Part-specific constants and macros.
(0183) #include "PSoCAPI.h"    	// PSoC API definitions for all User Modules.
(0184) #include "psocdynamic.h"	// Required for dynamically swapping configurations at run time.
2095: 7C 28 BA LCALL _takeAction
2098: 8F ED    JMP   0x2086
209A: 8F FF    JMP   0x209A
(0185) 
(0186) // These are declarations of all of the timer interrupts that are used for all configurations.
(0187) #pragma interrupt_handler TX_01234_TIMEOUT_ISR
(0188) #pragma interrupt_handler CHILD_1_TIMEOUT_ISR
(0189) #pragma interrupt_handler CHILD_2_TIMEOUT_ISR
(0190) #pragma interrupt_handler CHILD_3_TIMEOUT_ISR
(0191) #pragma interrupt_handler CHILD_4_TIMEOUT_ISR
(0192) #pragma interrupt_handler HELLO_TIMEOUT_ISR
_sayHello:
209C: 50 00    MOV   A,0
209E: 08       PUSH  A
209F: 50 02    MOV   A,2
20A1: 08       PUSH  A
20A2: 90 5D    CALL  _configToggle
20A4: 38 FE    ADD   SP,254
(0193) #pragma interrupt_handler INIT_TIMEOUT_ISR
(0194) 
(0195) // These defines are used as parameters of the configToggle function. Passing one of
20A6: 10       PUSH  X
20A7: 50 FC    MOV   A,252
20A9: 7C 0E D4 LCALL 0x0ED4
20AC: 20       POP   X
(0196) // these identifiers to configToggle will put the chip in that device configuration.
20AD: 10       PUSH  X
20AE: 50 FC    MOV   A,252
20B0: 7C 0E D4 LCALL 0x0ED4
20B3: 20       POP   X
(0197) #define		WAIT						(1)
20B4: 10       PUSH  X
20B5: 62 D0 00 MOV   REG[208],0
20B8: 51 E5    MOV   A,[ID]
20BA: 7C 0E D4 LCALL 0x0ED4
20BD: 20       POP   X
(0198) #define		MY_RESPONSE					(2)
20BE: 10       PUSH  X
20BF: 50 00    MOV   A,0
20C1: 7C 0E D4 LCALL 0x0ED4
20C4: 20       POP   X
(0199) #define 	RESPONSE_1					(3)
20C5: 10       PUSH  X
20C6: 50 C8    MOV   A,200
20C8: 7C 0E D4 LCALL 0x0ED4
20CB: 20       POP   X
(0200) #define 	RESPONSE_2					(4)
20CC: 10       PUSH  X
20CD: 62 D0 00 MOV   REG[208],0
20D0: 51 D4    MOV   A,[CHILD]
20D2: 7C 0E D4 LCALL 0x0ED4
20D5: 20       POP   X
(0201) #define 	RESPONSE_3					(5)
20D6: 10       PUSH  X
20D7: 50 FD    MOV   A,253
20D9: 7C 0E D4 LCALL 0x0ED4
20DC: 20       POP   X
(0202) #define 	RESPONSE_4					(6)
20DD: 10       PUSH  X
20DE: 50 FD    MOV   A,253
20E0: 7C 0E D4 LCALL 0x0ED4
20E3: 20       POP   X
(0203) #define		HELLO_MODE					(7)
(0204) #define		INITIALIZE					(8)
(0205) #define		SERVO_COMM					(9)
20E4: 10       PUSH  X
20E5: 7C 0E A7 LCALL 0x0EA7
20E8: 62 D0 00 MOV   REG[208],0
20EB: 20       POP   X
20EC: 53 CD    MOV   [__r0],A
20EE: 47 CD 20 TST   [__r0],32
20F1: AF F2    JZ    0x20E4
(0206) 
(0207) // These defines are used as comparisons to find what port the next module connected to.
(0208) #define		PORT_1						('1')
20F3: 7C 2F C0 LCALL _xmitWait
(0209) #define		PORT_2						('2')
(0210) #define		PORT_3						('3')
20F6: 50 00    MOV   A,0
20F8: 08       PUSH  A
20F9: 50 01    MOV   A,1
20FB: 08       PUSH  A
20FC: 90 03    CALL  _configToggle
20FE: 38 FE    ADD   SP,254
2100: 7F       RET   
(0211) #define		PORT_4						('4')
(0212) 
(0213) // Module Type
(0214) #define		TYPE						('1')
(0215) 
(0216) // These defines are used as transmission indicators for transmissions between PSoC controllers.
_configToggle:
  mode                 --> X-5
2101: 10       PUSH  X
2102: 4F       MOV   X,SP
(0217) #define		START_TRANSMIT				(252)	// Indicates the beginning of a transmission.
(0218) #define		END_TRANSMIT				(253)	// Indicates the end of a transmission.
(0219) #define		HELLO_BYTE					(200)	// Indicates master is ready to talk.
2103: 43 00 1F OR    REG[0],31
(0220) #define		ID_ASSIGNMENT				(201)	// Indicates an ID assignment from the master.
2106: 41 02 E0 AND   REG[2],224
(0221) #define		ID_ASSIGN_OK				(202)	// Indicates an ID assignment is complete.
(0222) #define		PING						(203)	// Indicates a ping message to or from the master.
(0223) #define		CLEAR						(204)	// Indicates the arm values are to be cleared.
(0224) #define		MASTER_ID					(0)		// The master node's ID.
2109: 62 D0 00 MOV   REG[208],0
210C: 3C D0 00 CMP   [STATE],0
210F: B0 06    JNZ   0x2116
2111: 3C D1 00 CMP   [STATE+1],0
2114: A0 11    JZ    0x2126
(0225) #define		DEFAULT_ID					(251)	// The ID that all modules start with.
(0226) #define		BROADCAST					(254)	// The broadcast ID for all controllers and servos.
2116: 62 D0 00 MOV   REG[208],0
2119: 51 D0    MOV   A,[STATE]
211B: 08       PUSH  A
211C: 51 D1    MOV   A,[STATE+1]
211E: 08       PUSH  A
211F: 7C 2A C0 LCALL _unloadConfig
2122: 38 FE    ADD   SP,254
(0227) 
2124: 80 04    JMP   0x2129
(0228) // SERVO DEFINES
(0229) // These numbers can all be found in the AX-12+ datasheet.
(0230) // These defines cover the range of IDs these servos are capable of.
2126: 7C 2A A4 LCALL _unloadAllConfigs
(0231) #define		SERVO_ID_MIN				(0)		// This is the lowest servo ID possible.
(0232) #define		SERVO_ID_MAX				(253)	// This is the highest servo ID possible.
(0233) // These defines are servo transmission indicators.
(0234) #define		SERVO_START					(255)	// This is the start byte for a servo transmission.
(0235) // These defines are used to fill in the length parameter for a given command type. These are the only
2129: 3D FB 00 CMP   [X-5],0
212C: B0 22    JNZ   0x214F
212E: 3D FC 01 CMP   [X-4],1
2131: B0 1D    JNZ   0x214F
(0236) // lengths used by this controller for servo configuration purposes. It is worth noting that any type
(0237) // and length of command can be issued from the master after configuration is complete.
(0238) #define		READ_LENGTH					(4)		// This is the length value for all reads.
(0239) #define		WRITE_LENGTH				(4)		// This is the length value for all writes.
2133: 7C 06 A2 LCALL 0x06A2
(0240) #define		PING_LENGTH					(2)		// This is the length value for a ping.
(0241) #define		RESET_LENGTH				(2)		// This is the length value for a reset.
(0242) // These defines are used to fill in the servo's EEPROM address parameter for a given command type.
2136: 10       PUSH  X
2137: 50 00    MOV   A,0
2139: 7C 0C CA LCALL 0x0CCA
213C: 20       POP   X
(0243) #define		ID_ADDRESS					(3)		// This is the address where servo ID is stored.
213D: 10       PUSH  X
213E: 50 00    MOV   A,0
2140: 7C 11 0E LCALL 0x110E
2143: 20       POP   X
(0244) #define		STATUS_RET_ADDRESS			(16)	// This is where the status return level is stored.
(0245) // These defines are used to fill in the instruction we are using on the servo.
(0246) #define		PING_SERVO					(1)		// This is the instruction number for ping.
2144: 62 D0 00 MOV   REG[208],0
2147: 55 D1 01 MOV   [STATE+1],1
214A: 55 D0 00 MOV   [STATE],0
(0247) #define		READ_SERVO					(2)		// This is the instruction number for a read.
214D: 81 A0    JMP   0x22EE
(0248) #define		WRITE_SERVO					(3)		// This is the instruction number for a write.
214F: 3D FB 00 CMP   [X-5],0
2152: B0 4C    JNZ   0x219F
2154: 3D FC 02 CMP   [X-4],2
2157: B0 47    JNZ   0x219F
(0249) #define		RESET_SERVO					(6)		// This is the instruction to reset the servo EEPROM.
(0250) // These defines cover all of the status return level possibilities.
(0251) #define		STATUS_RET_NEVER			(0)		// Only respond to ping commands.
2159: 7C 08 46 LCALL 0x0846
(0252) #define		STATUS_RET_READ				(1)		// Only respond to read data commands (recommended).
(0253) #define		STATUS_RET_ALL				(2)		// Respond to every command.
(0254) 
215C: 62 D0 00 MOV   REG[208],0
215F: 55 D3 00 MOV   [TIMEOUT+1],0
2162: 55 D2 00 MOV   [TIMEOUT],0
(0255) // This is the status return level, which is set to one of the possible status return values above.
(0256) // We want the status return level to be return on read commands only so that we don't have garbage
(0257) // return packets flying around every time we tell the servo to move.
2165: 10       PUSH  X
2166: 50 00    MOV   A,0
2168: 7C 0E 9B LCALL 0x0E9B
216B: 20       POP   X
(0258) #define		STATUS_RET_LEVEL			(STATUS_RET_READ)
216C: 10       PUSH  X
216D: 50 00    MOV   A,0
216F: 7C 0D C2 LCALL 0x0DC2
(0259) 
(0260) // This is the number of attempts we make to contact the servo per sweep of attempts before
2172: 7C 0F 59 LCALL 0x0F59
(0261) // writing to its EEPROM in an attempt to alter settings that keep us from communicating.
2175: 7C 0F 61 LCALL 0x0F61
2178: 20       POP   X
(0262) #define		SERVO_COMM_ATTEMPTS			(3)
(0263) // This is the number of times we do a loop of SERVO_COMM_ATTEMPTS. We would like this to be at least 2.
(0264) // This is because we do an EEPROM write after the first unsuccessful loop of SERVO_COMM_ATTEMPTS.
(0265) // If we don't then do at least one more loop, the EEPROM write was done for no reason.
2179: 62 D0 00 MOV   REG[208],0
217C: 3C D2 00 CMP   [TIMEOUT],0
217F: B0 06    JNZ   0x2186
2181: 3C D3 00 CMP   [TIMEOUT+1],0
2184: AF F4    JZ    0x2179
(0266) #define		SERVO_COMM_LOOPS			(2)
(0267) // This is the number of timeout periods to wait through while the servo boots up (2 ms per period).
2186: 10       PUSH  X
2187: 7C 0F 65 LCALL 0x0F65
218A: 20       POP   X
(0268) #define		SERVO_BOOT_TIMEOUTS			(100)
218B: 62 D0 00 MOV   REG[208],0
218E: 55 D3 00 MOV   [TIMEOUT+1],0
2191: 55 D2 00 MOV   [TIMEOUT],0
(0269) 
(0270) // This function receives a mode identifier as a parameter and toggles the system configuration.
(0271) void configToggle(int mode);
2194: 62 D0 00 MOV   REG[208],0
2197: 55 D1 02 MOV   [STATE+1],2
219A: 55 D0 00 MOV   [STATE],0
(0272) // This function unloads all configurations. This should only be needed at startup.
219D: 81 50    JMP   0x22EE
(0273) void unloadAllConfigs(void);
219F: 3D FB 00 CMP   [X-5],0
21A2: B0 2A    JNZ   0x21CD
21A4: 3D FC 03 CMP   [X-4],3
21A7: B0 25    JNZ   0x21CD
(0274) // This function unloads the configuration corresponding to the number passed to it.
(0275) void unloadConfig(int config_num);
(0276) // This function is a response to the master sending out a hello message.
21A9: 7C 08 AD LCALL 0x08AD
(0277) void sayHello(void);
(0278) // This function looks for commands and returns 1 if a command has been read, 0 if not.
(0279) int commandReady(void);
21AC: 62 D0 00 MOV   REG[208],0
21AF: 55 D3 00 MOV   [TIMEOUT+1],0
21B2: 55 D2 00 MOV   [TIMEOUT],0
(0280) // This function interprets the command that has just been read and performs an action accordingly.
(0281) void takeAction(void);
(0282) // This function responds to a ping.
21B5: 10       PUSH  X
21B6: 50 00    MOV   A,0
21B8: 7C 1F 6F LCALL 0x1F6F
(0283) void pingResponse(void);
(0284) // This function tells the master node that an ID assignment was completed on this module.
21BB: 7C 1F 07 LCALL 0x1F07
(0285) void assignedID(void);
21BE: 7C 1F 0F LCALL 0x1F0F
21C1: 20       POP   X
(0286) // This function listens for children and registers the port that they talk to.
(0287) int childListen(void);
(0288) // This function waits for a known child's response to a command to that child from the master.
21C2: 62 D0 00 MOV   REG[208],0
21C5: 55 D1 03 MOV   [STATE+1],3
21C8: 55 D0 00 MOV   [STATE],0
(0289) int childResponse(void);
21CB: 81 22    JMP   0x22EE
(0290) // This function does everything it can to find the servo attached to this controller.
21CD: 3D FB 00 CMP   [X-5],0
21D0: B0 2A    JNZ   0x21FB
21D2: 3D FC 04 CMP   [X-4],4
21D5: B0 25    JNZ   0x21FB
(0291) void servoFinder(void);
(0292) // This function carries out the passed servo instruction.
(0293) void servoInstruction(char id, char length, char instruction, char address, char value);
21D7: 7C 09 50 LCALL 0x0950
(0294) // This function does a simple for loop to stall and make doubly sure that the transmission finished.
(0295) // It is meant to be used as a definite amount of wait time after the transmission complete flag is set.
(0296) void xmitWait(void);
21DA: 62 D0 00 MOV   REG[208],0
21DD: 55 D3 00 MOV   [TIMEOUT+1],0
21E0: 55 D2 00 MOV   [TIMEOUT],0
(0297) // This function is called to do nothing while we wait for the servo to boot up.
(0298) void servoBootWait(void);
(0299) // This function is used to wait for other controllers to find their servos while not
21E3: 10       PUSH  X
21E4: 50 00    MOV   A,0
21E6: 7C 1D B6 LCALL 0x1DB6
(0300) // driving any pins (which would keep a child from talking to its servo).
(0301) void servoConfigWait(void);
21E9: 7C 1D 4E LCALL 0x1D4E
(0302) 
21EC: 7C 1D 56 LCALL 0x1D56
21EF: 20       POP   X
(0303) char CHILD;		// Keeps track of where the child is connected.
(0304) char ID;		// Stores the ID that the master gives this module.
(0305) 
21F0: 62 D0 00 MOV   REG[208],0
21F3: 55 D1 04 MOV   [STATE+1],4
21F6: 55 D0 00 MOV   [STATE],0
(0306) int CONFIGURED;	// Keeps track of whether or not this module has been configured by the master.
21F9: 80 F4    JMP   0x22EE
(0307) int TIMEOUT;	// This flag is set if a timeout occurs.
21FB: 3D FB 00 CMP   [X-5],0
21FE: B0 2A    JNZ   0x2229
2200: 3D FC 05 CMP   [X-4],5
2203: B0 25    JNZ   0x2229
(0308) int STATE;		// This stores the ID of the currently-loaded configuration.
(0309) 
(0310) char COMMAND_SOURCE;		// Stores who the current command is from.
2205: 7C 09 F3 LCALL 0x09F3
(0311) char COMMAND_DESTINATION;	// Stores who the current command is for.
(0312) char COMMAND_TYPE;			// Stores the type of command that was just read.
(0313) char COMMAND_PARAM;			// Stores a parameter that accompanies the command (if any).
2208: 62 D0 00 MOV   REG[208],0
220B: 55 D3 00 MOV   [TIMEOUT+1],0
220E: 55 D2 00 MOV   [TIMEOUT],0
(0314) char COMMAND_LENGTH;		// Stores the length parameter of a servo command.
(0315) char COMMAND_ERROR;			// Stores the error code of a servo command.
(0316) 
2211: 10       PUSH  X
2212: 50 00    MOV   A,0
2214: 7C 1B FD LCALL 0x1BFD
(0317) char SERVO_ID;				// Stores the ID of the servo inside of this module.
(0318) 
2217: 7C 1B 95 LCALL 0x1B95
(0319) void main(void)
221A: 7C 1B 9D LCALL 0x1B9D
221D: 20       POP   X
(0320) {	
(0321) 	// Initial value assignment for variables of importance.
(0322) 	CHILD = 0;				// There is no child yet.
221E: 62 D0 00 MOV   REG[208],0
2221: 55 D1 05 MOV   [STATE+1],5
2224: 55 D0 00 MOV   [STATE],0
(0323) 	CONFIGURED = 0;			// This module is not configured yet.
2227: 80 C6    JMP   0x22EE
(0324) 	TIMEOUT = 0;			// Set the timeout flag low to start.
2229: 3D FB 00 CMP   [X-5],0
222C: B0 2A    JNZ   0x2257
222E: 3D FC 06 CMP   [X-4],6
2231: B0 25    JNZ   0x2257
(0325) 	COMMAND_PARAM = 0;		// There is no parameter yet.
(0326) 	STATE = 0;				// There is no state yet.
(0327) 	ID = DEFAULT_ID;		// Set the ID of this controller to the default to start with.
2233: 7C 0A 96 LCALL 0x0A96
(0328) 
(0329) 	M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); // Activate GPIO ISR
(0330) 	
2236: 62 D0 00 MOV   REG[208],0
2239: 55 D3 00 MOV   [TIMEOUT+1],0
223C: 55 D2 00 MOV   [TIMEOUT],0
(0331) 	M8C_EnableGInt;			// Turn on global interrupts for the transmission timeout timer.
(0332) 	
(0333) 	// We have to wait for the servo to power up and get ready for communications.
223F: 10       PUSH  X
2240: 50 00    MOV   A,0
2242: 7C 1A 44 LCALL 0x1A44
(0334) 	servoBootWait();
(0335) 	
2245: 7C 19 DC LCALL 0x19DC
(0336) 	// Find the servo that is inside of this module.
2248: 7C 19 E4 LCALL 0x19E4
224B: 20       POP   X
(0337) 	servoFinder();
(0338) 	
(0339) 	// Loop and wait for commands.
224C: 62 D0 00 MOV   REG[208],0
224F: 55 D1 06 MOV   [STATE+1],6
2252: 55 D0 00 MOV   [STATE],0
(0340) 	while(1)
2255: 80 98    JMP   0x22EE
(0341) 	{	
2257: 3D FB 00 CMP   [X-5],0
225A: B0 3F    JNZ   0x229A
225C: 3D FC 07 CMP   [X-4],7
225F: B0 3A    JNZ   0x229A
(0342) 		if(commandReady())
(0343) 		{
(0344) 			// If the command is ready, take action.
2261: 7C 07 09 LCALL 0x0709
(0345) 			takeAction();
(0346) 		}
(0347) 	}
2264: 62 D0 00 MOV   REG[208],0
2267: 55 D3 00 MOV   [TIMEOUT+1],0
226A: 55 D2 00 MOV   [TIMEOUT],0
(0348) }
(0349) 
(0350) // This function transmits a response to a hello command from the master.
(0351) void sayHello(void)
(0352) {	
(0353) 	configToggle(MY_RESPONSE);		// Switch to response mode.
226D: 10       PUSH  X
226E: 50 00    MOV   A,0
2270: 7C 18 8B LCALL 0x188B
2273: 20       POP   X
(0354) 	
(0355) 	// Transmit a hello response to the master node.
(0356) 	TX_014_PutChar(START_TRANSMIT);	// Start byte one
(0357) 	TX_014_PutChar(START_TRANSMIT);	// Start byte two
(0358) 	TX_014_PutChar(ID);				// My ID (source)
2274: 10       PUSH  X
2275: 50 00    MOV   A,0
2277: 7C 17 32 LCALL 0x1732
227A: 20       POP   X
(0359) 	TX_014_PutChar(MASTER_ID);		// Master ID (destination)
(0360) 	TX_014_PutChar(HELLO_BYTE);		// This is a hello command.
(0361) 	TX_014_PutChar(CHILD);			// Sends child port value, default 0.
(0362) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission.
(0363) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission.
227B: 10       PUSH  X
227C: 50 00    MOV   A,0
227E: 7C 15 D9 LCALL 0x15D9
2281: 20       POP   X
(0364) 	
(0365) 	// Wait for the transmission to finish.
(0366) 	while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
(0367) 	
(0368) 	// Make completely sure we're done.
2282: 10       PUSH  X
2283: 50 00    MOV   A,0
2285: 7C 14 80 LCALL 0x1480
(0369) 	xmitWait();
(0370) 
(0371) 	configToggle(WAIT);				// Switch back to wait mode.
2288: 7C 13 A4 LCALL 0x13A4
(0372) }
228B: 7C 13 AC LCALL 0x13AC
228E: 20       POP   X
(0373) 
(0374) // This function receives a mode flag and switches the microcontroller to the
(0375) // desired hardware configuration.
228F: 62 D0 00 MOV   REG[208],0
2292: 55 D1 07 MOV   [STATE+1],7
2295: 55 D0 00 MOV   [STATE],0
(0376) void configToggle(int mode)
2298: 80 55    JMP   0x22EE
(0377) {	
229A: 3D FB 00 CMP   [X-5],0
229D: B0 2A    JNZ   0x22C8
229F: 3D FC 08 CMP   [X-4],8
22A2: B0 25    JNZ   0x22C8
(0378) 	// Set the pins high and disconnect from the global bus.
(0379) 	// This helps keep false start bits from happening while we swap configs.
(0380) 	PRT0DR |= 0b00011111;	// Set pins P00 through P04 high.
22A4: 7C 07 AC LCALL 0x07AC
(0381) 	PRT0GS &= 0b11100000;	// Disconnect pins P00 through P04 from the global bus.
(0382) 	
(0383) 	// Unload the configuration of the current state.
22A7: 62 D0 00 MOV   REG[208],0
22AA: 55 D3 00 MOV   [TIMEOUT+1],0
22AD: 55 D2 00 MOV   [TIMEOUT],0
(0384) 	// If there is no state, blindly wipe all configurations.
(0385) 	if(STATE)
(0386) 	{
22B0: 10       PUSH  X
22B1: 50 00    MOV   A,0
22B3: 7C 12 C7 LCALL 0x12C7
(0387) 		unloadConfig(STATE);
(0388) 	}
22B6: 7C 11 EB LCALL 0x11EB
(0389) 	else
22B9: 7C 11 F3 LCALL 0x11F3
22BC: 20       POP   X
(0390) 	{
(0391) 		unloadAllConfigs();
(0392) 	}
22BD: 62 D0 00 MOV   REG[208],0
22C0: 55 D1 08 MOV   [STATE+1],8
22C3: 55 D0 00 MOV   [STATE],0
(0393) 	
22C6: 80 27    JMP   0x22EE
(0394) 	// Go through the list of possible modes until we find the one that was passed in to us.
22C8: 3D FB 00 CMP   [X-5],0
22CB: B0 22    JNZ   0x22EE
22CD: 3D FC 09 CMP   [X-4],9
22D0: B0 1D    JNZ   0x22EE
(0395) 	// Then, load that configuration and initialize whatever needs to be initialized.
(0396) 	if(mode == WAIT)
(0397) 	{
22D2: 7C 0B 42 LCALL 0x0B42
(0398) 		// Load the wait receiver configuration. This is the receiver configuration used after
(0399) 		// initialization is complete. It listens and forwards everything it hears.
(0400) 		LoadConfig_waiting();
22D5: 62 D0 00 MOV   REG[208],0
22D8: 55 D3 00 MOV   [TIMEOUT+1],0
22DB: 55 D2 00 MOV   [TIMEOUT],0
(0401) 		
(0402) 		// Start the receivers.
(0403) 		WAIT_RECV_Start(WAIT_RECV_PARITY_NONE);
22DE: 10       PUSH  X
22DF: 50 00    MOV   A,0
22E1: 7C 0F D4 LCALL 0x0FD4
22E4: 20       POP   X
(0404) 		RX8_2_Start(RX8_2_PARITY_NONE);
(0405) 		
(0406) 		// Set the current state.
22E5: 62 D0 00 MOV   REG[208],0
22E8: 55 D1 09 MOV   [STATE+1],9
22EB: 55 D0 00 MOV   [STATE],0
(0407) 		STATE = WAIT;
(0408) 	}
(0409) 	else if(mode == MY_RESPONSE)
(0410) 	{
22EE: 62 D0 00 MOV   REG[208],0
22F1: 3C CE 00 CMP   [CONFIGURED],0
22F4: B0 06    JNZ   0x22FB
22F6: 3C CF 00 CMP   [CONFIGURED+1],0
22F9: A0 09    JZ    0x2303
(0411) 		// Load the transmitter configuration. This is for transmitting messages on all ports.
(0412) 		LoadConfig_my_response();
22FB: 43 02 1F OR    REG[2],31
(0413) 		
22FE: 41 08 FE AND   REG[8],254
(0414) 		// Clear the timeout flag.
2301: 80 07    JMP   0x2309
(0415) 		TIMEOUT = 0;
(0416) 		
(0417) 		// Start the transmitters.
2303: 43 02 01 OR    REG[2],1
(0418) 		TX_014_Start(TX_014_PARITY_NONE);	// Transmits on P00, P01, and P04.
2306: 43 08 01 OR    REG[8],1
(0419) 		TX_23_Start(TX_23_PARITY_NONE);		// Transmits on P02 and P03.
2309: 20       POP   X
230A: 7F       RET   
(0420) 		
(0421) 		TX_01234_TIMEOUT_EnableInt();		// Make sure interrupts are enabled.
(0422) 		TX_01234_TIMEOUT_Start();			// Start the timer.
(0423) 		
(0424) 		// Do nothing while we wait for one timeout period (1 ms).
(0425) 		// This is to allow everyone to get in the right configuration before talking.
(0426) 		while(!TIMEOUT) { }
_commandReady:
  runningTotal         --> X+3
  i                    --> X+1
  tempByte             --> X+0
230B: 10       PUSH  X
230C: 4F       MOV   X,SP
230D: 38 05    ADD   SP,5
(0427) 		
230F: 56 02 00 MOV   [X+2],0
2312: 56 01 00 MOV   [X+1],0
(0428) 		TX_01234_TIMEOUT_Stop();			// Stop the timer.
2315: 56 00 00 MOV   [X+0],0
(0429) 		TIMEOUT = 0;						// Reset the timeout flag.
(0430) 	
2318: 56 04 00 MOV   [X+4],0
231B: 56 03 00 MOV   [X+3],0
(0431) 		// Set the current state.
(0432) 		STATE = MY_RESPONSE;
(0433) 	}
(0434) 	else if(mode == RESPONSE_1)
231E: 62 D0 00 MOV   REG[208],0
2321: 3C D0 00 CMP   [STATE],0
2324: B0 D4    JNZ   0x23F9
2326: 3C D1 01 CMP   [STATE+1],1
2329: B0 CF    JNZ   0x23F9
(0435) 	{
(0436) 		// Load the response wait on port 1.
(0437) 		LoadConfig_response1();
(0438) 		
232B: 10       PUSH  X
232C: 7C 0C D9 LCALL 0x0CD9
232F: 62 D0 00 MOV   REG[208],0
2332: 20       POP   X
2333: 54 00    MOV   [X+0],A
(0439) 		// Clear the timeout flag.
(0440) 		TIMEOUT = 0;
(0441) 		
2335: 3D 00 FC CMP   [X+0],252
2338: B0 47    JNZ   0x2380
(0442) 		// Start listening for a response through child port 1.
233A: 80 0B    JMP   0x2346
(0443) 		CHILD_1_Start(CHILD_1_PARITY_NONE);
(0444) 		
(0445) 		CHILD_1_TIMEOUT_EnableInt();		// Make sure interrupts are enabled.
(0446) 		CHILD_1_TIMEOUT_Start();			// Start the timer.
233C: 10       PUSH  X
233D: 7C 0C D9 LCALL 0x0CD9
2340: 62 D0 00 MOV   REG[208],0
2343: 20       POP   X
2344: 54 00    MOV   [X+0],A
2346: 3D 00 FC CMP   [X+0],252
2349: AF F2    JZ    0x233C
(0447) 		
(0448) 		// Set the current state.
(0449) 		STATE = RESPONSE_1;
(0450) 	}
234B: 3D 00 00 CMP   [X+0],0
234E: B5 5E    JNZ   0x28AD
(0451) 	else if(mode == RESPONSE_2)
(0452) 	{
2350: 52 00    MOV   A,[X+0]
2352: 62 D0 00 MOV   REG[208],0
2355: 53 E4    MOV   [COMMAND_SOURCE],A
(0453) 		// Load the response wait on port 2.
2357: 10       PUSH  X
2358: 7C 0C D9 LCALL 0x0CD9
235B: 20       POP   X
235C: 62 D0 00 MOV   REG[208],0
235F: 53 E3    MOV   [COMMAND_DESTINATION],A
(0454) 		LoadConfig_response2();
2361: 10       PUSH  X
2362: 7C 0C D9 LCALL 0x0CD9
2365: 20       POP   X
2366: 62 D0 00 MOV   REG[208],0
2369: 53 E2    MOV   [COMMAND_TYPE],A
(0455) 		
236B: 10       PUSH  X
236C: 7C 0C D9 LCALL 0x0CD9
236F: 20       POP   X
2370: 62 D0 00 MOV   REG[208],0
2373: 53 E1    MOV   [COMMAND_PARAM],A
(0456) 		// Clear the timeout flag.
(0457) 		TIMEOUT = 0;
2375: 62 D0 00 MOV   REG[208],0
2378: 55 CC 01 MOV   [__r1],1
237B: 55 CD 00 MOV   [__r0],0
237E: 85 37    JMP   0x28B6
(0458) 		
(0459) 		// Start listening for a response through child port 2.
(0460) 		CHILD_2_Start(CHILD_2_PARITY_NONE);
2380: 3D 00 FF CMP   [X+0],255
2383: B5 29    JNZ   0x28AD
(0461) 		
2385: 80 0B    JMP   0x2391
(0462) 		CHILD_2_TIMEOUT_EnableInt();		// Make sure interrupts are enabled.
(0463) 		CHILD_2_TIMEOUT_Start();			// Start the timer.
(0464) 		
(0465) 		// Set the current state.
2387: 10       PUSH  X
2388: 7C 0C D9 LCALL 0x0CD9
238B: 62 D0 00 MOV   REG[208],0
238E: 20       POP   X
238F: 54 00    MOV   [X+0],A
2391: 3D 00 FF CMP   [X+0],255
2394: AF F2    JZ    0x2387
(0466) 		STATE = RESPONSE_2;
(0467) 	}
(0468) 	else if(mode == RESPONSE_3)
(0469) 	{
2396: 62 D0 00 MOV   REG[208],0
2399: 55 E4 00 MOV   [COMMAND_SOURCE],0
(0470) 		// Load the response wait on port 3.
(0471) 		LoadConfig_response3();
239C: 52 00    MOV   A,[X+0]
239E: 62 D0 00 MOV   REG[208],0
23A1: 53 E3    MOV   [COMMAND_DESTINATION],A
(0472) 		
(0473) 		// Clear the timeout flag.
(0474) 		TIMEOUT = 0;
(0475) 		
(0476) 		// Start listening for a response through child port 3.
23A3: 10       PUSH  X
23A4: 7C 0C D9 LCALL 0x0CD9
23A7: 62 D0 00 MOV   REG[208],0
23AA: 20       POP   X
23AB: 54 00    MOV   [X+0],A
(0477) 		CHILD_3_Start(CHILD_3_PARITY_NONE);
(0478) 		
(0479) 		CHILD_3_TIMEOUT_EnableInt();		// Make sure interrupts are enabled.
23AD: 10       PUSH  X
23AE: 7C 0C D9 LCALL 0x0CD9
23B1: 20       POP   X
23B2: 62 D0 00 MOV   REG[208],0
23B5: 53 E2    MOV   [COMMAND_TYPE],A
(0480) 		CHILD_3_TIMEOUT_Start();			// Start the timer.
(0481) 		
(0482) 		// Set the current state.
(0483) 		STATE = RESPONSE_3;
23B7: 56 02 00 MOV   [X+2],0
23BA: 56 01 00 MOV   [X+1],0
23BD: 80 0E    JMP   0x23CC
(0484) 	}
(0485) 	else if(mode == RESPONSE_4)
23BF: 10       PUSH  X
23C0: 7C 0C D9 LCALL 0x0CD9
23C3: 62 D0 00 MOV   REG[208],0
23C6: 20       POP   X
23C7: 77 02    INC   [X+2]
23C9: 0F 01 00 ADC   [X+1],0
23CC: 62 D0 00 MOV   REG[208],0
23CF: 52 00    MOV   A,[X+0]
23D1: 53 CC    MOV   [__r1],A
23D3: 55 CD 00 MOV   [__r0],0
23D6: 16 CC 01 SUB   [__r1],1
23D9: 1E CD 00 SBB   [__r0],0
23DC: 52 02    MOV   A,[X+2]
23DE: 12 CC    SUB   A,[__r1]
23E0: 51 CD    MOV   A,[__r0]
23E2: 31 80    XOR   A,128
23E4: 53 CA    MOV   [__rX],A
23E6: 52 01    MOV   A,[X+1]
23E8: 31 80    XOR   A,128
23EA: 1A CA    SBB   A,[__rX]
23EC: CF D2    JC    0x23BF
(0486) 	{
(0487) 		// Load the response wait on port 4.
(0488) 		LoadConfig_response4();
23EE: 62 D0 00 MOV   REG[208],0
23F1: 55 CC 01 MOV   [__r1],1
23F4: 55 CD 00 MOV   [__r0],0
23F7: 84 BE    JMP   0x28B6
(0489) 		
(0490) 		// Clear the timeout flag.
(0491) 		TIMEOUT = 0;
23F9: 62 D0 00 MOV   REG[208],0
23FC: 3C D0 00 CMP   [STATE],0
23FF: B0 E2    JNZ   0x24E2
2401: 3C D1 07 CMP   [STATE+1],7
2404: B0 DD    JNZ   0x24E2
(0492) 		
(0493) 		// Start listening for a response through child port 4.
(0494) 		CHILD_4_Start(CHILD_4_PARITY_NONE);
(0495) 		
2406: 10       PUSH  X
2407: 7C 18 A2 LCALL 0x18A2
240A: 62 D0 00 MOV   REG[208],0
240D: 20       POP   X
240E: 39 FC    CMP   A,252
2410: B0 2C    JNZ   0x243D
(0496) 		CHILD_4_TIMEOUT_EnableInt();		// Make sure interrupts are enabled.
2412: 80 1B    JMP   0x242E
(0497) 		CHILD_4_TIMEOUT_Start();			// Start the timer.
(0498) 		
(0499) 		// Set the current state.
2414: 10       PUSH  X
2415: 7C 18 A2 LCALL 0x18A2
2418: 20       POP   X
2419: 39 FD    CMP   A,253
241B: B0 12    JNZ   0x242E
(0500) 		STATE = RESPONSE_4;
(0501) 	}
241D: 62 D0 00 MOV   REG[208],0
2420: 55 D4 31 MOV   [CHILD],49
(0502) 	else if(mode == HELLO_MODE)
(0503) 	{
2423: 62 D0 00 MOV   REG[208],0
2426: 55 CC 01 MOV   [__r1],1
2429: 55 CD 00 MOV   [__r0],0
242C: 84 89    JMP   0x28B6
242E: 62 D0 00 MOV   REG[208],0
2431: 3C D2 00 CMP   [TIMEOUT],0
2434: B0 06    JNZ   0x243B
2436: 3C D3 00 CMP   [TIMEOUT+1],0
2439: AF DA    JZ    0x2414
(0504) 		// Load the hello wait mode. This is for listening on all ports for a hello response.
(0505) 		LoadConfig_hello();
(0506) 		
243B: 84 71    JMP   0x28AD
(0507) 		// Clear the timeout flag.
243D: 10       PUSH  X
243E: 7C 17 49 LCALL 0x1749
2441: 62 D0 00 MOV   REG[208],0
2444: 20       POP   X
2445: 39 FC    CMP   A,252
2447: B0 2C    JNZ   0x2474
(0508) 		TIMEOUT = 0;
2449: 80 1B    JMP   0x2465
(0509) 		
(0510) 		// The seemingly unnecessary brackets around each line are unfortunately needed.
(0511) 	
244B: 10       PUSH  X
244C: 7C 17 49 LCALL 0x1749
244F: 20       POP   X
2450: 39 FD    CMP   A,253
2452: B0 12    JNZ   0x2465
(0512) 		{
(0513) 		// Start listening for a response through child port 1.
2454: 62 D0 00 MOV   REG[208],0
2457: 55 D4 32 MOV   [CHILD],50
(0514) 		HELLO_1_Start(HELLO_1_PARITY_NONE);
(0515) 		}
245A: 62 D0 00 MOV   REG[208],0
245D: 55 CC 01 MOV   [__r1],1
2460: 55 CD 00 MOV   [__r0],0
2463: 84 52    JMP   0x28B6
2465: 62 D0 00 MOV   REG[208],0
2468: 3C D2 00 CMP   [TIMEOUT],0
246B: B0 06    JNZ   0x2472
246D: 3C D3 00 CMP   [TIMEOUT+1],0
2470: AF DA    JZ    0x244B
(0516) 		
(0517) 		{
(0518) 		// Start listening for a response through child port 2.
2472: 84 3A    JMP   0x28AD
(0519) 		HELLO_2_Start(HELLO_2_PARITY_NONE);
2474: 10       PUSH  X
2475: 7C 15 F0 LCALL 0x15F0
2478: 62 D0 00 MOV   REG[208],0
247B: 20       POP   X
247C: 39 FC    CMP   A,252
247E: B0 2C    JNZ   0x24AB
(0520) 		}
2480: 80 1B    JMP   0x249C
(0521) 		
(0522) 		{
(0523) 		// Start listening for a response through child port 3.
2482: 10       PUSH  X
2483: 7C 15 F0 LCALL 0x15F0
2486: 20       POP   X
2487: 39 FD    CMP   A,253
2489: B0 12    JNZ   0x249C
(0524) 		HELLO_3_Start(HELLO_3_PARITY_NONE);
(0525) 		}
248B: 62 D0 00 MOV   REG[208],0
248E: 55 D4 33 MOV   [CHILD],51
(0526) 		
(0527) 		{
2491: 62 D0 00 MOV   REG[208],0
2494: 55 CC 01 MOV   [__r1],1
2497: 55 CD 00 MOV   [__r0],0
249A: 84 1B    JMP   0x28B6
249C: 62 D0 00 MOV   REG[208],0
249F: 3C D2 00 CMP   [TIMEOUT],0
24A2: B0 06    JNZ   0x24A9
24A4: 3C D3 00 CMP   [TIMEOUT+1],0
24A7: AF DA    JZ    0x2482
(0528) 		// Start listening for a response through child port 4.
(0529) 		HELLO_4_Start(HELLO_4_PARITY_NONE);
(0530) 		}
24A9: 84 03    JMP   0x28AD
(0531) 		
24AB: 10       PUSH  X
24AC: 7C 14 97 LCALL 0x1497
24AF: 62 D0 00 MOV   REG[208],0
24B2: 20       POP   X
24B3: 39 FC    CMP   A,252
24B5: B3 F7    JNZ   0x28AD
(0532) 		HELLO_TIMEOUT_EnableInt();	// Make sure interrupts are enabled.
24B7: 80 1B    JMP   0x24D3
(0533) 		HELLO_TIMEOUT_Start();		// Start the timer.
(0534) 		
(0535) 		// Set the current state.
24B9: 10       PUSH  X
24BA: 7C 14 97 LCALL 0x1497
24BD: 20       POP   X
24BE: 39 FD    CMP   A,253
24C0: B0 12    JNZ   0x24D3
(0536) 		STATE = HELLO_MODE;
(0537) 	}
24C2: 62 D0 00 MOV   REG[208],0
24C5: 55 D4 34 MOV   [CHILD],52
(0538) 	else if(mode == INITIALIZE)
(0539) 	{
24C8: 62 D0 00 MOV   REG[208],0
24CB: 55 CC 01 MOV   [__r1],1
24CE: 55 CD 00 MOV   [__r0],0
24D1: 83 E4    JMP   0x28B6
24D3: 62 D0 00 MOV   REG[208],0
24D6: 3C D2 00 CMP   [TIMEOUT],0
24D9: B0 06    JNZ   0x24E0
24DB: 3C D3 00 CMP   [TIMEOUT+1],0
24DE: AF DA    JZ    0x24B9
(0540) 		// Load the configuration for initialization. This config listens but does not forward.
(0541) 		LoadConfig_initial();
(0542) 		
(0543) 		// Clear the timeout flag.
24E0: 83 CC    JMP   0x28AD
(0544) 		TIMEOUT = 0;
24E2: 62 D0 00 MOV   REG[208],0
24E5: 3C D0 00 CMP   [STATE],0
24E8: B0 D2    JNZ   0x25BB
24EA: 3C D1 03 CMP   [STATE+1],3
24ED: B0 CD    JNZ   0x25BB
(0545) 		
(0546) 		// Start the receiver.
24EF: 10       PUSH  X
24F0: 7C 1F 86 LCALL 0x1F86
24F3: 62 D0 00 MOV   REG[208],0
24F6: 20       POP   X
24F7: 54 00    MOV   [X+0],A
24F9: 39 00    CMP   A,0
24FB: A3 B1    JZ    0x28AD
(0547) 		INIT_RX_Start(INIT_RX_PARITY_NONE);
(0548) 		
24FD: 3D 00 FF CMP   [X+0],255
2500: B0 90    JNZ   0x2591
(0549) 		INIT_TIMEOUT_EnableInt();	// Make sure interrupts are enabled.
2502: 80 7F    JMP   0x2582
(0550) 		INIT_TIMEOUT_Start();		// Start the timer.
(0551) 		
(0552) 		// Set the current state.
(0553) 		STATE = INITIALIZE;
(0554) 	}
2504: 10       PUSH  X
2505: 7C 1F 86 LCALL 0x1F86
2508: 62 D0 00 MOV   REG[208],0
250B: 20       POP   X
250C: 54 00    MOV   [X+0],A
250E: 39 00    CMP   A,0
2510: A0 71    JZ    0x2582
(0555) 	else if(mode == SERVO_COMM)
(0556) 	{
(0557) 		// Load the configuration for servo communication. This config only transmits on P00.
(0558) 		LoadConfig_servo_transmit();
2512: 3D 00 FF CMP   [X+0],255
2515: A0 6C    JZ    0x2582
(0559) 		
(0560) 		// Clear the timeout flag.
(0561) 		TIMEOUT = 0;
2517: 52 00    MOV   A,[X+0]
2519: 05 04    ADD   [X+4],A
251B: 0F 03 00 ADC   [X+3],0
251E: 80 56    JMP   0x2575
(0562) 		
(0563) 		// Start the transmitter.
(0564) 		SERVO_TX_Start(SERVO_TX_PARITY_NONE);
(0565) 	
(0566) 		// Set the current state.
(0567) 		STATE = SERVO_COMM;
2520: 10       PUSH  X
2521: 7C 1F 86 LCALL 0x1F86
2524: 62 D0 00 MOV   REG[208],0
2527: 20       POP   X
2528: 54 00    MOV   [X+0],A
252A: 39 00    CMP   A,0
252C: A0 48    JZ    0x2575
(0568) 	}
(0569) 	
(0570) 	// If this module is configured, talk on all pins for potential children.
252E: 52 00    MOV   A,[X+0]
2530: 53 CC    MOV   [__r1],A
2532: 55 CD 00 MOV   [__r0],0
2535: 50 FF    MOV   A,255
2537: 12 CC    SUB   A,[__r1]
2539: 53 CC    MOV   [__r1],A
253B: 50 00    MOV   A,0
253D: 1A CD    SBB   A,[__r0]
253F: 53 CD    MOV   [__r0],A
2541: 50 01    MOV   A,1
2543: 08       PUSH  A
2544: 50 00    MOV   A,0
2546: 08       PUSH  A
2547: 52 03    MOV   A,[X+3]
2549: 08       PUSH  A
254A: 52 04    MOV   A,[X+4]
254C: 08       PUSH  A
254D: 7C 32 1F LCALL __divmod_16X16_16
2550: 38 FE    ADD   SP,254
2552: 18       POP   A
2553: 53 CB    MOV   [__r3],A
2555: 18       POP   A
2556: 3A CD    CMP   A,[__r0]
2558: B0 12    JNZ   0x256B
255A: 51 CB    MOV   A,[__r3]
255C: 3A CC    CMP   A,[__r1]
255E: B0 0C    JNZ   0x256B
(0571) 	if(CONFIGURED)
(0572) 	{
2560: 62 D0 00 MOV   REG[208],0
2563: 55 CC 01 MOV   [__r1],1
2566: 55 CD 00 MOV   [__r0],0
2569: 83 4C    JMP   0x28B6
(0573) 		PRT0GS |= 0b00011111;	// Connect all pins to the global bus.
(0574) 		PRT2DR &= 0b11111110;	// Turn on the LED (active low).
(0575) 	}
(0576) 	else
256B: 62 D0 00 MOV   REG[208],0
256E: 52 00    MOV   A,[X+0]
2570: 05 04    ADD   [X+4],A
2572: 0F 03 00 ADC   [X+3],0
2575: 62 D0 00 MOV   REG[208],0
2578: 3C D2 00 CMP   [TIMEOUT],0
257B: B0 06    JNZ   0x2582
257D: 3C D3 00 CMP   [TIMEOUT+1],0
2580: AF 9F    JZ    0x2520
2582: 62 D0 00 MOV   REG[208],0
2585: 3C D2 00 CMP   [TIMEOUT],0
2588: B0 06    JNZ   0x258F
258A: 3C D3 00 CMP   [TIMEOUT+1],0
258D: AF 76    JZ    0x2504
(0577) 	{
(0578) 		PRT0GS |= 0b00000001;	// Just connect pin 0;
(0579) 		PRT2DR |= 0b00000001;	// Turn off the LED (active low).
(0580) 	}
(0581) }
(0582) 
(0583) // This function checks the current hardware configuration state. Once it finds this state, it
258F: 83 1D    JMP   0x28AD
(0584) // uses the receivers that are in that configuration in the way they are intended to grab the
2591: 3D 00 FC CMP   [X+0],252
2594: B3 18    JNZ   0x28AD
(0585) // transmission information that we require (or just let commands pass through if we don't care).
2596: 80 15    JMP   0x25AC
(0586) int commandReady(void)
(0587) {
(0588) 	int i = 0;			// This integer is used for looping through the remaining bytes of commands.
(0589) 	char tempByte = 0;	// This byte is used to store each byte for comparison as it comes in.
2598: 10       PUSH  X
2599: 7C 1F 86 LCALL 0x1F86
259C: 62 D0 00 MOV   REG[208],0
259F: 20       POP   X
25A0: 39 FD    CMP   A,253
25A2: B0 09    JNZ   0x25AC
(0590) 	
(0591) 	int runningTotal = 0;	// This is used to check for a checksum in the case of a servo transmit.
25A4: 55 CC 01 MOV   [__r1],1
25A7: 55 CD 00 MOV   [__r0],0
25AA: 83 0B    JMP   0x28B6
25AC: 62 D0 00 MOV   REG[208],0
25AF: 3C D2 00 CMP   [TIMEOUT],0
25B2: B0 06    JNZ   0x25B9
25B4: 3C D3 00 CMP   [TIMEOUT+1],0
25B7: AF E0    JZ    0x2598
(0592) 	
(0593) 	// This conditional checks which configuration is loaded and uses the proper devices to
(0594) 	// read a transmission and store the important information from that transmission.
(0595) 	if(STATE == WAIT)
(0596) 	{	
25B9: 82 F3    JMP   0x28AD
(0597) 		// In wait mode, the only thing that progresses things forward is a master node transmission.
25BB: 62 D0 00 MOV   REG[208],0
25BE: 3C D0 00 CMP   [STATE],0
25C1: B0 D2    JNZ   0x2694
25C3: 3C D1 04 CMP   [STATE+1],4
25C6: B0 CD    JNZ   0x2694
(0598) 		// With this being the case, we use a blocking operation to sit and wait for a byte.
(0599) 		tempByte = WAIT_RECV_cGetChar();
25C8: 10       PUSH  X
25C9: 7C 1D CD LCALL 0x1DCD
25CC: 62 D0 00 MOV   REG[208],0
25CF: 20       POP   X
25D0: 54 00    MOV   [X+0],A
25D2: 39 00    CMP   A,0
25D4: A2 D8    JZ    0x28AD
(0600) 		
(0601) 		// If a transmission has started for either a controller or a servo...
25D6: 3D 00 FF CMP   [X+0],255
25D9: B0 90    JNZ   0x266A
(0602) 		if(tempByte == START_TRANSMIT)
25DB: 80 7F    JMP   0x265B
(0603) 		{
(0604) 			// While we keep reading start bytes, sit and spin.
(0605) 			while(tempByte == START_TRANSMIT)
(0606) 			{
(0607) 				tempByte = WAIT_RECV_cGetChar();
25DD: 10       PUSH  X
25DE: 7C 1D CD LCALL 0x1DCD
25E1: 62 D0 00 MOV   REG[208],0
25E4: 20       POP   X
25E5: 54 00    MOV   [X+0],A
25E7: 39 00    CMP   A,0
25E9: A0 71    JZ    0x265B
(0608) 			}
(0609) 			
(0610) 			// The tempByte variable contains the source ID. If the source is good, store all bytes.
(0611) 			if(tempByte == MASTER_ID)
25EB: 3D 00 FF CMP   [X+0],255
25EE: A0 6C    JZ    0x265B
(0612) 			{
(0613) 				COMMAND_SOURCE = tempByte;
(0614) 				COMMAND_DESTINATION = WAIT_RECV_cGetChar();
25F0: 52 00    MOV   A,[X+0]
25F2: 05 04    ADD   [X+4],A
25F4: 0F 03 00 ADC   [X+3],0
25F7: 80 56    JMP   0x264E
(0615) 				COMMAND_TYPE = WAIT_RECV_cGetChar();
(0616) 				COMMAND_PARAM = WAIT_RECV_cGetChar();
(0617) 				
(0618) 				return 1;
(0619) 			}
(0620) 		}
25F9: 10       PUSH  X
25FA: 7C 1D CD LCALL 0x1DCD
25FD: 62 D0 00 MOV   REG[208],0
2600: 20       POP   X
2601: 54 00    MOV   [X+0],A
2603: 39 00    CMP   A,0
2605: A0 48    JZ    0x264E
(0621) 		else if(tempByte == SERVO_START)
(0622) 		{
(0623) 			// While we keep reading start bytes, sit and spin.
2607: 52 00    MOV   A,[X+0]
2609: 53 CC    MOV   [__r1],A
260B: 55 CD 00 MOV   [__r0],0
260E: 50 FF    MOV   A,255
2610: 12 CC    SUB   A,[__r1]
2612: 53 CC    MOV   [__r1],A
2614: 50 00    MOV   A,0
2616: 1A CD    SBB   A,[__r0]
2618: 53 CD    MOV   [__r0],A
261A: 50 01    MOV   A,1
261C: 08       PUSH  A
261D: 50 00    MOV   A,0
261F: 08       PUSH  A
2620: 52 03    MOV   A,[X+3]
2622: 08       PUSH  A
2623: 52 04    MOV   A,[X+4]
2625: 08       PUSH  A
2626: 7C 32 1F LCALL __divmod_16X16_16
2629: 38 FE    ADD   SP,254
262B: 18       POP   A
262C: 53 CB    MOV   [__r3],A
262E: 18       POP   A
262F: 3A CD    CMP   A,[__r0]
2631: B0 12    JNZ   0x2644
2633: 51 CB    MOV   A,[__r3]
2635: 3A CC    CMP   A,[__r1]
2637: B0 0C    JNZ   0x2644
(0624) 			while(tempByte == SERVO_START)
(0625) 			{
2639: 62 D0 00 MOV   REG[208],0
263C: 55 CC 01 MOV   [__r1],1
263F: 55 CD 00 MOV   [__r0],0
2642: 82 73    JMP   0x28B6
(0626) 				tempByte = WAIT_RECV_cGetChar();
(0627) 			}
(0628) 			
(0629) 			// We assume (and hopefully rightly so) that this is a command from master.
2644: 62 D0 00 MOV   REG[208],0
2647: 52 00    MOV   A,[X+0]
2649: 05 04    ADD   [X+4],A
264B: 0F 03 00 ADC   [X+3],0
264E: 62 D0 00 MOV   REG[208],0
2651: 3C D2 00 CMP   [TIMEOUT],0
2654: B0 06    JNZ   0x265B
2656: 3C D3 00 CMP   [TIMEOUT+1],0
2659: AF 9F    JZ    0x25F9
265B: 62 D0 00 MOV   REG[208],0
265E: 3C D2 00 CMP   [TIMEOUT],0
2661: B0 06    JNZ   0x2668
2663: 3C D3 00 CMP   [TIMEOUT+1],0
2666: AF 76    JZ    0x25DD
(0630) 			COMMAND_SOURCE = MASTER_ID;
(0631) 			// The first parameter after the servo start is the destination.
(0632) 			COMMAND_DESTINATION = tempByte;
(0633) 			// The second parameter after the servo start is the command length.
(0634) 			// We don't need it to wait for the transmission to go through since the
(0635) 			// transmission goes through the chip with a delay of approximately 100 ns
(0636) 			// (it is already in and out by the time you read this byte).
2668: 82 44    JMP   0x28AD
(0637) 			tempByte = WAIT_RECV_cGetChar();
266A: 3D 00 FC CMP   [X+0],252
266D: B2 3F    JNZ   0x28AD
(0638) 			// Now we store the command type. Depending on what the status return level
266F: 80 15    JMP   0x2685
(0639) 			// is, we have special duties.
(0640) 			COMMAND_TYPE = WAIT_RECV_cGetChar();
(0641) 			
(0642) 			// This basically clears the rest of the command from the buffer
2671: 10       PUSH  X
2672: 7C 1D CD LCALL 0x1DCD
2675: 62 D0 00 MOV   REG[208],0
2678: 20       POP   X
2679: 39 FD    CMP   A,253
267B: B0 09    JNZ   0x2685
(0643) 			// and serves the dual purpose of allowing everybody time to hear it.
(0644) 			for(i = 0; i < (tempByte - 1); i++)
267D: 55 CC 01 MOV   [__r1],1
2680: 55 CD 00 MOV   [__r0],0
2683: 82 32    JMP   0x28B6
2685: 62 D0 00 MOV   REG[208],0
2688: 3C D2 00 CMP   [TIMEOUT],0
268B: B0 06    JNZ   0x2692
268D: 3C D3 00 CMP   [TIMEOUT+1],0
2690: AF E0    JZ    0x2671
(0645) 			{
(0646) 				WAIT_RECV_cGetChar();
(0647) 			}
(0648) 				
(0649) 			return 1;
2692: 82 1A    JMP   0x28AD
(0650) 		}
2694: 62 D0 00 MOV   REG[208],0
2697: 3C D0 00 CMP   [STATE],0
269A: B0 D2    JNZ   0x276D
269C: 3C D1 05 CMP   [STATE+1],5
269F: B0 CD    JNZ   0x276D
(0651) 	}
(0652) 	else if(STATE == HELLO_MODE)
26A1: 10       PUSH  X
26A2: 7C 1C 14 LCALL 0x1C14
26A5: 62 D0 00 MOV   REG[208],0
26A8: 20       POP   X
26A9: 54 00    MOV   [X+0],A
26AB: 39 00    CMP   A,0
26AD: A1 FF    JZ    0x28AD
(0653) 	{
(0654) 		// Check all of the ports for a start byte. Only one port will produce one.
26AF: 3D 00 FF CMP   [X+0],255
26B2: B0 90    JNZ   0x2743
(0655) 		// Only non-blocking commands are used to avoid getting stuck listening downstream.
26B4: 80 7F    JMP   0x2734
(0656) 		if(HELLO_1_cReadChar() == START_TRANSMIT)
(0657) 		{
(0658) 			while(!TIMEOUT)
(0659) 			{
(0660) 				if(HELLO_1_cReadChar() == END_TRANSMIT)
26B6: 10       PUSH  X
26B7: 7C 1C 14 LCALL 0x1C14
26BA: 62 D0 00 MOV   REG[208],0
26BD: 20       POP   X
26BE: 54 00    MOV   [X+0],A
26C0: 39 00    CMP   A,0
26C2: A0 71    JZ    0x2734
(0661) 				{
(0662) 					CHILD = PORT_1;
(0663) 				
(0664) 					return 1;
26C4: 3D 00 FF CMP   [X+0],255
26C7: A0 6C    JZ    0x2734
(0665) 				}
(0666) 			}
(0667) 		}
26C9: 52 00    MOV   A,[X+0]
26CB: 05 04    ADD   [X+4],A
26CD: 0F 03 00 ADC   [X+3],0
26D0: 80 56    JMP   0x2727
(0668) 		else if(HELLO_2_cReadChar() == START_TRANSMIT)
(0669) 		{
(0670) 			while(!TIMEOUT)
(0671) 			{
(0672) 				if(HELLO_2_cReadChar() == END_TRANSMIT)
(0673) 				{
26D2: 10       PUSH  X
26D3: 7C 1C 14 LCALL 0x1C14
26D6: 62 D0 00 MOV   REG[208],0
26D9: 20       POP   X
26DA: 54 00    MOV   [X+0],A
26DC: 39 00    CMP   A,0
26DE: A0 48    JZ    0x2727
(0674) 					CHILD = PORT_2;
(0675) 				
(0676) 					return 1;
26E0: 52 00    MOV   A,[X+0]
26E2: 53 CC    MOV   [__r1],A
26E4: 55 CD 00 MOV   [__r0],0
26E7: 50 FF    MOV   A,255
26E9: 12 CC    SUB   A,[__r1]
26EB: 53 CC    MOV   [__r1],A
26ED: 50 00    MOV   A,0
26EF: 1A CD    SBB   A,[__r0]
26F1: 53 CD    MOV   [__r0],A
26F3: 50 01    MOV   A,1
26F5: 08       PUSH  A
26F6: 50 00    MOV   A,0
26F8: 08       PUSH  A
26F9: 52 03    MOV   A,[X+3]
26FB: 08       PUSH  A
26FC: 52 04    MOV   A,[X+4]
26FE: 08       PUSH  A
26FF: 7C 32 1F LCALL __divmod_16X16_16
2702: 38 FE    ADD   SP,254
2704: 18       POP   A
2705: 53 CB    MOV   [__r3],A
2707: 18       POP   A
2708: 3A CD    CMP   A,[__r0]
270A: B0 12    JNZ   0x271D
270C: 51 CB    MOV   A,[__r3]
270E: 3A CC    CMP   A,[__r1]
2710: B0 0C    JNZ   0x271D
(0677) 				}
(0678) 			}
2712: 62 D0 00 MOV   REG[208],0
2715: 55 CC 01 MOV   [__r1],1
2718: 55 CD 00 MOV   [__r0],0
271B: 81 9A    JMP   0x28B6
(0679) 		}
(0680) 		else if(HELLO_3_cReadChar() == START_TRANSMIT)
(0681) 		{
(0682) 			while(!TIMEOUT)
271D: 62 D0 00 MOV   REG[208],0
2720: 52 00    MOV   A,[X+0]
2722: 05 04    ADD   [X+4],A
2724: 0F 03 00 ADC   [X+3],0
2727: 62 D0 00 MOV   REG[208],0
272A: 3C D2 00 CMP   [TIMEOUT],0
272D: B0 06    JNZ   0x2734
272F: 3C D3 00 CMP   [TIMEOUT+1],0
2732: AF 9F    JZ    0x26D2
2734: 62 D0 00 MOV   REG[208],0
2737: 3C D2 00 CMP   [TIMEOUT],0
273A: B0 06    JNZ   0x2741
273C: 3C D3 00 CMP   [TIMEOUT+1],0
273F: AF 76    JZ    0x26B6
(0683) 			{
(0684) 				if(HELLO_3_cReadChar() == END_TRANSMIT)
(0685) 				{
(0686) 					CHILD = PORT_3;
(0687) 				
(0688) 					return 1;
(0689) 				}
2741: 81 6B    JMP   0x28AD
(0690) 			}
2743: 3D 00 FC CMP   [X+0],252
2746: B1 66    JNZ   0x28AD
(0691) 		}
2748: 80 15    JMP   0x275E
(0692) 		else if(HELLO_4_cReadChar() == START_TRANSMIT)
(0693) 		{
(0694) 			while(!TIMEOUT)
(0695) 			{
274A: 10       PUSH  X
274B: 7C 1C 14 LCALL 0x1C14
274E: 62 D0 00 MOV   REG[208],0
2751: 20       POP   X
2752: 39 FD    CMP   A,253
2754: B0 09    JNZ   0x275E
(0696) 				if(HELLO_4_cReadChar() == END_TRANSMIT)
(0697) 				{
2756: 55 CC 01 MOV   [__r1],1
2759: 55 CD 00 MOV   [__r0],0
275C: 81 59    JMP   0x28B6
275E: 62 D0 00 MOV   REG[208],0
2761: 3C D2 00 CMP   [TIMEOUT],0
2764: B0 06    JNZ   0x276B
2766: 3C D3 00 CMP   [TIMEOUT+1],0
2769: AF E0    JZ    0x274A
(0698) 					CHILD = PORT_4;
(0699) 				
(0700) 					return 1;
(0701) 				}
(0702) 			}
276B: 81 41    JMP   0x28AD
(0703) 		}
276D: 62 D0 00 MOV   REG[208],0
2770: 3C D0 00 CMP   [STATE],0
2773: B0 D2    JNZ   0x2846
2775: 3C D1 06 CMP   [STATE+1],6
2778: B0 CD    JNZ   0x2846
(0704) 	}
(0705) 	else if(STATE == RESPONSE_1)
277A: 10       PUSH  X
277B: 7C 1A 5B LCALL 0x1A5B
277E: 62 D0 00 MOV   REG[208],0
2781: 20       POP   X
2782: 54 00    MOV   [X+0],A
2784: 39 00    CMP   A,0
2786: A1 26    JZ    0x28AD
(0706) 	{
(0707) 		if(tempByte = CHILD_1_cReadChar())	// If we have a nonzero byte...
2788: 3D 00 FF CMP   [X+0],255
278B: B0 90    JNZ   0x281C
(0708) 		{
278D: 80 7F    JMP   0x280D
(0709) 			if(tempByte == SERVO_START)		// We have a servo response coming.
(0710) 			{
(0711) 				// While we have not timed out, try to let all of the bytes through.
(0712) 				while(!TIMEOUT)
(0713) 				{
278F: 10       PUSH  X
2790: 7C 1A 5B LCALL 0x1A5B
2793: 62 D0 00 MOV   REG[208],0
2796: 20       POP   X
2797: 54 00    MOV   [X+0],A
2799: 39 00    CMP   A,0
279B: A0 71    JZ    0x280D
(0714) 					// Eat the remaining servo start bytes.
(0715) 					if(tempByte = CHILD_1_cReadChar())
(0716) 					{
(0717) 						// Once we get past the start bytes, we can start adding the
279D: 3D 00 FF CMP   [X+0],255
27A0: A0 6C    JZ    0x280D
(0718) 						// bytes to our running total and searching for a checksum.
(0719) 						if(tempByte != SERVO_START)
(0720) 						{
27A2: 52 00    MOV   A,[X+0]
27A4: 05 04    ADD   [X+4],A
27A6: 0F 03 00 ADC   [X+3],0
27A9: 80 56    JMP   0x2800
(0721) 							// Add to the running total.
(0722) 							runningTotal += tempByte;
(0723) 							
(0724) 							// Either find a checksum or time out. Either way we're not stuck.
(0725) 							while(!TIMEOUT)
(0726) 							{
27AB: 10       PUSH  X
27AC: 7C 1A 5B LCALL 0x1A5B
27AF: 62 D0 00 MOV   REG[208],0
27B2: 20       POP   X
27B3: 54 00    MOV   [X+0],A
27B5: 39 00    CMP   A,0
27B7: A0 48    JZ    0x2800
(0727) 								// If a nonzero byte has arrived...
(0728) 								if(tempByte = CHILD_1_cReadChar())
(0729) 								{
27B9: 52 00    MOV   A,[X+0]
27BB: 53 CC    MOV   [__r1],A
27BD: 55 CD 00 MOV   [__r0],0
27C0: 50 FF    MOV   A,255
27C2: 12 CC    SUB   A,[__r1]
27C4: 53 CC    MOV   [__r1],A
27C6: 50 00    MOV   A,0
27C8: 1A CD    SBB   A,[__r0]
27CA: 53 CD    MOV   [__r0],A
27CC: 50 01    MOV   A,1
27CE: 08       PUSH  A
27CF: 50 00    MOV   A,0
27D1: 08       PUSH  A
27D2: 52 03    MOV   A,[X+3]
27D4: 08       PUSH  A
27D5: 52 04    MOV   A,[X+4]
27D7: 08       PUSH  A
27D8: 7C 32 1F LCALL __divmod_16X16_16
27DB: 38 FE    ADD   SP,254
27DD: 18       POP   A
27DE: 53 CB    MOV   [__r3],A
27E0: 18       POP   A
27E1: 3A CD    CMP   A,[__r0]
27E3: B0 12    JNZ   0x27F6
27E5: 51 CB    MOV   A,[__r3]
27E7: 3A CC    CMP   A,[__r1]
27E9: B0 0C    JNZ   0x27F6
(0730) 									// Check to see if it is a checksum.
(0731) 									if((runningTotal%256) == (255-tempByte))
27EB: 62 D0 00 MOV   REG[208],0
27EE: 55 CC 01 MOV   [__r1],1
27F1: 55 CD 00 MOV   [__r0],0
27F4: 80 C1    JMP   0x28B6
(0732) 									{
(0733) 										return 1;
(0734) 									}
(0735) 									else
27F6: 62 D0 00 MOV   REG[208],0
27F9: 52 00    MOV   A,[X+0]
27FB: 05 04    ADD   [X+4],A
27FD: 0F 03 00 ADC   [X+3],0
2800: 62 D0 00 MOV   REG[208],0
2803: 3C D2 00 CMP   [TIMEOUT],0
2806: B0 06    JNZ   0x280D
2808: 3C D3 00 CMP   [TIMEOUT+1],0
280B: AF 9F    JZ    0x27AB
280D: 62 D0 00 MOV   REG[208],0
2810: 3C D2 00 CMP   [TIMEOUT],0
2813: B0 06    JNZ   0x281A
2815: 3C D3 00 CMP   [TIMEOUT+1],0
2818: AF 76    JZ    0x278F
(0736) 									{
(0737) 										runningTotal += tempByte;
(0738) 									}
(0739) 								}
(0740) 							}
(0741) 						}
(0742) 					}
281A: 80 92    JMP   0x28AD
(0743) 				}
281C: 3D 00 FC CMP   [X+0],252
281F: B0 8D    JNZ   0x28AD
(0744) 			}
2821: 80 15    JMP   0x2837
(0745) 			else if(tempByte == START_TRANSMIT)	// We have a controller response coming.
(0746) 			{
(0747) 				// We simply wait for the end transmit indicator.
(0748) 				while(!TIMEOUT)
2823: 10       PUSH  X
2824: 7C 1A 5B LCALL 0x1A5B
2827: 62 D0 00 MOV   REG[208],0
282A: 20       POP   X
282B: 39 FD    CMP   A,253
282D: B0 09    JNZ   0x2837
(0749) 				{
(0750) 					if(CHILD_1_cReadChar() == END_TRANSMIT)
282F: 55 CC 01 MOV   [__r1],1
2832: 55 CD 00 MOV   [__r0],0
2835: 80 80    JMP   0x28B6
2837: 62 D0 00 MOV   REG[208],0
283A: 3C D2 00 CMP   [TIMEOUT],0
283D: B0 06    JNZ   0x2844
283F: 3C D3 00 CMP   [TIMEOUT+1],0
2842: AF E0    JZ    0x2823
(0751) 					{
(0752) 						return 1;
(0753) 					}
(0754) 				}
(0755) 			}
2844: 80 68    JMP   0x28AD
(0756) 		}
2846: 62 D0 00 MOV   REG[208],0
2849: 3C D0 00 CMP   [STATE],0
284C: B0 60    JNZ   0x28AD
284E: 3C D1 08 CMP   [STATE+1],8
2851: B0 5B    JNZ   0x28AD
(0757) 	}
(0758) 	else if(STATE == RESPONSE_2)
2853: 10       PUSH  X
2854: 7C 12 DE LCALL 0x12DE
2857: 62 D0 00 MOV   REG[208],0
285A: 20       POP   X
285B: 39 FF    CMP   A,255
285D: B0 4F    JNZ   0x28AD
(0759) 	{
285F: 80 40    JMP   0x28A0
(0760) 		if(tempByte = CHILD_2_cReadChar())
(0761) 		{
(0762) 			if(tempByte == SERVO_START)		// We have a servo response coming.
(0763) 			{
2861: 10       PUSH  X
2862: 7C 12 DE LCALL 0x12DE
2865: 62 D0 00 MOV   REG[208],0
2868: 20       POP   X
2869: 39 FF    CMP   A,255
286B: B0 34    JNZ   0x28A0
(0764) 				// While we have not timed out, try to let all of the bytes through.
(0765) 				while(!TIMEOUT)
(0766) 				{
(0767) 					// Eat the remaining servo start bytes.
286D: 10       PUSH  X
286E: 7C 12 D6 LCALL 0x12D6
2871: 20       POP   X
2872: 62 D0 00 MOV   REG[208],0
2875: 53 E4    MOV   [COMMAND_SOURCE],A
(0768) 					if(tempByte = CHILD_2_cReadChar())
2877: 10       PUSH  X
2878: 7C 12 D6 LCALL 0x12D6
287B: 20       POP   X
287C: 62 D0 00 MOV   REG[208],0
287F: 53 E0    MOV   [COMMAND_LENGTH],A
(0769) 					{
2881: 10       PUSH  X
2882: 7C 12 D6 LCALL 0x12D6
2885: 20       POP   X
2886: 62 D0 00 MOV   REG[208],0
2889: 53 DF    MOV   [COMMAND_ERROR],A
(0770) 						// Once we get past the start bytes, we can start adding the
288B: 10       PUSH  X
288C: 7C 12 D6 LCALL 0x12D6
288F: 20       POP   X
2890: 62 D0 00 MOV   REG[208],0
2893: 53 E1    MOV   [COMMAND_PARAM],A
(0771) 						// bytes to our running total and searching for a checksum.
(0772) 						if(tempByte != SERVO_START)
2895: 62 D0 00 MOV   REG[208],0
2898: 55 CC 01 MOV   [__r1],1
289B: 55 CD 00 MOV   [__r0],0
289E: 80 17    JMP   0x28B6
28A0: 62 D0 00 MOV   REG[208],0
28A3: 3C D2 00 CMP   [TIMEOUT],0
28A6: B0 06    JNZ   0x28AD
28A8: 3C D3 00 CMP   [TIMEOUT+1],0
28AB: AF B5    JZ    0x2861
(0773) 						{
(0774) 							// Add to the running total.
(0775) 							runningTotal += tempByte;
(0776) 							
(0777) 							// Either find a checksum or time out. Either way we're not stuck.
(0778) 							while(!TIMEOUT)
28AD: 62 D0 00 MOV   REG[208],0
28B0: 55 CC 00 MOV   [__r1],0
28B3: 55 CD 00 MOV   [__r0],0
28B6: 38 FB    ADD   SP,251
28B8: 20       POP   X
28B9: 7F       RET   
(0779) 							{
(0780) 								// If a nonzero byte has arrived...
(0781) 								if(tempByte = CHILD_2_cReadChar())
(0782) 								{
(0783) 									// Check to see if it is a checksum.
(0784) 									if((runningTotal%256) == (255-tempByte))
_takeAction:
  runningTotal         --> X+3
  tempByte             --> X+2
  i                    --> X+0
28BA: 10       PUSH  X
28BB: 4F       MOV   X,SP
28BC: 38 05    ADD   SP,5
(0785) 									{
28BE: 56 01 00 MOV   [X+1],0
28C1: 56 00 00 MOV   [X+0],0
(0786) 										return 1;
28C4: 56 02 00 MOV   [X+2],0
(0787) 									}
28C7: 56 04 00 MOV   [X+4],0
28CA: 56 03 00 MOV   [X+3],0
(0788) 									else
(0789) 									{
28CD: 62 D0 00 MOV   REG[208],0
28D0: 3C E2 CC CMP   [COMMAND_TYPE],204
28D3: B0 1A    JNZ   0x28EE
(0790) 										runningTotal += tempByte;
(0791) 									}
(0792) 								}
28D5: 62 D0 00 MOV   REG[208],0
28D8: 55 E5 FB MOV   [ID],251
(0793) 							}
28DB: 62 D0 00 MOV   REG[208],0
28DE: 55 CF 00 MOV   [CONFIGURED+1],0
28E1: 55 CE 00 MOV   [CONFIGURED],0
(0794) 						}
28E4: 62 D0 00 MOV   REG[208],0
28E7: 55 D4 00 MOV   [CHILD],0
(0795) 					}
(0796) 				}
(0797) 			}
28EA: 94 3C    CALL  _servoFinder
(0798) 			else if(tempByte == START_TRANSMIT)	// We have a controller response coming.
28EC: 80 F2    JMP   0x29DF
(0799) 			{
28EE: 62 D0 00 MOV   REG[208],0
28F1: 3C E2 C8 CMP   [COMMAND_TYPE],200
28F4: B0 3B    JNZ   0x2930
(0800) 				// We simply wait for the end transmit indicator.
(0801) 				while(!TIMEOUT)
28F6: 62 D0 00 MOV   REG[208],0
28F9: 3C CE 00 CMP   [CONFIGURED],0
28FC: B0 0B    JNZ   0x2908
28FE: 3C CF 00 CMP   [CONFIGURED+1],0
2901: B0 06    JNZ   0x2908
(0802) 				{
(0803) 					if(CHILD_2_cReadChar() == END_TRANSMIT)
(0804) 					{
2903: 7C 20 9C LCALL _sayHello
(0805) 						return 1;
2906: 80 D8    JMP   0x29DF
(0806) 					}
2908: 62 D0 00 MOV   REG[208],0
290B: 3C D4 00 CMP   [CHILD],0
290E: B0 15    JNZ   0x2924
(0807) 				}
(0808) 			}
(0809) 		}
2910: 92 D6    CALL  _childListen
2912: 62 D0 00 MOV   REG[208],0
2915: 3C CD 00 CMP   [__r0],0
2918: B0 06    JNZ   0x291F
291A: 3C CC 00 CMP   [__r1],0
291D: A0 C1    JZ    0x29DF
(0810) 	}
(0811) 	else if(STATE == RESPONSE_3)
(0812) 	{
291F: 7C 20 9C LCALL _sayHello
(0813) 		if(tempByte = CHILD_3_cReadChar())
(0814) 		{
2922: 80 BC    JMP   0x29DF
(0815) 			if(tempByte == SERVO_START)		// We have a servo response coming.
2924: 62 D0 00 MOV   REG[208],0
2927: 3C D4 00 CMP   [CHILD],0
292A: A0 B4    JZ    0x29DF
(0816) 			{
(0817) 				// While we have not timed out, try to let all of the bytes through.
(0818) 				while(!TIMEOUT)
292C: 93 12    CALL  _childResponse
(0819) 				{
(0820) 					// Eat the remaining servo start bytes.
292E: 80 B0    JMP   0x29DF
(0821) 					if(tempByte = CHILD_3_cReadChar())
2930: 62 D0 00 MOV   REG[208],0
2933: 3C E2 CB CMP   [COMMAND_TYPE],203
2936: B0 21    JNZ   0x2958
(0822) 					{
(0823) 						// Once we get past the start bytes, we can start adding the
(0824) 						// bytes to our running total and searching for a checksum.
2938: 62 D0 00 MOV   REG[208],0
293B: 51 E3    MOV   A,[COMMAND_DESTINATION]
293D: 62 D0 00 MOV   REG[208],0
2940: 3A E5    CMP   A,[ID]
2942: B0 05    JNZ   0x2948
(0825) 						if(tempByte != SERVO_START)
(0826) 						{
(0827) 							// Add to the running total.
2944: 90 9D    CALL  _pingResponse
(0828) 							runningTotal += tempByte;
2946: 80 98    JMP   0x29DF
(0829) 							
2948: 62 D0 00 MOV   REG[208],0
294B: 51 E5    MOV   A,[ID]
294D: 62 D0 00 MOV   REG[208],0
2950: 3A E3    CMP   A,[COMMAND_DESTINATION]
2952: D0 8C    JNC   0x29DF
(0830) 							// Either find a checksum or time out. Either way we're not stuck.
(0831) 							while(!TIMEOUT)
(0832) 							{
2954: 92 EA    CALL  _childResponse
(0833) 								// If a nonzero byte has arrived...
(0834) 								if(tempByte = CHILD_3_cReadChar())
2956: 80 88    JMP   0x29DF
(0835) 								{
2958: 62 D0 00 MOV   REG[208],0
295B: 3C E2 C9 CMP   [COMMAND_TYPE],201
295E: B0 65    JNZ   0x29C4
(0836) 									// Check to see if it is a checksum.
(0837) 									if((runningTotal%256) == (255-tempByte))
(0838) 									{
2960: 62 D0 00 MOV   REG[208],0
2963: 51 E3    MOV   A,[COMMAND_DESTINATION]
2965: 62 D0 00 MOV   REG[208],0
2968: 3A E5    CMP   A,[ID]
296A: B0 49    JNZ   0x29B4
(0839) 										return 1;
(0840) 									}
296C: 62 D0 00 MOV   REG[208],0
296F: 50 00    MOV   A,0
2971: 3A E1    CMP   A,[COMMAND_PARAM]
2973: D0 6B    JNC   0x29DF
2975: 62 D0 00 MOV   REG[208],0
2978: 3C E1 FB CMP   [COMMAND_PARAM],251
297B: D0 63    JNC   0x29DF
(0841) 									else
(0842) 									{
(0843) 										runningTotal += tempByte;
297D: 62 D0 00 MOV   REG[208],0
2980: 51 E1    MOV   A,[COMMAND_PARAM]
2982: 62 D0 00 MOV   REG[208],0
2985: 53 E5    MOV   [ID],A
(0844) 									}
(0845) 								}
(0846) 							}
2987: 62 D0 00 MOV   REG[208],0
298A: 55 CF 01 MOV   [CONFIGURED+1],1
298D: 55 CE 00 MOV   [CONFIGURED],0
(0847) 						}
(0848) 					}
(0849) 				}
2990: 91 B7    CALL  _assignedID
(0850) 			}
(0851) 			else if(tempByte == START_TRANSMIT)	// We have a controller response coming.
(0852) 			{
2992: 62 D0 00 MOV   REG[208],0
2995: 51 E5    MOV   A,[ID]
2997: 08       PUSH  A
2998: 50 03    MOV   A,3
299A: 08       PUSH  A
299B: 08       PUSH  A
299C: 50 04    MOV   A,4
299E: 08       PUSH  A
299F: 62 D0 00 MOV   REG[208],0
29A2: 51 E7    MOV   A,[SERVO_ID]
29A4: 08       PUSH  A
29A5: 95 3B    CALL  _servoInstruction
(0853) 				// We simply wait for the end transmit indicator.
(0854) 				while(!TIMEOUT)
(0855) 				{
29A7: 50 00    MOV   A,0
29A9: 08       PUSH  A
29AA: 50 01    MOV   A,1
29AC: 08       PUSH  A
29AD: 7C 21 01 LCALL _configToggle
29B0: 38 F9    ADD   SP,249
(0856) 					if(CHILD_3_cReadChar() == END_TRANSMIT)
(0857) 					{
29B2: 80 2C    JMP   0x29DF
(0858) 						return 1;
29B4: 62 D0 00 MOV   REG[208],0
29B7: 51 E5    MOV   A,[ID]
29B9: 62 D0 00 MOV   REG[208],0
29BC: 3A E3    CMP   A,[COMMAND_DESTINATION]
29BE: D0 20    JNC   0x29DF
(0859) 					}
(0860) 				}
(0861) 			}
29C0: 92 7E    CALL  _childResponse
(0862) 		}
(0863) 	}
29C2: 80 1C    JMP   0x29DF
(0864) 	else if(STATE == RESPONSE_4)
29C4: 62 D0 00 MOV   REG[208],0
29C7: 3C E2 01 CMP   [COMMAND_TYPE],1
29CA: A0 06    JZ    0x29D1
29CC: 3C E2 02 CMP   [COMMAND_TYPE],2
29CF: B0 0F    JNZ   0x29DF
(0865) 	{
(0866) 		if(tempByte = CHILD_4_cReadChar())
29D1: 62 D0 00 MOV   REG[208],0
29D4: 51 E5    MOV   A,[ID]
29D6: 62 D0 00 MOV   REG[208],0
29D9: 3A E3    CMP   A,[COMMAND_DESTINATION]
29DB: D0 03    JNC   0x29DF
(0867) 		{
(0868) 			if(tempByte == SERVO_START)		// We have a servo response coming.
(0869) 			{
29DD: 92 61    CALL  _childResponse
(0870) 				// While we have not timed out, try to let all of the bytes through.
(0871) 				while(!TIMEOUT)
29DF: 38 FB    ADD   SP,251
29E1: 20       POP   X
29E2: 7F       RET   
(0872) 				{
(0873) 					// Eat the remaining servo start bytes.
(0874) 					if(tempByte = CHILD_4_cReadChar())
(0875) 					{
(0876) 						// Once we get past the start bytes, we can start adding the
(0877) 						// bytes to our running total and searching for a checksum.
_pingResponse:
29E3: 50 00    MOV   A,0
29E5: 08       PUSH  A
29E6: 50 02    MOV   A,2
29E8: 08       PUSH  A
29E9: 7C 21 01 LCALL _configToggle
29EC: 38 FE    ADD   SP,254
(0878) 						if(tempByte != SERVO_START)
(0879) 						{
(0880) 							// Add to the running total.
29EE: 10       PUSH  X
29EF: 50 FC    MOV   A,252
29F1: 7C 0E D4 LCALL 0x0ED4
29F4: 20       POP   X
(0881) 							runningTotal += tempByte;
29F5: 10       PUSH  X
29F6: 50 FC    MOV   A,252
29F8: 7C 0D FB LCALL 0x0DFB
29FB: 20       POP   X
(0882) 							
29FC: 10       PUSH  X
29FD: 50 FC    MOV   A,252
29FF: 7C 0E D4 LCALL 0x0ED4
2A02: 20       POP   X
(0883) 							// Either find a checksum or time out. Either way we're not stuck.
2A03: 10       PUSH  X
2A04: 50 FC    MOV   A,252
2A06: 7C 0D FB LCALL 0x0DFB
2A09: 20       POP   X
(0884) 							while(!TIMEOUT)
2A0A: 10       PUSH  X
2A0B: 62 D0 00 MOV   REG[208],0
2A0E: 51 E5    MOV   A,[ID]
2A10: 7C 0E D4 LCALL 0x0ED4
2A13: 20       POP   X
(0885) 							{
2A14: 10       PUSH  X
2A15: 62 D0 00 MOV   REG[208],0
2A18: 51 E5    MOV   A,[ID]
2A1A: 7C 0D FB LCALL 0x0DFB
2A1D: 20       POP   X
(0886) 								// If a nonzero byte has arrived...
2A1E: 10       PUSH  X
2A1F: 50 00    MOV   A,0
2A21: 7C 0E D4 LCALL 0x0ED4
2A24: 20       POP   X
(0887) 								if(tempByte = CHILD_4_cReadChar())
2A25: 10       PUSH  X
2A26: 50 00    MOV   A,0
2A28: 7C 0D FB LCALL 0x0DFB
2A2B: 20       POP   X
(0888) 								{
2A2C: 10       PUSH  X
2A2D: 50 CB    MOV   A,203
2A2F: 7C 0E D4 LCALL 0x0ED4
2A32: 20       POP   X
(0889) 									// Check to see if it is a checksum.
2A33: 10       PUSH  X
2A34: 50 CB    MOV   A,203
2A36: 7C 0D FB LCALL 0x0DFB
2A39: 20       POP   X
(0890) 									if((runningTotal%256) == (255-tempByte))
2A3A: 10       PUSH  X
2A3B: 50 31    MOV   A,49
2A3D: 7C 0E D4 LCALL 0x0ED4
2A40: 20       POP   X
(0891) 									{
2A41: 10       PUSH  X
2A42: 50 31    MOV   A,49
2A44: 7C 0D FB LCALL 0x0DFB
2A47: 20       POP   X
(0892) 										return 1;
2A48: 10       PUSH  X
2A49: 62 D0 00 MOV   REG[208],0
2A4C: 51 D4    MOV   A,[CHILD]
2A4E: 7C 0E D4 LCALL 0x0ED4
2A51: 20       POP   X
(0893) 									}
2A52: 10       PUSH  X
2A53: 62 D0 00 MOV   REG[208],0
2A56: 51 D4    MOV   A,[CHILD]
2A58: 7C 0D FB LCALL 0x0DFB
2A5B: 20       POP   X
(0894) 									else
2A5C: 10       PUSH  X
2A5D: 50 FD    MOV   A,253
2A5F: 7C 0E D4 LCALL 0x0ED4
2A62: 20       POP   X
(0895) 									{
2A63: 10       PUSH  X
2A64: 50 FD    MOV   A,253
2A66: 7C 0D FB LCALL 0x0DFB
2A69: 20       POP   X
(0896) 										runningTotal += tempByte;
2A6A: 10       PUSH  X
2A6B: 50 FD    MOV   A,253
2A6D: 7C 0E D4 LCALL 0x0ED4
2A70: 20       POP   X
(0897) 									}
2A71: 10       PUSH  X
2A72: 50 FD    MOV   A,253
2A74: 7C 0D FB LCALL 0x0DFB
2A77: 20       POP   X
(0898) 								}
(0899) 							}
(0900) 						}
2A78: 10       PUSH  X
2A79: 7C 0E A7 LCALL 0x0EA7
2A7C: 62 D0 00 MOV   REG[208],0
2A7F: 20       POP   X
2A80: 53 CD    MOV   [__r0],A
2A82: 47 CD 20 TST   [__r0],32
2A85: AF F2    JZ    0x2A78
(0901) 					}
2A87: 10       PUSH  X
2A88: 7C 0D CE LCALL 0x0DCE
2A8B: 62 D0 00 MOV   REG[208],0
2A8E: 20       POP   X
2A8F: 53 CD    MOV   [__r0],A
2A91: 47 CD 20 TST   [__r0],32
2A94: AF F2    JZ    0x2A87
(0902) 				}
(0903) 			}
(0904) 			else if(tempByte == START_TRANSMIT)	// We have a controller response coming.
2A96: 95 28    CALL  _xmitWait
(0905) 			{
(0906) 				// We simply wait for the end transmit indicator.
2A98: 50 00    MOV   A,0
2A9A: 08       PUSH  A
2A9B: 50 01    MOV   A,1
2A9D: 08       PUSH  A
2A9E: 7C 21 01 LCALL _configToggle
2AA1: 38 FE    ADD   SP,254
2AA3: 7F       RET   
(0907) 				while(!TIMEOUT)
(0908) 				{
(0909) 					if(CHILD_4_cReadChar() == END_TRANSMIT)
(0910) 					{
(0911) 						return 1;
(0912) 					}
(0913) 				}
_unloadAllConfigs:
2AA4: 7C 06 E6 LCALL 0x06E6
(0914) 			}
2AA7: 7C 07 55 LCALL 0x0755
(0915) 		}
2AAA: 7C 08 7A LCALL 0x087A
(0916) 	}
2AAD: 7C 08 FC LCALL 0x08FC
(0917) 	else if(STATE == INITIALIZE)
2AB0: 7C 09 9F LCALL 0x099F
(0918) 	{
2AB3: 7C 0A 42 LCALL 0x0A42
(0919) 		if(INIT_RX_cReadChar() == SERVO_START)
2AB6: 7C 0A EB LCALL 0x0AEB
(0920) 		{
2AB9: 7C 07 F5 LCALL 0x07F5
(0921) 			while(!TIMEOUT)
2ABC: 7C 0B 91 LCALL 0x0B91
2ABF: 7F       RET   
(0922) 			{
(0923) 				// We officially have a transmission.
(0924) 				if(INIT_RX_cReadChar() == SERVO_START)
(0925) 				{
(0926) 					// If we definitely have a transmission starting, grab all bytes from the rx buffer
(0927) 					// and store them in the proper variables for actions to be taken later.
_unloadConfig:
  config_num           --> X-5
2AC0: 10       PUSH  X
2AC1: 4F       MOV   X,SP
(0928) 					COMMAND_SOURCE = INIT_RX_cGetChar();
2AC2: 3D FB 00 CMP   [X-5],0
2AC5: B0 0B    JNZ   0x2AD1
2AC7: 3D FC 01 CMP   [X-4],1
2ACA: B0 06    JNZ   0x2AD1
(0929) 					COMMAND_LENGTH = INIT_RX_cGetChar();
(0930) 					COMMAND_ERROR = INIT_RX_cGetChar();
2ACC: 7C 06 E6 LCALL 0x06E6
(0931) 					COMMAND_PARAM = INIT_RX_cGetChar();
2ACF: 80 77    JMP   0x2B47
(0932) 					
2AD1: 3D FB 00 CMP   [X-5],0
2AD4: B0 0B    JNZ   0x2AE0
2AD6: 3D FC 07 CMP   [X-4],7
2AD9: B0 06    JNZ   0x2AE0
(0933) 					return 1;
(0934) 				}
2ADB: 7C 07 55 LCALL 0x0755
(0935) 			}
2ADE: 80 68    JMP   0x2B47
(0936) 		}
2AE0: 3D FB 00 CMP   [X-5],0
2AE3: B0 0B    JNZ   0x2AEF
2AE5: 3D FC 02 CMP   [X-4],2
2AE8: B0 06    JNZ   0x2AEF
(0937) 	}
(0938) 	
2AEA: 7C 08 7A LCALL 0x087A
(0939) 	return 0;
2AED: 80 59    JMP   0x2B47
(0940) }
2AEF: 3D FB 00 CMP   [X-5],0
2AF2: B0 0B    JNZ   0x2AFE
2AF4: 3D FC 03 CMP   [X-4],3
2AF7: B0 06    JNZ   0x2AFE
(0941) 
(0942) // This function interprets what has been read by the command ready function
2AF9: 7C 08 FC LCALL 0x08FC
(0943) // and performs the appropriate action.
2AFC: 80 4A    JMP   0x2B47
(0944) void takeAction(void)
2AFE: 3D FB 00 CMP   [X-5],0
2B01: B0 0B    JNZ   0x2B0D
2B03: 3D FC 04 CMP   [X-4],4
2B06: B0 06    JNZ   0x2B0D
(0945) {
(0946) 	int i = 0;							// An index variable for looping.
2B08: 7C 09 9F LCALL 0x099F
(0947) 	char tempByte = 0;					// A temporary byte storage variable.
2B0B: 80 3B    JMP   0x2B47
(0948) 	int runningTotal = 0;				// A running total of bytes to check against a checksum.
2B0D: 3D FB 00 CMP   [X-5],0
2B10: B0 0B    JNZ   0x2B1C
2B12: 3D FC 05 CMP   [X-4],5
2B15: B0 06    JNZ   0x2B1C
(0949) 	
(0950) 	if(COMMAND_TYPE == CLEAR)				// The master wants to clear the arm.
2B17: 7C 0A 42 LCALL 0x0A42
(0951) 	{
2B1A: 80 2C    JMP   0x2B47
(0952) 		// Reset the discovered parameters.
2B1C: 3D FB 00 CMP   [X-5],0
2B1F: B0 0B    JNZ   0x2B2B
2B21: 3D FC 06 CMP   [X-4],6
2B24: B0 06    JNZ   0x2B2B
(0953) 		ID = DEFAULT_ID;
(0954) 		CONFIGURED = 0;
2B26: 7C 0A EB LCALL 0x0AEB
(0955) 		CHILD = 0;
2B29: 80 1D    JMP   0x2B47
(0956) 		
2B2B: 3D FB 00 CMP   [X-5],0
2B2E: B0 0B    JNZ   0x2B3A
2B30: 3D FC 08 CMP   [X-4],8
2B33: B0 06    JNZ   0x2B3A
(0957) 		// Find the servo again.
(0958) 		servoFinder();
2B35: 7C 07 F5 LCALL 0x07F5
(0959) 	}
2B38: 80 0E    JMP   0x2B47
(0960) 	else if(COMMAND_TYPE == HELLO_BYTE)		// The master is probing for new modules.
2B3A: 3D FB 00 CMP   [X-5],0
2B3D: B0 09    JNZ   0x2B47
2B3F: 3D FC 09 CMP   [X-4],9
2B42: B0 04    JNZ   0x2B47
(0961) 	{
(0962) 		if(!CONFIGURED)
2B44: 7C 0B 91 LCALL 0x0B91
(0963) 		{
2B47: 20       POP   X
2B48: 7F       RET   
(0964) 			// Announce this module's presence if not configured.
(0965) 			sayHello();
(0966) 		}
(0967) 		else if(!CHILD)
(0968) 		{
(0969) 			// Listen for children if we have none.
_assignedID:
2B49: 50 00    MOV   A,0
2B4B: 08       PUSH  A
2B4C: 50 02    MOV   A,2
2B4E: 08       PUSH  A
2B4F: 7C 21 01 LCALL _configToggle
2B52: 38 FE    ADD   SP,254
(0970) 			if(childListen())
(0971) 			{
(0972) 				// If a child was heard saying hello, forward the command with the port number added.
2B54: 10       PUSH  X
2B55: 50 FC    MOV   A,252
2B57: 7C 0E D4 LCALL 0x0ED4
2B5A: 20       POP   X
(0973) 				sayHello();
2B5B: 10       PUSH  X
2B5C: 50 FC    MOV   A,252
2B5E: 7C 0D FB LCALL 0x0DFB
2B61: 20       POP   X
(0974) 			}
2B62: 10       PUSH  X
2B63: 50 FC    MOV   A,252
2B65: 7C 0E D4 LCALL 0x0ED4
2B68: 20       POP   X
(0975) 		}
2B69: 10       PUSH  X
2B6A: 50 FC    MOV   A,252
2B6C: 7C 0D FB LCALL 0x0DFB
2B6F: 20       POP   X
(0976) 		else if(CHILD)
2B70: 10       PUSH  X
2B71: 62 D0 00 MOV   REG[208],0
2B74: 51 E5    MOV   A,[ID]
2B76: 7C 0E D4 LCALL 0x0ED4
2B79: 20       POP   X
(0977) 		{
2B7A: 10       PUSH  X
2B7B: 62 D0 00 MOV   REG[208],0
2B7E: 51 E5    MOV   A,[ID]
2B80: 7C 0D FB LCALL 0x0DFB
2B83: 20       POP   X
(0978) 			// If you have a child established, listen to that child.
2B84: 10       PUSH  X
2B85: 50 00    MOV   A,0
2B87: 7C 0E D4 LCALL 0x0ED4
2B8A: 20       POP   X
(0979) 			childResponse();
2B8B: 10       PUSH  X
2B8C: 50 00    MOV   A,0
2B8E: 7C 0D FB LCALL 0x0DFB
2B91: 20       POP   X
(0980) 		}
2B92: 10       PUSH  X
2B93: 50 CA    MOV   A,202
2B95: 7C 0E D4 LCALL 0x0ED4
2B98: 20       POP   X
(0981) 	}
2B99: 10       PUSH  X
2B9A: 50 CA    MOV   A,202
2B9C: 7C 0D FB LCALL 0x0DFB
2B9F: 20       POP   X
(0982) 	else if(COMMAND_TYPE == PING)		// The master is trying to find a module that is configured.
2BA0: 10       PUSH  X
2BA1: 50 FD    MOV   A,253
2BA3: 7C 0E D4 LCALL 0x0ED4
2BA6: 20       POP   X
(0983) 	{
2BA7: 10       PUSH  X
2BA8: 50 FD    MOV   A,253
2BAA: 7C 0D FB LCALL 0x0DFB
2BAD: 20       POP   X
(0984) 		// If this is to me, act accordingly.
2BAE: 10       PUSH  X
2BAF: 50 FD    MOV   A,253
2BB1: 7C 0E D4 LCALL 0x0ED4
2BB4: 20       POP   X
(0985) 		if(COMMAND_DESTINATION == ID)
2BB5: 10       PUSH  X
2BB6: 50 FD    MOV   A,253
2BB8: 7C 0D FB LCALL 0x0DFB
2BBB: 20       POP   X
(0986) 		{
(0987) 			// Ping back to the master.
(0988) 			pingResponse();
2BBC: 10       PUSH  X
2BBD: 7C 0E A7 LCALL 0x0EA7
2BC0: 62 D0 00 MOV   REG[208],0
2BC3: 20       POP   X
2BC4: 53 CD    MOV   [__r0],A
2BC6: 47 CD 20 TST   [__r0],32
2BC9: AF F2    JZ    0x2BBC
(0989) 		}
2BCB: 10       PUSH  X
2BCC: 7C 0D CE LCALL 0x0DCE
2BCF: 62 D0 00 MOV   REG[208],0
2BD2: 20       POP   X
2BD3: 53 CD    MOV   [__r0],A
2BD5: 47 CD 20 TST   [__r0],32
2BD8: AF F2    JZ    0x2BCB
(0990) 		else if(COMMAND_DESTINATION > ID)
(0991) 		{
(0992) 			// If you have a child established, listen to that child.
2BDA: 93 E4    CALL  _xmitWait
(0993) 			childResponse();
(0994) 		}
2BDC: 50 00    MOV   A,0
2BDE: 08       PUSH  A
2BDF: 50 01    MOV   A,1
2BE1: 08       PUSH  A
2BE2: 7C 21 01 LCALL _configToggle
2BE5: 38 FE    ADD   SP,254
2BE7: 7F       RET   
(0995) 	}
(0996) 	else if(COMMAND_TYPE == ID_ASSIGNMENT)	// The master is assigning an ID to someone.
(0997) 	{
(0998) 		// If this is meant for me, change my ID.
(0999) 		if(COMMAND_DESTINATION == ID)
(1000) 		{
_childListen:
2BE8: 50 00    MOV   A,0
2BEA: 08       PUSH  A
2BEB: 50 07    MOV   A,7
2BED: 08       PUSH  A
2BEE: 7C 21 01 LCALL _configToggle
2BF1: 38 FE    ADD   SP,254
2BF3: 80 1C    JMP   0x2C10
(1001) 			if((COMMAND_PARAM > MASTER_ID) && (COMMAND_PARAM < DEFAULT_ID))
(1002) 			{
(1003) 				// Assign this module the ID that has been passed by the master.
(1004) 				ID = COMMAND_PARAM;
(1005) 				
2BF5: 7C 23 0B LCALL _commandReady
2BF8: 62 D0 00 MOV   REG[208],0
2BFB: 3C CD 00 CMP   [__r0],0
2BFE: B0 06    JNZ   0x2C05
2C00: 3C CC 00 CMP   [__r1],0
2C03: A0 0C    JZ    0x2C10
(1006) 				// This module is now configured.
(1007) 				CONFIGURED = 1;
2C05: 62 D0 00 MOV   REG[208],0
2C08: 55 CC 01 MOV   [__r1],1
2C0B: 55 CD 00 MOV   [__r0],0
2C0E: 80 30    JMP   0x2C3F
2C10: 62 D0 00 MOV   REG[208],0
2C13: 3C D2 00 CMP   [TIMEOUT],0
2C16: B0 06    JNZ   0x2C1D
2C18: 3C D3 00 CMP   [TIMEOUT+1],0
2C1B: AF D9    JZ    0x2BF5
(1008) 			
(1009) 				// Let the master node know that you got the ID assignment.
(1010) 				assignedID();
(1011) 				
2C1D: 10       PUSH  X
2C1E: 7C 13 B0 LCALL 0x13B0
2C21: 20       POP   X
(1012) 				// Send a request to change the servo ID to match the controller ID.
2C22: 62 D0 00 MOV   REG[208],0
2C25: 55 D3 00 MOV   [TIMEOUT+1],0
2C28: 55 D2 00 MOV   [TIMEOUT],0
(1013) 				servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, ID_ADDRESS, ID);
(1014) 				
2C2B: 50 00    MOV   A,0
2C2D: 08       PUSH  A
2C2E: 50 01    MOV   A,1
2C30: 08       PUSH  A
2C31: 7C 21 01 LCALL _configToggle
2C34: 38 FE    ADD   SP,254
(1015) 				// Get back into wait mode.
(1016) 				configToggle(WAIT);
2C36: 62 D0 00 MOV   REG[208],0
2C39: 55 CC 00 MOV   [__r1],0
2C3C: 55 CD 00 MOV   [__r0],0
2C3F: 7F       RET   
(1017) 			}
(1018) 		}
(1019) 		else if(COMMAND_DESTINATION > ID)
(1020) 		{
(1021) 			// Switch to listen to your child.
_childResponse:
  child_responded      --> X+0
2C40: 10       PUSH  X
2C41: 4F       MOV   X,SP
2C42: 38 02    ADD   SP,2
(1022) 			childResponse();
2C44: 56 01 00 MOV   [X+1],0
2C47: 56 00 00 MOV   [X+0],0
(1023) 		}
(1024) 	}
(1025) 	else if((COMMAND_TYPE == PING_SERVO) || (COMMAND_TYPE == READ_SERVO))
2C4A: 62 D0 00 MOV   REG[208],0
2C4D: 3C D4 31 CMP   [CHILD],49
2C50: B0 0E    JNZ   0x2C5F
(1026) 	{
(1027) 		if(COMMAND_DESTINATION > ID)
2C52: 50 00    MOV   A,0
2C54: 08       PUSH  A
2C55: 50 03    MOV   A,3
2C57: 08       PUSH  A
2C58: 7C 21 01 LCALL _configToggle
2C5B: 38 FE    ADD   SP,254
(1028) 		{
2C5D: 80 56    JMP   0x2CB4
(1029) 			// Allow the child response through.
2C5F: 62 D0 00 MOV   REG[208],0
2C62: 3C D4 32 CMP   [CHILD],50
2C65: B0 0E    JNZ   0x2C74
(1030) 			childResponse();
(1031) 		}
2C67: 50 00    MOV   A,0
2C69: 08       PUSH  A
2C6A: 50 04    MOV   A,4
2C6C: 08       PUSH  A
2C6D: 7C 21 01 LCALL _configToggle
2C70: 38 FE    ADD   SP,254
(1032) 	}
2C72: 80 41    JMP   0x2CB4
(1033) }
2C74: 62 D0 00 MOV   REG[208],0
2C77: 3C D4 33 CMP   [CHILD],51
2C7A: B0 0E    JNZ   0x2C89
(1034) 
(1035) // This function sends out a ping response for everyone to hear.
2C7C: 50 00    MOV   A,0
2C7E: 08       PUSH  A
2C7F: 50 05    MOV   A,5
2C81: 08       PUSH  A
2C82: 7C 21 01 LCALL _configToggle
2C85: 38 FE    ADD   SP,254
(1036) void pingResponse(void)
2C87: 80 2C    JMP   0x2CB4
(1037) {
2C89: 62 D0 00 MOV   REG[208],0
2C8C: 3C D4 34 CMP   [CHILD],52
2C8F: B0 24    JNZ   0x2CB4
(1038) 	configToggle(MY_RESPONSE);		// Switch to response mode.
(1039) 	
2C91: 50 00    MOV   A,0
2C93: 08       PUSH  A
2C94: 50 06    MOV   A,6
2C96: 08       PUSH  A
2C97: 7C 21 01 LCALL _configToggle
2C9A: 38 FE    ADD   SP,254
(1040) 	// Transmit a ping to everyone.
2C9C: 80 17    JMP   0x2CB4
(1041) 	TX_014_PutChar(START_TRANSMIT);	// Start byte one
(1042) 	TX_23_PutChar(START_TRANSMIT);	// Start byte one
(1043) 	TX_014_PutChar(START_TRANSMIT);	// Start byte two
(1044) 	TX_23_PutChar(START_TRANSMIT);	// Start byte two
(1045) 	TX_014_PutChar(ID);				// My ID
2C9E: 7C 23 0B LCALL _commandReady
2CA1: 62 D0 00 MOV   REG[208],0
2CA4: 3C CD 00 CMP   [__r0],0
2CA7: B0 06    JNZ   0x2CAE
2CA9: 3C CC 00 CMP   [__r1],0
2CAC: A0 07    JZ    0x2CB4
(1046) 	TX_23_PutChar(ID);				// My ID
(1047) 	TX_014_PutChar(MASTER_ID);		// Destination ID (master)
2CAE: 56 01 01 MOV   [X+1],1
2CB1: 56 00 00 MOV   [X+0],0
2CB4: 3D 00 00 CMP   [X+0],0
2CB7: B0 13    JNZ   0x2CCB
2CB9: 3D 01 00 CMP   [X+1],0
2CBC: B0 0E    JNZ   0x2CCB
2CBE: 62 D0 00 MOV   REG[208],0
2CC1: 3C D2 00 CMP   [TIMEOUT],0
2CC4: B0 06    JNZ   0x2CCB
2CC6: 3C D3 00 CMP   [TIMEOUT+1],0
2CC9: AF D4    JZ    0x2C9E
(1048) 	TX_23_PutChar(MASTER_ID);		// Destination ID (master)
(1049) 	TX_014_PutChar(PING);			// This is a ping response
(1050) 	TX_23_PutChar(PING);			// This is a ping response
(1051) 	TX_014_PutChar(TYPE);			// This is the module type
(1052) 	TX_23_PutChar(TYPE);			// This is the module type
2CCB: 62 D0 00 MOV   REG[208],0
2CCE: 3C D4 31 CMP   [CHILD],49
2CD1: B0 08    JNZ   0x2CDA
(1053) 	TX_014_PutChar(CHILD);			// This is the child-connected port
(1054) 	TX_23_PutChar(CHILD);			// This is the child-connected port
2CD3: 10       PUSH  X
2CD4: 7C 1F 13 LCALL 0x1F13
2CD7: 20       POP   X
(1055) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission
2CD8: 80 2C    JMP   0x2D05
(1056) 	TX_23_PutChar(END_TRANSMIT);	// This is the end of this transmission
2CDA: 62 D0 00 MOV   REG[208],0
2CDD: 3C D4 32 CMP   [CHILD],50
2CE0: B0 08    JNZ   0x2CE9
(1057) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1058) 	TX_23_PutChar(END_TRANSMIT);	// This is the end of this transmission
2CE2: 10       PUSH  X
2CE3: 7C 1D 5A LCALL 0x1D5A
2CE6: 20       POP   X
(1059) 	
2CE7: 80 1D    JMP   0x2D05
(1060) 	// Wait for the transmission to finish.
2CE9: 62 D0 00 MOV   REG[208],0
2CEC: 3C D4 33 CMP   [CHILD],51
2CEF: B0 08    JNZ   0x2CF8
(1061) 	while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
(1062) 	while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
2CF1: 10       PUSH  X
2CF2: 7C 1B A1 LCALL 0x1BA1
2CF5: 20       POP   X
(1063) 	
2CF6: 80 0E    JMP   0x2D05
(1064) 	// Make completely sure we're done.
2CF8: 62 D0 00 MOV   REG[208],0
2CFB: 3C D4 34 CMP   [CHILD],52
2CFE: B0 06    JNZ   0x2D05
(1065) 	xmitWait();
(1066) 	
2D00: 10       PUSH  X
2D01: 7C 19 E8 LCALL 0x19E8
2D04: 20       POP   X
(1067) 	configToggle(WAIT);				// Switch back to wait for a master response.
(1068) }
(1069) 
2D05: 62 D0 00 MOV   REG[208],0
2D08: 55 D3 00 MOV   [TIMEOUT+1],0
2D0B: 55 D2 00 MOV   [TIMEOUT],0
(1070) // This function blindly unloads all user configurations. This will be called once,
(1071) // when the system initially has no known state.
2D0E: 50 00    MOV   A,0
2D10: 08       PUSH  A
2D11: 50 01    MOV   A,1
2D13: 08       PUSH  A
2D14: 7C 21 01 LCALL _configToggle
2D17: 38 FE    ADD   SP,254
(1072) void unloadAllConfigs(void)
(1073) {
2D19: 62 D0 00 MOV   REG[208],0
2D1C: 52 01    MOV   A,[X+1]
2D1E: 53 CC    MOV   [__r1],A
2D20: 52 00    MOV   A,[X+0]
2D22: 53 CD    MOV   [__r0],A
2D24: 38 FE    ADD   SP,254
2D26: 20       POP   X
2D27: 7F       RET   
(1074) 	UnloadConfig_waiting();
(1075) 	UnloadConfig_hello();
(1076) 	UnloadConfig_my_response();
(1077) 	UnloadConfig_response1();
(1078) 	UnloadConfig_response2();
(1079) 	UnloadConfig_response3();
(1080) 	UnloadConfig_response4();
_servoFinder:
  flashWrite           --> X+5
  status_return_level  --> X+4
  j                    --> X+2
  i                    --> X+0
2D28: 10       PUSH  X
2D29: 4F       MOV   X,SP
2D2A: 38 07    ADD   SP,7
(1081) 	UnloadConfig_initial();
(1082) 	UnloadConfig_servo_transmit();
2D2C: 56 01 00 MOV   [X+1],0
2D2F: 56 00 00 MOV   [X+0],0
(1083) }
2D32: 56 03 00 MOV   [X+3],0
2D35: 56 02 00 MOV   [X+2],0
(1084) 
(1085) // This function unloads the configuration corresponding to the config number passed to it.
(1086) // We do this instead of unloadAllConfigs to cut down on set up time.
2D38: 56 06 00 MOV   [X+6],0
2D3B: 56 05 00 MOV   [X+5],0
(1087) void unloadConfig(int config_num)
(1088) {
(1089) 	if(config_num == WAIT)
2D3E: 56 04 03 MOV   [X+4],3
(1090) 	{
(1091) 		UnloadConfig_waiting();
(1092) 	}
2D41: 62 D0 00 MOV   REG[208],0
2D44: 55 E7 FF MOV   [SERVO_ID],255
(1093) 	else if(config_num == HELLO_MODE)
(1094) 	{
(1095) 		UnloadConfig_hello();
(1096) 	}
(1097) 	else if(config_num == MY_RESPONSE)
(1098) 	{
(1099) 		UnloadConfig_my_response();
(1100) 	}
(1101) 	else if(config_num == RESPONSE_1)
2D47: 56 03 00 MOV   [X+3],0
2D4A: 56 02 00 MOV   [X+2],0
(1102) 	{
(1103) 		UnloadConfig_response1();
(1104) 	}
2D4D: 56 01 00 MOV   [X+1],0
2D50: 56 00 00 MOV   [X+0],0
(1105) 	else if(config_num == RESPONSE_2)
(1106) 	{
(1107) 		UnloadConfig_response2();
2D53: 50 00    MOV   A,0
2D55: 08       PUSH  A
2D56: 08       PUSH  A
2D57: 50 01    MOV   A,1
2D59: 08       PUSH  A
2D5A: 50 02    MOV   A,2
2D5C: 08       PUSH  A
2D5D: 50 FE    MOV   A,254
2D5F: 08       PUSH  A
2D60: 91 80    CALL  _servoInstruction
2D62: 38 FB    ADD   SP,251
2D64: 80 4C    JMP   0x2DB1
(1108) 	}
(1109) 	else if(config_num == RESPONSE_3)
(1110) 	{
(1111) 		UnloadConfig_response3();
(1112) 	}
2D66: 7C 23 0B LCALL _commandReady
2D69: 62 D0 00 MOV   REG[208],0
2D6C: 3C CD 00 CMP   [__r0],0
2D6F: B0 06    JNZ   0x2D76
2D71: 3C CC 00 CMP   [__r1],0
2D74: A0 3C    JZ    0x2DB1
(1113) 	else if(config_num == RESPONSE_4)
(1114) 	{
(1115) 		UnloadConfig_response4();
2D76: 62 D0 00 MOV   REG[208],0
2D79: 3C E4 00 CMP   [COMMAND_SOURCE],0
2D7C: C0 2B    JC    0x2DA8
2D7E: 62 D0 00 MOV   REG[208],0
2D81: 50 FD    MOV   A,253
2D83: 3A E4    CMP   A,[COMMAND_SOURCE]
2D85: C0 22    JC    0x2DA8
(1116) 	}
(1117) 	else if(config_num == INITIALIZE)
(1118) 	{
2D87: 62 D0 00 MOV   REG[208],0
2D8A: 55 D3 01 MOV   [TIMEOUT+1],1
2D8D: 55 D2 00 MOV   [TIMEOUT],0
(1119) 		UnloadConfig_initial();
(1120) 	}
2D90: 62 D0 00 MOV   REG[208],0
2D93: 51 E4    MOV   A,[COMMAND_SOURCE]
2D95: 62 D0 00 MOV   REG[208],0
2D98: 53 E7    MOV   [SERVO_ID],A
(1121) 	else if(config_num == SERVO_COMM)
(1122) 	{
2D9A: 56 01 03 MOV   [X+1],3
2D9D: 56 00 00 MOV   [X+0],0
(1123) 		UnloadConfig_servo_transmit();
(1124) 	}
2DA0: 56 03 02 MOV   [X+3],2
2DA3: 56 02 00 MOV   [X+2],0
(1125) }
2DA6: 80 0A    JMP   0x2DB1
(1126) 
(1127) // This function responds that an ID has been assigned to it.
(1128) void assignedID(void)
(1129) {
2DA8: 62 D0 00 MOV   REG[208],0
2DAB: 55 D3 01 MOV   [TIMEOUT+1],1
2DAE: 55 D2 00 MOV   [TIMEOUT],0
2DB1: 62 D0 00 MOV   REG[208],0
2DB4: 3C D2 00 CMP   [TIMEOUT],0
2DB7: B0 06    JNZ   0x2DBE
2DB9: 3C D3 00 CMP   [TIMEOUT+1],0
2DBC: AF A9    JZ    0x2D66
2DBE: 77 01    INC   [X+1]
2DC0: 0F 00 00 ADC   [X+0],0
2DC3: 52 01    MOV   A,[X+1]
2DC5: 11 03    SUB   A,3
2DC7: 52 00    MOV   A,[X+0]
2DC9: 31 80    XOR   A,128
2DCB: 19 80    SBB   A,128
2DCD: CF 85    JC    0x2D53
(1130) 	configToggle(MY_RESPONSE);		// Switch to response mode.
(1131) 	
(1132) 	// Transmit a ping to everyone.
(1133) 	TX_014_PutChar(START_TRANSMIT);	// Start byte one
(1134) 	TX_23_PutChar(START_TRANSMIT);	// Start byte one
(1135) 	TX_014_PutChar(START_TRANSMIT);	// Start byte two
(1136) 	TX_23_PutChar(START_TRANSMIT);	// Start byte two
(1137) 	TX_014_PutChar(ID);				// My ID
2DCF: 62 D0 00 MOV   REG[208],0
2DD2: 3C E7 FF CMP   [SERVO_ID],255
2DD5: B0 22    JNZ   0x2DF8
2DD7: 3D 05 00 CMP   [X+5],0
2DDA: B0 1D    JNZ   0x2DF8
2DDC: 3D 06 00 CMP   [X+6],0
2DDF: B0 18    JNZ   0x2DF8
(1138) 	TX_23_PutChar(ID);				// My ID
(1139) 	TX_014_PutChar(MASTER_ID);		// Destination ID (master)
(1140) 	TX_23_PutChar(MASTER_ID);		// Destination ID (master)
2DE1: 56 06 01 MOV   [X+6],1
2DE4: 56 05 00 MOV   [X+5],0
(1141) 	TX_014_PutChar(ID_ASSIGN_OK);	// This is an assignment ack response
(1142) 	TX_23_PutChar(ID_ASSIGN_OK);	// This is an assignment ack response
(1143) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1144) 	TX_23_PutChar(END_TRANSMIT);	// This is the end of this transmission
2DE7: 50 00    MOV   A,0
2DE9: 08       PUSH  A
2DEA: 08       PUSH  A
2DEB: 50 06    MOV   A,6
2DED: 08       PUSH  A
2DEE: 50 02    MOV   A,2
2DF0: 08       PUSH  A
2DF1: 50 FE    MOV   A,254
2DF3: 08       PUSH  A
2DF4: 90 EC    CALL  _servoInstruction
2DF6: 38 FB    ADD   SP,251
2DF8: 77 03    INC   [X+3]
2DFA: 0F 02 00 ADC   [X+2],0
2DFD: 52 03    MOV   A,[X+3]
2DFF: 11 02    SUB   A,2
2E01: 52 02    MOV   A,[X+2]
2E03: 31 80    XOR   A,128
2E05: 19 80    SBB   A,128
2E07: CF 45    JC    0x2D4D
(1145) 	TX_014_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1146) 	TX_23_PutChar(END_TRANSMIT);	// This is the end of this transmission
(1147) 	
(1148) 	// Wait for the transmission to finish.
(1149) 	while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
2E09: 56 06 00 MOV   [X+6],0
2E0C: 56 05 00 MOV   [X+5],0
(1150) 	while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
(1151) 	
(1152) 	// Make completely sure we're done.
(1153) 	xmitWait();
2E0F: 62 D0 00 MOV   REG[208],0
2E12: 3C E7 FE CMP   [SERVO_ID],254
2E15: D0 C6    JNC   0x2EDC
(1154) 	
(1155) 	configToggle(WAIT);				// Switch back to wait for a master response.
(1156) }
(1157) 
(1158) // This function listens for children and registers the port that they talk to.
(1159) int childListen(void)
2E17: 56 03 00 MOV   [X+3],0
2E1A: 56 02 00 MOV   [X+2],0
(1160) {
(1161) 	configToggle(HELLO_MODE);	// Switch to listen for hellos on every port.
(1162) 	
2E1D: 56 01 00 MOV   [X+1],0
2E20: 56 00 00 MOV   [X+0],0
(1163) 	// Wait to either hear a child or time out.
(1164) 	while(!TIMEOUT)
(1165) 	{		
2E23: 50 01    MOV   A,1
2E25: 08       PUSH  A
2E26: 50 10    MOV   A,16
2E28: 08       PUSH  A
2E29: 50 02    MOV   A,2
2E2B: 08       PUSH  A
2E2C: 50 04    MOV   A,4
2E2E: 08       PUSH  A
2E2F: 62 D0 00 MOV   REG[208],0
2E32: 51 E7    MOV   A,[SERVO_ID]
2E34: 08       PUSH  A
2E35: 90 AB    CALL  _servoInstruction
2E37: 38 FB    ADD   SP,251
2E39: 80 48    JMP   0x2E82
(1166) 		if(commandReady())
(1167) 		{
(1168) 			return 1;
(1169) 		}
(1170) 	}
(1171) 	
2E3B: 7C 23 0B LCALL _commandReady
2E3E: 62 D0 00 MOV   REG[208],0
2E41: 3C CD 00 CMP   [__r0],0
2E44: B0 06    JNZ   0x2E4B
2E46: 3C CC 00 CMP   [__r1],0
2E49: A0 38    JZ    0x2E82
(1172) 	HELLO_TIMEOUT_Stop();		// Stop the timer.
(1173) 	TIMEOUT = 0;				// Clear the timeout flag.
2E4B: 62 D0 00 MOV   REG[208],0
2E4E: 3C DF 00 CMP   [COMMAND_ERROR],0
2E51: B0 30    JNZ   0x2E82
(1174) 	
(1175) 	configToggle(WAIT);			// Switch back to wait for a master response.
(1176) 	
2E53: 62 D0 00 MOV   REG[208],0
2E56: 3C E1 01 CMP   [COMMAND_PARAM],1
2E59: B0 1F    JNZ   0x2E79
(1177) 	return 0;					// Return the result of our listening session.
(1178) }
(1179) 
2E5B: 62 D0 00 MOV   REG[208],0
2E5E: 55 D3 01 MOV   [TIMEOUT+1],1
2E61: 55 D2 00 MOV   [TIMEOUT],0
(1180) // This function waits for a known child's response.
(1181) int childResponse(void)
2E64: 62 D0 00 MOV   REG[208],0
2E67: 51 E1    MOV   A,[COMMAND_PARAM]
2E69: 54 04    MOV   [X+4],A
(1182) {
(1183) 	int child_responded = 0;
2E6B: 56 01 03 MOV   [X+1],3
2E6E: 56 00 00 MOV   [X+0],0
(1184) 	
(1185) 	// Switch to the right port.
2E71: 56 03 02 MOV   [X+3],2
2E74: 56 02 00 MOV   [X+2],0
(1186) 	if(CHILD == PORT_1)
2E77: 80 0A    JMP   0x2E82
(1187) 	{
(1188) 		configToggle(RESPONSE_1);
(1189) 	}
(1190) 	else if(CHILD == PORT_2)
2E79: 62 D0 00 MOV   REG[208],0
2E7C: 55 D3 01 MOV   [TIMEOUT+1],1
2E7F: 55 D2 00 MOV   [TIMEOUT],0
2E82: 62 D0 00 MOV   REG[208],0
2E85: 3C D2 00 CMP   [TIMEOUT],0
2E88: B0 06    JNZ   0x2E8F
2E8A: 3C D3 00 CMP   [TIMEOUT+1],0
2E8D: AF AD    JZ    0x2E3B
2E8F: 77 01    INC   [X+1]
2E91: 0F 00 00 ADC   [X+0],0
2E94: 52 01    MOV   A,[X+1]
2E96: 11 03    SUB   A,3
2E98: 52 00    MOV   A,[X+0]
2E9A: 31 80    XOR   A,128
2E9C: 19 80    SBB   A,128
2E9E: CF 84    JC    0x2E23
(1191) 	{
(1192) 		configToggle(RESPONSE_2);
(1193) 	}
(1194) 	else if(CHILD == PORT_3)
(1195) 	{
(1196) 		configToggle(RESPONSE_3);
(1197) 	}
(1198) 	else if(CHILD == PORT_4)
(1199) 	{
2EA0: 3D 04 01 CMP   [X+4],1
2EA3: A0 27    JZ    0x2ECB
2EA5: 3D 05 00 CMP   [X+5],0
2EA8: B0 22    JNZ   0x2ECB
2EAA: 3D 06 00 CMP   [X+6],0
2EAD: B0 1D    JNZ   0x2ECB
(1200) 		configToggle(RESPONSE_4);
(1201) 	}
2EAF: 56 06 01 MOV   [X+6],1
2EB2: 56 05 00 MOV   [X+5],0
(1202) 	
(1203) 	// Wait for a response or a timeout.
(1204) 	while((!child_responded) && (!TIMEOUT))
2EB5: 50 01    MOV   A,1
2EB7: 08       PUSH  A
2EB8: 50 10    MOV   A,16
2EBA: 08       PUSH  A
2EBB: 50 03    MOV   A,3
2EBD: 08       PUSH  A
2EBE: 50 04    MOV   A,4
2EC0: 08       PUSH  A
2EC1: 62 D0 00 MOV   REG[208],0
2EC4: 51 E7    MOV   A,[SERVO_ID]
2EC6: 08       PUSH  A
2EC7: 90 19    CALL  _servoInstruction
2EC9: 38 FB    ADD   SP,251
2ECB: 77 03    INC   [X+3]
2ECD: 0F 02 00 ADC   [X+2],0
2ED0: 52 03    MOV   A,[X+3]
2ED2: 11 02    SUB   A,2
2ED4: 52 02    MOV   A,[X+2]
2ED6: 31 80    XOR   A,128
2ED8: 19 80    SBB   A,128
2EDA: CF 42    JC    0x2E1D
(1205) 	{
(1206) 		if(commandReady())
(1207) 		{
(1208) 			child_responded = 1;
(1209) 		}
(1210) 	}
2EDC: 91 55    CALL  _servoConfigWait
2EDE: 38 F9    ADD   SP,249
2EE0: 20       POP   X
2EE1: 7F       RET   
(1211) 	
(1212) 	// Stop the right timer.
(1213) 	if(CHILD == PORT_1)
(1214) 	{
(1215) 		CHILD_1_TIMEOUT_Stop();
(1216) 	}
_servoInstruction:
  checksum             --> X+0
  value                --> X-8
  address              --> X-7
  instruction          --> X-6
  length               --> X-5
  id                   --> X-4
2EE2: 10       PUSH  X
2EE3: 4F       MOV   X,SP
2EE4: 38 01    ADD   SP,1
(1217) 	else if(CHILD == PORT_2)
(1218) 	{
(1219) 		CHILD_2_TIMEOUT_Stop();
(1220) 	}
2EE6: 50 00    MOV   A,0
2EE8: 08       PUSH  A
2EE9: 50 09    MOV   A,9
2EEB: 08       PUSH  A
2EEC: 7C 21 01 LCALL _configToggle
2EEF: 38 FE    ADD   SP,254
(1221) 	else if(CHILD == PORT_3)
(1222) 	{
(1223) 		CHILD_3_TIMEOUT_Stop();
2EF1: 62 D0 00 MOV   REG[208],0
2EF4: 52 FB    MOV   A,[X-5]
2EF6: 53 CC    MOV   [__r1],A
2EF8: 55 CD 00 MOV   [__r0],0
2EFB: 52 FC    MOV   A,[X-4]
2EFD: 02 CC    ADD   A,[__r1]
2EFF: 53 CC    MOV   [__r1],A
2F01: 50 00    MOV   A,0
2F03: 0A CD    ADC   A,[__r0]
2F05: 53 CD    MOV   [__r0],A
2F07: 52 FA    MOV   A,[X-6]
2F09: 04 CC    ADD   [__r1],A
2F0B: 0E CD 00 ADC   [__r0],0
2F0E: 52 F9    MOV   A,[X-7]
2F10: 04 CC    ADD   [__r1],A
2F12: 0E CD 00 ADC   [__r0],0
2F15: 52 F8    MOV   A,[X-8]
2F17: 04 CC    ADD   [__r1],A
2F19: 0E CD 00 ADC   [__r0],0
2F1C: 50 01    MOV   A,1
2F1E: 08       PUSH  A
2F1F: 50 00    MOV   A,0
2F21: 08       PUSH  A
2F22: 51 CD    MOV   A,[__r0]
2F24: 08       PUSH  A
2F25: 51 CC    MOV   A,[__r1]
2F27: 08       PUSH  A
2F28: 7C 32 1F LCALL __divmod_16X16_16
2F2B: 38 FE    ADD   SP,254
2F2D: 18       POP   A
2F2E: 53 CC    MOV   [__r1],A
2F30: 18       POP   A
2F31: 50 FF    MOV   A,255
2F33: 12 CC    SUB   A,[__r1]
2F35: 54 00    MOV   [X+0],A
(1224) 	}
(1225) 	else if(CHILD == PORT_4)
(1226) 	{
2F37: 3D FA 01 CMP   [X-6],1
2F3A: B0 2D    JNZ   0x2F68
(1227) 		CHILD_4_TIMEOUT_Stop();
(1228) 	}
2F3C: 10       PUSH  X
2F3D: 50 FF    MOV   A,255
2F3F: 7C 10 0D LCALL 0x100D
2F42: 20       POP   X
(1229) 	
2F43: 10       PUSH  X
2F44: 50 FF    MOV   A,255
2F46: 7C 10 0D LCALL 0x100D
2F49: 20       POP   X
(1230) 	TIMEOUT = 0;					// Reset the timeout flag.
2F4A: 10       PUSH  X
2F4B: 52 FC    MOV   A,[X-4]
2F4D: 7C 10 0D LCALL 0x100D
2F50: 20       POP   X
(1231) 	
2F51: 10       PUSH  X
2F52: 52 FB    MOV   A,[X-5]
2F54: 7C 10 0D LCALL 0x100D
2F57: 20       POP   X
(1232) 	configToggle(WAIT);				// Switch back to wait for a master response.
2F58: 10       PUSH  X
2F59: 52 FA    MOV   A,[X-6]
2F5B: 7C 10 0D LCALL 0x100D
2F5E: 20       POP   X
(1233) 	
2F5F: 10       PUSH  X
2F60: 52 00    MOV   A,[X+0]
2F62: 7C 10 0D LCALL 0x100D
2F65: 20       POP   X
(1234) 	return child_responded;
2F66: 80 39    JMP   0x2FA0
(1235) }
(1236) 
(1237) // This function is used to find the servo that is directly connected to this module's controller.
2F68: 10       PUSH  X
2F69: 50 FF    MOV   A,255
2F6B: 7C 10 0D LCALL 0x100D
2F6E: 20       POP   X
(1238) // After the servo ID is found, the status return level is changed so that packets are only
2F6F: 10       PUSH  X
2F70: 50 FF    MOV   A,255
2F72: 7C 10 0D LCALL 0x100D
2F75: 20       POP   X
(1239) // returned for the desired status return level defined at the top of this file.
2F76: 10       PUSH  X
2F77: 52 FC    MOV   A,[X-4]
2F79: 7C 10 0D LCALL 0x100D
2F7C: 20       POP   X
(1240) void servoFinder(void)
2F7D: 10       PUSH  X
2F7E: 52 FB    MOV   A,[X-5]
2F80: 7C 10 0D LCALL 0x100D
2F83: 20       POP   X
(1241) {				
2F84: 10       PUSH  X
2F85: 52 FA    MOV   A,[X-6]
2F87: 7C 10 0D LCALL 0x100D
2F8A: 20       POP   X
(1242) 	// Index variables for incrementing and checking against the maximum servo comm attempts.
2F8B: 10       PUSH  X
2F8C: 52 F9    MOV   A,[X-7]
2F8E: 7C 10 0D LCALL 0x100D
2F91: 20       POP   X
(1243) 	int i = 0;
2F92: 10       PUSH  X
2F93: 52 F8    MOV   A,[X-8]
2F95: 7C 10 0D LCALL 0x100D
2F98: 20       POP   X
(1244) 	int j = 0;
2F99: 10       PUSH  X
2F9A: 52 00    MOV   A,[X+0]
2F9C: 7C 10 0D LCALL 0x100D
2F9F: 20       POP   X
(1245) 	
(1246) 	// Integer used as a flag so that EEPROM writes aren't done more than once.
(1247) 	int flashWrite = 0;
(1248) 	
2FA0: 10       PUSH  X
2FA1: 7C 0F E0 LCALL 0x0FE0
2FA4: 62 D0 00 MOV   REG[208],0
2FA7: 20       POP   X
2FA8: 53 CD    MOV   [__r0],A
2FAA: 47 CD 20 TST   [__r0],32
2FAD: AF F2    JZ    0x2FA0
(1249) 	// Create a status return level variable and set it to an out of range value initially.
(1250) 	char status_return_level = 3;
(1251) 	
2FAF: 90 0F    CALL  _xmitWait
(1252) 	// Start with a servo ID of 255 (out of valid range).
(1253) 	SERVO_ID = SERVO_START;
(1254) 
2FB1: 50 00    MOV   A,0
2FB3: 08       PUSH  A
2FB4: 50 08    MOV   A,8
2FB6: 08       PUSH  A
2FB7: 7C 21 01 LCALL _configToggle
2FBA: 38 FE    ADD   SP,254
2FBC: 38 FF    ADD   SP,255
2FBE: 20       POP   X
2FBF: 7F       RET   
(1255) 	// This for loop will loop SERVO_COMM_LOOPS number of times and ping the servo SERVO_COMM_ATTEMPTS
(1256) 	// number of times in each loop (unless stopped short due to early success). If this fails for the
(1257) 	// first round of pings, a broadcast reset will be performed to reset the servo. This is done
(1258) 	// because we assume that the baud rate is matching up, but the servo's return delay time is too
(1259) 	// fast for the controller to switch into receive mode to read the response. The default return
(1260) 	// delay time is 500 microseconds. If we loop for SERVO_COMM_LOOPS number of times and still don't
_xmitWait:
  i                    --> X+0
2FC0: 10       PUSH  X
2FC1: 4F       MOV   X,SP
2FC2: 38 02    ADD   SP,2
(1261) 	// see anything, we assume that there is something is too wrong for us to fix.
(1262) 	for(j = 0; j < SERVO_COMM_LOOPS; j++)
(1263) 	{	
2FC4: 56 01 00 MOV   [X+1],0
2FC7: 56 00 00 MOV   [X+0],0
2FCA: 77 01    INC   [X+1]
2FCC: 0F 00 00 ADC   [X+0],0
2FCF: 52 01    MOV   A,[X+1]
2FD1: 11 19    SUB   A,25
2FD3: 52 00    MOV   A,[X+0]
2FD5: 31 80    XOR   A,128
2FD7: 19 80    SBB   A,128
2FD9: CF F0    JC    0x2FCA
2FDB: 38 FE    ADD   SP,254
2FDD: 20       POP   X
2FDE: 7F       RET   
(1264) 		// Ping SERVO_COMM_ATTEMPTS times to try and extract the servo ID.
(1265) 		for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
(1266) 		{
(1267) 			// Send a ping out for any servo connected to me (will only be one).
(1268) 			servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
(1269) 			
(1270) 			// Wait for either a timeout or a valid servo ID (which will trigger a timeout).
(1271) 			while(!TIMEOUT)
(1272) 			{	
(1273) 				if(commandReady())
(1274) 				{
_servoBootWait:
  i                    --> X+0
2FDF: 10       PUSH  X
2FE0: 4F       MOV   X,SP
2FE1: 38 02    ADD   SP,2
(1275) 					// If we read a source ID within the range, exit the loop.
2FE3: 56 01 00 MOV   [X+1],0
2FE6: 56 00 00 MOV   [X+0],0
(1276) 					if((COMMAND_SOURCE >= SERVO_ID_MIN) && (COMMAND_SOURCE <= SERVO_ID_MAX))
(1277) 					{	
2FE9: 50 00    MOV   A,0
2FEB: 08       PUSH  A
2FEC: 50 08    MOV   A,8
2FEE: 08       PUSH  A
2FEF: 7C 21 01 LCALL _configToggle
2FF2: 38 FE    ADD   SP,254
(1278) 						// Exit this while loop by setting the timeout flag.
(1279) 						TIMEOUT = 1;
(1280) 						// Set the servo ID variable to where the ping came from.
2FF4: 56 01 00 MOV   [X+1],0
2FF7: 56 00 00 MOV   [X+0],0
(1281) 						SERVO_ID = COMMAND_SOURCE;
(1282) 						// Set the index variable such that the for loop exits.
2FFA: 62 D0 00 MOV   REG[208],0
2FFD: 3C D2 00 CMP   [TIMEOUT],0
3000: B0 06    JNZ   0x3007
3002: 3C D3 00 CMP   [TIMEOUT+1],0
3005: AF F4    JZ    0x2FFA
(1283) 						i = SERVO_COMM_ATTEMPTS;
3007: 62 D0 00 MOV   REG[208],0
300A: 55 D3 00 MOV   [TIMEOUT+1],0
300D: 55 D2 00 MOV   [TIMEOUT],0
3010: 77 01    INC   [X+1]
3012: 0F 00 00 ADC   [X+0],0
3015: 52 01    MOV   A,[X+1]
3017: 11 64    SUB   A,100
3019: 52 00    MOV   A,[X+0]
301B: 31 80    XOR   A,128
301D: 19 80    SBB   A,128
301F: CF DA    JC    0x2FFA
(1284) 						// Set the outer index variable to 2 to not attempt again for no reason.
(1285) 						j = SERVO_COMM_LOOPS;
(1286) 					}
3021: 10       PUSH  X
3022: 7C 11 F7 LCALL 0x11F7
3025: 20       POP   X
(1287) 					else
3026: 62 D0 00 MOV   REG[208],0
3029: 55 D3 00 MOV   [TIMEOUT+1],0
302C: 55 D2 00 MOV   [TIMEOUT],0
302F: 38 FE    ADD   SP,254
3031: 20       POP   X
3032: 7F       RET   
(1288) 					{
(1289) 						// Exit this while loop and try to ping again.
(1290) 						TIMEOUT = 1;
(1291) 					}
(1292) 				}
(1293) 			}
_servoConfigWait:
  i                    --> X+0
3033: 10       PUSH  X
3034: 4F       MOV   X,SP
3035: 38 02    ADD   SP,2
(1294) 		}
3037: 56 01 00 MOV   [X+1],0
303A: 56 00 00 MOV   [X+0],0
(1295) 		
(1296) 		// If we didn't get a response and haven't written to the flash of the
303D: 50 00    MOV   A,0
303F: 08       PUSH  A
3040: 50 08    MOV   A,8
3042: 08       PUSH  A
3043: 7C 21 01 LCALL _configToggle
3046: 38 FE    ADD   SP,254
(1297) 		// servo (first time through), send out a broadcast reset.
(1298) 		if((SERVO_ID == SERVO_START) && (!flashWrite))
(1299) 		{
(1300) 			// Set the flash write flag so that we only do this once per power cycle.
(1301) 			flashWrite = 1;
3048: 56 01 00 MOV   [X+1],0
304B: 56 00 00 MOV   [X+0],0
(1302) 			
(1303) 			// Send out a broadcast reset so that we know that the response time interval
304E: 62 D0 00 MOV   REG[208],0
3051: 3C D2 00 CMP   [TIMEOUT],0
3054: B0 06    JNZ   0x305B
3056: 3C D3 00 CMP   [TIMEOUT+1],0
3059: AF F4    JZ    0x304E
(1304) 			// is large enough (default delay time for a servo is 500 microseconds).
305B: 62 D0 00 MOV   REG[208],0
305E: 55 D3 00 MOV   [TIMEOUT+1],0
3061: 55 D2 00 MOV   [TIMEOUT],0
3064: 77 01    INC   [X+1]
3066: 0F 00 00 ADC   [X+0],0
3069: 52 01    MOV   A,[X+1]
306B: 11 06    SUB   A,6
306D: 52 00    MOV   A,[X+0]
306F: 31 80    XOR   A,128
3071: 19 80    SBB   A,128
3073: CF DA    JC    0x304E
(1305) 			servoInstruction(BROADCAST, RESET_LENGTH, RESET_SERVO, 0, 0);
(1306) 		}
(1307) 	}
3075: 10       PUSH  X
3076: 7C 11 F7 LCALL 0x11F7
3079: 20       POP   X
(1308) 
307A: 62 D0 00 MOV   REG[208],0
307D: 55 D3 00 MOV   [TIMEOUT+1],0
3080: 55 D2 00 MOV   [TIMEOUT],0
(1309) 	// Reset flash write flag.
(1310) 	flashWrite = 0;
3083: 50 00    MOV   A,0
3085: 08       PUSH  A
3086: 50 01    MOV   A,1
3088: 08       PUSH  A
3089: 7C 21 01 LCALL _configToggle
308C: 38 FE    ADD   SP,254
308E: 38 FE    ADD   SP,254
3090: 20       POP   X
3091: 7F       RET   
(1311) 	
(1312) 	// If we have a valid servo ID, set the status return level. If we don't, just skip this
(1313) 	// because all hope is lost.
(1314) 	if(SERVO_ID < BROADCAST)
(1315) 	{
(1316) 		// This for loop will loop SERVO_COMM_LOOPS number of times and poll for the servo's status
(1317) 		// return level SERVO_COMM_ATTEMPTS number of times in each loop (unless stopped short due
(1318) 		// to early success). If this fails for the first iteration, or we read a status return level
_TX_01234_TIMEOUT_ISR:
3092: 71 C0    OR    F,192
3094: 08       PUSH  A
3095: 5D D0    MOV   A,REG[208]
3097: 08       PUSH  A
(1319) 		// other than what we want, we will attempt to write the desired status return level onto the servo.
3098: 62 D0 00 MOV   REG[208],0
309B: 55 D3 01 MOV   [TIMEOUT+1],1
309E: 55 D2 00 MOV   [TIMEOUT],0
(1320) 		for(j = 0; j < SERVO_COMM_LOOPS; j++)
30A1: 62 DA FD MOV   REG[218],253
30A4: 18       POP   A
30A5: 60 D0    MOV   REG[208],A
30A7: 18       POP   A
30A8: 7E       RETI  
(1321) 		{
(1322) 			// Attempt to read the status return level for the defined number of attempts.
(1323) 			for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
(1324) 			{
(1325) 				// Send a request for the servo's status return level.
_HELLO_TIMEOUT_ISR:
30A9: 71 C0    OR    F,192
30AB: 08       PUSH  A
30AC: 5D D0    MOV   A,REG[208]
30AE: 08       PUSH  A
(1326) 				servoInstruction(SERVO_ID, READ_LENGTH, READ_SERVO, STATUS_RET_ADDRESS, 1);
30AF: 62 D0 00 MOV   REG[208],0
30B2: 55 D3 01 MOV   [TIMEOUT+1],1
30B5: 55 D2 00 MOV   [TIMEOUT],0
(1327) 				
30B8: 62 DA FD MOV   REG[218],253
30BB: 18       POP   A
30BC: 60 D0    MOV   REG[208],A
30BE: 18       POP   A
30BF: 7E       RETI  
(1328) 				// Wait for either a timeout or an indication that we want to exit the loop.
(1329) 				while(!TIMEOUT)
(1330) 				{
(1331) 					// If a valid command is ready, interpret it.
(1332) 					if(commandReady())
_CHILD_1_TIMEOUT_ISR:
30C0: 71 C0    OR    F,192
30C2: 08       PUSH  A
30C3: 5D D0    MOV   A,REG[208]
30C5: 08       PUSH  A
(1333) 					{
30C6: 62 D0 00 MOV   REG[208],0
30C9: 55 D3 01 MOV   [TIMEOUT+1],1
30CC: 55 D2 00 MOV   [TIMEOUT],0
(1334) 						if(!COMMAND_ERROR)
30CF: 62 DA FD MOV   REG[218],253
30D2: 18       POP   A
30D3: 60 D0    MOV   REG[208],A
30D5: 18       POP   A
30D6: 7E       RETI  
(1335) 						{
(1336) 							// If the return level is equal to what is desired, store it.
(1337) 							if(COMMAND_PARAM == STATUS_RET_LEVEL)
(1338) 							{
_CHILD_2_TIMEOUT_ISR:
30D7: 71 C0    OR    F,192
30D9: 08       PUSH  A
30DA: 5D D0    MOV   A,REG[208]
30DC: 08       PUSH  A
(1339) 								// Set the timeout flag to exit the loop.
30DD: 62 D0 00 MOV   REG[208],0
30E0: 55 D3 01 MOV   [TIMEOUT+1],1
30E3: 55 D2 00 MOV   [TIMEOUT],0
(1340) 								TIMEOUT = 1;
30E6: 62 DA FD MOV   REG[218],253
30E9: 18       POP   A
30EA: 60 D0    MOV   REG[208],A
30EC: 18       POP   A
30ED: 7E       RETI  
(1341) 								// Store the status return level.
(1342) 								status_return_level = COMMAND_PARAM;
(1343) 								// Set i so that we exit the for loop.
(1344) 								i = SERVO_COMM_ATTEMPTS;
_CHILD_3_TIMEOUT_ISR:
30EE: 71 C0    OR    F,192
30F0: 08       PUSH  A
30F1: 5D D0    MOV   A,REG[208]
30F3: 08       PUSH  A
(1345) 								// Set the outer loop's variable so that we don't loop again.
30F4: 62 D0 00 MOV   REG[208],0
30F7: 55 D3 01 MOV   [TIMEOUT+1],1
30FA: 55 D2 00 MOV   [TIMEOUT],0
(1346) 								j = SERVO_COMM_LOOPS;
30FD: 62 DA FD MOV   REG[218],253
3100: 18       POP   A
3101: 60 D0    MOV   REG[208],A
3103: 18       POP   A
3104: 7E       RETI  
(1347) 							}
(1348) 							else
(1349) 							{	
(1350) 								// Set the timeout flag to exit the loop.
_CHILD_4_TIMEOUT_ISR:
3105: 71 C0    OR    F,192
3107: 08       PUSH  A
3108: 5D D0    MOV   A,REG[208]
310A: 08       PUSH  A
(1351) 								TIMEOUT = 1;
310B: 62 D0 00 MOV   REG[208],0
310E: 55 D3 01 MOV   [TIMEOUT+1],1
3111: 55 D2 00 MOV   [TIMEOUT],0
(1352) 							}
3114: 62 DA FD MOV   REG[218],253
3117: 18       POP   A
3118: 60 D0    MOV   REG[208],A
311A: 18       POP   A
311B: 7E       RETI  
(1353) 						}
(1354) 					}
(1355) 				}
(1356) 			}
_INIT_TIMEOUT_ISR:
311C: 71 C0    OR    F,192
311E: 08       PUSH  A
311F: 5D D0    MOV   A,REG[208]
3121: 08       PUSH  A
(1357) 		
3122: 62 D0 00 MOV   REG[208],0
3125: 55 D3 01 MOV   [TIMEOUT+1],1
3128: 55 D2 00 MOV   [TIMEOUT],0
(1358) 			// If we didn't get a good response and haven't written to the flash of the servo,
312B: 62 DA FD MOV   REG[218],253
312E: 18       POP   A
312F: 60 D0    MOV   REG[208],A
3131: 18       POP   A
3132: 7E       RETI  

FILE: lib\psocdynamicint.asm
                                   (0001) ; Generated by PSoC Designer 5.0.985.0
                                   (0002) ;
                                   (0003) ;
                                   (0004) ;  thesis_revoluteINT.asm
                                   (0005) ;
                                   (0006) ;  Data: 29 October, 2001
                                   (0007) ;  Copyright Cypress MicroSystems 2001
                                   (0008) ;
                                   (0009) ;  This file is generated by the Device Editor on Application Generation.
                                   (0010) ;  It contains dispatch code that ensures that interrupt vectors are 
                                   (0011) ;  serviced by the appropriate ISR depending on the currently active
                                   (0012) ;  configuration.
                                   (0013) ;  
                                   (0014) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0015) ;  Edits to this file will not be preserved.
                                   (0016) ;
                                   (0017) include "PSoCDynamic.inc"
                                   (0018) include "m8c.inc"
                                   (0019) export	Dispatch_INTERRUPT_10
                                   (0020) export	Dispatch_INTERRUPT_11
                                   (0021) export	Dispatch_INTERRUPT_9
                                   (0022) 
                                   (0023) 
                                   (0024) Dispatch_INTERRUPT_10:
3133: 08       PUSH  A             (0025) 	push	a
3134: 50 00    MOV   A,0           (0026) 	mov		a,0
3136: 47 04 02 TST   [4],2         (0027) 	tst		[ACTIVE_CONFIG_STATUS+hello_ADDR_OFF], hello_BIT
3139: B0 3D    JNZ   0x3177        (0028) 	jnz		Dispatch_INTERRUPT_10_END
313B: 50 04    MOV   A,4           (0029) 	mov		a,4
313D: 47 04 04 TST   [4],4         (0030) 	tst		[ACTIVE_CONFIG_STATUS+initial_ADDR_OFF], initial_BIT
3140: B0 36    JNZ   0x3177        (0031) 	jnz		Dispatch_INTERRUPT_10_END
3142: 50 08    MOV   A,8           (0032) 	mov		a,8
3144: 47 04 08 TST   [4],8         (0033) 	tst		[ACTIVE_CONFIG_STATUS+my_response_ADDR_OFF], my_response_BIT
3147: B0 2F    JNZ   0x3177        (0034) 	jnz		Dispatch_INTERRUPT_10_END
3149: 50 0C    MOV   A,12          (0035) 	mov		a,12
314B: 47 04 10 TST   [4],16        (0036) 	tst		[ACTIVE_CONFIG_STATUS+response1_ADDR_OFF], response1_BIT
314E: B0 28    JNZ   0x3177        (0037) 	jnz		Dispatch_INTERRUPT_10_END
3150: 50 10    MOV   A,16          (0038) 	mov		a,16
3152: 47 04 20 TST   [4],32        (0039) 	tst		[ACTIVE_CONFIG_STATUS+response2_ADDR_OFF], response2_BIT
3155: B0 21    JNZ   0x3177        (0040) 	jnz		Dispatch_INTERRUPT_10_END
3157: 50 14    MOV   A,20          (0041) 	mov		a,20
3159: 47 04 40 TST   [4],64        (0042) 	tst		[ACTIVE_CONFIG_STATUS+response3_ADDR_OFF], response3_BIT
315C: B0 1A    JNZ   0x3177        (0043) 	jnz		Dispatch_INTERRUPT_10_END
315E: 50 18    MOV   A,24          (0044) 	mov		a,24
3160: 47 04 80 TST   [4],128       (0045) 	tst		[ACTIVE_CONFIG_STATUS+response4_ADDR_OFF], response4_BIT
3163: B0 13    JNZ   0x3177        (0046) 	jnz		Dispatch_INTERRUPT_10_END
3165: 50 1C    MOV   A,28          (0047) 	mov		a,28
3167: 47 05 01 TST   [5],1         (0048) 	tst		[ACTIVE_CONFIG_STATUS+servo_transmit_ADDR_OFF], servo_transmit_BIT
316A: B0 0C    JNZ   0x3177        (0049) 	jnz		Dispatch_INTERRUPT_10_END
316C: 50 20    MOV   A,32          (0050) 	mov		a,32
316E: 47 04 01 TST   [4],1         (0051) 	tst		[ACTIVE_CONFIG_STATUS+waiting_ADDR_OFF], waiting_BIT
3171: B0 05    JNZ   0x3177        (0052) 	jnz		Dispatch_INTERRUPT_10_END
3173: 18       POP   A             (0053) 	pop		a
3174: 7E       RETI                (0054) 	reti
                                   (0055) ; Stop Code Compressor from breaking table alignment
                                   (0056) ; The next instruction does not get executed.
3175: 71 00    OR    F,0           (0057) 	Suspend_CodeCompressor
                                   (0058) Dispatch_INTERRUPT_10_END:
3177: E0 01    JACC  0x3179        (0059) 	jacc	Dispatch_INTERRUPT_10_TBL
                                   (0060) Dispatch_INTERRUPT_10_TBL:
3179: 18       POP   A             (0061) 	pop		a
317A: 7D 18 0F LJMP  0x180F        (0062) 	ljmp	_HELLO_1_ISR
317D: 18       POP   A             (0063) 	pop		a
317E: 7D 12 4B LJMP  0x124B        (0064) 	ljmp	_INIT_RX_ISR
3181: 18       POP   A             (0065) 	pop		a
3182: 7D 0E 80 LJMP  0x0E80        (0066) 	ljmp	_TX_014_ISR
3185: 18       POP   A             (0067) 	pop		a
3186: 7D 1E 93 LJMP  0x1E93        (0068) 	ljmp	_CHILD_1_ISR
3189: 18       POP   A             (0069) 	pop		a
318A: 7D 1C DA LJMP  0x1CDA        (0070) 	ljmp	_CHILD_2_ISR
318D: 18       POP   A             (0071) 	pop		a
318E: 7D 1B 21 LJMP  0x1B21        (0072) 	ljmp	_CHILD_3_ISR
3191: 18       POP   A             (0073) 	pop		a
3192: 7D 19 68 LJMP  0x1968        (0074) 	ljmp	_CHILD_4_ISR
3195: 18       POP   A             (0075) 	pop		a
3196: 7D 0F B9 LJMP  0x0FB9        (0076) 	ljmp	_SERVO_TX_ISR
3199: 18       POP   A             (0077) 	pop		a
319A: 7D 0C 4E LJMP  0x0C4E        (0078) 	ljmp	_WAIT_RECV_ISR
                                   (0079) ; Resume Code Compressor.
                                   (0080) ; The next instruction does not get executed.
319D: 38 00    ADD   SP,0          (0081) 	Resume_CodeCompressor
                                   (0082) 
                                   (0083) Dispatch_INTERRUPT_11:
319F: 08       PUSH  A             (0084) 	push	a
31A0: 50 00    MOV   A,0           (0085) 	mov		a,0
31A2: 47 04 02 TST   [4],2         (0086) 	tst		[ACTIVE_CONFIG_STATUS+hello_ADDR_OFF], hello_BIT
31A5: B0 13    JNZ   0x31B9        (0087) 	jnz		Dispatch_INTERRUPT_11_END
31A7: 50 04    MOV   A,4           (0088) 	mov		a,4
31A9: 47 04 08 TST   [4],8         (0089) 	tst		[ACTIVE_CONFIG_STATUS+my_response_ADDR_OFF], my_response_BIT
31AC: B0 0C    JNZ   0x31B9        (0090) 	jnz		Dispatch_INTERRUPT_11_END
31AE: 50 08    MOV   A,8           (0091) 	mov		a,8
31B0: 47 04 01 TST   [4],1         (0092) 	tst		[ACTIVE_CONFIG_STATUS+waiting_ADDR_OFF], waiting_BIT
31B3: B0 05    JNZ   0x31B9        (0093) 	jnz		Dispatch_INTERRUPT_11_END
31B5: 18       POP   A             (0094) 	pop		a
31B6: 7E       RETI                (0095) 	reti
                                   (0096) ; Stop Code Compressor from breaking table alignment
                                   (0097) ; The next instruction does not get executed.
31B7: 71 00    OR    F,0           (0098) 	Suspend_CodeCompressor
                                   (0099) Dispatch_INTERRUPT_11_END:
31B9: E0 01    JACC  0x31BB        (0100) 	jacc	Dispatch_INTERRUPT_11_TBL
                                   (0101) Dispatch_INTERRUPT_11_TBL:
31BB: 18       POP   A             (0102) 	pop		a
31BC: 7D 16 B6 LJMP  0x16B6        (0103) 	ljmp	_HELLO_2_ISR
31BF: 18       POP   A             (0104) 	pop		a
31C0: 7D 0D A7 LJMP  0x0DA7        (0105) 	ljmp	_TX_23_ISR
31C3: 18       POP   A             (0106) 	pop		a
31C4: 7D 10 92 LJMP  0x1092        (0107) 	ljmp	_RX8_2_ISR
                                   (0108) ; Resume Code Compressor.
                                   (0109) ; The next instruction does not get executed.
31C7: 38 00    ADD   SP,0          (0110) 	Resume_CodeCompressor
                                   (0111) 
                                   (0112) Dispatch_INTERRUPT_9:
31C9: 08       PUSH  A             (0113) 	push	a
31CA: 50 00    MOV   A,0           (0114) 	mov		a,0
31CC: 47 04 02 TST   [4],2         (0115) 	tst		[ACTIVE_CONFIG_STATUS+hello_ADDR_OFF], hello_BIT
31CF: B0 2F    JNZ   0x31FF        (0116) 	jnz		Dispatch_INTERRUPT_9_END
31D1: 50 04    MOV   A,4           (0117) 	mov		a,4
31D3: 47 04 04 TST   [4],4         (0118) 	tst		[ACTIVE_CONFIG_STATUS+initial_ADDR_OFF], initial_BIT
31D6: B0 28    JNZ   0x31FF        (0119) 	jnz		Dispatch_INTERRUPT_9_END
31D8: 50 08    MOV   A,8           (0120) 	mov		a,8
31DA: 47 04 08 TST   [4],8         (0121) 	tst		[ACTIVE_CONFIG_STATUS+my_response_ADDR_OFF], my_response_BIT
31DD: B0 21    JNZ   0x31FF        (0122) 	jnz		Dispatch_INTERRUPT_9_END
31DF: 50 0C    MOV   A,12          (0123) 	mov		a,12
31E1: 47 04 10 TST   [4],16        (0124) 	tst		[ACTIVE_CONFIG_STATUS+response1_ADDR_OFF], response1_BIT
31E4: B0 1A    JNZ   0x31FF        (0125) 	jnz		Dispatch_INTERRUPT_9_END
31E6: 50 10    MOV   A,16          (0126) 	mov		a,16
31E8: 47 04 20 TST   [4],32        (0127) 	tst		[ACTIVE_CONFIG_STATUS+response2_ADDR_OFF], response2_BIT
31EB: B0 13    JNZ   0x31FF        (0128) 	jnz		Dispatch_INTERRUPT_9_END
31ED: 50 14    MOV   A,20          (0129) 	mov		a,20
31EF: 47 04 40 TST   [4],64        (0130) 	tst		[ACTIVE_CONFIG_STATUS+response3_ADDR_OFF], response3_BIT
31F2: B0 0C    JNZ   0x31FF        (0131) 	jnz		Dispatch_INTERRUPT_9_END
31F4: 50 18    MOV   A,24          (0132) 	mov		a,24
31F6: 47 04 80 TST   [4],128       (0133) 	tst		[ACTIVE_CONFIG_STATUS+response4_ADDR_OFF], response4_BIT
31F9: B0 05    JNZ   0x31FF        (0134) 	jnz		Dispatch_INTERRUPT_9_END
31FB: 18       POP   A             (0135) 	pop		a
31FC: 7E       RETI                (0136) 	reti
                                   (0137) ; Stop Code Compressor from breaking table alignment
                                   (0138) ; The next instruction does not get executed.
31FD: 71 00    OR    F,0           (0139) 	Suspend_CodeCompressor
                                   (0140) Dispatch_INTERRUPT_9_END:
31FF: E0 01    JACC  0x3201        (0141) 	jacc	Dispatch_INTERRUPT_9_TBL
                                   (0142) Dispatch_INTERRUPT_9_TBL:
3201: 18       POP   A             (0143) 	pop		a
3202: 7D 30 A9 LJMP  _HELLO_TIMEOUT_ISR(0144) 	ljmp	_HELLO_TIMEOUT_ISR
3205: 18       POP   A             (0145) 	pop		a
3206: 7D 31 1C LJMP  _INIT_TIMEOUT_ISR(0146) 	ljmp	_INIT_TIMEOUT_ISR
3209: 18       POP   A             (0147) 	pop		a
320A: 7D 30 92 LJMP  _TX_01234_TIMEOUT_ISR(0148) 	ljmp	_TX_01234_TIMEOUT_ISR
320D: 18       POP   A             (0149) 	pop		a
320E: 7D 30 C0 LJMP  _CHILD_1_TIMEOUT_ISR(0150) 	ljmp	_CHILD_1_TIMEOUT_ISR
3211: 18       POP   A             (0151) 	pop		a
3212: 7D 30 D7 LJMP  _CHILD_2_TIMEOUT_ISR(0152) 	ljmp	_CHILD_2_TIMEOUT_ISR
3215: 18       POP   A             (0153) 	pop		a
3216: 7D 30 EE LJMP  _CHILD_3_TIMEOUT_ISR(0154) 	ljmp	_CHILD_3_TIMEOUT_ISR
3219: 18       POP   A             (0155) 	pop		a
321A: 7D 31 05 LJMP  _CHILD_4_TIMEOUT_ISR(0156) 	ljmp	_CHILD_4_TIMEOUT_ISR
                                   (0157) ; Resume Code Compressor.
                                   (0158) ; The next instruction does not get executed.
                                   (0159) 	Resume_CodeCompressor

FILE: <library>
--------------------------------------------------------------------------------


PSoC Designer Version: 5.0.985.0

Copyright (C) 1994 - 2009 ImageCraft Creations Inc.
ImageCraft, 706 Colorado Ave., Suite 10-88, Palo Alto, CA 94303
info@imagecraft.com, phone (650) 493-9326 FAX (650) 493-9329
http://www.imagecraft.com
lcc source code (C) 1995, by David R. Hanson and AT&T. Reproduced by permission.
Release version 7.01
