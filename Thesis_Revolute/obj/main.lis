 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 159
 0000           ; // Author: Jason Tennyson
 0000           ; // Date: 7-10-11
 0000           ; // File: main.c
 0000           ; //
 0000           ; // This is the design for the revolute modules of Jason Tennyson's Thesis.
 0000           ; // This design is made for a PSoC CY8C28433-24PVXI.
 0000           ; //
 0000           ; // Controller Packet Structure (each field is a byte)
 0000           ; // -----------------------------------------------------
 0000           ; // All Packets:
 0000           ; // START BYTE/START BYTE/SOURCE ID/DESTINATION ID/COMMAND TYPE/PARAM 1/.../PARAM N/END TRANSMIT
 0000           ; //
 0000           ; // Servo Packet Structure (each field is a byte)
 0000           ; // -----------------------------------------------------
 0000           ; // Source Packets:
 0000           ; // START BYTE/START BYTE/DESTINATION ID/LENGTH/COMMAND TYPE/PARAM 1/.../PARAM N/CHECKSUM
 0000           ; //
 0000           ; // Return Packets:
 0000           ; // START BYTE/START BYTE/SOURCE ID/LENGTH/ERROR/PARAM1/.../PARAM N/CHECKSUM
 0000           ; 
 0000           ; #include <m8c.h>              // Part-specific constants and macros.
 0000           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules.
 0000           ; #include "psocdynamic.h"      // Required for dynamically swapping configurations at run time.
 0000           ; 
 0000           ; // These are declarations of all of the timer interrupts that are used for all configurations.
 0000           ; #pragma interrupt_handler TX_01234_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_1_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_2_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_3_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_4_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler HELLO_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler INIT_TIMEOUT_ISR
 0000           ; 
 0000           ; // These defines are used as parameters of the configToggle function. Passing one of
 0000           ; // these identifiers to configToggle will put the chip in that device configuration.
 0000           ; #define               WAIT                                            (1)
 0000           ; #define               MY_RESPONSE                                     (2)
 0000           ; #define       RESPONSE_1                                      (3)
 0000           ; #define       RESPONSE_2                                      (4)
 0000           ; #define       RESPONSE_3                                      (5)
 0000           ; #define       RESPONSE_4                                      (6)
 0000           ; #define               HELLO_MODE                                      (7)
 0000           ; #define               INITIALIZE                                      (8)
 0000           ; #define               SERVO_COMM                                      (9)
 0000           ; 
 0000           ; // These defines are used as comparisons to find what port the next module connected to.
 0000           ; #define               PORT_1                                          ('1')
 0000           ; #define               PORT_2                                          ('2')
 0000           ; #define               PORT_3                                          ('3')
 0000           ; #define               PORT_4                                          ('4')
 0000           ; 
 0000           ; // Module Type
 0000           ; #define               TYPE                                            ('1')
 0000           ; 
 0000           ; // These defines are used as transmission indicators for transmissions between PSoC controllers.
 0000           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0000           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0000           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0000           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0000           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is complete.
 0000           ; #define               PING                                            (203)   // Indicates a ping message to or from the master.
 0000           ; #define               CLEAR                                           (204)   // Indicates the arm values are to be cleared.
 0000           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0000           ; #define               DEFAULT_ID                                      (251)   // The ID that all modules start with.
 0000           ; #define               BROADCAST                                       (254)   // The broadcast ID for all controllers and servos.
 0000           ; 
 0000           ; // SERVO DEFINES
 0000           ; // These numbers can all be found in the AX-12+ datasheet.
 0000           ; // These defines cover the range of IDs these servos are capable of.
 0000           ; #define               SERVO_ID_MIN                            (0)             // This is the lowest servo ID possible.
 0000           ; #define               SERVO_ID_MAX                            (253)   // This is the highest servo ID possible.
 0000           ; // These defines are servo transmission indicators.
 0000           ; #define               SERVO_START                                     (255)   // This is the start byte for a servo transmission.
 0000           ; // These defines are used to fill in the length parameter for a given command type. These are the only
 0000           ; // lengths used by this controller for servo configuration purposes. It is worth noting that any type
 0000           ; // and length of command can be issued from the master after configuration is complete.
 0000           ; #define               READ_LENGTH                                     (4)             // This is the length value for all reads.
 0000           ; #define               WRITE_LENGTH                            (4)             // This is the length value for all writes.
 0000           ; #define               PING_LENGTH                                     (2)             // This is the length value for a ping.
 0000           ; #define               RESET_LENGTH                            (2)             // This is the length value for a reset.
 0000           ; // These defines are used to fill in the servo's EEPROM address parameter for a given command type.
 0000           ; #define               ID_ADDRESS                                      (3)             // This is the address where servo ID is stored.
 0000           ; #define               STATUS_RET_ADDRESS                      (16)    // This is where the status return level is stored.
 0000           ; // These defines are used to fill in the instruction we are using on the servo.
 0000           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0000           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0000           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0000           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0000           ; // These defines cover all of the status return level possibilities.
 0000           ; #define               STATUS_RET_NEVER                        (0)             // Only respond to ping commands.
 0000           ; #define               STATUS_RET_READ                         (1)             // Only respond to read data commands (recommended).
 0000           ; #define               STATUS_RET_ALL                          (2)             // Respond to every command.
 0000           ; 
 0000           ; // This is the status return level, which is set to one of the possible status return values above.
 0000           ; // We want the status return level to be return on read commands only so that we don't have garbage
 0000           ; // return packets flying around every time we tell the servo to move.
 0000           ; #define               STATUS_RET_LEVEL                        (STATUS_RET_READ)
 0000           ; 
 0000           ; // This is the number of attempts we make to contact the servo per sweep of attempts before
 0000           ; // writing to its EEPROM in an attempt to alter settings that keep us from communicating.
 0000           ; #define               SERVO_COMM_ATTEMPTS                     (10)
 0000           ; // This is the number of times we do a loop of SERVO_COMM_ATTEMPTS. We would like this to be at least 2.
 0000           ; // This is because we do an EEPROM write after the first unsuccessful loop of SERVO_COMM_ATTEMPTS.
 0000           ; // If we don't then do at least one more loop, the EEPROM write was done for no reason.
 0000           ; #define               SERVO_COMM_LOOPS                        (2)
 0000           ; // This is the number of timeout periods to wait through while the servo boots up (2 ms per period).
 0000           ; #define               SERVO_BOOT_TIMEOUTS                     (100)
 0000           ; 
 0000           ; // This function receives a mode identifier as a parameter and toggles the system configuration.
 0000           ; void configToggle(int mode);
 0000           ; // This function unloads all configurations. This should only be needed at startup.
 0000           ; void unloadAllConfigs(void);
 0000           ; // This function unloads the configuration corresponding to the number passed to it.
 0000           ; void unloadConfig(int config_num);
 0000           ; // This function is a response to the master sending out a hello message.
 0000           ; void sayHello(void);
 0000           ; // This function looks for commands and returns 1 if a command has been read, 0 if not.
 0000           ; int commandReady(void);
 0000           ; // This function interprets the command that has just been read and performs an action accordingly.
 0000           ; void takeAction(void);
 0000           ; // This function responds to a ping.
 0000           ; void pingResponse(void);
 0000           ; // This function tells the master node that an ID assignment was completed on this module.
 0000           ; void assignedID(void);
 0000           ; // This function listens for children and registers the port that they talk to.
 0000           ; int childListen(void);
 0000           ; // This function waits for a known child's response to a command to that child from the master.
 0000           ; int childResponse(void);
 0000           ; // This function does everything it can to find the servo attached to this controller.
 0000           ; void servoFinder(void);
 0000           ; // This function carries out the passed servo instruction.
 0000           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0000           ; // This function does a simple for loop to stall and make doubly sure that the transmission finished.
 0000           ; // It is meant to be used as a definite amount of wait time after the transmission complete flag is set.
 0000           ; void xmitWait(void);
 0000           ; // This function is called to do nothing while we wait for the servo to boot up.
 0000           ; void servoBootWait(void);
 0000           ; // This function is used to wait for other controllers to find their servos while not
 0000           ; // driving any pins (which would keep a child from talking to its servo).
 0000           ; void servoConfigWait(void);
 0000           ; 
 0000           ; char CHILD;           // Keeps track of where the child is connected.
 0000           ; char ID;              // Stores the ID that the master gives this module.
 0000           ; 
 0000           ; int CONFIGURED;       // Keeps track of whether or not this module has been configured by the master.
 0000           ; int TIMEOUT;  // This flag is set if a timeout occurs.
 0000           ; int STATE;            // This stores the ID of the currently-loaded configuration.
 0000           ; 
 0000           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0000           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0000           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0000           ; char COMMAND_PARAM;                   // Stores a parameter that accompanies the command (if any).
 0000           ; char COMMAND_LENGTH;          // Stores the length parameter of a servo command.
 0000           ; char COMMAND_ERROR;                   // Stores the error code of a servo command.
 0000           ; 
 0000           ; char SERVO_ID;                                // Stores the ID of the servo inside of this module.
 0000           ; 
 0000           ; void main(void)
 0000           ; {     
 0000                   .dbline 161
 0000           ;       // Initial value assignment for variables of importance.
 0000           ;       CHILD = 0;                              // There is no child yet.
 0000 62D000            mov REG[0xd0],>_CHILD
 0003 550000            mov [_CHILD],0
 0006                   .dbline 162
 0006           ;       CONFIGURED = 0;                 // This module is not configured yet.
 0006 62D000            mov REG[0xd0],>_CONFIGURED
 0009 550100            mov [_CONFIGURED+1],0
 000C 550000            mov [_CONFIGURED],0
 000F                   .dbline 163
 000F           ;       TIMEOUT = 0;                    // Set the timeout flag low to start.
 000F 62D000            mov REG[0xd0],>_TIMEOUT
 0012 550100            mov [_TIMEOUT+1],0
 0015 550000            mov [_TIMEOUT],0
 0018                   .dbline 164
 0018           ;       COMMAND_PARAM = 0;              // There is no parameter yet.
 0018 62D000            mov REG[0xd0],>_COMMAND_PARAM
 001B 550000            mov [_COMMAND_PARAM],0
 001E                   .dbline 165
 001E           ;       STATE = 0;                              // There is no state yet.
 001E 62D000            mov REG[0xd0],>_STATE
 0021 550100            mov [_STATE+1],0
 0024 550000            mov [_STATE],0
 0027                   .dbline 166
 0027           ;       ID = DEFAULT_ID;                // Set the ID of this controller to the default to start with.
 0027 62D000            mov REG[0xd0],>_ID
 002A 5500FB            mov [_ID],-5
 002D                   .dbline 168
 002D           ; 
 002D           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); // Activate GPIO ISR
 002D 43E020            or REG[0xe0],32
 0030                   .dbline 170
 0030           ;       
 0030           ;       M8C_EnableGInt;                 // Turn on global interrupts for the transmission timeout timer.
 0030 7101                      or  F, 01h
 0032           
 0032                   .dbline 173
 0032           ;       
 0032           ;       // We have to wait for the servo to power up and get ready for communications.
 0032           ;       servoBootWait();
 0032 7C1037            xcall _servoBootWait
 0035                   .dbline 176
 0035           ;       
 0035           ;       // Find the servo that is inside of this module.
 0035           ;       servoFinder();
 0035 7C0D80            xcall _servoFinder
 0038 8013              xjmp L3
 003A           L2:
 003A                   .dbline 180
 003A           ;       
 003A           ;       // Loop and wait for commands.
 003A           ;       while(1)
 003A           ;       {       
 003A                   .dbline 181
 003A           ;               if(commandReady())
 003A 9283              xcall _commandReady
 003C 62D000            mov REG[0xd0],>__r0
 003F 3C0000            cmp [__r0],0
 0042 B006              jnz X1
 0044 3C0000            cmp [__r1],0
 0047 A004              jz L5
 0049           X1:
 0049                   .dbline 182
 0049           ;               {
 0049                   .dbline 184
 0049           ;                       // If the command is ready, take action.
 0049           ;                       takeAction();
 0049 7C086E            xcall _takeAction
 004C                   .dbline 185
 004C           ;               }
 004C           L5:
 004C                   .dbline 186
 004C           ;       }
 004C           L3:
 004C                   .dbline 179
 004C 8FED              xjmp L2
 004E           X0:
 004E                   .dbline -2
 004E           L1:
 004E                   .dbline 0 ; func end
 004E 8FFF              jmp .
 0050                   .dbend
 0050                   .dbfunc e sayHello _sayHello fV
 0050           _sayHello::
 0050                   .dbline -1
 0050                   .dbline 191
 0050           ; }
 0050           ; 
 0050           ; // This function transmits a response to a hello command from the master.
 0050           ; void sayHello(void)
 0050           ; {     
 0050                   .dbline 192
 0050           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 0050 5000              mov A,0
 0052 08                push A
 0053 5002              mov A,2
 0055 08                push A
 0056 905D              xcall _configToggle
 0058 38FE              add SP,-2
 005A                   .dbline 195
 005A           ;       
 005A           ;       // Transmit a hello response to the master node.
 005A           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 005A 10                push X
 005B 50FC              mov A,-4
 005D 7C0000            xcall _TX_014_PutChar
 0060 20                pop X
 0061                   .dbline 196
 0061           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 0061 10                push X
 0062 50FC              mov A,-4
 0064 7C0000            xcall _TX_014_PutChar
 0067 20                pop X
 0068                   .dbline 197
 0068           ;       TX_014_PutChar(ID);                             // My ID (source)
 0068 10                push X
 0069 62D000            mov REG[0xd0],>_ID
 006C 5100              mov A,[_ID]
 006E 7C0000            xcall _TX_014_PutChar
 0071 20                pop X
 0072                   .dbline 198
 0072           ;       TX_014_PutChar(MASTER_ID);              // Master ID (destination)
 0072 10                push X
 0073 5000              mov A,0
 0075 7C0000            xcall _TX_014_PutChar
 0078 20                pop X
 0079                   .dbline 199
 0079           ;       TX_014_PutChar(HELLO_BYTE);             // This is a hello command.
 0079 10                push X
 007A 50C8              mov A,-56
 007C 7C0000            xcall _TX_014_PutChar
 007F 20                pop X
 0080                   .dbline 200
 0080           ;       TX_014_PutChar(CHILD);                  // Sends child port value, default 0.
 0080 10                push X
 0081 62D000            mov REG[0xd0],>_CHILD
 0084 5100              mov A,[_CHILD]
 0086 7C0000            xcall _TX_014_PutChar
 0089 20                pop X
 008A                   .dbline 201
 008A           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission.
 008A 10                push X
 008B 50FD              mov A,-3
 008D 7C0000            xcall _TX_014_PutChar
 0090 20                pop X
 0091                   .dbline 202
 0091           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission.
 0091 10                push X
 0092 50FD              mov A,-3
 0094 7C0000            xcall _TX_014_PutChar
 0097 20                pop X
 0098           L8:
 0098                   .dbline 205
 0098           ;       
 0098           ;       // Wait for the transmission to finish.
 0098           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0098           L9:
 0098                   .dbline 205
 0098 10                push X
 0099 7C0000            xcall _TX_014_bReadTxStatus
 009C 62D000            mov REG[0xd0],>__r0
 009F 20                pop X
 00A0 5300              mov [__r0],A
 00A2 470020            tst [__r0],32
 00A5 AFF2              jz L8
 00A7                   .dbline 208
 00A7           ;       
 00A7           ;       // Make completely sure we're done.
 00A7           ;       xmitWait();
 00A7 7C1018            xcall _xmitWait
 00AA                   .dbline 210
 00AA           ; 
 00AA           ;       configToggle(WAIT);                             // Switch back to wait mode.
 00AA 5000              mov A,0
 00AC 08                push A
 00AD 5001              mov A,1
 00AF 08                push A
 00B0 9003              xcall _configToggle
 00B2 38FE              add SP,-2
 00B4                   .dbline -2
 00B4           L7:
 00B4                   .dbline 0 ; func end
 00B4 7F                ret
 00B5                   .dbend
 00B5                   .dbfunc e configToggle _configToggle fV
 00B5           ;           mode -> X-5
 00B5           _configToggle::
 00B5                   .dbline -1
 00B5 10                push X
 00B6 4F                mov X,SP
 00B7                   .dbline 216
 00B7           ; }
 00B7           ; 
 00B7           ; // This function receives a mode flag and switches the microcontroller to the
 00B7           ; // desired hardware configuration.
 00B7           ; void configToggle(int mode)
 00B7           ; {     
 00B7                   .dbline 219
 00B7           ;       // Set the pins high and disconnect from the global bus.
 00B7           ;       // This helps keep false start bits from happening while we swap configs.
 00B7           ;       PRT0DR |= 0b00011111;   // Set pins P00 through P04 high.
 00B7 43001F            or REG[0],31
 00BA                   .dbline 220
 00BA           ;       PRT0GS &= 0b11100000;   // Disconnect pins P00 through P04 from the global bus.
 00BA 4102E0            and REG[0x2],-32
 00BD                   .dbline 224
 00BD           ;       
 00BD           ;       // Unload the configuration of the current state.
 00BD           ;       // If there is no state, blindly wipe all configurations.
 00BD           ;       if(STATE)
 00BD 62D000            mov REG[0xd0],>_STATE
 00C0 3C0000            cmp [_STATE],0
 00C3 B006              jnz X2
 00C5 3C0100            cmp [_STATE+1],0
 00C8 A011              jz L12
 00CA           X2:
 00CA                   .dbline 225
 00CA           ;       {
 00CA                   .dbline 226
 00CA           ;               unloadConfig(STATE);
 00CA 62D000            mov REG[0xd0],>_STATE
 00CD 5100              mov A,[_STATE]
 00CF 08                push A
 00D0 5101              mov A,[_STATE+1]
 00D2 08                push A
 00D3 7C0B18            xcall _unloadConfig
 00D6 38FE              add SP,-2
 00D8                   .dbline 227
 00D8           ;       }
 00D8 8004              xjmp L13
 00DA           L12:
 00DA                   .dbline 229
 00DA           ;       else
 00DA           ;       {
 00DA                   .dbline 230
 00DA           ;               unloadAllConfigs();
 00DA 7C0AFC            xcall _unloadAllConfigs
 00DD                   .dbline 231
 00DD           ;       }
 00DD           L13:
 00DD                   .dbline 235
 00DD           ;       
 00DD           ;       // Go through the list of possible modes until we find the one that was passed in to us.
 00DD           ;       // Then, load that configuration and initialize whatever needs to be initialized.
 00DD           ;       if(mode == WAIT)
 00DD 3DFB00            cmp [X-5],0
 00E0 B022              jnz L14
 00E2 3DFC01            cmp [X-4],1
 00E5 B01D              jnz L14
 00E7           X3:
 00E7                   .dbline 236
 00E7           ;       {
 00E7                   .dbline 239
 00E7           ;               // Load the wait receiver configuration. This is the receiver configuration used after
 00E7           ;               // initialization is complete. It listens and forwards everything it hears.
 00E7           ;               LoadConfig_waiting();
 00E7 7C0000            xcall _LoadConfig_waiting
 00EA                   .dbline 242
 00EA           ;               
 00EA           ;               // Start the receivers.
 00EA           ;               WAIT_RECV_Start(WAIT_RECV_PARITY_NONE);
 00EA 10                push X
 00EB 5000              mov A,0
 00ED 7C0000            xcall _WAIT_RECV_Start
 00F0 20                pop X
 00F1                   .dbline 243
 00F1           ;               RX8_2_Start(RX8_2_PARITY_NONE);
 00F1 10                push X
 00F2 5000              mov A,0
 00F4 7C0000            xcall _RX8_2_Start
 00F7 20                pop X
 00F8                   .dbline 246
 00F8           ;               
 00F8           ;               // Set the current state.
 00F8           ;               STATE = WAIT;
 00F8 62D000            mov REG[0xd0],>_STATE
 00FB 550101            mov [_STATE+1],1
 00FE 550000            mov [_STATE],0
 0101                   .dbline 247
 0101           ;       }
 0101 81A0              xjmp L15
 0103           L14:
 0103                   .dbline 248
 0103           ;       else if(mode == MY_RESPONSE)
 0103 3DFB00            cmp [X-5],0
 0106 B04C              jnz L16
 0108 3DFC02            cmp [X-4],2
 010B B047              jnz L16
 010D           X4:
 010D                   .dbline 249
 010D           ;       {
 010D                   .dbline 251
 010D           ;               // Load the transmitter configuration. This is for transmitting messages on all ports.
 010D           ;               LoadConfig_my_response();
 010D 7C0000            xcall _LoadConfig_my_response
 0110                   .dbline 254
 0110           ;               
 0110           ;               // Clear the timeout flag.
 0110           ;               TIMEOUT = 0;
 0110 62D000            mov REG[0xd0],>_TIMEOUT
 0113 550100            mov [_TIMEOUT+1],0
 0116 550000            mov [_TIMEOUT],0
 0119                   .dbline 257
 0119           ;               
 0119           ;               // Start the transmitters.
 0119           ;               TX_014_Start(TX_014_PARITY_NONE);       // Transmits on P00, P01, and P04.
 0119 10                push X
 011A 5000              mov A,0
 011C 7C0000            xcall _TX_014_Start
 011F 20                pop X
 0120                   .dbline 258
 0120           ;               TX_23_Start(TX_23_PARITY_NONE);         // Transmits on P02 and P03.
 0120 10                push X
 0121 5000              mov A,0
 0123 7C0000            xcall _TX_23_Start
 0126                   .dbline 260
 0126           ;               
 0126           ;               TX_01234_TIMEOUT_EnableInt();           // Make sure interrupts are enabled.
 0126 7C0000            xcall _TX_01234_TIMEOUT_EnableInt
 0129                   .dbline 261
 0129           ;               TX_01234_TIMEOUT_Start();                       // Start the timer.
 0129 7C0000            xcall _TX_01234_TIMEOUT_Start
 012C 20                pop X
 012D           L18:
 012D                   .dbline 265
 012D           ;               
 012D           ;               // Do nothing while we wait for one timeout period (1 ms).
 012D           ;               // This is to allow everyone to get in the right configuration before talking.
 012D           ;               while(!TIMEOUT) { }
 012D                   .dbline 265
 012D           L19:
 012D                   .dbline 265
 012D 62D000            mov REG[0xd0],>_TIMEOUT
 0130 3C0000            cmp [_TIMEOUT],0
 0133 B006              jnz X5
 0135 3C0100            cmp [_TIMEOUT+1],0
 0138 AFF4              jz L18
 013A           X5:
 013A                   .dbline 267
 013A           ;               
 013A           ;               TX_01234_TIMEOUT_Stop();                        // Stop the timer.
 013A 10                push X
 013B 7C0000            xcall _TX_01234_TIMEOUT_Stop
 013E 20                pop X
 013F                   .dbline 268
 013F           ;               TIMEOUT = 0;                                            // Reset the timeout flag.
 013F 62D000            mov REG[0xd0],>_TIMEOUT
 0142 550100            mov [_TIMEOUT+1],0
 0145 550000            mov [_TIMEOUT],0
 0148                   .dbline 271
 0148           ;       
 0148           ;               // Set the current state.
 0148           ;               STATE = MY_RESPONSE;
 0148 62D000            mov REG[0xd0],>_STATE
 014B 550102            mov [_STATE+1],2
 014E 550000            mov [_STATE],0
 0151                   .dbline 272
 0151           ;       }
 0151 8150              xjmp L17
 0153           L16:
 0153                   .dbline 273
 0153           ;       else if(mode == RESPONSE_1)
 0153 3DFB00            cmp [X-5],0
 0156 B02A              jnz L21
 0158 3DFC03            cmp [X-4],3
 015B B025              jnz L21
 015D           X6:
 015D                   .dbline 274
 015D           ;       {
 015D                   .dbline 276
 015D           ;               // Load the response wait on port 1.
 015D           ;               LoadConfig_response1();
 015D 7C0000            xcall _LoadConfig_response1
 0160                   .dbline 279
 0160           ;               
 0160           ;               // Clear the timeout flag.
 0160           ;               TIMEOUT = 0;
 0160 62D000            mov REG[0xd0],>_TIMEOUT
 0163 550100            mov [_TIMEOUT+1],0
 0166 550000            mov [_TIMEOUT],0
 0169                   .dbline 282
 0169           ;               
 0169           ;               // Start listening for a response through child port 1.
 0169           ;               CHILD_1_Start(CHILD_1_PARITY_NONE);
 0169 10                push X
 016A 5000              mov A,0
 016C 7C0000            xcall _CHILD_1_Start
 016F                   .dbline 284
 016F           ;               
 016F           ;               CHILD_1_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 016F 7C0000            xcall _CHILD_1_TIMEOUT_EnableInt
 0172                   .dbline 285
 0172           ;               CHILD_1_TIMEOUT_Start();                        // Start the timer.
 0172 7C0000            xcall _CHILD_1_TIMEOUT_Start
 0175 20                pop X
 0176                   .dbline 288
 0176           ;               
 0176           ;               // Set the current state.
 0176           ;               STATE = RESPONSE_1;
 0176 62D000            mov REG[0xd0],>_STATE
 0179 550103            mov [_STATE+1],3
 017C 550000            mov [_STATE],0
 017F                   .dbline 289
 017F           ;       }
 017F 8122              xjmp L22
 0181           L21:
 0181                   .dbline 290
 0181           ;       else if(mode == RESPONSE_2)
 0181 3DFB00            cmp [X-5],0
 0184 B02A              jnz L23
 0186 3DFC04            cmp [X-4],4
 0189 B025              jnz L23
 018B           X7:
 018B                   .dbline 291
 018B           ;       {
 018B                   .dbline 293
 018B           ;               // Load the response wait on port 2.
 018B           ;               LoadConfig_response2();
 018B 7C0000            xcall _LoadConfig_response2
 018E                   .dbline 296
 018E           ;               
 018E           ;               // Clear the timeout flag.
 018E           ;               TIMEOUT = 0;
 018E 62D000            mov REG[0xd0],>_TIMEOUT
 0191 550100            mov [_TIMEOUT+1],0
 0194 550000            mov [_TIMEOUT],0
 0197                   .dbline 299
 0197           ;               
 0197           ;               // Start listening for a response through child port 2.
 0197           ;               CHILD_2_Start(CHILD_2_PARITY_NONE);
 0197 10                push X
 0198 5000              mov A,0
 019A 7C0000            xcall _CHILD_2_Start
 019D                   .dbline 301
 019D           ;               
 019D           ;               CHILD_2_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 019D 7C0000            xcall _CHILD_2_TIMEOUT_EnableInt
 01A0                   .dbline 302
 01A0           ;               CHILD_2_TIMEOUT_Start();                        // Start the timer.
 01A0 7C0000            xcall _CHILD_2_TIMEOUT_Start
 01A3 20                pop X
 01A4                   .dbline 305
 01A4           ;               
 01A4           ;               // Set the current state.
 01A4           ;               STATE = RESPONSE_2;
 01A4 62D000            mov REG[0xd0],>_STATE
 01A7 550104            mov [_STATE+1],4
 01AA 550000            mov [_STATE],0
 01AD                   .dbline 306
 01AD           ;       }
 01AD 80F4              xjmp L24
 01AF           L23:
 01AF                   .dbline 307
 01AF           ;       else if(mode == RESPONSE_3)
 01AF 3DFB00            cmp [X-5],0
 01B2 B02A              jnz L25
 01B4 3DFC05            cmp [X-4],5
 01B7 B025              jnz L25
 01B9           X8:
 01B9                   .dbline 308
 01B9           ;       {
 01B9                   .dbline 310
 01B9           ;               // Load the response wait on port 3.
 01B9           ;               LoadConfig_response3();
 01B9 7C0000            xcall _LoadConfig_response3
 01BC                   .dbline 313
 01BC           ;               
 01BC           ;               // Clear the timeout flag.
 01BC           ;               TIMEOUT = 0;
 01BC 62D000            mov REG[0xd0],>_TIMEOUT
 01BF 550100            mov [_TIMEOUT+1],0
 01C2 550000            mov [_TIMEOUT],0
 01C5                   .dbline 316
 01C5           ;               
 01C5           ;               // Start listening for a response through child port 3.
 01C5           ;               CHILD_3_Start(CHILD_3_PARITY_NONE);
 01C5 10                push X
 01C6 5000              mov A,0
 01C8 7C0000            xcall _CHILD_3_Start
 01CB                   .dbline 318
 01CB           ;               
 01CB           ;               CHILD_3_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 01CB 7C0000            xcall _CHILD_3_TIMEOUT_EnableInt
 01CE                   .dbline 319
 01CE           ;               CHILD_3_TIMEOUT_Start();                        // Start the timer.
 01CE 7C0000            xcall _CHILD_3_TIMEOUT_Start
 01D1 20                pop X
 01D2                   .dbline 322
 01D2           ;               
 01D2           ;               // Set the current state.
 01D2           ;               STATE = RESPONSE_3;
 01D2 62D000            mov REG[0xd0],>_STATE
 01D5 550105            mov [_STATE+1],5
 01D8 550000            mov [_STATE],0
 01DB                   .dbline 323
 01DB           ;       }
 01DB 80C6              xjmp L26
 01DD           L25:
 01DD                   .dbline 324
 01DD           ;       else if(mode == RESPONSE_4)
 01DD 3DFB00            cmp [X-5],0
 01E0 B02A              jnz L27
 01E2 3DFC06            cmp [X-4],6
 01E5 B025              jnz L27
 01E7           X9:
 01E7                   .dbline 325
 01E7           ;       {
 01E7                   .dbline 327
 01E7           ;               // Load the response wait on port 4.
 01E7           ;               LoadConfig_response4();
 01E7 7C0000            xcall _LoadConfig_response4
 01EA                   .dbline 330
 01EA           ;               
 01EA           ;               // Clear the timeout flag.
 01EA           ;               TIMEOUT = 0;
 01EA 62D000            mov REG[0xd0],>_TIMEOUT
 01ED 550100            mov [_TIMEOUT+1],0
 01F0 550000            mov [_TIMEOUT],0
 01F3                   .dbline 333
 01F3           ;               
 01F3           ;               // Start listening for a response through child port 4.
 01F3           ;               CHILD_4_Start(CHILD_4_PARITY_NONE);
 01F3 10                push X
 01F4 5000              mov A,0
 01F6 7C0000            xcall _CHILD_4_Start
 01F9                   .dbline 335
 01F9           ;               
 01F9           ;               CHILD_4_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 01F9 7C0000            xcall _CHILD_4_TIMEOUT_EnableInt
 01FC                   .dbline 336
 01FC           ;               CHILD_4_TIMEOUT_Start();                        // Start the timer.
 01FC 7C0000            xcall _CHILD_4_TIMEOUT_Start
 01FF 20                pop X
 0200                   .dbline 339
 0200           ;               
 0200           ;               // Set the current state.
 0200           ;               STATE = RESPONSE_4;
 0200 62D000            mov REG[0xd0],>_STATE
 0203 550106            mov [_STATE+1],6
 0206 550000            mov [_STATE],0
 0209                   .dbline 340
 0209           ;       }
 0209 8098              xjmp L28
 020B           L27:
 020B                   .dbline 341
 020B           ;       else if(mode == HELLO_MODE)
 020B 3DFB00            cmp [X-5],0
 020E B03F              jnz L29
 0210 3DFC07            cmp [X-4],7
 0213 B03A              jnz L29
 0215           X10:
 0215                   .dbline 342
 0215           ;       {
 0215                   .dbline 344
 0215           ;               // Load the hello wait mode. This is for listening on all ports for a hello response.
 0215           ;               LoadConfig_hello();
 0215 7C0000            xcall _LoadConfig_hello
 0218                   .dbline 347
 0218           ;               
 0218           ;               // Clear the timeout flag.
 0218           ;               TIMEOUT = 0;
 0218 62D000            mov REG[0xd0],>_TIMEOUT
 021B 550100            mov [_TIMEOUT+1],0
 021E 550000            mov [_TIMEOUT],0
 0221                   .dbline 351
 0221           ;               
 0221           ;               // The seemingly unnecessary brackets around each line are unfortunately needed.
 0221           ;       
 0221           ;               {
 0221                   .dbline 353
 0221           ;               // Start listening for a response through child port 1.
 0221           ;               HELLO_1_Start(HELLO_1_PARITY_NONE);
 0221 10                push X
 0222 5000              mov A,0
 0224 7C0000            xcall _HELLO_1_Start
 0227 20                pop X
 0228                   .dbline 354
 0228           ;               }
 0228                   .dbline 356
 0228           ;               
 0228           ;               {
 0228                   .dbline 358
 0228           ;               // Start listening for a response through child port 2.
 0228           ;               HELLO_2_Start(HELLO_2_PARITY_NONE);
 0228 10                push X
 0229 5000              mov A,0
 022B 7C0000            xcall _HELLO_2_Start
 022E 20                pop X
 022F                   .dbline 359
 022F           ;               }
 022F                   .dbline 361
 022F           ;               
 022F           ;               {
 022F                   .dbline 363
 022F           ;               // Start listening for a response through child port 3.
 022F           ;               HELLO_3_Start(HELLO_3_PARITY_NONE);
 022F 10                push X
 0230 5000              mov A,0
 0232 7C0000            xcall _HELLO_3_Start
 0235 20                pop X
 0236                   .dbline 364
 0236           ;               }
 0236                   .dbline 366
 0236           ;               
 0236           ;               {
 0236                   .dbline 368
 0236           ;               // Start listening for a response through child port 4.
 0236           ;               HELLO_4_Start(HELLO_4_PARITY_NONE);
 0236 10                push X
 0237 5000              mov A,0
 0239 7C0000            xcall _HELLO_4_Start
 023C                   .dbline 369
 023C           ;               }
 023C                   .dbline 371
 023C           ;               
 023C           ;               HELLO_TIMEOUT_EnableInt();      // Make sure interrupts are enabled.
 023C 7C0000            xcall _HELLO_TIMEOUT_EnableInt
 023F                   .dbline 372
 023F           ;               HELLO_TIMEOUT_Start();          // Start the timer.
 023F 7C0000            xcall _HELLO_TIMEOUT_Start
 0242 20                pop X
 0243                   .dbline 375
 0243           ;               
 0243           ;               // Set the current state.
 0243           ;               STATE = HELLO_MODE;
 0243 62D000            mov REG[0xd0],>_STATE
 0246 550107            mov [_STATE+1],7
 0249 550000            mov [_STATE],0
 024C                   .dbline 376
 024C           ;       }
 024C 8055              xjmp L30
 024E           L29:
 024E                   .dbline 377
 024E           ;       else if(mode == INITIALIZE)
 024E 3DFB00            cmp [X-5],0
 0251 B02A              jnz L31
 0253 3DFC08            cmp [X-4],8
 0256 B025              jnz L31
 0258           X11:
 0258                   .dbline 378
 0258           ;       {
 0258                   .dbline 380
 0258           ;               // Load the configuration for initialization. This config listens but does not forward.
 0258           ;               LoadConfig_initial();
 0258 7C0000            xcall _LoadConfig_initial
 025B                   .dbline 383
 025B           ;               
 025B           ;               // Clear the timeout flag.
 025B           ;               TIMEOUT = 0;
 025B 62D000            mov REG[0xd0],>_TIMEOUT
 025E 550100            mov [_TIMEOUT+1],0
 0261 550000            mov [_TIMEOUT],0
 0264                   .dbline 386
 0264           ;               
 0264           ;               // Start the receiver.
 0264           ;               INIT_RX_Start(INIT_RX_PARITY_NONE);
 0264 10                push X
 0265 5000              mov A,0
 0267 7C0000            xcall _INIT_RX_Start
 026A                   .dbline 388
 026A           ;               
 026A           ;               INIT_TIMEOUT_EnableInt();       // Make sure interrupts are enabled.
 026A 7C0000            xcall _INIT_TIMEOUT_EnableInt
 026D                   .dbline 389
 026D           ;               INIT_TIMEOUT_Start();           // Start the timer.
 026D 7C0000            xcall _INIT_TIMEOUT_Start
 0270 20                pop X
 0271                   .dbline 392
 0271           ;               
 0271           ;               // Set the current state.
 0271           ;               STATE = INITIALIZE;
 0271 62D000            mov REG[0xd0],>_STATE
 0274 550108            mov [_STATE+1],8
 0277 550000            mov [_STATE],0
 027A                   .dbline 393
 027A           ;       }
 027A 8027              xjmp L32
 027C           L31:
 027C                   .dbline 394
 027C           ;       else if(mode == SERVO_COMM)
 027C 3DFB00            cmp [X-5],0
 027F B022              jnz L33
 0281 3DFC09            cmp [X-4],9
 0284 B01D              jnz L33
 0286           X12:
 0286                   .dbline 395
 0286           ;       {
 0286                   .dbline 397
 0286           ;               // Load the configuration for servo communication. This config only transmits on P00.
 0286           ;               LoadConfig_servo_transmit();
 0286 7C0000            xcall _LoadConfig_servo_transmit
 0289                   .dbline 400
 0289           ;               
 0289           ;               // Clear the timeout flag.
 0289           ;               TIMEOUT = 0;
 0289 62D000            mov REG[0xd0],>_TIMEOUT
 028C 550100            mov [_TIMEOUT+1],0
 028F 550000            mov [_TIMEOUT],0
 0292                   .dbline 403
 0292           ;               
 0292           ;               // Start the transmitter.
 0292           ;               SERVO_TX_Start(SERVO_TX_PARITY_NONE);
 0292 10                push X
 0293 5000              mov A,0
 0295 7C0000            xcall _SERVO_TX_Start
 0298 20                pop X
 0299                   .dbline 406
 0299           ;       
 0299           ;               // Set the current state.
 0299           ;               STATE = SERVO_COMM;
 0299 62D000            mov REG[0xd0],>_STATE
 029C 550109            mov [_STATE+1],9
 029F 550000            mov [_STATE],0
 02A2                   .dbline 407
 02A2           ;       }
 02A2           L33:
 02A2           L32:
 02A2           L30:
 02A2           L28:
 02A2           L26:
 02A2           L24:
 02A2           L22:
 02A2           L17:
 02A2           L15:
 02A2                   .dbline 410
 02A2           ;       
 02A2           ;       // If this module is configured, talk on all pins for potential children.
 02A2           ;       if(CONFIGURED)
 02A2 62D000            mov REG[0xd0],>_CONFIGURED
 02A5 3C0000            cmp [_CONFIGURED],0
 02A8 B006              jnz X13
 02AA 3C0100            cmp [_CONFIGURED+1],0
 02AD A009              jz L35
 02AF           X13:
 02AF                   .dbline 411
 02AF           ;       {
 02AF                   .dbline 412
 02AF           ;               PRT0GS |= 0b00011111;   // Connect all pins to the global bus.
 02AF 43021F            or REG[0x2],31
 02B2                   .dbline 413
 02B2           ;               PRT2DR &= 0b11111110;   // Turn on the LED (active low).
 02B2 4108FE            and REG[0x8],-2
 02B5                   .dbline 414
 02B5           ;       }
 02B5 8007              xjmp L36
 02B7           L35:
 02B7                   .dbline 416
 02B7           ;       else
 02B7           ;       {
 02B7                   .dbline 417
 02B7           ;               PRT0GS |= 0b00000001;   // Just connect pin 0;
 02B7 430201            or REG[0x2],1
 02BA                   .dbline 418
 02BA           ;               PRT2DR |= 0b00000001;   // Turn off the LED (active low).
 02BA 430801            or REG[0x8],1
 02BD                   .dbline 419
 02BD           ;       }
 02BD           L36:
 02BD                   .dbline -2
 02BD           L11:
 02BD 20                pop X
 02BE                   .dbline 0 ; func end
 02BE 7F                ret
 02BF                   .dbsym l mode -5 I
 02BF                   .dbend
 02BF                   .dbfunc e commandReady _commandReady fI
 02BF           ;   runningTotal -> X+3
 02BF           ;              i -> X+1
 02BF           ;       tempByte -> X+0
 02BF           _commandReady::
 02BF                   .dbline -1
 02BF 10                push X
 02C0 4F                mov X,SP
 02C1 3805              add SP,5
 02C3                   .dbline 426
 02C3           ; }
 02C3           ; 
 02C3           ; // This function checks the current hardware configuration state. Once it finds this state, it
 02C3           ; // uses the receivers that are in that configuration in the way they are intended to grab the
 02C3           ; // transmission information that we require (or just let commands pass through if we don't care).
 02C3           ; int commandReady(void)
 02C3           ; {
 02C3                   .dbline 427
 02C3           ;       int i = 0;                      // This integer is used for looping through the remaining bytes of commands.
 02C3 560200            mov [X+2],0
 02C6 560100            mov [X+1],0
 02C9                   .dbline 428
 02C9           ;       char tempByte = 0;      // This byte is used to store each byte for comparison as it comes in.
 02C9 560000            mov [X+0],0
 02CC                   .dbline 430
 02CC           ;       
 02CC           ;       int runningTotal = 0;   // This is used to check for a checksum in the case of a servo transmit.
 02CC 560400            mov [X+4],0
 02CF 560300            mov [X+3],0
 02D2                   .dbline 434
 02D2           ;       
 02D2           ;       // This conditional checks which configuration is loaded and uses the proper devices to
 02D2           ;       // read a transmission and store the important information from that transmission.
 02D2           ;       if(STATE == WAIT)
 02D2 62D000            mov REG[0xd0],>_STATE
 02D5 3C0000            cmp [_STATE],0
 02D8 B0D4              jnz L38
 02DA 3C0101            cmp [_STATE+1],1
 02DD B0CF              jnz L38
 02DF           X14:
 02DF                   .dbline 435
 02DF           ;       {       
 02DF                   .dbline 438
 02DF           ;               // In wait mode, the only thing that progresses things forward is a master node transmission.
 02DF           ;               // With this being the case, we use a blocking operation to sit and wait for a byte.
 02DF           ;               tempByte = WAIT_RECV_cGetChar();
 02DF 10                push X
 02E0 7C0000            xcall _WAIT_RECV_cGetChar
 02E3 62D000            mov REG[0xd0],>__r0
 02E6 20                pop X
 02E7 5400              mov [X+0],A
 02E9                   .dbline 441
 02E9           ;               
 02E9           ;               // If a transmission has started for either a controller or a servo...
 02E9           ;               if(tempByte == START_TRANSMIT)
 02E9 3D00FC            cmp [X+0],-4
 02EC B047              jnz L40
 02EE                   .dbline 442
 02EE           ;               {
 02EE 800B              xjmp L43
 02F0           L42:
 02F0                   .dbline 445
 02F0           ;                       // While we keep reading start bytes, sit and spin.
 02F0           ;                       while(tempByte == START_TRANSMIT)
 02F0           ;                       {
 02F0                   .dbline 446
 02F0           ;                               tempByte = WAIT_RECV_cGetChar();
 02F0 10                push X
 02F1 7C0000            xcall _WAIT_RECV_cGetChar
 02F4 62D000            mov REG[0xd0],>__r0
 02F7 20                pop X
 02F8 5400              mov [X+0],A
 02FA                   .dbline 447
 02FA           ;                       }
 02FA           L43:
 02FA                   .dbline 444
 02FA 3D00FC            cmp [X+0],-4
 02FD AFF2              jz L42
 02FF                   .dbline 450
 02FF           ;                       
 02FF           ;                       // The tempByte variable contains the source ID. If the source is good, store all bytes.
 02FF           ;                       if(tempByte == MASTER_ID)
 02FF 3D0000            cmp [X+0],0
 0302 B55E              jnz L39
 0304                   .dbline 451
 0304           ;                       {
 0304                   .dbline 452
 0304           ;                               COMMAND_SOURCE = tempByte;
 0304 5200              mov A,[X+0]
 0306 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0309 5300              mov [_COMMAND_SOURCE],A
 030B                   .dbline 453
 030B           ;                               COMMAND_DESTINATION = WAIT_RECV_cGetChar();
 030B 10                push X
 030C 7C0000            xcall _WAIT_RECV_cGetChar
 030F 20                pop X
 0310 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0313 5300              mov [_COMMAND_DESTINATION],A
 0315                   .dbline 454
 0315           ;                               COMMAND_TYPE = WAIT_RECV_cGetChar();
 0315 10                push X
 0316 7C0000            xcall _WAIT_RECV_cGetChar
 0319 20                pop X
 031A 62D000            mov REG[0xd0],>_COMMAND_TYPE
 031D 5300              mov [_COMMAND_TYPE],A
 031F                   .dbline 455
 031F           ;                               COMMAND_PARAM = WAIT_RECV_cGetChar();
 031F 10                push X
 0320 7C0000            xcall _WAIT_RECV_cGetChar
 0323 20                pop X
 0324 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0327 5300              mov [_COMMAND_PARAM],A
 0329                   .dbline 457
 0329           ;                               
 0329           ;                               return 1;
 0329 62D000            mov REG[0xd0],>__r0
 032C 550001            mov [__r1],1
 032F 550000            mov [__r0],0
 0332 8537              xjmp L37
 0334           L40:
 0334                   .dbline 460
 0334           ;                       }
 0334           ;               }
 0334           ;               else if(tempByte == SERVO_START)
 0334 3D00FF            cmp [X+0],-1
 0337 B529              jnz L39
 0339                   .dbline 461
 0339           ;               {
 0339 800B              xjmp L50
 033B           L49:
 033B                   .dbline 464
 033B           ;                       // While we keep reading start bytes, sit and spin.
 033B           ;                       while(tempByte == SERVO_START)
 033B           ;                       {
 033B                   .dbline 465
 033B           ;                               tempByte = WAIT_RECV_cGetChar();
 033B 10                push X
 033C 7C0000            xcall _WAIT_RECV_cGetChar
 033F 62D000            mov REG[0xd0],>__r0
 0342 20                pop X
 0343 5400              mov [X+0],A
 0345                   .dbline 466
 0345           ;                       }
 0345           L50:
 0345                   .dbline 463
 0345 3D00FF            cmp [X+0],-1
 0348 AFF2              jz L49
 034A                   .dbline 469
 034A           ;                       
 034A           ;                       // We assume (and hopefully rightly so) that this is a command from master.
 034A           ;                       COMMAND_SOURCE = MASTER_ID;
 034A 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 034D 550000            mov [_COMMAND_SOURCE],0
 0350                   .dbline 471
 0350           ;                       // The first parameter after the servo start is the destination.
 0350           ;                       COMMAND_DESTINATION = tempByte;
 0350 5200              mov A,[X+0]
 0352 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0355 5300              mov [_COMMAND_DESTINATION],A
 0357                   .dbline 476
 0357           ;                       // The second parameter after the servo start is the command length.
 0357           ;                       // We don't need it to wait for the transmission to go through since the
 0357           ;                       // transmission goes through the chip with a delay of approximately 100 ns
 0357           ;                       // (it is already in and out by the time you read this byte).
 0357           ;                       tempByte = WAIT_RECV_cGetChar();
 0357 10                push X
 0358 7C0000            xcall _WAIT_RECV_cGetChar
 035B 62D000            mov REG[0xd0],>__r0
 035E 20                pop X
 035F 5400              mov [X+0],A
 0361                   .dbline 479
 0361           ;                       // Now we store the command type. Depending on what the status return level
 0361           ;                       // is, we have special duties.
 0361           ;                       COMMAND_TYPE = WAIT_RECV_cGetChar();
 0361 10                push X
 0362 7C0000            xcall _WAIT_RECV_cGetChar
 0365 20                pop X
 0366 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0369 5300              mov [_COMMAND_TYPE],A
 036B                   .dbline 483
 036B           ;                       
 036B           ;                       // This basically clears the rest of the command from the buffer
 036B           ;                       // and serves the dual purpose of allowing everybody time to hear it.
 036B           ;                       for(i = 0; i < (tempByte - 1); i++)
 036B 560200            mov [X+2],0
 036E 560100            mov [X+1],0
 0371 800E              xjmp L55
 0373           L52:
 0373                   .dbline 484
 0373           ;                       {
 0373                   .dbline 485
 0373           ;                               WAIT_RECV_cGetChar();
 0373 10                push X
 0374 7C0000            xcall _WAIT_RECV_cGetChar
 0377 62D000            mov REG[0xd0],>__r0
 037A 20                pop X
 037B                   .dbline 486
 037B           ;                       }
 037B           L53:
 037B                   .dbline 483
 037B 7702              inc [X+2]
 037D 0F0100            adc [X+1],0
 0380           L55:
 0380                   .dbline 483
 0380 62D000            mov REG[0xd0],>__r0
 0383 5200              mov A,[X+0]
 0385 5300              mov [__r1],A
 0387 550000            mov [__r0],0
 038A 160001            sub [__r1],1
 038D 1E0000            sbb [__r0],0
 0390 5202              mov A,[X+2]
 0392 1200              sub A,[__r1]
 0394 5100              mov A,[__r0]
 0396 3180              xor A,-128
 0398 5300              mov [__rX],A
 039A 5201              mov A,[X+1]
 039C 3180              xor A,-128
 039E 1A00              sbb A,[__rX]
 03A0 CFD2              jc L52
 03A2           X15:
 03A2                   .dbline 488
 03A2           ;                               
 03A2           ;                       return 1;
 03A2 62D000            mov REG[0xd0],>__r0
 03A5 550001            mov [__r1],1
 03A8 550000            mov [__r0],0
 03AB 84BE              xjmp L37
 03AD           L38:
 03AD                   .dbline 491
 03AD           ;               }
 03AD           ;       }
 03AD           ;       else if(STATE == HELLO_MODE)
 03AD 62D000            mov REG[0xd0],>_STATE
 03B0 3C0000            cmp [_STATE],0
 03B3 B0E2              jnz L56
 03B5 3C0107            cmp [_STATE+1],7
 03B8 B0DD              jnz L56
 03BA           X16:
 03BA                   .dbline 492
 03BA           ;       {
 03BA                   .dbline 495
 03BA           ;               // Check all of the ports for a start byte. Only one port will produce one.
 03BA           ;               // Only non-blocking commands are used to avoid getting stuck listening downstream.
 03BA           ;               if(HELLO_1_cReadChar() == START_TRANSMIT)
 03BA 10                push X
 03BB 7C0000            xcall _HELLO_1_cReadChar
 03BE 62D000            mov REG[0xd0],>__r0
 03C1 20                pop X
 03C2 39FC              cmp A,-4
 03C4 B02C              jnz L58
 03C6                   .dbline 496
 03C6           ;               {
 03C6 801B              xjmp L61
 03C8           L60:
 03C8                   .dbline 498
 03C8           ;                       while(!TIMEOUT)
 03C8           ;                       {
 03C8                   .dbline 499
 03C8           ;                               if(HELLO_1_cReadChar() == END_TRANSMIT)
 03C8 10                push X
 03C9 7C0000            xcall _HELLO_1_cReadChar
 03CC 20                pop X
 03CD 39FD              cmp A,-3
 03CF B012              jnz L63
 03D1                   .dbline 500
 03D1           ;                               {
 03D1                   .dbline 501
 03D1           ;                                       CHILD = PORT_1;
 03D1 62D000            mov REG[0xd0],>_CHILD
 03D4 550031            mov [_CHILD],49
 03D7                   .dbline 503
 03D7           ;                               
 03D7           ;                                       return 1;
 03D7 62D000            mov REG[0xd0],>__r0
 03DA 550001            mov [__r1],1
 03DD 550000            mov [__r0],0
 03E0 8489              xjmp L37
 03E2           L63:
 03E2                   .dbline 505
 03E2           ;                               }
 03E2           ;                       }
 03E2           L61:
 03E2                   .dbline 497
 03E2 62D000            mov REG[0xd0],>_TIMEOUT
 03E5 3C0000            cmp [_TIMEOUT],0
 03E8 B006              jnz X17
 03EA 3C0100            cmp [_TIMEOUT+1],0
 03ED AFDA              jz L60
 03EF           X17:
 03EF                   .dbline 506
 03EF           ;               }
 03EF 8471              xjmp L57
 03F1           L58:
 03F1                   .dbline 507
 03F1           ;               else if(HELLO_2_cReadChar() == START_TRANSMIT)
 03F1 10                push X
 03F2 7C0000            xcall _HELLO_2_cReadChar
 03F5 62D000            mov REG[0xd0],>__r0
 03F8 20                pop X
 03F9 39FC              cmp A,-4
 03FB B02C              jnz L65
 03FD                   .dbline 508
 03FD           ;               {
 03FD 801B              xjmp L68
 03FF           L67:
 03FF                   .dbline 510
 03FF           ;                       while(!TIMEOUT)
 03FF           ;                       {
 03FF                   .dbline 511
 03FF           ;                               if(HELLO_2_cReadChar() == END_TRANSMIT)
 03FF 10                push X
 0400 7C0000            xcall _HELLO_2_cReadChar
 0403 20                pop X
 0404 39FD              cmp A,-3
 0406 B012              jnz L70
 0408                   .dbline 512
 0408           ;                               {
 0408                   .dbline 513
 0408           ;                                       CHILD = PORT_2;
 0408 62D000            mov REG[0xd0],>_CHILD
 040B 550032            mov [_CHILD],50
 040E                   .dbline 515
 040E           ;                               
 040E           ;                                       return 1;
 040E 62D000            mov REG[0xd0],>__r0
 0411 550001            mov [__r1],1
 0414 550000            mov [__r0],0
 0417 8452              xjmp L37
 0419           L70:
 0419                   .dbline 517
 0419           ;                               }
 0419           ;                       }
 0419           L68:
 0419                   .dbline 509
 0419 62D000            mov REG[0xd0],>_TIMEOUT
 041C 3C0000            cmp [_TIMEOUT],0
 041F B006              jnz X18
 0421 3C0100            cmp [_TIMEOUT+1],0
 0424 AFDA              jz L67
 0426           X18:
 0426                   .dbline 518
 0426           ;               }
 0426 843A              xjmp L57
 0428           L65:
 0428                   .dbline 519
 0428           ;               else if(HELLO_3_cReadChar() == START_TRANSMIT)
 0428 10                push X
 0429 7C0000            xcall _HELLO_3_cReadChar
 042C 62D000            mov REG[0xd0],>__r0
 042F 20                pop X
 0430 39FC              cmp A,-4
 0432 B02C              jnz L72
 0434                   .dbline 520
 0434           ;               {
 0434 801B              xjmp L75
 0436           L74:
 0436                   .dbline 522
 0436           ;                       while(!TIMEOUT)
 0436           ;                       {
 0436                   .dbline 523
 0436           ;                               if(HELLO_3_cReadChar() == END_TRANSMIT)
 0436 10                push X
 0437 7C0000            xcall _HELLO_3_cReadChar
 043A 20                pop X
 043B 39FD              cmp A,-3
 043D B012              jnz L77
 043F                   .dbline 524
 043F           ;                               {
 043F                   .dbline 525
 043F           ;                                       CHILD = PORT_3;
 043F 62D000            mov REG[0xd0],>_CHILD
 0442 550033            mov [_CHILD],51
 0445                   .dbline 527
 0445           ;                               
 0445           ;                                       return 1;
 0445 62D000            mov REG[0xd0],>__r0
 0448 550001            mov [__r1],1
 044B 550000            mov [__r0],0
 044E 841B              xjmp L37
 0450           L77:
 0450                   .dbline 529
 0450           ;                               }
 0450           ;                       }
 0450           L75:
 0450                   .dbline 521
 0450 62D000            mov REG[0xd0],>_TIMEOUT
 0453 3C0000            cmp [_TIMEOUT],0
 0456 B006              jnz X19
 0458 3C0100            cmp [_TIMEOUT+1],0
 045B AFDA              jz L74
 045D           X19:
 045D                   .dbline 530
 045D           ;               }
 045D 8403              xjmp L57
 045F           L72:
 045F                   .dbline 531
 045F           ;               else if(HELLO_4_cReadChar() == START_TRANSMIT)
 045F 10                push X
 0460 7C0000            xcall _HELLO_4_cReadChar
 0463 62D000            mov REG[0xd0],>__r0
 0466 20                pop X
 0467 39FC              cmp A,-4
 0469 B3F7              jnz L57
 046B                   .dbline 532
 046B           ;               {
 046B 801B              xjmp L82
 046D           L81:
 046D                   .dbline 534
 046D           ;                       while(!TIMEOUT)
 046D           ;                       {
 046D                   .dbline 535
 046D           ;                               if(HELLO_4_cReadChar() == END_TRANSMIT)
 046D 10                push X
 046E 7C0000            xcall _HELLO_4_cReadChar
 0471 20                pop X
 0472 39FD              cmp A,-3
 0474 B012              jnz L84
 0476                   .dbline 536
 0476           ;                               {
 0476                   .dbline 537
 0476           ;                                       CHILD = PORT_4;
 0476 62D000            mov REG[0xd0],>_CHILD
 0479 550034            mov [_CHILD],52
 047C                   .dbline 539
 047C           ;                               
 047C           ;                                       return 1;
 047C 62D000            mov REG[0xd0],>__r0
 047F 550001            mov [__r1],1
 0482 550000            mov [__r0],0
 0485 83E4              xjmp L37
 0487           L84:
 0487                   .dbline 541
 0487           ;                               }
 0487           ;                       }
 0487           L82:
 0487                   .dbline 533
 0487 62D000            mov REG[0xd0],>_TIMEOUT
 048A 3C0000            cmp [_TIMEOUT],0
 048D B006              jnz X20
 048F 3C0100            cmp [_TIMEOUT+1],0
 0492 AFDA              jz L81
 0494           X20:
 0494                   .dbline 542
 0494           ;               }
 0494                   .dbline 543
 0494           ;       }
 0494 83CC              xjmp L57
 0496           L56:
 0496                   .dbline 544
 0496           ;       else if(STATE == RESPONSE_1)
 0496 62D000            mov REG[0xd0],>_STATE
 0499 3C0000            cmp [_STATE],0
 049C B0D2              jnz L86
 049E 3C0103            cmp [_STATE+1],3
 04A1 B0CD              jnz L86
 04A3           X21:
 04A3                   .dbline 545
 04A3           ;       {
 04A3                   .dbline 546
 04A3           ;               if(tempByte = CHILD_1_cReadChar())      // If we have a nonzero byte...
 04A3 10                push X
 04A4 7C0000            xcall _CHILD_1_cReadChar
 04A7 62D000            mov REG[0xd0],>__r0
 04AA 20                pop X
 04AB 5400              mov [X+0],A
 04AD 3900              cmp A,0
 04AF A3B1              jz L87
 04B1                   .dbline 547
 04B1           ;               {
 04B1                   .dbline 548
 04B1           ;                       if(tempByte == SERVO_START)             // We have a servo response coming.
 04B1 3D00FF            cmp [X+0],-1
 04B4 B090              jnz L90
 04B6                   .dbline 549
 04B6           ;                       {
 04B6 807F              xjmp L93
 04B8           L92:
 04B8                   .dbline 552
 04B8           ;                               // While we have not timed out, try to let all of the bytes through.
 04B8           ;                               while(!TIMEOUT)
 04B8           ;                               {
 04B8                   .dbline 554
 04B8           ;                                       // Eat the remaining servo start bytes.
 04B8           ;                                       if(tempByte = CHILD_1_cReadChar())
 04B8 10                push X
 04B9 7C0000            xcall _CHILD_1_cReadChar
 04BC 62D000            mov REG[0xd0],>__r0
 04BF 20                pop X
 04C0 5400              mov [X+0],A
 04C2 3900              cmp A,0
 04C4 A071              jz L95
 04C6                   .dbline 555
 04C6           ;                                       {
 04C6                   .dbline 558
 04C6           ;                                               // Once we get past the start bytes, we can start adding the
 04C6           ;                                               // bytes to our running total and searching for a checksum.
 04C6           ;                                               if(tempByte != SERVO_START)
 04C6 3D00FF            cmp [X+0],-1
 04C9 A06C              jz L97
 04CB                   .dbline 559
 04CB           ;                                               {
 04CB                   .dbline 561
 04CB           ;                                                       // Add to the running total.
 04CB           ;                                                       runningTotal += tempByte;
 04CB 5200              mov A,[X+0]
 04CD 0504              add [X+4],A
 04CF 0F0300            adc [X+3],0
 04D2 8056              xjmp L100
 04D4           L99:
 04D4                   .dbline 565
 04D4           ;                                                       
 04D4           ;                                                       // Either find a checksum or time out. Either way we're not stuck.
 04D4           ;                                                       while(!TIMEOUT)
 04D4           ;                                                       {
 04D4                   .dbline 567
 04D4           ;                                                               // If a nonzero byte has arrived...
 04D4           ;                                                               if(tempByte = CHILD_1_cReadChar())
 04D4 10                push X
 04D5 7C0000            xcall _CHILD_1_cReadChar
 04D8 62D000            mov REG[0xd0],>__r0
 04DB 20                pop X
 04DC 5400              mov [X+0],A
 04DE 3900              cmp A,0
 04E0 A048              jz L102
 04E2                   .dbline 568
 04E2           ;                                                               {
 04E2                   .dbline 570
 04E2           ;                                                                       // Check to see if it is a checksum.
 04E2           ;                                                                       if((runningTotal%256) == (255-tempByte))
 04E2 5200              mov A,[X+0]
 04E4 5300              mov [__r1],A
 04E6 550000            mov [__r0],0
 04E9 50FF              mov A,-1
 04EB 1200              sub A,[__r1]
 04ED 5300              mov [__r1],A
 04EF 5000              mov A,0
 04F1 1A00              sbb A,[__r0]
 04F3 5300              mov [__r0],A
 04F5 5001              mov A,1
 04F7 08                push A
 04F8 5000              mov A,0
 04FA 08                push A
 04FB 5203              mov A,[X+3]
 04FD 08                push A
 04FE 5204              mov A,[X+4]
 0500 08                push A
 0501 7C0000            xcall __divmod_16X16_16
 0504 38FE              add SP,-2
 0506 18                pop A
 0507 5300              mov [__r3],A
 0509 18                pop A
 050A 3A00              cmp A,[__r0]
 050C B012              jnz L104
 050E 5100              mov A,[__r3]
 0510 3A00              cmp A,[__r1]
 0512 B00C              jnz L104
 0514           X22:
 0514                   .dbline 571
 0514           ;                                                                       {
 0514                   .dbline 572
 0514           ;                                                                               return 1;
 0514 62D000            mov REG[0xd0],>__r0
 0517 550001            mov [__r1],1
 051A 550000            mov [__r0],0
 051D 834C              xjmp L37
 051F           L104:
 051F                   .dbline 575
 051F           ;                                                                       }
 051F           ;                                                                       else
 051F           ;                                                                       {
 051F                   .dbline 576
 051F           ;                                                                               runningTotal += tempByte;
 051F 62D000            mov REG[0xd0],>__r0
 0522 5200              mov A,[X+0]
 0524 0504              add [X+4],A
 0526 0F0300            adc [X+3],0
 0529                   .dbline 577
 0529           ;                                                                       }
 0529                   .dbline 578
 0529           ;                                                               }
 0529           L102:
 0529                   .dbline 579
 0529           ;                                                       }
 0529           L100:
 0529                   .dbline 564
 0529 62D000            mov REG[0xd0],>_TIMEOUT
 052C 3C0000            cmp [_TIMEOUT],0
 052F B006              jnz X23
 0531 3C0100            cmp [_TIMEOUT+1],0
 0534 AF9F              jz L99
 0536           X23:
 0536                   .dbline 580
 0536           ;                                               }
 0536           L97:
 0536                   .dbline 581
 0536           ;                                       }
 0536           L95:
 0536                   .dbline 582
 0536           ;                               }
 0536           L93:
 0536                   .dbline 551
 0536 62D000            mov REG[0xd0],>_TIMEOUT
 0539 3C0000            cmp [_TIMEOUT],0
 053C B006              jnz X24
 053E 3C0100            cmp [_TIMEOUT+1],0
 0541 AF76              jz L92
 0543           X24:
 0543                   .dbline 583
 0543           ;                       }
 0543 831D              xjmp L87
 0545           L90:
 0545                   .dbline 584
 0545           ;                       else if(tempByte == START_TRANSMIT)     // We have a controller response coming.
 0545 3D00FC            cmp [X+0],-4
 0548 B318              jnz L87
 054A                   .dbline 585
 054A           ;                       {
 054A 8015              xjmp L109
 054C           L108:
 054C                   .dbline 588
 054C           ;                               // We simply wait for the end transmit indicator.
 054C           ;                               while(!TIMEOUT)
 054C           ;                               {
 054C                   .dbline 589
 054C           ;                                       if(CHILD_1_cReadChar() == END_TRANSMIT)
 054C 10                push X
 054D 7C0000            xcall _CHILD_1_cReadChar
 0550 62D000            mov REG[0xd0],>__r0
 0553 20                pop X
 0554 39FD              cmp A,-3
 0556 B009              jnz L111
 0558                   .dbline 590
 0558           ;                                       {
 0558                   .dbline 591
 0558           ;                                               return 1;
 0558 550001            mov [__r1],1
 055B 550000            mov [__r0],0
 055E 830B              xjmp L37
 0560           L111:
 0560                   .dbline 593
 0560           ;                                       }
 0560           ;                               }
 0560           L109:
 0560                   .dbline 587
 0560 62D000            mov REG[0xd0],>_TIMEOUT
 0563 3C0000            cmp [_TIMEOUT],0
 0566 B006              jnz X25
 0568 3C0100            cmp [_TIMEOUT+1],0
 056B AFE0              jz L108
 056D           X25:
 056D                   .dbline 594
 056D           ;                       }
 056D                   .dbline 595
 056D           ;               }
 056D                   .dbline 596
 056D           ;       }
 056D 82F3              xjmp L87
 056F           L86:
 056F                   .dbline 597
 056F           ;       else if(STATE == RESPONSE_2)
 056F 62D000            mov REG[0xd0],>_STATE
 0572 3C0000            cmp [_STATE],0
 0575 B0D2              jnz L113
 0577 3C0104            cmp [_STATE+1],4
 057A B0CD              jnz L113
 057C           X26:
 057C                   .dbline 598
 057C           ;       {
 057C                   .dbline 599
 057C           ;               if(tempByte = CHILD_2_cReadChar())
 057C 10                push X
 057D 7C0000            xcall _CHILD_2_cReadChar
 0580 62D000            mov REG[0xd0],>__r0
 0583 20                pop X
 0584 5400              mov [X+0],A
 0586 3900              cmp A,0
 0588 A2D8              jz L114
 058A                   .dbline 600
 058A           ;               {
 058A                   .dbline 601
 058A           ;                       if(tempByte == SERVO_START)             // We have a servo response coming.
 058A 3D00FF            cmp [X+0],-1
 058D B090              jnz L117
 058F                   .dbline 602
 058F           ;                       {
 058F 807F              xjmp L120
 0591           L119:
 0591                   .dbline 605
 0591           ;                               // While we have not timed out, try to let all of the bytes through.
 0591           ;                               while(!TIMEOUT)
 0591           ;                               {
 0591                   .dbline 607
 0591           ;                                       // Eat the remaining servo start bytes.
 0591           ;                                       if(tempByte = CHILD_2_cReadChar())
 0591 10                push X
 0592 7C0000            xcall _CHILD_2_cReadChar
 0595 62D000            mov REG[0xd0],>__r0
 0598 20                pop X
 0599 5400              mov [X+0],A
 059B 3900              cmp A,0
 059D A071              jz L122
 059F                   .dbline 608
 059F           ;                                       {
 059F                   .dbline 611
 059F           ;                                               // Once we get past the start bytes, we can start adding the
 059F           ;                                               // bytes to our running total and searching for a checksum.
 059F           ;                                               if(tempByte != SERVO_START)
 059F 3D00FF            cmp [X+0],-1
 05A2 A06C              jz L124
 05A4                   .dbline 612
 05A4           ;                                               {
 05A4                   .dbline 614
 05A4           ;                                                       // Add to the running total.
 05A4           ;                                                       runningTotal += tempByte;
 05A4 5200              mov A,[X+0]
 05A6 0504              add [X+4],A
 05A8 0F0300            adc [X+3],0
 05AB 8056              xjmp L127
 05AD           L126:
 05AD                   .dbline 618
 05AD           ;                                                       
 05AD           ;                                                       // Either find a checksum or time out. Either way we're not stuck.
 05AD           ;                                                       while(!TIMEOUT)
 05AD           ;                                                       {
 05AD                   .dbline 620
 05AD           ;                                                               // If a nonzero byte has arrived...
 05AD           ;                                                               if(tempByte = CHILD_2_cReadChar())
 05AD 10                push X
 05AE 7C0000            xcall _CHILD_2_cReadChar
 05B1 62D000            mov REG[0xd0],>__r0
 05B4 20                pop X
 05B5 5400              mov [X+0],A
 05B7 3900              cmp A,0
 05B9 A048              jz L129
 05BB                   .dbline 621
 05BB           ;                                                               {
 05BB                   .dbline 623
 05BB           ;                                                                       // Check to see if it is a checksum.
 05BB           ;                                                                       if((runningTotal%256) == (255-tempByte))
 05BB 5200              mov A,[X+0]
 05BD 5300              mov [__r1],A
 05BF 550000            mov [__r0],0
 05C2 50FF              mov A,-1
 05C4 1200              sub A,[__r1]
 05C6 5300              mov [__r1],A
 05C8 5000              mov A,0
 05CA 1A00              sbb A,[__r0]
 05CC 5300              mov [__r0],A
 05CE 5001              mov A,1
 05D0 08                push A
 05D1 5000              mov A,0
 05D3 08                push A
 05D4 5203              mov A,[X+3]
 05D6 08                push A
 05D7 5204              mov A,[X+4]
 05D9 08                push A
 05DA 7C0000            xcall __divmod_16X16_16
 05DD 38FE              add SP,-2
 05DF 18                pop A
 05E0 5300              mov [__r3],A
 05E2 18                pop A
 05E3 3A00              cmp A,[__r0]
 05E5 B012              jnz L131
 05E7 5100              mov A,[__r3]
 05E9 3A00              cmp A,[__r1]
 05EB B00C              jnz L131
 05ED           X27:
 05ED                   .dbline 624
 05ED           ;                                                                       {
 05ED                   .dbline 625
 05ED           ;                                                                               return 1;
 05ED 62D000            mov REG[0xd0],>__r0
 05F0 550001            mov [__r1],1
 05F3 550000            mov [__r0],0
 05F6 8273              xjmp L37
 05F8           L131:
 05F8                   .dbline 628
 05F8           ;                                                                       }
 05F8           ;                                                                       else
 05F8           ;                                                                       {
 05F8                   .dbline 629
 05F8           ;                                                                               runningTotal += tempByte;
 05F8 62D000            mov REG[0xd0],>__r0
 05FB 5200              mov A,[X+0]
 05FD 0504              add [X+4],A
 05FF 0F0300            adc [X+3],0
 0602                   .dbline 630
 0602           ;                                                                       }
 0602                   .dbline 631
 0602           ;                                                               }
 0602           L129:
 0602                   .dbline 632
 0602           ;                                                       }
 0602           L127:
 0602                   .dbline 617
 0602 62D000            mov REG[0xd0],>_TIMEOUT
 0605 3C0000            cmp [_TIMEOUT],0
 0608 B006              jnz X28
 060A 3C0100            cmp [_TIMEOUT+1],0
 060D AF9F              jz L126
 060F           X28:
 060F                   .dbline 633
 060F           ;                                               }
 060F           L124:
 060F                   .dbline 634
 060F           ;                                       }
 060F           L122:
 060F                   .dbline 635
 060F           ;                               }
 060F           L120:
 060F                   .dbline 604
 060F 62D000            mov REG[0xd0],>_TIMEOUT
 0612 3C0000            cmp [_TIMEOUT],0
 0615 B006              jnz X29
 0617 3C0100            cmp [_TIMEOUT+1],0
 061A AF76              jz L119
 061C           X29:
 061C                   .dbline 636
 061C           ;                       }
 061C 8244              xjmp L114
 061E           L117:
 061E                   .dbline 637
 061E           ;                       else if(tempByte == START_TRANSMIT)     // We have a controller response coming.
 061E 3D00FC            cmp [X+0],-4
 0621 B23F              jnz L114
 0623                   .dbline 638
 0623           ;                       {
 0623 8015              xjmp L136
 0625           L135:
 0625                   .dbline 641
 0625           ;                               // We simply wait for the end transmit indicator.
 0625           ;                               while(!TIMEOUT)
 0625           ;                               {
 0625                   .dbline 642
 0625           ;                                       if(CHILD_2_cReadChar() == END_TRANSMIT)
 0625 10                push X
 0626 7C0000            xcall _CHILD_2_cReadChar
 0629 62D000            mov REG[0xd0],>__r0
 062C 20                pop X
 062D 39FD              cmp A,-3
 062F B009              jnz L138
 0631                   .dbline 643
 0631           ;                                       {
 0631                   .dbline 644
 0631           ;                                               return 1;
 0631 550001            mov [__r1],1
 0634 550000            mov [__r0],0
 0637 8232              xjmp L37
 0639           L138:
 0639                   .dbline 646
 0639           ;                                       }
 0639           ;                               }
 0639           L136:
 0639                   .dbline 640
 0639 62D000            mov REG[0xd0],>_TIMEOUT
 063C 3C0000            cmp [_TIMEOUT],0
 063F B006              jnz X30
 0641 3C0100            cmp [_TIMEOUT+1],0
 0644 AFE0              jz L135
 0646           X30:
 0646                   .dbline 647
 0646           ;                       }
 0646                   .dbline 648
 0646           ;               }
 0646                   .dbline 649
 0646           ;       }
 0646 821A              xjmp L114
 0648           L113:
 0648                   .dbline 650
 0648           ;       else if(STATE == RESPONSE_3)
 0648 62D000            mov REG[0xd0],>_STATE
 064B 3C0000            cmp [_STATE],0
 064E B0D2              jnz L140
 0650 3C0105            cmp [_STATE+1],5
 0653 B0CD              jnz L140
 0655           X31:
 0655                   .dbline 651
 0655           ;       {
 0655                   .dbline 652
 0655           ;               if(tempByte = CHILD_3_cReadChar())
 0655 10                push X
 0656 7C0000            xcall _CHILD_3_cReadChar
 0659 62D000            mov REG[0xd0],>__r0
 065C 20                pop X
 065D 5400              mov [X+0],A
 065F 3900              cmp A,0
 0661 A1FF              jz L141
 0663                   .dbline 653
 0663           ;               {
 0663                   .dbline 654
 0663           ;                       if(tempByte == SERVO_START)             // We have a servo response coming.
 0663 3D00FF            cmp [X+0],-1
 0666 B090              jnz L144
 0668                   .dbline 655
 0668           ;                       {
 0668 807F              xjmp L147
 066A           L146:
 066A                   .dbline 658
 066A           ;                               // While we have not timed out, try to let all of the bytes through.
 066A           ;                               while(!TIMEOUT)
 066A           ;                               {
 066A                   .dbline 660
 066A           ;                                       // Eat the remaining servo start bytes.
 066A           ;                                       if(tempByte = CHILD_3_cReadChar())
 066A 10                push X
 066B 7C0000            xcall _CHILD_3_cReadChar
 066E 62D000            mov REG[0xd0],>__r0
 0671 20                pop X
 0672 5400              mov [X+0],A
 0674 3900              cmp A,0
 0676 A071              jz L149
 0678                   .dbline 661
 0678           ;                                       {
 0678                   .dbline 664
 0678           ;                                               // Once we get past the start bytes, we can start adding the
 0678           ;                                               // bytes to our running total and searching for a checksum.
 0678           ;                                               if(tempByte != SERVO_START)
 0678 3D00FF            cmp [X+0],-1
 067B A06C              jz L151
 067D                   .dbline 665
 067D           ;                                               {
 067D                   .dbline 667
 067D           ;                                                       // Add to the running total.
 067D           ;                                                       runningTotal += tempByte;
 067D 5200              mov A,[X+0]
 067F 0504              add [X+4],A
 0681 0F0300            adc [X+3],0
 0684 8056              xjmp L154
 0686           L153:
 0686                   .dbline 671
 0686           ;                                                       
 0686           ;                                                       // Either find a checksum or time out. Either way we're not stuck.
 0686           ;                                                       while(!TIMEOUT)
 0686           ;                                                       {
 0686                   .dbline 673
 0686           ;                                                               // If a nonzero byte has arrived...
 0686           ;                                                               if(tempByte = CHILD_3_cReadChar())
 0686 10                push X
 0687 7C0000            xcall _CHILD_3_cReadChar
 068A 62D000            mov REG[0xd0],>__r0
 068D 20                pop X
 068E 5400              mov [X+0],A
 0690 3900              cmp A,0
 0692 A048              jz L156
 0694                   .dbline 674
 0694           ;                                                               {
 0694                   .dbline 676
 0694           ;                                                                       // Check to see if it is a checksum.
 0694           ;                                                                       if((runningTotal%256) == (255-tempByte))
 0694 5200              mov A,[X+0]
 0696 5300              mov [__r1],A
 0698 550000            mov [__r0],0
 069B 50FF              mov A,-1
 069D 1200              sub A,[__r1]
 069F 5300              mov [__r1],A
 06A1 5000              mov A,0
 06A3 1A00              sbb A,[__r0]
 06A5 5300              mov [__r0],A
 06A7 5001              mov A,1
 06A9 08                push A
 06AA 5000              mov A,0
 06AC 08                push A
 06AD 5203              mov A,[X+3]
 06AF 08                push A
 06B0 5204              mov A,[X+4]
 06B2 08                push A
 06B3 7C0000            xcall __divmod_16X16_16
 06B6 38FE              add SP,-2
 06B8 18                pop A
 06B9 5300              mov [__r3],A
 06BB 18                pop A
 06BC 3A00              cmp A,[__r0]
 06BE B012              jnz L158
 06C0 5100              mov A,[__r3]
 06C2 3A00              cmp A,[__r1]
 06C4 B00C              jnz L158
 06C6           X32:
 06C6                   .dbline 677
 06C6           ;                                                                       {
 06C6                   .dbline 678
 06C6           ;                                                                               return 1;
 06C6 62D000            mov REG[0xd0],>__r0
 06C9 550001            mov [__r1],1
 06CC 550000            mov [__r0],0
 06CF 819A              xjmp L37
 06D1           L158:
 06D1                   .dbline 681
 06D1           ;                                                                       }
 06D1           ;                                                                       else
 06D1           ;                                                                       {
 06D1                   .dbline 682
 06D1           ;                                                                               runningTotal += tempByte;
 06D1 62D000            mov REG[0xd0],>__r0
 06D4 5200              mov A,[X+0]
 06D6 0504              add [X+4],A
 06D8 0F0300            adc [X+3],0
 06DB                   .dbline 683
 06DB           ;                                                                       }
 06DB                   .dbline 684
 06DB           ;                                                               }
 06DB           L156:
 06DB                   .dbline 685
 06DB           ;                                                       }
 06DB           L154:
 06DB                   .dbline 670
 06DB 62D000            mov REG[0xd0],>_TIMEOUT
 06DE 3C0000            cmp [_TIMEOUT],0
 06E1 B006              jnz X33
 06E3 3C0100            cmp [_TIMEOUT+1],0
 06E6 AF9F              jz L153
 06E8           X33:
 06E8                   .dbline 686
 06E8           ;                                               }
 06E8           L151:
 06E8                   .dbline 687
 06E8           ;                                       }
 06E8           L149:
 06E8                   .dbline 688
 06E8           ;                               }
 06E8           L147:
 06E8                   .dbline 657
 06E8 62D000            mov REG[0xd0],>_TIMEOUT
 06EB 3C0000            cmp [_TIMEOUT],0
 06EE B006              jnz X34
 06F0 3C0100            cmp [_TIMEOUT+1],0
 06F3 AF76              jz L146
 06F5           X34:
 06F5                   .dbline 689
 06F5           ;                       }
 06F5 816B              xjmp L141
 06F7           L144:
 06F7                   .dbline 690
 06F7           ;                       else if(tempByte == START_TRANSMIT)     // We have a controller response coming.
 06F7 3D00FC            cmp [X+0],-4
 06FA B166              jnz L141
 06FC                   .dbline 691
 06FC           ;                       {
 06FC 8015              xjmp L163
 06FE           L162:
 06FE                   .dbline 694
 06FE           ;                               // We simply wait for the end transmit indicator.
 06FE           ;                               while(!TIMEOUT)
 06FE           ;                               {
 06FE                   .dbline 695
 06FE           ;                                       if(CHILD_3_cReadChar() == END_TRANSMIT)
 06FE 10                push X
 06FF 7C0000            xcall _CHILD_3_cReadChar
 0702 62D000            mov REG[0xd0],>__r0
 0705 20                pop X
 0706 39FD              cmp A,-3
 0708 B009              jnz L165
 070A                   .dbline 696
 070A           ;                                       {
 070A                   .dbline 697
 070A           ;                                               return 1;
 070A 550001            mov [__r1],1
 070D 550000            mov [__r0],0
 0710 8159              xjmp L37
 0712           L165:
 0712                   .dbline 699
 0712           ;                                       }
 0712           ;                               }
 0712           L163:
 0712                   .dbline 693
 0712 62D000            mov REG[0xd0],>_TIMEOUT
 0715 3C0000            cmp [_TIMEOUT],0
 0718 B006              jnz X35
 071A 3C0100            cmp [_TIMEOUT+1],0
 071D AFE0              jz L162
 071F           X35:
 071F                   .dbline 700
 071F           ;                       }
 071F                   .dbline 701
 071F           ;               }
 071F                   .dbline 702
 071F           ;       }
 071F 8141              xjmp L141
 0721           L140:
 0721                   .dbline 703
 0721           ;       else if(STATE == RESPONSE_4)
 0721 62D000            mov REG[0xd0],>_STATE
 0724 3C0000            cmp [_STATE],0
 0727 B0D2              jnz L167
 0729 3C0106            cmp [_STATE+1],6
 072C B0CD              jnz L167
 072E           X36:
 072E                   .dbline 704
 072E           ;       {
 072E                   .dbline 705
 072E           ;               if(tempByte = CHILD_4_cReadChar())
 072E 10                push X
 072F 7C0000            xcall _CHILD_4_cReadChar
 0732 62D000            mov REG[0xd0],>__r0
 0735 20                pop X
 0736 5400              mov [X+0],A
 0738 3900              cmp A,0
 073A A126              jz L168
 073C                   .dbline 706
 073C           ;               {
 073C                   .dbline 707
 073C           ;                       if(tempByte == SERVO_START)             // We have a servo response coming.
 073C 3D00FF            cmp [X+0],-1
 073F B090              jnz L171
 0741                   .dbline 708
 0741           ;                       {
 0741 807F              xjmp L174
 0743           L173:
 0743                   .dbline 711
 0743           ;                               // While we have not timed out, try to let all of the bytes through.
 0743           ;                               while(!TIMEOUT)
 0743           ;                               {
 0743                   .dbline 713
 0743           ;                                       // Eat the remaining servo start bytes.
 0743           ;                                       if(tempByte = CHILD_4_cReadChar())
 0743 10                push X
 0744 7C0000            xcall _CHILD_4_cReadChar
 0747 62D000            mov REG[0xd0],>__r0
 074A 20                pop X
 074B 5400              mov [X+0],A
 074D 3900              cmp A,0
 074F A071              jz L176
 0751                   .dbline 714
 0751           ;                                       {
 0751                   .dbline 717
 0751           ;                                               // Once we get past the start bytes, we can start adding the
 0751           ;                                               // bytes to our running total and searching for a checksum.
 0751           ;                                               if(tempByte != SERVO_START)
 0751 3D00FF            cmp [X+0],-1
 0754 A06C              jz L178
 0756                   .dbline 718
 0756           ;                                               {
 0756                   .dbline 720
 0756           ;                                                       // Add to the running total.
 0756           ;                                                       runningTotal += tempByte;
 0756 5200              mov A,[X+0]
 0758 0504              add [X+4],A
 075A 0F0300            adc [X+3],0
 075D 8056              xjmp L181
 075F           L180:
 075F                   .dbline 724
 075F           ;                                                       
 075F           ;                                                       // Either find a checksum or time out. Either way we're not stuck.
 075F           ;                                                       while(!TIMEOUT)
 075F           ;                                                       {
 075F                   .dbline 726
 075F           ;                                                               // If a nonzero byte has arrived...
 075F           ;                                                               if(tempByte = CHILD_4_cReadChar())
 075F 10                push X
 0760 7C0000            xcall _CHILD_4_cReadChar
 0763 62D000            mov REG[0xd0],>__r0
 0766 20                pop X
 0767 5400              mov [X+0],A
 0769 3900              cmp A,0
 076B A048              jz L183
 076D                   .dbline 727
 076D           ;                                                               {
 076D                   .dbline 729
 076D           ;                                                                       // Check to see if it is a checksum.
 076D           ;                                                                       if((runningTotal%256) == (255-tempByte))
 076D 5200              mov A,[X+0]
 076F 5300              mov [__r1],A
 0771 550000            mov [__r0],0
 0774 50FF              mov A,-1
 0776 1200              sub A,[__r1]
 0778 5300              mov [__r1],A
 077A 5000              mov A,0
 077C 1A00              sbb A,[__r0]
 077E 5300              mov [__r0],A
 0780 5001              mov A,1
 0782 08                push A
 0783 5000              mov A,0
 0785 08                push A
 0786 5203              mov A,[X+3]
 0788 08                push A
 0789 5204              mov A,[X+4]
 078B 08                push A
 078C 7C0000            xcall __divmod_16X16_16
 078F 38FE              add SP,-2
 0791 18                pop A
 0792 5300              mov [__r3],A
 0794 18                pop A
 0795 3A00              cmp A,[__r0]
 0797 B012              jnz L185
 0799 5100              mov A,[__r3]
 079B 3A00              cmp A,[__r1]
 079D B00C              jnz L185
 079F           X37:
 079F                   .dbline 730
 079F           ;                                                                       {
 079F                   .dbline 731
 079F           ;                                                                               return 1;
 079F 62D000            mov REG[0xd0],>__r0
 07A2 550001            mov [__r1],1
 07A5 550000            mov [__r0],0
 07A8 80C1              xjmp L37
 07AA           L185:
 07AA                   .dbline 734
 07AA           ;                                                                       }
 07AA           ;                                                                       else
 07AA           ;                                                                       {
 07AA                   .dbline 735
 07AA           ;                                                                               runningTotal += tempByte;
 07AA 62D000            mov REG[0xd0],>__r0
 07AD 5200              mov A,[X+0]
 07AF 0504              add [X+4],A
 07B1 0F0300            adc [X+3],0
 07B4                   .dbline 736
 07B4           ;                                                                       }
 07B4                   .dbline 737
 07B4           ;                                                               }
 07B4           L183:
 07B4                   .dbline 738
 07B4           ;                                                       }
 07B4           L181:
 07B4                   .dbline 723
 07B4 62D000            mov REG[0xd0],>_TIMEOUT
 07B7 3C0000            cmp [_TIMEOUT],0
 07BA B006              jnz X38
 07BC 3C0100            cmp [_TIMEOUT+1],0
 07BF AF9F              jz L180
 07C1           X38:
 07C1                   .dbline 739
 07C1           ;                                               }
 07C1           L178:
 07C1                   .dbline 740
 07C1           ;                                       }
 07C1           L176:
 07C1                   .dbline 741
 07C1           ;                               }
 07C1           L174:
 07C1                   .dbline 710
 07C1 62D000            mov REG[0xd0],>_TIMEOUT
 07C4 3C0000            cmp [_TIMEOUT],0
 07C7 B006              jnz X39
 07C9 3C0100            cmp [_TIMEOUT+1],0
 07CC AF76              jz L173
 07CE           X39:
 07CE                   .dbline 742
 07CE           ;                       }
 07CE 8092              xjmp L168
 07D0           L171:
 07D0                   .dbline 743
 07D0           ;                       else if(tempByte == START_TRANSMIT)     // We have a controller response coming.
 07D0 3D00FC            cmp [X+0],-4
 07D3 B08D              jnz L168
 07D5                   .dbline 744
 07D5           ;                       {
 07D5 8015              xjmp L190
 07D7           L189:
 07D7                   .dbline 747
 07D7           ;                               // We simply wait for the end transmit indicator.
 07D7           ;                               while(!TIMEOUT)
 07D7           ;                               {
 07D7                   .dbline 748
 07D7           ;                                       if(CHILD_4_cReadChar() == END_TRANSMIT)
 07D7 10                push X
 07D8 7C0000            xcall _CHILD_4_cReadChar
 07DB 62D000            mov REG[0xd0],>__r0
 07DE 20                pop X
 07DF 39FD              cmp A,-3
 07E1 B009              jnz L192
 07E3                   .dbline 749
 07E3           ;                                       {
 07E3                   .dbline 750
 07E3           ;                                               return 1;
 07E3 550001            mov [__r1],1
 07E6 550000            mov [__r0],0
 07E9 8080              xjmp L37
 07EB           L192:
 07EB                   .dbline 752
 07EB           ;                                       }
 07EB           ;                               }
 07EB           L190:
 07EB                   .dbline 746
 07EB 62D000            mov REG[0xd0],>_TIMEOUT
 07EE 3C0000            cmp [_TIMEOUT],0
 07F1 B006              jnz X40
 07F3 3C0100            cmp [_TIMEOUT+1],0
 07F6 AFE0              jz L189
 07F8           X40:
 07F8                   .dbline 753
 07F8           ;                       }
 07F8                   .dbline 754
 07F8           ;               }
 07F8                   .dbline 755
 07F8           ;       }
 07F8 8068              xjmp L168
 07FA           L167:
 07FA                   .dbline 756
 07FA           ;       else if(STATE == INITIALIZE)
 07FA 62D000            mov REG[0xd0],>_STATE
 07FD 3C0000            cmp [_STATE],0
 0800 B060              jnz L194
 0802 3C0108            cmp [_STATE+1],8
 0805 B05B              jnz L194
 0807           X41:
 0807                   .dbline 757
 0807           ;       {
 0807                   .dbline 758
 0807           ;               if(INIT_RX_cReadChar() == SERVO_START)
 0807 10                push X
 0808 7C0000            xcall _INIT_RX_cReadChar
 080B 62D000            mov REG[0xd0],>__r0
 080E 20                pop X
 080F 39FF              cmp A,-1
 0811 B04F              jnz L196
 0813                   .dbline 759
 0813           ;               {
 0813 8040              xjmp L199
 0815           L198:
 0815                   .dbline 761
 0815           ;                       while(!TIMEOUT)
 0815           ;                       {
 0815                   .dbline 763
 0815           ;                               // We officially have a transmission.
 0815           ;                               if(INIT_RX_cReadChar() == SERVO_START)
 0815 10                push X
 0816 7C0000            xcall _INIT_RX_cReadChar
 0819 62D000            mov REG[0xd0],>__r0
 081C 20                pop X
 081D 39FF              cmp A,-1
 081F B034              jnz L201
 0821                   .dbline 764
 0821           ;                               {
 0821                   .dbline 767
 0821           ;                                       // If we definitely have a transmission starting, grab all bytes from the rx buffer
 0821           ;                                       // and store them in the proper variables for actions to be taken later.
 0821           ;                                       COMMAND_SOURCE = INIT_RX_cGetChar();
 0821 10                push X
 0822 7C0000            xcall _INIT_RX_cGetChar
 0825 20                pop X
 0826 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0829 5300              mov [_COMMAND_SOURCE],A
 082B                   .dbline 768
 082B           ;                                       COMMAND_LENGTH = INIT_RX_cGetChar();
 082B 10                push X
 082C 7C0000            xcall _INIT_RX_cGetChar
 082F 20                pop X
 0830 62D000            mov REG[0xd0],>_COMMAND_LENGTH
 0833 5300              mov [_COMMAND_LENGTH],A
 0835                   .dbline 769
 0835           ;                                       COMMAND_ERROR = INIT_RX_cGetChar();
 0835 10                push X
 0836 7C0000            xcall _INIT_RX_cGetChar
 0839 20                pop X
 083A 62D000            mov REG[0xd0],>_COMMAND_ERROR
 083D 5300              mov [_COMMAND_ERROR],A
 083F                   .dbline 770
 083F           ;                                       COMMAND_PARAM = INIT_RX_cGetChar();
 083F 10                push X
 0840 7C0000            xcall _INIT_RX_cGetChar
 0843 20                pop X
 0844 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0847 5300              mov [_COMMAND_PARAM],A
 0849                   .dbline 772
 0849           ;                                       
 0849           ;                                       return 1;
 0849 62D000            mov REG[0xd0],>__r0
 084C 550001            mov [__r1],1
 084F 550000            mov [__r0],0
 0852 8017              xjmp L37
 0854           L201:
 0854                   .dbline 774
 0854           ;                               }
 0854           ;                       }
 0854           L199:
 0854                   .dbline 760
 0854 62D000            mov REG[0xd0],>_TIMEOUT
 0857 3C0000            cmp [_TIMEOUT],0
 085A B006              jnz X42
 085C 3C0100            cmp [_TIMEOUT+1],0
 085F AFB5              jz L198
 0861           X42:
 0861                   .dbline 775
 0861           ;               }
 0861           L196:
 0861                   .dbline 776
 0861           ;       }
 0861           L194:
 0861           L168:
 0861           L141:
 0861           L114:
 0861           L87:
 0861           L57:
 0861           L39:
 0861                   .dbline 778
 0861           ;       
 0861           ;       return 0;
 0861 62D000            mov REG[0xd0],>__r0
 0864 550000            mov [__r1],0
 0867 550000            mov [__r0],0
 086A                   .dbline -2
 086A           L37:
 086A 38FB              add SP,-5
 086C 20                pop X
 086D                   .dbline 0 ; func end
 086D 7F                ret
 086E                   .dbsym l runningTotal 3 I
 086E                   .dbsym l i 1 I
 086E                   .dbsym l tempByte 0 c
 086E                   .dbend
 086E                   .dbfunc e takeAction _takeAction fV
 086E           ;              j -> X+8
 086E           ;              i -> X+6
 086E           ;         tempID -> X+5
 086E           ;   runningTotal -> X+3
 086E           ;       tempByte -> X+2
 086E           ;              i -> X+0
 086E           _takeAction::
 086E                   .dbline -1
 086E 10                push X
 086F 4F                mov X,SP
 0870 380A              add SP,10
 0872                   .dbline 784
 0872           ; }
 0872           ; 
 0872           ; // This function interprets what has been read by the command ready function
 0872           ; // and performs the appropriate action.
 0872           ; void takeAction(void)
 0872           ; {
 0872                   .dbline 785
 0872           ;       int i = 0;                                                      // An index variable for looping.
 0872 560100            mov [X+1],0
 0875 560000            mov [X+0],0
 0878                   .dbline 786
 0878           ;       char tempByte = 0;                                      // A temporary byte storage variable.
 0878 560200            mov [X+2],0
 087B                   .dbline 787
 087B           ;       int runningTotal = 0;                           // A running total of bytes to check against a checksum.
 087B 560400            mov [X+4],0
 087E 560300            mov [X+3],0
 0881                   .dbline 789
 0881           ;       
 0881           ;       if(COMMAND_TYPE == CLEAR)                               // The master wants to clear the arm.
 0881 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0884 3C00CC            cmp [_COMMAND_TYPE],-52
 0887 B01A              jnz L204
 0889                   .dbline 790
 0889           ;       {
 0889                   .dbline 792
 0889           ;               // Reset the discovered parameters.
 0889           ;               ID = DEFAULT_ID;
 0889 62D000            mov REG[0xd0],>_ID
 088C 5500FB            mov [_ID],-5
 088F                   .dbline 793
 088F           ;               CONFIGURED = 0;
 088F 62D000            mov REG[0xd0],>_CONFIGURED
 0892 550100            mov [_CONFIGURED+1],0
 0895 550000            mov [_CONFIGURED],0
 0898                   .dbline 794
 0898           ;               CHILD = 0;
 0898 62D000            mov REG[0xd0],>_CHILD
 089B 550000            mov [_CHILD],0
 089E                   .dbline 797
 089E           ;               
 089E           ;               // Find the servo again.
 089E           ;               servoFinder();
 089E 94E0              xcall _servoFinder
 08A0                   .dbline 798
 08A0           ;       }
 08A0 8196              xjmp L205
 08A2           L204:
 08A2                   .dbline 799
 08A2           ;       else if(COMMAND_TYPE == HELLO_BYTE)             // The master is probing for new modules.
 08A2 62D000            mov REG[0xd0],>_COMMAND_TYPE
 08A5 3C00C8            cmp [_COMMAND_TYPE],-56
 08A8 B03B              jnz L206
 08AA                   .dbline 800
 08AA           ;       {
 08AA                   .dbline 801
 08AA           ;               if(!CONFIGURED)
 08AA 62D000            mov REG[0xd0],>_CONFIGURED
 08AD 3C0000            cmp [_CONFIGURED],0
 08B0 B00B              jnz L208
 08B2 3C0100            cmp [_CONFIGURED+1],0
 08B5 B006              jnz L208
 08B7           X43:
 08B7                   .dbline 802
 08B7           ;               {
 08B7                   .dbline 804
 08B7           ;                       // Announce this module's presence if not configured.
 08B7           ;                       sayHello();
 08B7 7C0050            xcall _sayHello
 08BA                   .dbline 805
 08BA           ;               }
 08BA 817C              xjmp L207
 08BC           L208:
 08BC                   .dbline 806
 08BC           ;               else if(!CHILD)
 08BC 62D000            mov REG[0xd0],>_CHILD
 08BF 3C0000            cmp [_CHILD],0
 08C2 B015              jnz L210
 08C4                   .dbline 807
 08C4           ;               {
 08C4                   .dbline 809
 08C4           ;                       // Listen for children if we have none.
 08C4           ;                       if(childListen())
 08C4 937A              xcall _childListen
 08C6 62D000            mov REG[0xd0],>__r0
 08C9 3C0000            cmp [__r0],0
 08CC B006              jnz X44
 08CE 3C0000            cmp [__r1],0
 08D1 A165              jz L207
 08D3           X44:
 08D3                   .dbline 810
 08D3           ;                       {
 08D3                   .dbline 812
 08D3           ;                               // If a child was heard saying hello, forward the command with the port number added.
 08D3           ;                               sayHello();
 08D3 7C0050            xcall _sayHello
 08D6                   .dbline 813
 08D6           ;                       }
 08D6                   .dbline 814
 08D6           ;               }
 08D6 8160              xjmp L207
 08D8           L210:
 08D8                   .dbline 815
 08D8           ;               else if(CHILD)
 08D8 62D000            mov REG[0xd0],>_CHILD
 08DB 3C0000            cmp [_CHILD],0
 08DE A158              jz L207
 08E0                   .dbline 816
 08E0           ;               {
 08E0                   .dbline 818
 08E0           ;                       // If you have a child established, listen to that child.
 08E0           ;                       childResponse();
 08E0 93B6              xcall _childResponse
 08E2                   .dbline 819
 08E2           ;               }
 08E2                   .dbline 820
 08E2           ;       }
 08E2 8154              xjmp L207
 08E4           L206:
 08E4                   .dbline 821
 08E4           ;       else if(COMMAND_TYPE == PING)           // The master is trying to find a module that is configured.
 08E4 62D000            mov REG[0xd0],>_COMMAND_TYPE
 08E7 3C00CB            cmp [_COMMAND_TYPE],-53
 08EA B021              jnz L216
 08EC                   .dbline 822
 08EC           ;       {
 08EC                   .dbline 824
 08EC           ;               // If this is to me, act accordingly.
 08EC           ;               if(COMMAND_DESTINATION == ID)
 08EC 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 08EF 5100              mov A,[_COMMAND_DESTINATION]
 08F1 62D000            mov REG[0xd0],>_ID
 08F4 3A00              cmp A,[_ID]
 08F6 B005              jnz L218
 08F8                   .dbline 825
 08F8           ;               {
 08F8                   .dbline 827
 08F8           ;                       // Ping back to the master.
 08F8           ;                       pingResponse();
 08F8 9141              xcall _pingResponse
 08FA                   .dbline 828
 08FA           ;               }
 08FA 813C              xjmp L217
 08FC           L218:
 08FC                   .dbline 829
 08FC           ;               else if(COMMAND_DESTINATION > ID)
 08FC 62D000            mov REG[0xd0],>_ID
 08FF 5100              mov A,[_ID]
 0901 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0904 3A00              cmp A,[_COMMAND_DESTINATION]
 0906 D130              jnc L217
 0908           X45:
 0908                   .dbline 830
 0908           ;               {
 0908                   .dbline 832
 0908           ;                       // If you have a child established, listen to that child.
 0908           ;                       childResponse();
 0908 938E              xcall _childResponse
 090A                   .dbline 833
 090A           ;               }
 090A                   .dbline 834
 090A           ;       }
 090A 812C              xjmp L217
 090C           L216:
 090C                   .dbline 835
 090C           ;       else if(COMMAND_TYPE == ID_ASSIGNMENT)  // The master is assigning an ID to someone.
 090C 62D000            mov REG[0xd0],>_COMMAND_TYPE
 090F 3C00C9            cmp [_COMMAND_TYPE],-55
 0912 B109              jnz L222
 0914                   .dbline 836
 0914           ;       {
 0914                   .dbline 838
 0914           ;               // If this is meant for me, change my ID.
 0914           ;               if(COMMAND_DESTINATION == ID)
 0914 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0917 5100              mov A,[_COMMAND_DESTINATION]
 0919 62D000            mov REG[0xd0],>_ID
 091C 3A00              cmp A,[_ID]
 091E B0ED              jnz L224
 0920                   .dbline 839
 0920           ;               {
 0920                   .dbline 840
 0920           ;                       if((COMMAND_PARAM > MASTER_ID) && (COMMAND_PARAM < DEFAULT_ID))
 0920 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0923 5000              mov A,0
 0925 3A00              cmp A,[_COMMAND_PARAM]
 0927 D10F              jnc L223
 0929           X46:
 0929 62D000            mov REG[0xd0],>_COMMAND_PARAM
 092C 3C00FB            cmp [_COMMAND_PARAM],-5
 092F D107              jnc L223
 0931           X47:
 0931                   .dbline 841
 0931           ;                       {
 0931                   .dbline 842
 0931           ;                               char tempID = COMMAND_PARAM;
 0931 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0934 5100              mov A,[_COMMAND_PARAM]
 0936 5405              mov [X+5],A
 0938                   .dbline 845
 0938           ;                               
 0938           ;                               // If the servo ID doesn't match what we want, change it to match.
 0938           ;                               if(tempID != SERVO_ID)
 0938 62D000            mov REG[0xd0],>_SERVO_ID
 093B 5205              mov A,[X+5]
 093D 3A00              cmp A,[_SERVO_ID]
 093F A09F              jz L228
 0941                   .dbline 846
 0941           ;                               {
 0941                   .dbline 853
 0941           ;                                       // These are our index variables for communication attempt timeouts.
 0941           ;                                       int i;
 0941           ;                                       int j;
 0941           ;                                       
 0941           ;                                       //while(ID != SERVO_ID)
 0941           ;                                       
 0941           ;                                       for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0941 560900            mov [X+9],0
 0944 560800            mov [X+8],0
 0947           L230:
 0947                   .dbline 854
 0947           ;                                       {       
 0947                   .dbline 856
 0947           ;                                               // Send a request to change the servo ID to match the controller ID.
 0947           ;                                               servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, ID_ADDRESS, tempID);
 0947 5205              mov A,[X+5]
 0949 08                push A
 094A 5003              mov A,3
 094C 08                push A
 094D 08                push A
 094E 5004              mov A,4
 0950 08                push A
 0951 62D000            mov REG[0xd0],>_SERVO_ID
 0954 5100              mov A,[_SERVO_ID]
 0956 08                push A
 0957 95E1              xcall _servoInstruction
 0959 38FB              add SP,-5
 095B                   .dbline 859
 095B           ;                                       
 095B           ;                                               // Try to read the servo's ID several times.
 095B           ;                                               for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 095B 560700            mov [X+7],0
 095E 560600            mov [X+6],0
 0961           L234:
 0961                   .dbline 860
 0961           ;                                               {
 0961                   .dbline 862
 0961           ;                                                       // Send a request for the servo ID, which is presumably now equal to ID.
 0961           ;                                                       servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
 0961 5000              mov A,0
 0963 08                push A
 0964 08                push A
 0965 5001              mov A,1
 0967 08                push A
 0968 5002              mov A,2
 096A 08                push A
 096B 50FE              mov A,-2
 096D 08                push A
 096E 95CA              xcall _servoInstruction
 0970 38FB              add SP,-5
 0972 803D              xjmp L239
 0974           L238:
 0974                   .dbline 866
 0974           ;                                                       
 0974           ;                                                       // Wait for either a timeout or an indication that we want to exit the loop.
 0974           ;                                                       while(!TIMEOUT)
 0974           ;                                                       {
 0974                   .dbline 868
 0974           ;                                                               // If we have a command to interpret, read it.
 0974           ;                                                               if(commandReady())
 0974 9949              xcall _commandReady
 0976 62D000            mov REG[0xd0],>__r0
 0979 3C0000            cmp [__r0],0
 097C B006              jnz X48
 097E 3C0000            cmp [__r1],0
 0981 A02E              jz L241
 0983           X48:
 0983                   .dbline 869
 0983           ;                                                               {
 0983                   .dbline 870
 0983           ;                                                                       if(!COMMAND_ERROR)
 0983 62D000            mov REG[0xd0],>_COMMAND_ERROR
 0986 3C0000            cmp [_COMMAND_ERROR],0
 0989 B026              jnz L243
 098B                   .dbline 871
 098B           ;                                                                       {
 098B                   .dbline 873
 098B           ;                                                                               // If we have a valid servo ID, exit the loop.
 098B           ;                                                                               if(COMMAND_SOURCE == tempID)
 098B 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 098E 5100              mov A,[_COMMAND_SOURCE]
 0990 3B05              cmp A,[X+5]
 0992 B01D              jnz L245
 0994                   .dbline 874
 0994           ;                                                                               {
 0994                   .dbline 876
 0994           ;                                                                                       // Set the timeout flag to exit the while loop.
 0994           ;                                                                                       TIMEOUT = 1;
 0994 62D000            mov REG[0xd0],>_TIMEOUT
 0997 550101            mov [_TIMEOUT+1],1
 099A 550000            mov [_TIMEOUT],0
 099D                   .dbline 878
 099D           ;                                                                                       // Set i such that the for loop is exited.
 099D           ;                                                                                       i = SERVO_COMM_ATTEMPTS;
 099D 56070A            mov [X+7],10
 09A0 560600            mov [X+6],0
 09A3                   .dbline 880
 09A3           ;                                                                                       // Set j such that we exit the outer loop as well.
 09A3           ;                                                                                       j = SERVO_COMM_LOOPS;
 09A3 560902            mov [X+9],2
 09A6 560800            mov [X+8],0
 09A9                   .dbline 882
 09A9           ;                                                                                       // Store the ID value.
 09A9           ;                                                                                       SERVO_ID = tempID;
 09A9 5205              mov A,[X+5]
 09AB 62D000            mov REG[0xd0],>_SERVO_ID
 09AE 5300              mov [_SERVO_ID],A
 09B0                   .dbline 883
 09B0           ;                                                                               }
 09B0           L245:
 09B0                   .dbline 884
 09B0           ;                                                                       }
 09B0           L243:
 09B0                   .dbline 885
 09B0           ;                                                               }
 09B0           L241:
 09B0                   .dbline 886
 09B0           ;                                                       }
 09B0           L239:
 09B0                   .dbline 865
 09B0 62D000            mov REG[0xd0],>_TIMEOUT
 09B3 3C0000            cmp [_TIMEOUT],0
 09B6 B006              jnz X49
 09B8 3C0100            cmp [_TIMEOUT+1],0
 09BB AFB8              jz L238
 09BD           X49:
 09BD                   .dbline 887
 09BD           ;                                               }
 09BD           L235:
 09BD                   .dbline 859
 09BD 7707              inc [X+7]
 09BF 0F0600            adc [X+6],0
 09C2                   .dbline 859
 09C2 5207              mov A,[X+7]
 09C4 110A              sub A,10
 09C6 5206              mov A,[X+6]
 09C8 3180              xor A,-128
 09CA 1980              sbb A,(0 ^ 0x80)
 09CC CF94              jc L234
 09CE           X50:
 09CE                   .dbline 888
 09CE           ;                                       }       
 09CE           L231:
 09CE                   .dbline 853
 09CE 7709              inc [X+9]
 09D0 0F0800            adc [X+8],0
 09D3                   .dbline 853
 09D3 5209              mov A,[X+9]
 09D5 1102              sub A,2
 09D7 5208              mov A,[X+8]
 09D9 3180              xor A,-128
 09DB 1980              sbb A,(0 ^ 0x80)
 09DD CF69              jc L230
 09DF           X51:
 09DF                   .dbline 889
 09DF           ;                               }
 09DF           L228:
 09DF                   .dbline 891
 09DF           ;                               
 09DF           ;                               if(tempID != SERVO_ID)
 09DF 62D000            mov REG[0xd0],>_SERVO_ID
 09E2 5205              mov A,[X+5]
 09E4 3A00              cmp A,[_SERVO_ID]
 09E6 A00E              jz L247
 09E8                   .dbline 892
 09E8           ;                               {
 09E8                   .dbline 894
 09E8           ;                                       // Toggle back to normal wait mode.
 09E8           ;                                       configToggle(WAIT);
 09E8 5000              mov A,0
 09EA 08                push A
 09EB 5001              mov A,1
 09ED 08                push A
 09EE 7C00B5            xcall _configToggle
 09F1 38FE              add SP,-2
 09F3                   .dbline 895
 09F3           ;                               }
 09F3 8043              xjmp L223
 09F5           L247:
 09F5                   .dbline 897
 09F5           ;                               else
 09F5           ;                               {
 09F5                   .dbline 899
 09F5           ;                                       // Assign this module the ID that has been passed by the master.
 09F5           ;                                       ID = SERVO_ID;
 09F5 62D000            mov REG[0xd0],>_SERVO_ID
 09F8 5100              mov A,[_SERVO_ID]
 09FA 62D000            mov REG[0xd0],>_ID
 09FD 5300              mov [_ID],A
 09FF                   .dbline 902
 09FF           ;                                       
 09FF           ;                                       // This module is now configured.
 09FF           ;                                       CONFIGURED = 1;
 09FF 62D000            mov REG[0xd0],>_CONFIGURED
 0A02 550101            mov [_CONFIGURED+1],1
 0A05 550000            mov [_CONFIGURED],0
 0A08                   .dbline 905
 0A08           ;                               
 0A08           ;                                       // Let the master node know that you got the ID assignment.
 0A08           ;                                       assignedID();
 0A08 9197              xcall _assignedID
 0A0A                   .dbline 906
 0A0A           ;                               }
 0A0A                   .dbline 907
 0A0A           ;                       }
 0A0A                   .dbline 908
 0A0A           ;               }
 0A0A 802C              xjmp L223
 0A0C           L224:
 0A0C                   .dbline 909
 0A0C           ;               else if(COMMAND_DESTINATION > ID)
 0A0C 62D000            mov REG[0xd0],>_ID
 0A0F 5100              mov A,[_ID]
 0A11 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0A14 3A00              cmp A,[_COMMAND_DESTINATION]
 0A16 D020              jnc L223
 0A18           X52:
 0A18                   .dbline 910
 0A18           ;               {
 0A18                   .dbline 912
 0A18           ;                       // Switch to listen to your child.
 0A18           ;                       childResponse();
 0A18 927E              xcall _childResponse
 0A1A                   .dbline 913
 0A1A           ;               }
 0A1A                   .dbline 914
 0A1A           ;       }
 0A1A 801C              xjmp L223
 0A1C           L222:
 0A1C                   .dbline 915
 0A1C           ;       else if((COMMAND_TYPE == PING_SERVO) || (COMMAND_TYPE == READ_SERVO))
 0A1C 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0A1F 3C0001            cmp [_COMMAND_TYPE],1
 0A22 A006              jz L253
 0A24 3C0002            cmp [_COMMAND_TYPE],2
 0A27 B00F              jnz L251
 0A29           L253:
 0A29                   .dbline 916
 0A29           ;       {
 0A29                   .dbline 917
 0A29           ;               if(COMMAND_DESTINATION > ID)
 0A29 62D000            mov REG[0xd0],>_ID
 0A2C 5100              mov A,[_ID]
 0A2E 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0A31 3A00              cmp A,[_COMMAND_DESTINATION]
 0A33 D003              jnc L254
 0A35           X53:
 0A35                   .dbline 918
 0A35           ;               {
 0A35                   .dbline 920
 0A35           ;                       // Allow the child response through.
 0A35           ;                       childResponse();
 0A35 9261              xcall _childResponse
 0A37                   .dbline 921
 0A37           ;               }
 0A37           L254:
 0A37                   .dbline 922
 0A37           ;       }
 0A37           L251:
 0A37           L223:
 0A37           L217:
 0A37           L207:
 0A37           L205:
 0A37                   .dbline -2
 0A37           L203:
 0A37 38F6              add SP,-10
 0A39 20                pop X
 0A3A                   .dbline 0 ; func end
 0A3A 7F                ret
 0A3B                   .dbsym l j 8 I
 0A3B                   .dbsym l i 6 I
 0A3B                   .dbsym l tempID 5 c
 0A3B                   .dbsym l runningTotal 3 I
 0A3B                   .dbsym l tempByte 2 c
 0A3B                   .dbsym l i 0 I
 0A3B                   .dbend
 0A3B                   .dbfunc e pingResponse _pingResponse fV
 0A3B           _pingResponse::
 0A3B                   .dbline -1
 0A3B                   .dbline 927
 0A3B           ; }
 0A3B           ; 
 0A3B           ; // This function sends out a ping response for everyone to hear.
 0A3B           ; void pingResponse(void)
 0A3B           ; {
 0A3B                   .dbline 928
 0A3B           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 0A3B 5000              mov A,0
 0A3D 08                push A
 0A3E 5002              mov A,2
 0A40 08                push A
 0A41 7C00B5            xcall _configToggle
 0A44 38FE              add SP,-2
 0A46                   .dbline 931
 0A46           ;       
 0A46           ;       // Transmit a ping to everyone.
 0A46           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 0A46 10                push X
 0A47 50FC              mov A,-4
 0A49 7C0000            xcall _TX_014_PutChar
 0A4C 20                pop X
 0A4D                   .dbline 932
 0A4D           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 0A4D 10                push X
 0A4E 50FC              mov A,-4
 0A50 7C0000            xcall _TX_23_PutChar
 0A53 20                pop X
 0A54                   .dbline 933
 0A54           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 0A54 10                push X
 0A55 50FC              mov A,-4
 0A57 7C0000            xcall _TX_014_PutChar
 0A5A 20                pop X
 0A5B                   .dbline 934
 0A5B           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 0A5B 10                push X
 0A5C 50FC              mov A,-4
 0A5E 7C0000            xcall _TX_23_PutChar
 0A61 20                pop X
 0A62                   .dbline 935
 0A62           ;       TX_014_PutChar(ID);                             // My ID
 0A62 10                push X
 0A63 62D000            mov REG[0xd0],>_ID
 0A66 5100              mov A,[_ID]
 0A68 7C0000            xcall _TX_014_PutChar
 0A6B 20                pop X
 0A6C                   .dbline 936
 0A6C           ;       TX_23_PutChar(ID);                              // My ID
 0A6C 10                push X
 0A6D 62D000            mov REG[0xd0],>_ID
 0A70 5100              mov A,[_ID]
 0A72 7C0000            xcall _TX_23_PutChar
 0A75 20                pop X
 0A76                   .dbline 937
 0A76           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 0A76 10                push X
 0A77 5000              mov A,0
 0A79 7C0000            xcall _TX_014_PutChar
 0A7C 20                pop X
 0A7D                   .dbline 938
 0A7D           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 0A7D 10                push X
 0A7E 5000              mov A,0
 0A80 7C0000            xcall _TX_23_PutChar
 0A83 20                pop X
 0A84                   .dbline 939
 0A84           ;       TX_014_PutChar(PING);                   // This is a ping response
 0A84 10                push X
 0A85 50CB              mov A,-53
 0A87 7C0000            xcall _TX_014_PutChar
 0A8A 20                pop X
 0A8B                   .dbline 940
 0A8B           ;       TX_23_PutChar(PING);                    // This is a ping response
 0A8B 10                push X
 0A8C 50CB              mov A,-53
 0A8E 7C0000            xcall _TX_23_PutChar
 0A91 20                pop X
 0A92                   .dbline 941
 0A92           ;       TX_014_PutChar(TYPE);                   // This is the module type
 0A92 10                push X
 0A93 5031              mov A,49
 0A95 7C0000            xcall _TX_014_PutChar
 0A98 20                pop X
 0A99                   .dbline 942
 0A99           ;       TX_23_PutChar(TYPE);                    // This is the module type
 0A99 10                push X
 0A9A 5031              mov A,49
 0A9C 7C0000            xcall _TX_23_PutChar
 0A9F 20                pop X
 0AA0                   .dbline 943
 0AA0           ;       TX_014_PutChar(CHILD);                  // This is the child-connected port
 0AA0 10                push X
 0AA1 62D000            mov REG[0xd0],>_CHILD
 0AA4 5100              mov A,[_CHILD]
 0AA6 7C0000            xcall _TX_014_PutChar
 0AA9 20                pop X
 0AAA                   .dbline 944
 0AAA           ;       TX_23_PutChar(CHILD);                   // This is the child-connected port
 0AAA 10                push X
 0AAB 62D000            mov REG[0xd0],>_CHILD
 0AAE 5100              mov A,[_CHILD]
 0AB0 7C0000            xcall _TX_23_PutChar
 0AB3 20                pop X
 0AB4                   .dbline 945
 0AB4           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0AB4 10                push X
 0AB5 50FD              mov A,-3
 0AB7 7C0000            xcall _TX_014_PutChar
 0ABA 20                pop X
 0ABB                   .dbline 946
 0ABB           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0ABB 10                push X
 0ABC 50FD              mov A,-3
 0ABE 7C0000            xcall _TX_23_PutChar
 0AC1 20                pop X
 0AC2                   .dbline 947
 0AC2           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0AC2 10                push X
 0AC3 50FD              mov A,-3
 0AC5 7C0000            xcall _TX_014_PutChar
 0AC8 20                pop X
 0AC9                   .dbline 948
 0AC9           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0AC9 10                push X
 0ACA 50FD              mov A,-3
 0ACC 7C0000            xcall _TX_23_PutChar
 0ACF 20                pop X
 0AD0           L257:
 0AD0                   .dbline 951
 0AD0           ;       
 0AD0           ;       // Wait for the transmission to finish.
 0AD0           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0AD0           L258:
 0AD0                   .dbline 951
 0AD0 10                push X
 0AD1 7C0000            xcall _TX_014_bReadTxStatus
 0AD4 62D000            mov REG[0xd0],>__r0
 0AD7 20                pop X
 0AD8 5300              mov [__r0],A
 0ADA 470020            tst [__r0],32
 0ADD AFF2              jz L257
 0ADF           L260:
 0ADF                   .dbline 952
 0ADF           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 0ADF           L261:
 0ADF                   .dbline 952
 0ADF 10                push X
 0AE0 7C0000            xcall _TX_23_bReadTxStatus
 0AE3 62D000            mov REG[0xd0],>__r0
 0AE6 20                pop X
 0AE7 5300              mov [__r0],A
 0AE9 470020            tst [__r0],32
 0AEC AFF2              jz L260
 0AEE                   .dbline 955
 0AEE           ;       
 0AEE           ;       // Make completely sure we're done.
 0AEE           ;       xmitWait();
 0AEE 9528              xcall _xmitWait
 0AF0                   .dbline 957
 0AF0           ;       
 0AF0           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0AF0 5000              mov A,0
 0AF2 08                push A
 0AF3 5001              mov A,1
 0AF5 08                push A
 0AF6 7C00B5            xcall _configToggle
 0AF9 38FE              add SP,-2
 0AFB                   .dbline -2
 0AFB           L256:
 0AFB                   .dbline 0 ; func end
 0AFB 7F                ret
 0AFC                   .dbend
 0AFC                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0AFC           _unloadAllConfigs::
 0AFC                   .dbline -1
 0AFC                   .dbline 963
 0AFC           ; }
 0AFC           ; 
 0AFC           ; // This function blindly unloads all user configurations. This will be called once,
 0AFC           ; // when the system initially has no known state.
 0AFC           ; void unloadAllConfigs(void)
 0AFC           ; {
 0AFC                   .dbline 964
 0AFC           ;       UnloadConfig_waiting();
 0AFC 7C0000            xcall _UnloadConfig_waiting
 0AFF                   .dbline 965
 0AFF           ;       UnloadConfig_hello();
 0AFF 7C0000            xcall _UnloadConfig_hello
 0B02                   .dbline 966
 0B02           ;       UnloadConfig_my_response();
 0B02 7C0000            xcall _UnloadConfig_my_response
 0B05                   .dbline 967
 0B05           ;       UnloadConfig_response1();
 0B05 7C0000            xcall _UnloadConfig_response1
 0B08                   .dbline 968
 0B08           ;       UnloadConfig_response2();
 0B08 7C0000            xcall _UnloadConfig_response2
 0B0B                   .dbline 969
 0B0B           ;       UnloadConfig_response3();
 0B0B 7C0000            xcall _UnloadConfig_response3
 0B0E                   .dbline 970
 0B0E           ;       UnloadConfig_response4();
 0B0E 7C0000            xcall _UnloadConfig_response4
 0B11                   .dbline 971
 0B11           ;       UnloadConfig_initial();
 0B11 7C0000            xcall _UnloadConfig_initial
 0B14                   .dbline 972
 0B14           ;       UnloadConfig_servo_transmit();
 0B14 7C0000            xcall _UnloadConfig_servo_transmit
 0B17                   .dbline -2
 0B17           L263:
 0B17                   .dbline 0 ; func end
 0B17 7F                ret
 0B18                   .dbend
 0B18                   .dbfunc e unloadConfig _unloadConfig fV
 0B18           ;     config_num -> X-5
 0B18           _unloadConfig::
 0B18                   .dbline -1
 0B18 10                push X
 0B19 4F                mov X,SP
 0B1A                   .dbline 978
 0B1A           ; }
 0B1A           ; 
 0B1A           ; // This function unloads the configuration corresponding to the config number passed to it.
 0B1A           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0B1A           ; void unloadConfig(int config_num)
 0B1A           ; {
 0B1A                   .dbline 979
 0B1A           ;       if(config_num == WAIT)
 0B1A 3DFB00            cmp [X-5],0
 0B1D B00B              jnz L265
 0B1F 3DFC01            cmp [X-4],1
 0B22 B006              jnz L265
 0B24           X54:
 0B24                   .dbline 980
 0B24           ;       {
 0B24                   .dbline 981
 0B24           ;               UnloadConfig_waiting();
 0B24 7C0000            xcall _UnloadConfig_waiting
 0B27                   .dbline 982
 0B27           ;       }
 0B27 8077              xjmp L266
 0B29           L265:
 0B29                   .dbline 983
 0B29           ;       else if(config_num == HELLO_MODE)
 0B29 3DFB00            cmp [X-5],0
 0B2C B00B              jnz L267
 0B2E 3DFC07            cmp [X-4],7
 0B31 B006              jnz L267
 0B33           X55:
 0B33                   .dbline 984
 0B33           ;       {
 0B33                   .dbline 985
 0B33           ;               UnloadConfig_hello();
 0B33 7C0000            xcall _UnloadConfig_hello
 0B36                   .dbline 986
 0B36           ;       }
 0B36 8068              xjmp L268
 0B38           L267:
 0B38                   .dbline 987
 0B38           ;       else if(config_num == MY_RESPONSE)
 0B38 3DFB00            cmp [X-5],0
 0B3B B00B              jnz L269
 0B3D 3DFC02            cmp [X-4],2
 0B40 B006              jnz L269
 0B42           X56:
 0B42                   .dbline 988
 0B42           ;       {
 0B42                   .dbline 989
 0B42           ;               UnloadConfig_my_response();
 0B42 7C0000            xcall _UnloadConfig_my_response
 0B45                   .dbline 990
 0B45           ;       }
 0B45 8059              xjmp L270
 0B47           L269:
 0B47                   .dbline 991
 0B47           ;       else if(config_num == RESPONSE_1)
 0B47 3DFB00            cmp [X-5],0
 0B4A B00B              jnz L271
 0B4C 3DFC03            cmp [X-4],3
 0B4F B006              jnz L271
 0B51           X57:
 0B51                   .dbline 992
 0B51           ;       {
 0B51                   .dbline 993
 0B51           ;               UnloadConfig_response1();
 0B51 7C0000            xcall _UnloadConfig_response1
 0B54                   .dbline 994
 0B54           ;       }
 0B54 804A              xjmp L272
 0B56           L271:
 0B56                   .dbline 995
 0B56           ;       else if(config_num == RESPONSE_2)
 0B56 3DFB00            cmp [X-5],0
 0B59 B00B              jnz L273
 0B5B 3DFC04            cmp [X-4],4
 0B5E B006              jnz L273
 0B60           X58:
 0B60                   .dbline 996
 0B60           ;       {
 0B60                   .dbline 997
 0B60           ;               UnloadConfig_response2();
 0B60 7C0000            xcall _UnloadConfig_response2
 0B63                   .dbline 998
 0B63           ;       }
 0B63 803B              xjmp L274
 0B65           L273:
 0B65                   .dbline 999
 0B65           ;       else if(config_num == RESPONSE_3)
 0B65 3DFB00            cmp [X-5],0
 0B68 B00B              jnz L275
 0B6A 3DFC05            cmp [X-4],5
 0B6D B006              jnz L275
 0B6F           X59:
 0B6F                   .dbline 1000
 0B6F           ;       {
 0B6F                   .dbline 1001
 0B6F           ;               UnloadConfig_response3();
 0B6F 7C0000            xcall _UnloadConfig_response3
 0B72                   .dbline 1002
 0B72           ;       }
 0B72 802C              xjmp L276
 0B74           L275:
 0B74                   .dbline 1003
 0B74           ;       else if(config_num == RESPONSE_4)
 0B74 3DFB00            cmp [X-5],0
 0B77 B00B              jnz L277
 0B79 3DFC06            cmp [X-4],6
 0B7C B006              jnz L277
 0B7E           X60:
 0B7E                   .dbline 1004
 0B7E           ;       {
 0B7E                   .dbline 1005
 0B7E           ;               UnloadConfig_response4();
 0B7E 7C0000            xcall _UnloadConfig_response4
 0B81                   .dbline 1006
 0B81           ;       }
 0B81 801D              xjmp L278
 0B83           L277:
 0B83                   .dbline 1007
 0B83           ;       else if(config_num == INITIALIZE)
 0B83 3DFB00            cmp [X-5],0
 0B86 B00B              jnz L279
 0B88 3DFC08            cmp [X-4],8
 0B8B B006              jnz L279
 0B8D           X61:
 0B8D                   .dbline 1008
 0B8D           ;       {
 0B8D                   .dbline 1009
 0B8D           ;               UnloadConfig_initial();
 0B8D 7C0000            xcall _UnloadConfig_initial
 0B90                   .dbline 1010
 0B90           ;       }
 0B90 800E              xjmp L280
 0B92           L279:
 0B92                   .dbline 1011
 0B92           ;       else if(config_num == SERVO_COMM)
 0B92 3DFB00            cmp [X-5],0
 0B95 B009              jnz L281
 0B97 3DFC09            cmp [X-4],9
 0B9A B004              jnz L281
 0B9C           X62:
 0B9C                   .dbline 1012
 0B9C           ;       {
 0B9C                   .dbline 1013
 0B9C           ;               UnloadConfig_servo_transmit();
 0B9C 7C0000            xcall _UnloadConfig_servo_transmit
 0B9F                   .dbline 1014
 0B9F           ;       }
 0B9F           L281:
 0B9F           L280:
 0B9F           L278:
 0B9F           L276:
 0B9F           L274:
 0B9F           L272:
 0B9F           L270:
 0B9F           L268:
 0B9F           L266:
 0B9F                   .dbline -2
 0B9F           L264:
 0B9F 20                pop X
 0BA0                   .dbline 0 ; func end
 0BA0 7F                ret
 0BA1                   .dbsym l config_num -5 I
 0BA1                   .dbend
 0BA1                   .dbfunc e assignedID _assignedID fV
 0BA1           _assignedID::
 0BA1                   .dbline -1
 0BA1                   .dbline 1019
 0BA1           ; }
 0BA1           ; 
 0BA1           ; // This function responds that an ID has been assigned to it.
 0BA1           ; void assignedID(void)
 0BA1           ; {
 0BA1                   .dbline 1020
 0BA1           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 0BA1 5000              mov A,0
 0BA3 08                push A
 0BA4 5002              mov A,2
 0BA6 08                push A
 0BA7 7C00B5            xcall _configToggle
 0BAA 38FE              add SP,-2
 0BAC                   .dbline 1023
 0BAC           ;       
 0BAC           ;       // Transmit a ping to everyone.
 0BAC           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 0BAC 10                push X
 0BAD 50FC              mov A,-4
 0BAF 7C0000            xcall _TX_014_PutChar
 0BB2 20                pop X
 0BB3                   .dbline 1024
 0BB3           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 0BB3 10                push X
 0BB4 50FC              mov A,-4
 0BB6 7C0000            xcall _TX_23_PutChar
 0BB9 20                pop X
 0BBA                   .dbline 1025
 0BBA           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 0BBA 10                push X
 0BBB 50FC              mov A,-4
 0BBD 7C0000            xcall _TX_014_PutChar
 0BC0 20                pop X
 0BC1                   .dbline 1026
 0BC1           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 0BC1 10                push X
 0BC2 50FC              mov A,-4
 0BC4 7C0000            xcall _TX_23_PutChar
 0BC7 20                pop X
 0BC8                   .dbline 1027
 0BC8           ;       TX_014_PutChar(ID);                             // My ID
 0BC8 10                push X
 0BC9 62D000            mov REG[0xd0],>_ID
 0BCC 5100              mov A,[_ID]
 0BCE 7C0000            xcall _TX_014_PutChar
 0BD1 20                pop X
 0BD2                   .dbline 1028
 0BD2           ;       TX_23_PutChar(ID);                              // My ID
 0BD2 10                push X
 0BD3 62D000            mov REG[0xd0],>_ID
 0BD6 5100              mov A,[_ID]
 0BD8 7C0000            xcall _TX_23_PutChar
 0BDB 20                pop X
 0BDC                   .dbline 1029
 0BDC           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 0BDC 10                push X
 0BDD 5000              mov A,0
 0BDF 7C0000            xcall _TX_014_PutChar
 0BE2 20                pop X
 0BE3                   .dbline 1030
 0BE3           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 0BE3 10                push X
 0BE4 5000              mov A,0
 0BE6 7C0000            xcall _TX_23_PutChar
 0BE9 20                pop X
 0BEA                   .dbline 1031
 0BEA           ;       TX_014_PutChar(ID_ASSIGN_OK);   // This is an assignment ack response
 0BEA 10                push X
 0BEB 50CA              mov A,-54
 0BED 7C0000            xcall _TX_014_PutChar
 0BF0 20                pop X
 0BF1                   .dbline 1032
 0BF1           ;       TX_23_PutChar(ID_ASSIGN_OK);    // This is an assignment ack response
 0BF1 10                push X
 0BF2 50CA              mov A,-54
 0BF4 7C0000            xcall _TX_23_PutChar
 0BF7 20                pop X
 0BF8                   .dbline 1033
 0BF8           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0BF8 10                push X
 0BF9 50FD              mov A,-3
 0BFB 7C0000            xcall _TX_014_PutChar
 0BFE 20                pop X
 0BFF                   .dbline 1034
 0BFF           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0BFF 10                push X
 0C00 50FD              mov A,-3
 0C02 7C0000            xcall _TX_23_PutChar
 0C05 20                pop X
 0C06                   .dbline 1035
 0C06           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0C06 10                push X
 0C07 50FD              mov A,-3
 0C09 7C0000            xcall _TX_014_PutChar
 0C0C 20                pop X
 0C0D                   .dbline 1036
 0C0D           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0C0D 10                push X
 0C0E 50FD              mov A,-3
 0C10 7C0000            xcall _TX_23_PutChar
 0C13 20                pop X
 0C14           L284:
 0C14                   .dbline 1039
 0C14           ;       
 0C14           ;       // Wait for the transmission to finish.
 0C14           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0C14           L285:
 0C14                   .dbline 1039
 0C14 10                push X
 0C15 7C0000            xcall _TX_014_bReadTxStatus
 0C18 62D000            mov REG[0xd0],>__r0
 0C1B 20                pop X
 0C1C 5300              mov [__r0],A
 0C1E 470020            tst [__r0],32
 0C21 AFF2              jz L284
 0C23           L287:
 0C23                   .dbline 1040
 0C23           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 0C23           L288:
 0C23                   .dbline 1040
 0C23 10                push X
 0C24 7C0000            xcall _TX_23_bReadTxStatus
 0C27 62D000            mov REG[0xd0],>__r0
 0C2A 20                pop X
 0C2B 5300              mov [__r0],A
 0C2D 470020            tst [__r0],32
 0C30 AFF2              jz L287
 0C32                   .dbline 1043
 0C32           ;       
 0C32           ;       // Make completely sure we're done.
 0C32           ;       xmitWait();
 0C32 93E4              xcall _xmitWait
 0C34                   .dbline 1045
 0C34           ;       
 0C34           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0C34 5000              mov A,0
 0C36 08                push A
 0C37 5001              mov A,1
 0C39 08                push A
 0C3A 7C00B5            xcall _configToggle
 0C3D 38FE              add SP,-2
 0C3F                   .dbline -2
 0C3F           L283:
 0C3F                   .dbline 0 ; func end
 0C3F 7F                ret
 0C40                   .dbend
 0C40                   .dbfunc e childListen _childListen fI
 0C40           _childListen::
 0C40                   .dbline -1
 0C40                   .dbline 1050
 0C40           ; }
 0C40           ; 
 0C40           ; // This function listens for children and registers the port that they talk to.
 0C40           ; int childListen(void)
 0C40           ; {
 0C40                   .dbline 1051
 0C40           ;       configToggle(HELLO_MODE);       // Switch to listen for hellos on every port.
 0C40 5000              mov A,0
 0C42 08                push A
 0C43 5007              mov A,7
 0C45 08                push A
 0C46 7C00B5            xcall _configToggle
 0C49 38FE              add SP,-2
 0C4B 801C              xjmp L292
 0C4D           L291:
 0C4D                   .dbline 1055
 0C4D           ;       
 0C4D           ;       // Wait to either hear a child or time out.
 0C4D           ;       while(!TIMEOUT)
 0C4D           ;       {               
 0C4D                   .dbline 1056
 0C4D           ;               if(commandReady())
 0C4D 7C02BF            xcall _commandReady
 0C50 62D000            mov REG[0xd0],>__r0
 0C53 3C0000            cmp [__r0],0
 0C56 B006              jnz X63
 0C58 3C0000            cmp [__r1],0
 0C5B A00C              jz L294
 0C5D           X63:
 0C5D                   .dbline 1057
 0C5D           ;               {
 0C5D                   .dbline 1058
 0C5D           ;                       return 1;
 0C5D 62D000            mov REG[0xd0],>__r0
 0C60 550001            mov [__r1],1
 0C63 550000            mov [__r0],0
 0C66 8030              xjmp L290
 0C68           L294:
 0C68                   .dbline 1060
 0C68           ;               }
 0C68           ;       }
 0C68           L292:
 0C68                   .dbline 1054
 0C68 62D000            mov REG[0xd0],>_TIMEOUT
 0C6B 3C0000            cmp [_TIMEOUT],0
 0C6E B006              jnz X64
 0C70 3C0100            cmp [_TIMEOUT+1],0
 0C73 AFD9              jz L291
 0C75           X64:
 0C75                   .dbline 1062
 0C75           ;       
 0C75           ;       HELLO_TIMEOUT_Stop();           // Stop the timer.
 0C75 10                push X
 0C76 7C0000            xcall _HELLO_TIMEOUT_Stop
 0C79 20                pop X
 0C7A                   .dbline 1063
 0C7A           ;       TIMEOUT = 0;                            // Clear the timeout flag.
 0C7A 62D000            mov REG[0xd0],>_TIMEOUT
 0C7D 550100            mov [_TIMEOUT+1],0
 0C80 550000            mov [_TIMEOUT],0
 0C83                   .dbline 1065
 0C83           ;       
 0C83           ;       configToggle(WAIT);                     // Switch back to wait for a master response.
 0C83 5000              mov A,0
 0C85 08                push A
 0C86 5001              mov A,1
 0C88 08                push A
 0C89 7C00B5            xcall _configToggle
 0C8C 38FE              add SP,-2
 0C8E                   .dbline 1067
 0C8E           ;       
 0C8E           ;       return 0;                                       // Return the result of our listening session.
 0C8E 62D000            mov REG[0xd0],>__r0
 0C91 550000            mov [__r1],0
 0C94 550000            mov [__r0],0
 0C97                   .dbline -2
 0C97           L290:
 0C97                   .dbline 0 ; func end
 0C97 7F                ret
 0C98                   .dbend
 0C98                   .dbfunc e childResponse _childResponse fI
 0C98           ; child_responded -> X+0
 0C98           _childResponse::
 0C98                   .dbline -1
 0C98 10                push X
 0C99 4F                mov X,SP
 0C9A 3802              add SP,2
 0C9C                   .dbline 1072
 0C9C           ; }
 0C9C           ; 
 0C9C           ; // This function waits for a known child's response.
 0C9C           ; int childResponse(void)
 0C9C           ; {
 0C9C                   .dbline 1073
 0C9C           ;       int child_responded = 0;
 0C9C 560100            mov [X+1],0
 0C9F 560000            mov [X+0],0
 0CA2                   .dbline 1076
 0CA2           ;       
 0CA2           ;       // Switch to the right port.
 0CA2           ;       if(CHILD == PORT_1)
 0CA2 62D000            mov REG[0xd0],>_CHILD
 0CA5 3C0031            cmp [_CHILD],49
 0CA8 B00E              jnz L297
 0CAA                   .dbline 1077
 0CAA           ;       {
 0CAA                   .dbline 1078
 0CAA           ;               configToggle(RESPONSE_1);
 0CAA 5000              mov A,0
 0CAC 08                push A
 0CAD 5003              mov A,3
 0CAF 08                push A
 0CB0 7C00B5            xcall _configToggle
 0CB3 38FE              add SP,-2
 0CB5                   .dbline 1079
 0CB5           ;       }
 0CB5 8056              xjmp L306
 0CB7           L297:
 0CB7                   .dbline 1080
 0CB7           ;       else if(CHILD == PORT_2)
 0CB7 62D000            mov REG[0xd0],>_CHILD
 0CBA 3C0032            cmp [_CHILD],50
 0CBD B00E              jnz L299
 0CBF                   .dbline 1081
 0CBF           ;       {
 0CBF                   .dbline 1082
 0CBF           ;               configToggle(RESPONSE_2);
 0CBF 5000              mov A,0
 0CC1 08                push A
 0CC2 5004              mov A,4
 0CC4 08                push A
 0CC5 7C00B5            xcall _configToggle
 0CC8 38FE              add SP,-2
 0CCA                   .dbline 1083
 0CCA           ;       }
 0CCA 8041              xjmp L306
 0CCC           L299:
 0CCC                   .dbline 1084
 0CCC           ;       else if(CHILD == PORT_3)
 0CCC 62D000            mov REG[0xd0],>_CHILD
 0CCF 3C0033            cmp [_CHILD],51
 0CD2 B00E              jnz L301
 0CD4                   .dbline 1085
 0CD4           ;       {
 0CD4                   .dbline 1086
 0CD4           ;               configToggle(RESPONSE_3);
 0CD4 5000              mov A,0
 0CD6 08                push A
 0CD7 5005              mov A,5
 0CD9 08                push A
 0CDA 7C00B5            xcall _configToggle
 0CDD 38FE              add SP,-2
 0CDF                   .dbline 1087
 0CDF           ;       }
 0CDF 802C              xjmp L306
 0CE1           L301:
 0CE1                   .dbline 1088
 0CE1           ;       else if(CHILD == PORT_4)
 0CE1 62D000            mov REG[0xd0],>_CHILD
 0CE4 3C0034            cmp [_CHILD],52
 0CE7 B024              jnz L306
 0CE9                   .dbline 1089
 0CE9           ;       {
 0CE9                   .dbline 1090
 0CE9           ;               configToggle(RESPONSE_4);
 0CE9 5000              mov A,0
 0CEB 08                push A
 0CEC 5006              mov A,6
 0CEE 08                push A
 0CEF 7C00B5            xcall _configToggle
 0CF2 38FE              add SP,-2
 0CF4                   .dbline 1091
 0CF4           ;       }
 0CF4 8017              xjmp L306
 0CF6           L305:
 0CF6                   .dbline 1095
 0CF6           ;       
 0CF6           ;       // Wait for a response or a timeout.
 0CF6           ;       while((!child_responded) && (!TIMEOUT))
 0CF6           ;       {
 0CF6                   .dbline 1096
 0CF6           ;               if(commandReady())
 0CF6 7C02BF            xcall _commandReady
 0CF9 62D000            mov REG[0xd0],>__r0
 0CFC 3C0000            cmp [__r0],0
 0CFF B006              jnz X65
 0D01 3C0000            cmp [__r1],0
 0D04 A007              jz L308
 0D06           X65:
 0D06                   .dbline 1097
 0D06           ;               {
 0D06                   .dbline 1098
 0D06           ;                       child_responded = 1;
 0D06 560101            mov [X+1],1
 0D09 560000            mov [X+0],0
 0D0C                   .dbline 1099
 0D0C           ;               }
 0D0C           L308:
 0D0C                   .dbline 1100
 0D0C           ;       }
 0D0C           L306:
 0D0C                   .dbline 1094
 0D0C 3D0000            cmp [X+0],0
 0D0F B013              jnz L310
 0D11 3D0100            cmp [X+1],0
 0D14 B00E              jnz L310
 0D16           X66:
 0D16 62D000            mov REG[0xd0],>_TIMEOUT
 0D19 3C0000            cmp [_TIMEOUT],0
 0D1C B006              jnz X67
 0D1E 3C0100            cmp [_TIMEOUT+1],0
 0D21 AFD4              jz L305
 0D23           X67:
 0D23           L310:
 0D23                   .dbline 1103
 0D23           ;       
 0D23           ;       // Stop the right timer.
 0D23           ;       if(CHILD == PORT_1)
 0D23 62D000            mov REG[0xd0],>_CHILD
 0D26 3C0031            cmp [_CHILD],49
 0D29 B008              jnz L311
 0D2B                   .dbline 1104
 0D2B           ;       {
 0D2B                   .dbline 1105
 0D2B           ;               CHILD_1_TIMEOUT_Stop();
 0D2B 10                push X
 0D2C 7C0000            xcall _CHILD_1_TIMEOUT_Stop
 0D2F 20                pop X
 0D30                   .dbline 1106
 0D30           ;       }
 0D30 802C              xjmp L312
 0D32           L311:
 0D32                   .dbline 1107
 0D32           ;       else if(CHILD == PORT_2)
 0D32 62D000            mov REG[0xd0],>_CHILD
 0D35 3C0032            cmp [_CHILD],50
 0D38 B008              jnz L313
 0D3A                   .dbline 1108
 0D3A           ;       {
 0D3A                   .dbline 1109
 0D3A           ;               CHILD_2_TIMEOUT_Stop();
 0D3A 10                push X
 0D3B 7C0000            xcall _CHILD_2_TIMEOUT_Stop
 0D3E 20                pop X
 0D3F                   .dbline 1110
 0D3F           ;       }
 0D3F 801D              xjmp L314
 0D41           L313:
 0D41                   .dbline 1111
 0D41           ;       else if(CHILD == PORT_3)
 0D41 62D000            mov REG[0xd0],>_CHILD
 0D44 3C0033            cmp [_CHILD],51
 0D47 B008              jnz L315
 0D49                   .dbline 1112
 0D49           ;       {
 0D49                   .dbline 1113
 0D49           ;               CHILD_3_TIMEOUT_Stop();
 0D49 10                push X
 0D4A 7C0000            xcall _CHILD_3_TIMEOUT_Stop
 0D4D 20                pop X
 0D4E                   .dbline 1114
 0D4E           ;       }
 0D4E 800E              xjmp L316
 0D50           L315:
 0D50                   .dbline 1115
 0D50           ;       else if(CHILD == PORT_4)
 0D50 62D000            mov REG[0xd0],>_CHILD
 0D53 3C0034            cmp [_CHILD],52
 0D56 B006              jnz L317
 0D58                   .dbline 1116
 0D58           ;       {
 0D58                   .dbline 1117
 0D58           ;               CHILD_4_TIMEOUT_Stop();
 0D58 10                push X
 0D59 7C0000            xcall _CHILD_4_TIMEOUT_Stop
 0D5C 20                pop X
 0D5D                   .dbline 1118
 0D5D           ;       }
 0D5D           L317:
 0D5D           L316:
 0D5D           L314:
 0D5D           L312:
 0D5D                   .dbline 1120
 0D5D           ;       
 0D5D           ;       TIMEOUT = 0;                                    // Reset the timeout flag.
 0D5D 62D000            mov REG[0xd0],>_TIMEOUT
 0D60 550100            mov [_TIMEOUT+1],0
 0D63 550000            mov [_TIMEOUT],0
 0D66                   .dbline 1122
 0D66           ;       
 0D66           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0D66 5000              mov A,0
 0D68 08                push A
 0D69 5001              mov A,1
 0D6B 08                push A
 0D6C 7C00B5            xcall _configToggle
 0D6F 38FE              add SP,-2
 0D71                   .dbline 1124
 0D71           ;       
 0D71           ;       return child_responded;
 0D71 62D000            mov REG[0xd0],>__r0
 0D74 5201              mov A,[X+1]
 0D76 5300              mov [__r1],A
 0D78 5200              mov A,[X+0]
 0D7A 5300              mov [__r0],A
 0D7C                   .dbline -2
 0D7C           L296:
 0D7C 38FE              add SP,-2
 0D7E 20                pop X
 0D7F                   .dbline 0 ; func end
 0D7F 7F                ret
 0D80                   .dbsym l child_responded 0 I
 0D80                   .dbend
 0D80                   .dbfunc e servoFinder _servoFinder fV
 0D80           ;     flashWrite -> X+5
 0D80           ; status_return_level -> X+4
 0D80           ;              j -> X+2
 0D80           ;              i -> X+0
 0D80           _servoFinder::
 0D80                   .dbline -1
 0D80 10                push X
 0D81 4F                mov X,SP
 0D82 3807              add SP,7
 0D84                   .dbline 1131
 0D84           ; }
 0D84           ; 
 0D84           ; // This function is used to find the servo that is directly connected to this module's controller.
 0D84           ; // After the servo ID is found, the status return level is changed so that packets are only
 0D84           ; // returned for the desired status return level defined at the top of this file.
 0D84           ; void servoFinder(void)
 0D84           ; {                             
 0D84                   .dbline 1133
 0D84           ;       // Index variables for incrementing and checking against the maximum servo comm attempts.
 0D84           ;       int i = 0;
 0D84 560100            mov [X+1],0
 0D87 560000            mov [X+0],0
 0D8A                   .dbline 1134
 0D8A           ;       int j = 0;
 0D8A 560300            mov [X+3],0
 0D8D 560200            mov [X+2],0
 0D90                   .dbline 1137
 0D90           ;       
 0D90           ;       // Integer used as a flag so that EEPROM writes aren't done more than once.
 0D90           ;       int flashWrite = 0;
 0D90 560600            mov [X+6],0
 0D93 560500            mov [X+5],0
 0D96                   .dbline 1140
 0D96           ;       
 0D96           ;       // Create a status return level variable and set it to an out of range value initially.
 0D96           ;       char status_return_level = 3;
 0D96 560403            mov [X+4],3
 0D99                   .dbline 1143
 0D99           ;       
 0D99           ;       // Start with a servo ID of 255 (out of valid range).
 0D99           ;       SERVO_ID = SERVO_START;
 0D99 62D000            mov REG[0xd0],>_SERVO_ID
 0D9C 5500FF            mov [_SERVO_ID],-1
 0D9F                   .dbline 1152
 0D9F           ; 
 0D9F           ;       // This for loop will loop SERVO_COMM_LOOPS number of times and ping the servo SERVO_COMM_ATTEMPTS
 0D9F           ;       // number of times in each loop (unless stopped short due to early success). If this fails for the
 0D9F           ;       // first round of pings, a broadcast reset will be performed to reset the servo. This is done
 0D9F           ;       // because we assume that the baud rate is matching up, but the servo's return delay time is too
 0D9F           ;       // fast for the controller to switch into receive mode to read the response. The default return
 0D9F           ;       // delay time is 500 microseconds. If we loop for SERVO_COMM_LOOPS number of times and still don't
 0D9F           ;       // see anything, we assume that there is something is too wrong for us to fix.
 0D9F           ;       for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0D9F 560300            mov [X+3],0
 0DA2 560200            mov [X+2],0
 0DA5           L320:
 0DA5                   .dbline 1153
 0DA5           ;       {       
 0DA5                   .dbline 1155
 0DA5           ;               // Ping SERVO_COMM_ATTEMPTS times to try and extract the servo ID.
 0DA5           ;               for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0DA5 560100            mov [X+1],0
 0DA8 560000            mov [X+0],0
 0DAB           L324:
 0DAB                   .dbline 1156
 0DAB           ;               {
 0DAB                   .dbline 1158
 0DAB           ;                       // Send a ping out for any servo connected to me (will only be one).
 0DAB           ;                       servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
 0DAB 5000              mov A,0
 0DAD 08                push A
 0DAE 08                push A
 0DAF 5001              mov A,1
 0DB1 08                push A
 0DB2 5002              mov A,2
 0DB4 08                push A
 0DB5 50FE              mov A,-2
 0DB7 08                push A
 0DB8 9180              xcall _servoInstruction
 0DBA 38FB              add SP,-5
 0DBC 804C              xjmp L329
 0DBE           L328:
 0DBE                   .dbline 1162
 0DBE           ;                       
 0DBE           ;                       // Wait for either a timeout or a valid servo ID (which will trigger a timeout).
 0DBE           ;                       while(!TIMEOUT)
 0DBE           ;                       {       
 0DBE                   .dbline 1163
 0DBE           ;                               if(commandReady())
 0DBE 7C02BF            xcall _commandReady
 0DC1 62D000            mov REG[0xd0],>__r0
 0DC4 3C0000            cmp [__r0],0
 0DC7 B006              jnz X68
 0DC9 3C0000            cmp [__r1],0
 0DCC A03C              jz L331
 0DCE           X68:
 0DCE                   .dbline 1164
 0DCE           ;                               {
 0DCE                   .dbline 1166
 0DCE           ;                                       // If we read a source ID within the range, exit the loop.
 0DCE           ;                                       if((COMMAND_SOURCE >= SERVO_ID_MIN) && (COMMAND_SOURCE <= SERVO_ID_MAX))
 0DCE 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0DD1 3C0000            cmp [_COMMAND_SOURCE],0
 0DD4 C02B              jc L333
 0DD6           X69:
 0DD6 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0DD9 50FD              mov A,-3
 0DDB 3A00              cmp A,[_COMMAND_SOURCE]
 0DDD C022              jc L333
 0DDF           X70:
 0DDF                   .dbline 1167
 0DDF           ;                                       {       
 0DDF                   .dbline 1169
 0DDF           ;                                               // Exit this while loop by setting the timeout flag.
 0DDF           ;                                               TIMEOUT = 1;
 0DDF 62D000            mov REG[0xd0],>_TIMEOUT
 0DE2 550101            mov [_TIMEOUT+1],1
 0DE5 550000            mov [_TIMEOUT],0
 0DE8                   .dbline 1171
 0DE8           ;                                               // Set the servo ID variable to where the ping came from.
 0DE8           ;                                               SERVO_ID = COMMAND_SOURCE;
 0DE8 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0DEB 5100              mov A,[_COMMAND_SOURCE]
 0DED 62D000            mov REG[0xd0],>_SERVO_ID
 0DF0 5300              mov [_SERVO_ID],A
 0DF2                   .dbline 1173
 0DF2           ;                                               // Set the index variable such that the for loop exits.
 0DF2           ;                                               i = SERVO_COMM_ATTEMPTS;
 0DF2 56010A            mov [X+1],10
 0DF5 560000            mov [X+0],0
 0DF8                   .dbline 1175
 0DF8           ;                                               // Set the outer index variable to 2 to not attempt again for no reason.
 0DF8           ;                                               j = SERVO_COMM_LOOPS;
 0DF8 560302            mov [X+3],2
 0DFB 560200            mov [X+2],0
 0DFE                   .dbline 1176
 0DFE           ;                                       }
 0DFE 800A              xjmp L334
 0E00           L333:
 0E00                   .dbline 1178
 0E00           ;                                       else
 0E00           ;                                       {
 0E00                   .dbline 1180
 0E00           ;                                               // Exit this while loop and try to ping again.
 0E00           ;                                               TIMEOUT = 1;
 0E00 62D000            mov REG[0xd0],>_TIMEOUT
 0E03 550101            mov [_TIMEOUT+1],1
 0E06 550000            mov [_TIMEOUT],0
 0E09                   .dbline 1181
 0E09           ;                                       }
 0E09           L334:
 0E09                   .dbline 1182
 0E09           ;                               }
 0E09           L331:
 0E09                   .dbline 1183
 0E09           ;                       }
 0E09           L329:
 0E09                   .dbline 1161
 0E09 62D000            mov REG[0xd0],>_TIMEOUT
 0E0C 3C0000            cmp [_TIMEOUT],0
 0E0F B006              jnz X71
 0E11 3C0100            cmp [_TIMEOUT+1],0
 0E14 AFA9              jz L328
 0E16           X71:
 0E16                   .dbline 1184
 0E16           ;               }
 0E16           L325:
 0E16                   .dbline 1155
 0E16 7701              inc [X+1]
 0E18 0F0000            adc [X+0],0
 0E1B                   .dbline 1155
 0E1B 5201              mov A,[X+1]
 0E1D 110A              sub A,10
 0E1F 5200              mov A,[X+0]
 0E21 3180              xor A,-128
 0E23 1980              sbb A,(0 ^ 0x80)
 0E25 CF85              jc L324
 0E27           X72:
 0E27                   .dbline 1188
 0E27           ;               
 0E27           ;               // If we didn't get a response and haven't written to the flash of the
 0E27           ;               // servo (first time through), send out a broadcast reset.
 0E27           ;               if((SERVO_ID == SERVO_START) && (!flashWrite))
 0E27 62D000            mov REG[0xd0],>_SERVO_ID
 0E2A 3C00FF            cmp [_SERVO_ID],-1
 0E2D B022              jnz L335
 0E2F 3D0500            cmp [X+5],0
 0E32 B01D              jnz L335
 0E34 3D0600            cmp [X+6],0
 0E37 B018              jnz L335
 0E39           X73:
 0E39                   .dbline 1189
 0E39           ;               {
 0E39                   .dbline 1191
 0E39           ;                       // Set the flash write flag so that we only do this once per power cycle.
 0E39           ;                       flashWrite = 1;
 0E39 560601            mov [X+6],1
 0E3C 560500            mov [X+5],0
 0E3F                   .dbline 1195
 0E3F           ;                       
 0E3F           ;                       // Send out a broadcast reset so that we know that the response time interval
 0E3F           ;                       // is large enough (default delay time for a servo is 500 microseconds).
 0E3F           ;                       servoInstruction(BROADCAST, RESET_LENGTH, RESET_SERVO, 0, 0);
 0E3F 5000              mov A,0
 0E41 08                push A
 0E42 08                push A
 0E43 5006              mov A,6
 0E45 08                push A
 0E46 5002              mov A,2
 0E48 08                push A
 0E49 50FE              mov A,-2
 0E4B 08                push A
 0E4C 90EC              xcall _servoInstruction
 0E4E 38FB              add SP,-5
 0E50                   .dbline 1196
 0E50           ;               }
 0E50           L335:
 0E50                   .dbline 1197
 0E50           ;       }
 0E50           L321:
 0E50                   .dbline 1152
 0E50 7703              inc [X+3]
 0E52 0F0200            adc [X+2],0
 0E55                   .dbline 1152
 0E55 5203              mov A,[X+3]
 0E57 1102              sub A,2
 0E59 5202              mov A,[X+2]
 0E5B 3180              xor A,-128
 0E5D 1980              sbb A,(0 ^ 0x80)
 0E5F CF45              jc L320
 0E61           X74:
 0E61                   .dbline 1200
 0E61           ; 
 0E61           ;       // Reset flash write flag.
 0E61           ;       flashWrite = 0;
 0E61 560600            mov [X+6],0
 0E64 560500            mov [X+5],0
 0E67                   .dbline 1204
 0E67           ;       
 0E67           ;       // If we have a valid servo ID, set the status return level. If we don't, just skip this
 0E67           ;       // because all hope is lost.
 0E67           ;       if(SERVO_ID < BROADCAST)
 0E67 62D000            mov REG[0xd0],>_SERVO_ID
 0E6A 3C00FE            cmp [_SERVO_ID],-2
 0E6D D0C6              jnc L337
 0E6F           X75:
 0E6F                   .dbline 1205
 0E6F           ;       {
 0E6F                   .dbline 1210
 0E6F           ;               // This for loop will loop SERVO_COMM_LOOPS number of times and poll for the servo's status
 0E6F           ;               // return level SERVO_COMM_ATTEMPTS number of times in each loop (unless stopped short due
 0E6F           ;               // to early success). If this fails for the first iteration, or we read a status return level
 0E6F           ;               // other than what we want, we will attempt to write the desired status return level onto the servo.
 0E6F           ;               for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0E6F 560300            mov [X+3],0
 0E72 560200            mov [X+2],0
 0E75           L339:
 0E75                   .dbline 1211
 0E75           ;               {
 0E75                   .dbline 1213
 0E75           ;                       // Attempt to read the status return level for the defined number of attempts.
 0E75           ;                       for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0E75 560100            mov [X+1],0
 0E78 560000            mov [X+0],0
 0E7B           L343:
 0E7B                   .dbline 1214
 0E7B           ;                       {
 0E7B                   .dbline 1216
 0E7B           ;                               // Send a request for the servo's status return level.
 0E7B           ;                               servoInstruction(SERVO_ID, READ_LENGTH, READ_SERVO, STATUS_RET_ADDRESS, 1);
 0E7B 5001              mov A,1
 0E7D 08                push A
 0E7E 5010              mov A,16
 0E80 08                push A
 0E81 5002              mov A,2
 0E83 08                push A
 0E84 5004              mov A,4
 0E86 08                push A
 0E87 62D000            mov REG[0xd0],>_SERVO_ID
 0E8A 5100              mov A,[_SERVO_ID]
 0E8C 08                push A
 0E8D 90AB              xcall _servoInstruction
 0E8F 38FB              add SP,-5
 0E91 8048              xjmp L348
 0E93           L347:
 0E93                   .dbline 1220
 0E93           ;                               
 0E93           ;                               // Wait for either a timeout or an indication that we want to exit the loop.
 0E93           ;                               while(!TIMEOUT)
 0E93           ;                               {
 0E93                   .dbline 1222
 0E93           ;                                       // If a valid command is ready, interpret it.
 0E93           ;                                       if(commandReady())
 0E93 7C02BF            xcall _commandReady
 0E96 62D000            mov REG[0xd0],>__r0
 0E99 3C0000            cmp [__r0],0
 0E9C B006              jnz X76
 0E9E 3C0000            cmp [__r1],0
 0EA1 A038              jz L350
 0EA3           X76:
 0EA3                   .dbline 1223
 0EA3           ;                                       {
 0EA3                   .dbline 1224
 0EA3           ;                                               if(!COMMAND_ERROR)
 0EA3 62D000            mov REG[0xd0],>_COMMAND_ERROR
 0EA6 3C0000            cmp [_COMMAND_ERROR],0
 0EA9 B030              jnz L352
 0EAB                   .dbline 1225
 0EAB           ;                                               {
 0EAB                   .dbline 1227
 0EAB           ;                                                       // If the return level is equal to what is desired, store it.
 0EAB           ;                                                       if(COMMAND_PARAM == STATUS_RET_LEVEL)
 0EAB 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0EAE 3C0001            cmp [_COMMAND_PARAM],1
 0EB1 B01F              jnz L354
 0EB3                   .dbline 1228
 0EB3           ;                                                       {
 0EB3                   .dbline 1230
 0EB3           ;                                                               // Set the timeout flag to exit the loop.
 0EB3           ;                                                               TIMEOUT = 1;
 0EB3 62D000            mov REG[0xd0],>_TIMEOUT
 0EB6 550101            mov [_TIMEOUT+1],1
 0EB9 550000            mov [_TIMEOUT],0
 0EBC                   .dbline 1232
 0EBC           ;                                                               // Store the status return level.
 0EBC           ;                                                               status_return_level = COMMAND_PARAM;
 0EBC 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0EBF 5100              mov A,[_COMMAND_PARAM]
 0EC1 5404              mov [X+4],A
 0EC3                   .dbline 1234
 0EC3           ;                                                               // Set i so that we exit the for loop.
 0EC3           ;                                                               i = SERVO_COMM_ATTEMPTS;
 0EC3 56010A            mov [X+1],10
 0EC6 560000            mov [X+0],0
 0EC9                   .dbline 1236
 0EC9           ;                                                               // Set the outer loop's variable so that we don't loop again.
 0EC9           ;                                                               j = SERVO_COMM_LOOPS;
 0EC9 560302            mov [X+3],2
 0ECC 560200            mov [X+2],0
 0ECF                   .dbline 1237
 0ECF           ;                                                       }
 0ECF 800A              xjmp L355
 0ED1           L354:
 0ED1                   .dbline 1239
 0ED1           ;                                                       else
 0ED1           ;                                                       {       
 0ED1                   .dbline 1241
 0ED1           ;                                                               // Set the timeout flag to exit the loop.
 0ED1           ;                                                               TIMEOUT = 1;
 0ED1 62D000            mov REG[0xd0],>_TIMEOUT
 0ED4 550101            mov [_TIMEOUT+1],1
 0ED7 550000            mov [_TIMEOUT],0
 0EDA                   .dbline 1242
 0EDA           ;                                                       }
 0EDA           L355:
 0EDA                   .dbline 1243
 0EDA           ;                                               }
 0EDA           L352:
 0EDA                   .dbline 1244
 0EDA           ;                                       }
 0EDA           L350:
 0EDA                   .dbline 1245
 0EDA           ;                               }
 0EDA           L348:
 0EDA                   .dbline 1219
 0EDA 62D000            mov REG[0xd0],>_TIMEOUT
 0EDD 3C0000            cmp [_TIMEOUT],0
 0EE0 B006              jnz X77
 0EE2 3C0100            cmp [_TIMEOUT+1],0
 0EE5 AFAD              jz L347
 0EE7           X77:
 0EE7                   .dbline 1246
 0EE7           ;                       }
 0EE7           L344:
 0EE7                   .dbline 1213
 0EE7 7701              inc [X+1]
 0EE9 0F0000            adc [X+0],0
 0EEC                   .dbline 1213
 0EEC 5201              mov A,[X+1]
 0EEE 110A              sub A,10
 0EF0 5200              mov A,[X+0]
 0EF2 3180              xor A,-128
 0EF4 1980              sbb A,(0 ^ 0x80)
 0EF6 CF84              jc L343
 0EF8           X78:
 0EF8                   .dbline 1250
 0EF8           ;               
 0EF8           ;                       // If we didn't get a good response and haven't written to the flash of the servo,
 0EF8           ;                       // force a change in the status return level with an EEPROM write.
 0EF8           ;                       if((status_return_level != STATUS_RET_LEVEL) && (!flashWrite))
 0EF8 3D0401            cmp [X+4],1
 0EFB A027              jz L356
 0EFD 3D0500            cmp [X+5],0
 0F00 B022              jnz L356
 0F02 3D0600            cmp [X+6],0
 0F05 B01D              jnz L356
 0F07           X79:
 0F07                   .dbline 1251
 0F07           ;                       {       
 0F07                   .dbline 1252
 0F07           ;                               flashWrite = 1;
 0F07 560601            mov [X+6],1
 0F0A 560500            mov [X+5],0
 0F0D                   .dbline 1255
 0F0D           ;                               
 0F0D           ;                               // Try to force the return status to what we want.
 0F0D           ;                               servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, STATUS_RET_ADDRESS, STATUS_RET_LEVEL);
 0F0D 5001              mov A,1
 0F0F 08                push A
 0F10 5010              mov A,16
 0F12 08                push A
 0F13 5003              mov A,3
 0F15 08                push A
 0F16 5004              mov A,4
 0F18 08                push A
 0F19 62D000            mov REG[0xd0],>_SERVO_ID
 0F1C 5100              mov A,[_SERVO_ID]
 0F1E 08                push A
 0F1F 9019              xcall _servoInstruction
 0F21 38FB              add SP,-5
 0F23                   .dbline 1256
 0F23           ;                       }
 0F23           L356:
 0F23                   .dbline 1257
 0F23           ;               }
 0F23           L340:
 0F23                   .dbline 1210
 0F23 7703              inc [X+3]
 0F25 0F0200            adc [X+2],0
 0F28                   .dbline 1210
 0F28 5203              mov A,[X+3]
 0F2A 1102              sub A,2
 0F2C 5202              mov A,[X+2]
 0F2E 3180              xor A,-128
 0F30 1980              sbb A,(0 ^ 0x80)
 0F32 CF42              jc L339
 0F34           X80:
 0F34                   .dbline 1258
 0F34           ;       }
 0F34           L337:
 0F34                   .dbline 1261
 0F34           ;       
 0F34           ;       // Wait for the other controllers to find their servos.
 0F34           ;       servoConfigWait();
 0F34 9155              xcall _servoConfigWait
 0F36                   .dbline -2
 0F36           L319:
 0F36 38F9              add SP,-7
 0F38 20                pop X
 0F39                   .dbline 0 ; func end
 0F39 7F                ret
 0F3A                   .dbsym l flashWrite 5 I
 0F3A                   .dbsym l status_return_level 4 c
 0F3A                   .dbsym l j 2 I
 0F3A                   .dbsym l i 0 I
 0F3A                   .dbend
 0F3A                   .dbfunc e servoInstruction _servoInstruction fV
 0F3A           ;       checksum -> X+0
 0F3A           ;          value -> X-8
 0F3A           ;        address -> X-7
 0F3A           ;    instruction -> X-6
 0F3A           ;         length -> X-5
 0F3A           ;             id -> X-4
 0F3A           _servoInstruction::
 0F3A                   .dbline -1
 0F3A 10                push X
 0F3B 4F                mov X,SP
 0F3C 3801              add SP,1
 0F3E                   .dbline 1267
 0F3E           ; }
 0F3E           ; 
 0F3E           ; // This function receives a destination, command length, instruction type, address, and value.
 0F3E           ; // With these parameters, the function sends a packet to the communication bus.
 0F3E           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 0F3E           ; {
 0F3E                   .dbline 1271
 0F3E           ;       char checksum;
 0F3E           ;       
 0F3E           ;       // Toggle into transmit mode.
 0F3E           ;       configToggle(SERVO_COMM);
 0F3E 5000              mov A,0
 0F40 08                push A
 0F41 5009              mov A,9
 0F43 08                push A
 0F44 7C00B5            xcall _configToggle
 0F47 38FE              add SP,-2
 0F49                   .dbline 1274
 0F49           ;       
 0F49           ;       // Calculate the checksum value for our servo communication.
 0F49           ;       checksum = 255-((id + length + instruction + address + value)%256);
 0F49 62D000            mov REG[0xd0],>__r0
 0F4C 52FB              mov A,[X-5]
 0F4E 5300              mov [__r1],A
 0F50 550000            mov [__r0],0
 0F53 52FC              mov A,[X-4]
 0F55 0200              add A,[__r1]
 0F57 5300              mov [__r1],A
 0F59 5000              mov A,0
 0F5B 0A00              adc A,[__r0]
 0F5D 5300              mov [__r0],A
 0F5F 52FA              mov A,[X-6]
 0F61 0400              add [__r1],A
 0F63 0E0000            adc [__r0],0
 0F66 52F9              mov A,[X-7]
 0F68 0400              add [__r1],A
 0F6A 0E0000            adc [__r0],0
 0F6D 52F8              mov A,[X-8]
 0F6F 0400              add [__r1],A
 0F71 0E0000            adc [__r0],0
 0F74 5001              mov A,1
 0F76 08                push A
 0F77 5000              mov A,0
 0F79 08                push A
 0F7A 5100              mov A,[__r0]
 0F7C 08                push A
 0F7D 5100              mov A,[__r1]
 0F7F 08                push A
 0F80 7C0000            xcall __divmod_16X16_16
 0F83 38FE              add SP,-2
 0F85 18                pop A
 0F86 5300              mov [__r1],A
 0F88 18                pop A
 0F89 50FF              mov A,-1
 0F8B 1200              sub A,[__r1]
 0F8D 5400              mov [X+0],A
 0F8F                   .dbline 1277
 0F8F           ;       
 0F8F           ;       // Talk to the servo.
 0F8F           ;       if(instruction == PING_SERVO)
 0F8F 3DFA01            cmp [X-6],1
 0F92 B02D              jnz L359
 0F94                   .dbline 1278
 0F94           ;       {
 0F94                   .dbline 1279
 0F94           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte one
 0F94 10                push X
 0F95 50FF              mov A,-1
 0F97 7C0000            xcall _SERVO_TX_PutChar
 0F9A 20                pop X
 0F9B                   .dbline 1280
 0F9B           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte two
 0F9B 10                push X
 0F9C 50FF              mov A,-1
 0F9E 7C0000            xcall _SERVO_TX_PutChar
 0FA1 20                pop X
 0FA2                   .dbline 1281
 0FA2           ;               SERVO_TX_PutChar(id);                   // Servo ID
 0FA2 10                push X
 0FA3 52FC              mov A,[X-4]
 0FA5 7C0000            xcall _SERVO_TX_PutChar
 0FA8 20                pop X
 0FA9                   .dbline 1282
 0FA9           ;               SERVO_TX_PutChar(length);               // The instruction length.
 0FA9 10                push X
 0FAA 52FB              mov A,[X-5]
 0FAC 7C0000            xcall _SERVO_TX_PutChar
 0FAF 20                pop X
 0FB0                   .dbline 1283
 0FB0           ;               SERVO_TX_PutChar(instruction);  // The instruction to carry out.
 0FB0 10                push X
 0FB1 52FA              mov A,[X-6]
 0FB3 7C0000            xcall _SERVO_TX_PutChar
 0FB6 20                pop X
 0FB7                   .dbline 1284
 0FB7           ;               SERVO_TX_PutChar(checksum);             // This is the checksum.
 0FB7 10                push X
 0FB8 5200              mov A,[X+0]
 0FBA 7C0000            xcall _SERVO_TX_PutChar
 0FBD 20                pop X
 0FBE                   .dbline 1285
 0FBE           ;       }
 0FBE 8039              xjmp L362
 0FC0           L359:
 0FC0                   .dbline 1287
 0FC0           ;       else
 0FC0           ;       {
 0FC0                   .dbline 1288
 0FC0           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte one
 0FC0 10                push X
 0FC1 50FF              mov A,-1
 0FC3 7C0000            xcall _SERVO_TX_PutChar
 0FC6 20                pop X
 0FC7                   .dbline 1289
 0FC7           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte two
 0FC7 10                push X
 0FC8 50FF              mov A,-1
 0FCA 7C0000            xcall _SERVO_TX_PutChar
 0FCD 20                pop X
 0FCE                   .dbline 1290
 0FCE           ;               SERVO_TX_PutChar(id);                   // Servo ID
 0FCE 10                push X
 0FCF 52FC              mov A,[X-4]
 0FD1 7C0000            xcall _SERVO_TX_PutChar
 0FD4 20                pop X
 0FD5                   .dbline 1291
 0FD5           ;               SERVO_TX_PutChar(length);               // The instruction length.
 0FD5 10                push X
 0FD6 52FB              mov A,[X-5]
 0FD8 7C0000            xcall _SERVO_TX_PutChar
 0FDB 20                pop X
 0FDC                   .dbline 1292
 0FDC           ;               SERVO_TX_PutChar(instruction);  // The instruction to carry out.
 0FDC 10                push X
 0FDD 52FA              mov A,[X-6]
 0FDF 7C0000            xcall _SERVO_TX_PutChar
 0FE2 20                pop X
 0FE3                   .dbline 1293
 0FE3           ;               SERVO_TX_PutChar(address);              // The address to read/write from/to.
 0FE3 10                push X
 0FE4 52F9              mov A,[X-7]
 0FE6 7C0000            xcall _SERVO_TX_PutChar
 0FE9 20                pop X
 0FEA                   .dbline 1294
 0FEA           ;               SERVO_TX_PutChar(value);                // The value to write or number of bytes to read.
 0FEA 10                push X
 0FEB 52F8              mov A,[X-8]
 0FED 7C0000            xcall _SERVO_TX_PutChar
 0FF0 20                pop X
 0FF1                   .dbline 1295
 0FF1           ;               SERVO_TX_PutChar(checksum);             // This is the checksum.
 0FF1 10                push X
 0FF2 5200              mov A,[X+0]
 0FF4 7C0000            xcall _SERVO_TX_PutChar
 0FF7 20                pop X
 0FF8                   .dbline 1296
 0FF8           ;       }
 0FF8           L361:
 0FF8                   .dbline 1299
 0FF8           ;       
 0FF8           ;       // Wait for the transmission to finish.
 0FF8           ;       while(!(SERVO_TX_bReadTxStatus() & SERVO_TX_TX_COMPLETE));
 0FF8           L362:
 0FF8                   .dbline 1299
 0FF8 10                push X
 0FF9 7C0000            xcall _SERVO_TX_bReadTxStatus
 0FFC 62D000            mov REG[0xd0],>__r0
 0FFF 20                pop X
 1000 5300              mov [__r0],A
 1002 470020            tst [__r0],32
 1005 AFF2              jz L361
 1007                   .dbline 1302
 1007           ;       
 1007           ;       // Make completely sure we're done.
 1007           ;       xmitWait();
 1007 900F              xcall _xmitWait
 1009                   .dbline 1305
 1009           ;       
 1009           ;       // Switch back to wait for a servo response.
 1009           ;       configToggle(INITIALIZE);
 1009 5000              mov A,0
 100B 08                push A
 100C 5008              mov A,8
 100E 08                push A
 100F 7C00B5            xcall _configToggle
 1012 38FE              add SP,-2
 1014                   .dbline -2
 1014           L358:
 1014 38FF              add SP,-1
 1016 20                pop X
 1017                   .dbline 0 ; func end
 1017 7F                ret
 1018                   .dbsym l checksum 0 c
 1018                   .dbsym l value -8 c
 1018                   .dbsym l address -7 c
 1018                   .dbsym l instruction -6 c
 1018                   .dbsym l length -5 c
 1018                   .dbsym l id -4 c
 1018                   .dbend
 1018                   .dbfunc e xmitWait _xmitWait fV
 1018           ;              i -> X+0
 1018           _xmitWait::
 1018                   .dbline -1
 1018 10                push X
 1019 4F                mov X,SP
 101A 3802              add SP,2
 101C                   .dbline 1311
 101C           ; }
 101C           ; 
 101C           ; // This function is used in various ways to create a period of nothingness. Mostly,
 101C           ; // it is used to allow the controller enough time to transmit bytes (as its name suggests).
 101C           ; void xmitWait(void)
 101C           ; {
 101C                   .dbline 1314
 101C           ;       int i;
 101C           ;       
 101C           ;       for(i = 0; i < 25; i++)
 101C 560100            mov [X+1],0
 101F 560000            mov [X+0],0
 1022           L365:
 1022                   .dbline 1315
 1022           ;       {
 1022                   .dbline 1317
 1022           ;               // Does nothing and wastes approximately 50 microseconds.
 1022           ;       }
 1022           L366:
 1022                   .dbline 1314
 1022 7701              inc [X+1]
 1024 0F0000            adc [X+0],0
 1027                   .dbline 1314
 1027 5201              mov A,[X+1]
 1029 1119              sub A,25
 102B 5200              mov A,[X+0]
 102D 3180              xor A,-128
 102F 1980              sbb A,(0 ^ 0x80)
 1031 CFF0              jc L365
 1033           X81:
 1033                   .dbline -2
 1033           L364:
 1033 38FE              add SP,-2
 1035 20                pop X
 1036                   .dbline 0 ; func end
 1036 7F                ret
 1037                   .dbsym l i 0 I
 1037                   .dbend
 1037                   .dbfunc e servoBootWait _servoBootWait fV
 1037           ;              i -> X+0
 1037           _servoBootWait::
 1037                   .dbline -1
 1037 10                push X
 1038 4F                mov X,SP
 1039 3802              add SP,2
 103B                   .dbline 1325
 103B           ; }
 103B           ; 
 103B           ; // This function wastes time while the servo that is attached to this controller boots up.
 103B           ; // Once that happens, communications should happen quickly and reliably. The estimated boot
 103B           ; // time in testing was approximately 120 ms. This means that the define SERVO_BOOT_TIMEOUTS
 103B           ; // at the top must be a minimum of 60 since timeout periods are in 2 ms intervals.
 103B           ; void servoBootWait(void)
 103B           ; {
 103B                   .dbline 1326
 103B           ;       int i = 0;                                      // Index integer used for looping.
 103B 560100            mov [X+1],0
 103E 560000            mov [X+0],0
 1041                   .dbline 1328
 1041           ; 
 1041           ;       configToggle(INITIALIZE);       // Switch to initialize mode to do this timeout routine.
 1041 5000              mov A,0
 1043 08                push A
 1044 5008              mov A,8
 1046 08                push A
 1047 7C00B5            xcall _configToggle
 104A 38FE              add SP,-2
 104C                   .dbline 1331
 104C           ;       
 104C           ;       // Loop and wait for enough timeouts to happen before we talk to the servo.
 104C           ;       for(i = 0; i < SERVO_BOOT_TIMEOUTS; i++)
 104C 560100            mov [X+1],0
 104F 560000            mov [X+0],0
 1052                   .dbline 1332
 1052           ;       {
 1052           L374:
 1052                   .dbline 1333
 1052           ;               while(!TIMEOUT) { }             // Do nothing while we wait for one timeout period.
 1052                   .dbline 1333
 1052           L375:
 1052                   .dbline 1333
 1052 62D000            mov REG[0xd0],>_TIMEOUT
 1055 3C0000            cmp [_TIMEOUT],0
 1058 B006              jnz X82
 105A 3C0100            cmp [_TIMEOUT+1],0
 105D AFF4              jz L374
 105F           X82:
 105F                   .dbline 1334
 105F           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 105F 62D000            mov REG[0xd0],>_TIMEOUT
 1062 550100            mov [_TIMEOUT+1],0
 1065 550000            mov [_TIMEOUT],0
 1068                   .dbline 1335
 1068           ;       }
 1068           L371:
 1068                   .dbline 1331
 1068 7701              inc [X+1]
 106A 0F0000            adc [X+0],0
 106D                   .dbline 1331
 106D 5201              mov A,[X+1]
 106F 1164              sub A,100
 1071 5200              mov A,[X+0]
 1073 3180              xor A,-128
 1075 1980              sbb A,(0 ^ 0x80)
 1077 CFDA              jc L375
 1079           X83:
 1079                   .dbline 1337
 1079           ;       
 1079           ;       INIT_TIMEOUT_Stop();            // Stop the timeout timer.
 1079 10                push X
 107A 7C0000            xcall _INIT_TIMEOUT_Stop
 107D 20                pop X
 107E                   .dbline 1338
 107E           ;       TIMEOUT = 0;                            // Clear the timeout flag.
 107E 62D000            mov REG[0xd0],>_TIMEOUT
 1081 550100            mov [_TIMEOUT+1],0
 1084 550000            mov [_TIMEOUT],0
 1087                   .dbline -2
 1087           L369:
 1087 38FE              add SP,-2
 1089 20                pop X
 108A                   .dbline 0 ; func end
 108A 7F                ret
 108B                   .dbsym l i 0 I
 108B                   .dbend
 108B                   .dbfunc e servoConfigWait _servoConfigWait fV
 108B           ;              i -> X+0
 108B           _servoConfigWait::
 108B                   .dbline -1
 108B 10                push X
 108C 4F                mov X,SP
 108D 3802              add SP,2
 108F                   .dbline 1344
 108F           ; }
 108F           ; 
 108F           ; // Sits and spins for the amount of time it takes for a worst case scenario for setup time
 108F           ; // to take place. This allows all other modules to initialize.
 108F           ; void servoConfigWait(void)
 108F           ; {
 108F                   .dbline 1345
 108F           ;       int i = 0;                                      // Index integer for looping purposes.
 108F 560100            mov [X+1],0
 1092 560000            mov [X+0],0
 1095                   .dbline 1347
 1095           ;       
 1095           ;       configToggle(INITIALIZE);       // Switch to initialize mode to do this timeout routine.
 1095 5000              mov A,0
 1097 08                push A
 1098 5008              mov A,8
 109A 08                push A
 109B 7C00B5            xcall _configToggle
 109E 38FE              add SP,-2
 10A0                   .dbline 1352
 10A0           ;       
 10A0           ;       // For SERVO_COMM_ATTEMPTS*SERVO_COMM_LOOPS cycles, let the other controllers find
 10A0           ;       // their servos. The reason we loop this many times is to allow for a possible worst
 10A0           ;       // case scenario of setup time to complete.
 10A0           ;       for(i = 0; i < (SERVO_COMM_ATTEMPTS*SERVO_COMM_LOOPS); i++)
 10A0 560100            mov [X+1],0
 10A3 560000            mov [X+0],0
 10A6                   .dbline 1353
 10A6           ;       {
 10A6           L382:
 10A6                   .dbline 1354
 10A6           ;               while(!TIMEOUT) { }             // Do nothing while we wait for one timeout period.
 10A6                   .dbline 1354
 10A6           L383:
 10A6                   .dbline 1354
 10A6 62D000            mov REG[0xd0],>_TIMEOUT
 10A9 3C0000            cmp [_TIMEOUT],0
 10AC B006              jnz X84
 10AE 3C0100            cmp [_TIMEOUT+1],0
 10B1 AFF4              jz L382
 10B3           X84:
 10B3                   .dbline 1355
 10B3           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 10B3 62D000            mov REG[0xd0],>_TIMEOUT
 10B6 550100            mov [_TIMEOUT+1],0
 10B9 550000            mov [_TIMEOUT],0
 10BC                   .dbline 1356
 10BC           ;       }
 10BC           L379:
 10BC                   .dbline 1352
 10BC 7701              inc [X+1]
 10BE 0F0000            adc [X+0],0
 10C1                   .dbline 1352
 10C1 5201              mov A,[X+1]
 10C3 1114              sub A,20
 10C5 5200              mov A,[X+0]
 10C7 3180              xor A,-128
 10C9 1980              sbb A,(0 ^ 0x80)
 10CB CFDA              jc L383
 10CD           X85:
 10CD                   .dbline 1358
 10CD           ;       
 10CD           ;       INIT_TIMEOUT_Stop();            // Stop the timer.
 10CD 10                push X
 10CE 7C0000            xcall _INIT_TIMEOUT_Stop
 10D1 20                pop X
 10D2                   .dbline 1359
 10D2           ;       TIMEOUT = 0;                            // Reset the timeout flag.
 10D2 62D000            mov REG[0xd0],>_TIMEOUT
 10D5 550100            mov [_TIMEOUT+1],0
 10D8 550000            mov [_TIMEOUT],0
 10DB                   .dbline 1361
 10DB           ; 
 10DB           ;       configToggle(WAIT);                     // Switch to wait for the master node to speak to you.
 10DB 5000              mov A,0
 10DD 08                push A
 10DE 5001              mov A,1
 10E0 08                push A
 10E1 7C00B5            xcall _configToggle
 10E4 38FE              add SP,-2
 10E6                   .dbline -2
 10E6           L377:
 10E6 38FE              add SP,-2
 10E8 20                pop X
 10E9                   .dbline 0 ; func end
 10E9 7F                ret
 10EA                   .dbsym l i 0 I
 10EA                   .dbend
 10EA                   .dbfunc e TX_01234_TIMEOUT_ISR _TX_01234_TIMEOUT_ISR fV
 10EA           _TX_01234_TIMEOUT_ISR::
 10EA                   .dbline -1
 10EA 71C0              or F,-64
 10EC 08                push A
 10ED 5DD0              mov A,REG[0xd0]
 10EF 08                push A
 10F0                   .dbline 1369
 10F0           ; }
 10F0           ; 
 10F0           ; // This timeout ISR is for waiting before a transmission is made from this module.
 10F0           ; // This is to give all the other modules a chance to set up and clear their buffers.
 10F0           ; // It is currently set so that there is 1 ms of down time between the last transmission
 10F0           ; // and this module's transmission.
 10F0           ; void TX_01234_TIMEOUT_ISR(void)
 10F0           ; {
 10F0                   .dbline 1370
 10F0           ;       TIMEOUT = 1;    // Set the timeout flag.
 10F0 62D000            mov REG[0xd0],>_TIMEOUT
 10F3 550101            mov [_TIMEOUT+1],1
 10F6 550000            mov [_TIMEOUT],0
 10F9                   .dbline 1371
 10F9           ;       M8C_ClearIntFlag(INT_CLR0,TX_01234_TIMEOUT_INT_MASK);
 10F9 62DAFD            mov REG[0xda],-3
 10FC                   .dbline -2
 10FC           L385:
 10FC 18                pop A
 10FD 60D0              mov REG[208],A
 10FF 18                pop A
 1100                   .dbline 0 ; func end
 1100 7E                reti
 1101                   .dbend
 1101                   .dbfunc e HELLO_TIMEOUT_ISR _HELLO_TIMEOUT_ISR fV
 1101           _HELLO_TIMEOUT_ISR::
 1101                   .dbline -1
 1101 71C0              or F,-64
 1103 08                push A
 1104 5DD0              mov A,REG[0xd0]
 1106 08                push A
 1107                   .dbline 1376
 1107           ; }
 1107           ; 
 1107           ; // This is the ISR for a hello response timeout.
 1107           ; void HELLO_TIMEOUT_ISR(void)
 1107           ; {
 1107                   .dbline 1377
 1107           ;       TIMEOUT = 1;    // Set the timeout flag.
 1107 62D000            mov REG[0xd0],>_TIMEOUT
 110A 550101            mov [_TIMEOUT+1],1
 110D 550000            mov [_TIMEOUT],0
 1110                   .dbline 1378
 1110           ;       M8C_ClearIntFlag(INT_CLR0,HELLO_TIMEOUT_INT_MASK);
 1110 62DAFD            mov REG[0xda],-3
 1113                   .dbline -2
 1113           L386:
 1113 18                pop A
 1114 60D0              mov REG[208],A
 1116 18                pop A
 1117                   .dbline 0 ; func end
 1117 7E                reti
 1118                   .dbend
 1118                   .dbfunc e CHILD_1_TIMEOUT_ISR _CHILD_1_TIMEOUT_ISR fV
 1118           _CHILD_1_TIMEOUT_ISR::
 1118                   .dbline -1
 1118 71C0              or F,-64
 111A 08                push A
 111B 5DD0              mov A,REG[0xd0]
 111D 08                push A
 111E                   .dbline 1383
 111E           ; }
 111E           ; 
 111E           ; // These remaining ISRs are for all the child timeout scenarios.
 111E           ; void CHILD_1_TIMEOUT_ISR(void)
 111E           ; {
 111E                   .dbline 1384
 111E           ;       TIMEOUT = 1;    // Set the timeout flag.
 111E 62D000            mov REG[0xd0],>_TIMEOUT
 1121 550101            mov [_TIMEOUT+1],1
 1124 550000            mov [_TIMEOUT],0
 1127                   .dbline 1385
 1127           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_1_TIMEOUT_INT_MASK);
 1127 62DAFD            mov REG[0xda],-3
 112A                   .dbline -2
 112A           L387:
 112A 18                pop A
 112B 60D0              mov REG[208],A
 112D 18                pop A
 112E                   .dbline 0 ; func end
 112E 7E                reti
 112F                   .dbend
 112F                   .dbfunc e CHILD_2_TIMEOUT_ISR _CHILD_2_TIMEOUT_ISR fV
 112F           _CHILD_2_TIMEOUT_ISR::
 112F                   .dbline -1
 112F 71C0              or F,-64
 1131 08                push A
 1132 5DD0              mov A,REG[0xd0]
 1134 08                push A
 1135                   .dbline 1389
 1135           ; }
 1135           ; 
 1135           ; void CHILD_2_TIMEOUT_ISR(void)
 1135           ; {
 1135                   .dbline 1390
 1135           ;       TIMEOUT = 1;    // Set the timeout flag.
 1135 62D000            mov REG[0xd0],>_TIMEOUT
 1138 550101            mov [_TIMEOUT+1],1
 113B 550000            mov [_TIMEOUT],0
 113E                   .dbline 1391
 113E           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_2_TIMEOUT_INT_MASK);
 113E 62DAFD            mov REG[0xda],-3
 1141                   .dbline -2
 1141           L388:
 1141 18                pop A
 1142 60D0              mov REG[208],A
 1144 18                pop A
 1145                   .dbline 0 ; func end
 1145 7E                reti
 1146                   .dbend
 1146                   .dbfunc e CHILD_3_TIMEOUT_ISR _CHILD_3_TIMEOUT_ISR fV
 1146           _CHILD_3_TIMEOUT_ISR::
 1146                   .dbline -1
 1146 71C0              or F,-64
 1148 08                push A
 1149 5DD0              mov A,REG[0xd0]
 114B 08                push A
 114C                   .dbline 1395
 114C           ; }
 114C           ; 
 114C           ; void CHILD_3_TIMEOUT_ISR(void)
 114C           ; {
 114C                   .dbline 1396
 114C           ;       TIMEOUT = 1;    // Set the timeout flag.
 114C 62D000            mov REG[0xd0],>_TIMEOUT
 114F 550101            mov [_TIMEOUT+1],1
 1152 550000            mov [_TIMEOUT],0
 1155                   .dbline 1397
 1155           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_3_TIMEOUT_INT_MASK);
 1155 62DAFD            mov REG[0xda],-3
 1158                   .dbline -2
 1158           L389:
 1158 18                pop A
 1159 60D0              mov REG[208],A
 115B 18                pop A
 115C                   .dbline 0 ; func end
 115C 7E                reti
 115D                   .dbend
 115D                   .dbfunc e CHILD_4_TIMEOUT_ISR _CHILD_4_TIMEOUT_ISR fV
 115D           _CHILD_4_TIMEOUT_ISR::
 115D                   .dbline -1
 115D 71C0              or F,-64
 115F 08                push A
 1160 5DD0              mov A,REG[0xd0]
 1162 08                push A
 1163                   .dbline 1401
 1163           ; }
 1163           ; 
 1163           ; void CHILD_4_TIMEOUT_ISR(void)
 1163           ; {
 1163                   .dbline 1402
 1163           ;       TIMEOUT = 1;    // Set the timeout flag.
 1163 62D000            mov REG[0xd0],>_TIMEOUT
 1166 550101            mov [_TIMEOUT+1],1
 1169 550000            mov [_TIMEOUT],0
 116C                   .dbline 1403
 116C           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_4_TIMEOUT_INT_MASK);
 116C 62DAFD            mov REG[0xda],-3
 116F                   .dbline -2
 116F           L390:
 116F 18                pop A
 1170 60D0              mov REG[208],A
 1172 18                pop A
 1173                   .dbline 0 ; func end
 1173 7E                reti
 1174                   .dbend
 1174                   .dbfunc e INIT_TIMEOUT_ISR _INIT_TIMEOUT_ISR fV
 1174           _INIT_TIMEOUT_ISR::
 1174                   .dbline -1
 1174 71C0              or F,-64
 1176 08                push A
 1177 5DD0              mov A,REG[0xd0]
 1179 08                push A
 117A                   .dbline 1407
 117A           ; }
 117A           ; 
 117A           ; void INIT_TIMEOUT_ISR(void)
 117A           ; {
 117A                   .dbline 1408
 117A           ;       TIMEOUT = 1;    // Set the timeout flag.
 117A 62D000            mov REG[0xd0],>_TIMEOUT
 117D 550101            mov [_TIMEOUT+1],1
 1180 550000            mov [_TIMEOUT],0
 1183                   .dbline 1409
 1183           ;       M8C_ClearIntFlag(INT_CLR0,INIT_TIMEOUT_INT_MASK);
 1183 62DAFD            mov REG[0xda],-3
 1186                   .dbline -2
 1186           L391:
 1186 18                pop A
 1187 60D0              mov REG[208],A
 1189 18                pop A
 118A                   .dbline 0 ; func end
 118A 7E                reti
 118B                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _SERVO_ID::
 0000 00                .byte 0
 0001                   .dbsym e SERVO_ID _SERVO_ID c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_ERROR::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_ERROR _COMMAND_ERROR c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_LENGTH::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_LENGTH _COMMAND_LENGTH c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_PARAM::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_PARAM _COMMAND_PARAM c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _CONFIGURED::
 0000 0000              .byte 0,0
 0002                   .dbsym e CONFIGURED _CONFIGURED I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _ID::
 0000 00                .byte 0
 0001                   .dbsym e ID _ID c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _CHILD::
 0000 00                .byte 0
 0001                   .dbsym e CHILD _CHILD c
