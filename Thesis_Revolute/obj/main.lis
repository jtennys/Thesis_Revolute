 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 160
 0000           ; // Author: Jason Tennyson
 0000           ; // Date: 3-18-11
 0000           ; // File: main.c
 0000           ; //
 0000           ; // This is the design for the revolute modules for Jason Tennyson's Thesis.
 0000           ; // This design is made for a PSoC CY8C28433-24PVXI.
 0000           ; //
 0000           ; // Controller Packet Structure (each field is a byte)
 0000           ; // -----------------------------------------------------
 0000           ; // All Packets:
 0000           ; // START BYTE/START BYTE/SOURCE ID/DESTINATION ID/COMMAND TYPE/PARAM 1/.../PARAM N/END TRANSMIT
 0000           ; //
 0000           ; // Servo Packet Structure (each field is a byte)
 0000           ; // -----------------------------------------------------
 0000           ; // Source Packets:
 0000           ; // START BYTE/START BYTE/DESTINATION ID/LENGTH/COMMAND TYPE/PARAM 1/.../PARAM N/CHECKSUM
 0000           ; //
 0000           ; // Return Packets:
 0000           ; // START BYTE/START BYTE/SOURCE ID/LENGTH/ERROR/PARAM1/.../PARAM N/CHECKSUM
 0000           ; 
 0000           ; #include <m8c.h>              // Part-specific constants and macros.
 0000           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules.
 0000           ; #include "psocdynamic.h"      // Required for dynamically swapping configurations at run time.
 0000           ; 
 0000           ; // These are declarations of all of the timer interrupts that are used for all configurations.
 0000           ; #pragma interrupt_handler TX_01234_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_1_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_2_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_3_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_4_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler HELLO_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler INIT_TIMEOUT_ISR
 0000           ; 
 0000           ; // These defines are used as parameters of the configToggle function. Passing one of
 0000           ; // these identifiers to configToggle will put the chip in that device configuration.
 0000           ; #define               WAIT                                            (1)
 0000           ; #define               MY_RESPONSE                                     (2)
 0000           ; #define       RESPONSE_1                                      (3)
 0000           ; #define       RESPONSE_2                                      (4)
 0000           ; #define       RESPONSE_3                                      (5)
 0000           ; #define       RESPONSE_4                                      (6)
 0000           ; #define               HELLO_MODE                                      (7)
 0000           ; #define               INITIALIZE                                      (8)
 0000           ; #define               SERVO_COMM                                      (9)
 0000           ; 
 0000           ; // These defines are used as comparisons to find what port the next module connected to.
 0000           ; #define               PORT_1                                          ('1')
 0000           ; #define               PORT_2                                          ('2')
 0000           ; #define               PORT_3                                          ('3')
 0000           ; #define               PORT_4                                          ('4')
 0000           ; 
 0000           ; // Module Type
 0000           ; #define               TYPE                                            (1)
 0000           ; 
 0000           ; // These defines are used as transmission indicators for transmissions between PSoC controllers.
 0000           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0000           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0000           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0000           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0000           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is complete.
 0000           ; #define               PING                                            (203)   // Indicates a ping message to or from the master.
 0000           ; #define               CLEAR_CONFIG                            (204)   // Indicates that the master is asking for a config clear.
 0000           ; #define               CONFIG_CLEARED                          (205)   // Indicates that a module has cleared its own config.
 0000           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0000           ; #define               DEFAULT_ID                                      (251)   // The ID that all modules start with.
 0000           ; #define               BROADCAST                                       (254)   // The broadcast ID for all controllers and servos.
 0000           ; 
 0000           ; // SERVO DEFINES
 0000           ; // These numbers can all be found in the AX-12+ datasheet.
 0000           ; // These defines cover the range of IDs these servos are capable of.
 0000           ; #define               SERVO_ID_MIN                            (0)             // This is the lowest servo ID possible.
 0000           ; #define               SERVO_ID_MAX                            (253)   // This is the highest servo ID possible.
 0000           ; // These defines are servo transmission indicators.
 0000           ; #define               SERVO_START                                     (255)   // This is the start byte for a servo transmission.
 0000           ; // These defines are used to fill in the length parameter for a given command type. These are the only
 0000           ; // lengths used by this controller for servo configuration purposes. It is worth noting that any type
 0000           ; // and length of command can be issued from the master after configuration is complete.
 0000           ; #define               READ_LENGTH                                     (4)             // This is the length value for all reads.
 0000           ; #define               WRITE_LENGTH                            (4)             // This is the length value for all writes.
 0000           ; #define               PING_LENGTH                                     (2)             // This is the length value for a ping.
 0000           ; #define               RESET_LENGTH                            (2)             // This is the length value for a reset.
 0000           ; // These defines are used to fill in the servo's EEPROM address parameter for a given command type.
 0000           ; #define               ID_ADDRESS                                      (3)             // This is the address where servo ID is stored.
 0000           ; #define               STATUS_RET_ADDRESS                      (16)    // This is where the status return level is stored.
 0000           ; // These defines are used to fill in the instruction we are using on the servo.
 0000           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0000           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0000           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0000           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0000           ; // These defines cover all of the status return level possibilities.
 0000           ; #define               STATUS_RET_NEVER                        (0)             // Only respond to ping commands.
 0000           ; #define               STATUS_RET_READ                         (1)             // Only respond to read data commands (recommended).
 0000           ; #define               STATUS_RET_ALL                          (2)             // Respond to every command.
 0000           ; 
 0000           ; // This is the status return level, which is set to one of the possible status return values above.
 0000           ; // We want the status return level to be return on read commands only so that we don't have garbage
 0000           ; // return packets flying around every time we tell the servo to move.
 0000           ; #define               STATUS_RET_LEVEL                        (STATUS_RET_READ)
 0000           ; 
 0000           ; // This is the number of attempts we make to contact the servo per sweep of attempts before
 0000           ; // writing to its EEPROM in an attempt to alter settings that keep us from communicating.
 0000           ; #define               SERVO_COMM_ATTEMPTS                     (10)
 0000           ; // This is the number of times we do a loop of SERVO_COMM_ATTEMPTS. We would like this to be at least 2.
 0000           ; // This is because we do an EEPROM write after the first unsuccessful loop of SERVO_COMM_ATTEMPTS.
 0000           ; // If we don't then do at least one more loop, the EEPROM write was done for no reason.
 0000           ; #define               SERVO_COMM_LOOPS                        (2)
 0000           ; // This is the number of timeout periods to wait through while the servo boots up (2 ms per period).
 0000           ; #define               SERVO_BOOT_TIMEOUTS                     (75)
 0000           ; 
 0000           ; // This function receives a mode identifier as a parameter and toggles the system configuration.
 0000           ; void configToggle(int mode);
 0000           ; // This function unloads all configurations. This should only be needed at startup.
 0000           ; void unloadAllConfigs(void);
 0000           ; // This function unloads the configuration corresponding to the number passed to it.
 0000           ; void unloadConfig(int config_num);
 0000           ; // This function is a response to the master sending out a hello message.
 0000           ; void sayHello(void);
 0000           ; // This function looks for commands and returns 1 if a command has been read, 0 if not.
 0000           ; int commandReady(void);
 0000           ; // This function interprets the command that has just been read and performs an action accordingly.
 0000           ; void takeAction(void);
 0000           ; // This function responds to a ping.
 0000           ; void pingResponse(void);
 0000           ; // This function tells the master node that an ID assignment was completed on this module.
 0000           ; void assignedID(void);
 0000           ; // This function listens for children and registers the port that they talk to.
 0000           ; int childListen(void);
 0000           ; // This function waits for a known child's response to a command to that child from the master.
 0000           ; int childResponse(void);
 0000           ; // This function does everything it can to find the servo attached to this controller.
 0000           ; void servoFinder(void);
 0000           ; // This function carries out the passed servo instruction.
 0000           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0000           ; // This function does a simple for loop to stall and make doubly sure that the transmission finished.
 0000           ; // It is meant to be used as a definite amount of wait time after the transmission complete flag is set.
 0000           ; void xmitWait(void);
 0000           ; // This function is called to do nothing while we wait for the servo to boot up.
 0000           ; void servoBootWait(void);
 0000           ; // This function is used to wait for other controllers to find their servos while not
 0000           ; // driving any pins (which would keep a child from talking to its servo).
 0000           ; void servoConfigWait(void);
 0000           ; 
 0000           ; char CHILD;           // Keeps track of where the child is connected.
 0000           ; char ID;              // Stores the ID that the master gives this module.
 0000           ; 
 0000           ; int CONFIGURED;       // Keeps track of whether or not this module has been configured by the master.
 0000           ; int TIMEOUT;  // This flag is set if a timeout occurs.
 0000           ; int STATE;            // This stores the ID of the currently-loaded configuration.
 0000           ; 
 0000           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0000           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0000           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0000           ; char COMMAND_PARAM;                   // Stores a parameter that accompanies the command (if any).
 0000           ; char COMMAND_LENGTH;          // Stores the length parameter of a servo command.
 0000           ; char COMMAND_ERROR;                   // Stores the error code of a servo command.
 0000           ; 
 0000           ; char SERVO_ID;                                // Stores the ID of the servo inside of this module.
 0000           ; 
 0000           ; void main(void)
 0000           ; {     
 0000                   .dbline 162
 0000           ;       // Initial value assignment for variables of importance.
 0000           ;       CHILD = 0;                              // There is no child yet.
 0000 62D000            mov REG[0xd0],>_CHILD
 0003 550000            mov [_CHILD],0
 0006                   .dbline 163
 0006           ;       CONFIGURED = 0;                 // This module is not configured yet.
 0006 62D000            mov REG[0xd0],>_CONFIGURED
 0009 550100            mov [_CONFIGURED+1],0
 000C 550000            mov [_CONFIGURED],0
 000F                   .dbline 164
 000F           ;       TIMEOUT = 0;                    // Set the timeout flag low to start.
 000F 62D000            mov REG[0xd0],>_TIMEOUT
 0012 550100            mov [_TIMEOUT+1],0
 0015 550000            mov [_TIMEOUT],0
 0018                   .dbline 165
 0018           ;       COMMAND_PARAM = 0;              // There is no parameter yet.
 0018 62D000            mov REG[0xd0],>_COMMAND_PARAM
 001B 550000            mov [_COMMAND_PARAM],0
 001E                   .dbline 166
 001E           ;       STATE = 0;                              // There is no state yet.
 001E 62D000            mov REG[0xd0],>_STATE
 0021 550100            mov [_STATE+1],0
 0024 550000            mov [_STATE],0
 0027                   .dbline 167
 0027           ;       ID = DEFAULT_ID;                // Set the ID of this controller to the default to start with.
 0027 62D000            mov REG[0xd0],>_ID
 002A 5500FB            mov [_ID],-5
 002D                   .dbline 169
 002D           ; 
 002D           ;       M8C_EnableGInt;                 // Turn on global interrupts for the transmission timeout timer.
 002D 7101                      or  F, 01h
 002F           
 002F                   .dbline 171
 002F           ;       
 002F           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); // Activate GPIO ISR
 002F 43E020            or REG[0xe0],32
 0032                   .dbline 174
 0032           ;       
 0032           ;       // We have to wait for the servo to power up and get ready for communications.
 0032           ;       servoBootWait();
 0032 7C0FB2            xcall _servoBootWait
 0035                   .dbline 177
 0035           ;       
 0035           ;       // Find the servo that is inside of this module.
 0035           ;       servoFinder();
 0035 7C0CF0            xcall _servoFinder
 0038 8012              xjmp L3
 003A           L2:
 003A                   .dbline 181
 003A           ;       
 003A           ;       // Loop and wait for commands.
 003A           ;       while(1)
 003A           ;       {       
 003A                   .dbline 182
 003A           ;               if(commandReady())
 003A 9282              xcall _commandReady
 003C 62D000            mov REG[0xd0],>__r0
 003F 3C0000            cmp [__r0],0
 0042 B006              jnz X1
 0044 3C0000            cmp [__r1],0
 0047 A003              jz L5
 0049           X1:
 0049                   .dbline 183
 0049           ;               {
 0049                   .dbline 185
 0049           ;                       // If the command is ready, take action.
 0049           ;                       takeAction();
 0049 97AE              xcall _takeAction
 004B                   .dbline 186
 004B           ;               }
 004B           L5:
 004B                   .dbline 187
 004B           ;       }
 004B           L3:
 004B                   .dbline 180
 004B 8FEE              xjmp L2
 004D           X0:
 004D                   .dbline -2
 004D           L1:
 004D                   .dbline 0 ; func end
 004D 8FFF              jmp .
 004F                   .dbend
 004F                   .dbfunc e sayHello _sayHello fV
 004F           _sayHello::
 004F                   .dbline -1
 004F                   .dbline 192
 004F           ; }
 004F           ; 
 004F           ; // This function transmits a response to a hello command from the master.
 004F           ; void sayHello(void)
 004F           ; {     
 004F                   .dbline 193
 004F           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 004F 5000              mov A,0
 0051 08                push A
 0052 5002              mov A,2
 0054 08                push A
 0055 905D              xcall _configToggle
 0057 38FE              add SP,-2
 0059                   .dbline 196
 0059           ;       
 0059           ;       // Transmit a hello response to the master node.
 0059           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 0059 10                push X
 005A 50FC              mov A,-4
 005C 7C0000            xcall _TX_014_PutChar
 005F 20                pop X
 0060                   .dbline 197
 0060           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 0060 10                push X
 0061 50FC              mov A,-4
 0063 7C0000            xcall _TX_014_PutChar
 0066 20                pop X
 0067                   .dbline 198
 0067           ;       TX_014_PutChar(ID);                             // My ID (source)
 0067 10                push X
 0068 62D000            mov REG[0xd0],>_ID
 006B 5100              mov A,[_ID]
 006D 7C0000            xcall _TX_014_PutChar
 0070 20                pop X
 0071                   .dbline 199
 0071           ;       TX_014_PutChar(MASTER_ID);              // Master ID (destination)
 0071 10                push X
 0072 5000              mov A,0
 0074 7C0000            xcall _TX_014_PutChar
 0077 20                pop X
 0078                   .dbline 200
 0078           ;       TX_014_PutChar(HELLO_BYTE);             // This is a hello command.
 0078 10                push X
 0079 50C8              mov A,-56
 007B 7C0000            xcall _TX_014_PutChar
 007E 20                pop X
 007F                   .dbline 201
 007F           ;       TX_014_PutChar(CHILD);                  // Sends child port value, default 0.
 007F 10                push X
 0080 62D000            mov REG[0xd0],>_CHILD
 0083 5100              mov A,[_CHILD]
 0085 7C0000            xcall _TX_014_PutChar
 0088 20                pop X
 0089                   .dbline 202
 0089           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission.
 0089 10                push X
 008A 50FD              mov A,-3
 008C 7C0000            xcall _TX_014_PutChar
 008F 20                pop X
 0090                   .dbline 203
 0090           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission.
 0090 10                push X
 0091 50FD              mov A,-3
 0093 7C0000            xcall _TX_014_PutChar
 0096 20                pop X
 0097           L8:
 0097                   .dbline 206
 0097           ;       
 0097           ;       // Wait for the transmission to finish.
 0097           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0097           L9:
 0097                   .dbline 206
 0097 10                push X
 0098 7C0000            xcall _TX_014_bReadTxStatus
 009B 62D000            mov REG[0xd0],>__r0
 009E 20                pop X
 009F 5300              mov [__r0],A
 00A1 470020            tst [__r0],32
 00A4 AFF2              jz L8
 00A6                   .dbline 209
 00A6           ;       
 00A6           ;       // Make completely sure we're done.
 00A6           ;       xmitWait();
 00A6 7C0F93            xcall _xmitWait
 00A9                   .dbline 211
 00A9           ; 
 00A9           ;       configToggle(WAIT);                             // Switch back to wait mode.
 00A9 5000              mov A,0
 00AB 08                push A
 00AC 5001              mov A,1
 00AE 08                push A
 00AF 9003              xcall _configToggle
 00B1 38FE              add SP,-2
 00B3                   .dbline -2
 00B3           L7:
 00B3                   .dbline 0 ; func end
 00B3 7F                ret
 00B4                   .dbend
 00B4                   .dbfunc e configToggle _configToggle fV
 00B4           ;           mode -> X-5
 00B4           _configToggle::
 00B4                   .dbline -1
 00B4 10                push X
 00B5 4F                mov X,SP
 00B6                   .dbline 217
 00B6           ; }
 00B6           ; 
 00B6           ; // This function receives a mode flag and switches the microcontroller to the
 00B6           ; // desired hardware configuration.
 00B6           ; void configToggle(int mode)
 00B6           ; {     
 00B6                   .dbline 220
 00B6           ;       // Set the pins high and disconnect from the global bus.
 00B6           ;       // This helps keep false start bits from happening while we swap configs.
 00B6           ;       PRT0DR |= 0b00011111;   // Set pins P00 through P04 high.
 00B6 43001F            or REG[0],31
 00B9                   .dbline 221
 00B9           ;       PRT0GS &= 0b11100000;   // Disconnect pins P00 through P04 from the global bus.
 00B9 4102E0            and REG[0x2],-32
 00BC                   .dbline 225
 00BC           ;       
 00BC           ;       // Unload the configuration of the current state.
 00BC           ;       // If there is no state, blindly wipe all configurations.
 00BC           ;       if(STATE)
 00BC 62D000            mov REG[0xd0],>_STATE
 00BF 3C0000            cmp [_STATE],0
 00C2 B006              jnz X2
 00C4 3C0100            cmp [_STATE+1],0
 00C7 A011              jz L12
 00C9           X2:
 00C9                   .dbline 226
 00C9           ;       {
 00C9                   .dbline 227
 00C9           ;               unloadConfig(STATE);
 00C9 62D000            mov REG[0xd0],>_STATE
 00CC 5100              mov A,[_STATE]
 00CE 08                push A
 00CF 5101              mov A,[_STATE+1]
 00D1 08                push A
 00D2 7C0A88            xcall _unloadConfig
 00D5 38FE              add SP,-2
 00D7                   .dbline 228
 00D7           ;       }
 00D7 8004              xjmp L13
 00D9           L12:
 00D9                   .dbline 230
 00D9           ;       else
 00D9           ;       {
 00D9                   .dbline 231
 00D9           ;               unloadAllConfigs();
 00D9 7C0A6C            xcall _unloadAllConfigs
 00DC                   .dbline 232
 00DC           ;       }
 00DC           L13:
 00DC                   .dbline 236
 00DC           ;       
 00DC           ;       // Go through the list of possible modes until we find the one that was passed in to us.
 00DC           ;       // Then, load that configuration and initialize whatever needs to be initialized.
 00DC           ;       if(mode == WAIT)
 00DC 3DFB00            cmp [X-5],0
 00DF B022              jnz L14
 00E1 3DFC01            cmp [X-4],1
 00E4 B01D              jnz L14
 00E6           X3:
 00E6                   .dbline 237
 00E6           ;       {
 00E6                   .dbline 240
 00E6           ;               // Load the wait receiver configuration. This is the receiver configuration used after
 00E6           ;               // initialization is complete. It listens and forwards everything it hears.
 00E6           ;               LoadConfig_waiting();
 00E6 7C0000            xcall _LoadConfig_waiting
 00E9                   .dbline 243
 00E9           ;               
 00E9           ;               // Start the receivers.
 00E9           ;               WAIT_RECV_Start(WAIT_RECV_PARITY_NONE);
 00E9 10                push X
 00EA 5000              mov A,0
 00EC 7C0000            xcall _WAIT_RECV_Start
 00EF 20                pop X
 00F0                   .dbline 244
 00F0           ;               RX8_2_Start(RX8_2_PARITY_NONE);
 00F0 10                push X
 00F1 5000              mov A,0
 00F3 7C0000            xcall _RX8_2_Start
 00F6 20                pop X
 00F7                   .dbline 247
 00F7           ;               
 00F7           ;               // Set the current state.
 00F7           ;               STATE = WAIT;
 00F7 62D000            mov REG[0xd0],>_STATE
 00FA 550101            mov [_STATE+1],1
 00FD 550000            mov [_STATE],0
 0100                   .dbline 248
 0100           ;       }
 0100 81A0              xjmp L15
 0102           L14:
 0102                   .dbline 249
 0102           ;       else if(mode == MY_RESPONSE)
 0102 3DFB00            cmp [X-5],0
 0105 B04C              jnz L16
 0107 3DFC02            cmp [X-4],2
 010A B047              jnz L16
 010C           X4:
 010C                   .dbline 250
 010C           ;       {
 010C                   .dbline 252
 010C           ;               // Load the transmitter configuration. This is for transmitting messages on all ports.
 010C           ;               LoadConfig_my_response();
 010C 7C0000            xcall _LoadConfig_my_response
 010F                   .dbline 255
 010F           ;               
 010F           ;               // Clear the timeout flag.
 010F           ;               TIMEOUT = 0;
 010F 62D000            mov REG[0xd0],>_TIMEOUT
 0112 550100            mov [_TIMEOUT+1],0
 0115 550000            mov [_TIMEOUT],0
 0118                   .dbline 258
 0118           ;               
 0118           ;               // Start the transmitters.
 0118           ;               TX_014_Start(TX_014_PARITY_NONE);       // Transmits on P00, P01, and P04.
 0118 10                push X
 0119 5000              mov A,0
 011B 7C0000            xcall _TX_014_Start
 011E 20                pop X
 011F                   .dbline 259
 011F           ;               TX_23_Start(TX_23_PARITY_NONE);         // Transmits on P02 and P03.
 011F 10                push X
 0120 5000              mov A,0
 0122 7C0000            xcall _TX_23_Start
 0125                   .dbline 261
 0125           ;               
 0125           ;               TX_01234_TIMEOUT_EnableInt();           // Make sure interrupts are enabled.
 0125 7C0000            xcall _TX_01234_TIMEOUT_EnableInt
 0128                   .dbline 262
 0128           ;               TX_01234_TIMEOUT_Start();                       // Start the timer.
 0128 7C0000            xcall _TX_01234_TIMEOUT_Start
 012B 20                pop X
 012C           L18:
 012C                   .dbline 266
 012C           ;               
 012C           ;               // Do nothing while we wait for one timeout period (1 ms).
 012C           ;               // This is to allow everyone to get in the right configuration before talking.
 012C           ;               while(!TIMEOUT) { }
 012C                   .dbline 266
 012C           L19:
 012C                   .dbline 266
 012C 62D000            mov REG[0xd0],>_TIMEOUT
 012F 3C0000            cmp [_TIMEOUT],0
 0132 B006              jnz X5
 0134 3C0100            cmp [_TIMEOUT+1],0
 0137 AFF4              jz L18
 0139           X5:
 0139                   .dbline 268
 0139           ;               
 0139           ;               TX_01234_TIMEOUT_Stop();                        // Stop the timer.
 0139 10                push X
 013A 7C0000            xcall _TX_01234_TIMEOUT_Stop
 013D 20                pop X
 013E                   .dbline 269
 013E           ;               TIMEOUT = 0;                                            // Reset the timeout flag.
 013E 62D000            mov REG[0xd0],>_TIMEOUT
 0141 550100            mov [_TIMEOUT+1],0
 0144 550000            mov [_TIMEOUT],0
 0147                   .dbline 272
 0147           ;       
 0147           ;               // Set the current state.
 0147           ;               STATE = MY_RESPONSE;
 0147 62D000            mov REG[0xd0],>_STATE
 014A 550102            mov [_STATE+1],2
 014D 550000            mov [_STATE],0
 0150                   .dbline 273
 0150           ;       }
 0150 8150              xjmp L17
 0152           L16:
 0152                   .dbline 274
 0152           ;       else if(mode == RESPONSE_1)
 0152 3DFB00            cmp [X-5],0
 0155 B02A              jnz L21
 0157 3DFC03            cmp [X-4],3
 015A B025              jnz L21
 015C           X6:
 015C                   .dbline 275
 015C           ;       {
 015C                   .dbline 277
 015C           ;               // Load the response wait on port 1.
 015C           ;               LoadConfig_response1();
 015C 7C0000            xcall _LoadConfig_response1
 015F                   .dbline 280
 015F           ;               
 015F           ;               // Clear the timeout flag.
 015F           ;               TIMEOUT = 0;
 015F 62D000            mov REG[0xd0],>_TIMEOUT
 0162 550100            mov [_TIMEOUT+1],0
 0165 550000            mov [_TIMEOUT],0
 0168                   .dbline 283
 0168           ;               
 0168           ;               // Start listening for a response through child port 1.
 0168           ;               CHILD_1_Start(CHILD_1_PARITY_NONE);
 0168 10                push X
 0169 5000              mov A,0
 016B 7C0000            xcall _CHILD_1_Start
 016E                   .dbline 285
 016E           ;               
 016E           ;               CHILD_1_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 016E 7C0000            xcall _CHILD_1_TIMEOUT_EnableInt
 0171                   .dbline 286
 0171           ;               CHILD_1_TIMEOUT_Start();                        // Start the timer.
 0171 7C0000            xcall _CHILD_1_TIMEOUT_Start
 0174 20                pop X
 0175                   .dbline 289
 0175           ;               
 0175           ;               // Set the current state.
 0175           ;               STATE = RESPONSE_1;
 0175 62D000            mov REG[0xd0],>_STATE
 0178 550103            mov [_STATE+1],3
 017B 550000            mov [_STATE],0
 017E                   .dbline 290
 017E           ;       }
 017E 8122              xjmp L22
 0180           L21:
 0180                   .dbline 291
 0180           ;       else if(mode == RESPONSE_2)
 0180 3DFB00            cmp [X-5],0
 0183 B02A              jnz L23
 0185 3DFC04            cmp [X-4],4
 0188 B025              jnz L23
 018A           X7:
 018A                   .dbline 292
 018A           ;       {
 018A                   .dbline 294
 018A           ;               // Load the response wait on port 2.
 018A           ;               LoadConfig_response2();
 018A 7C0000            xcall _LoadConfig_response2
 018D                   .dbline 297
 018D           ;               
 018D           ;               // Clear the timeout flag.
 018D           ;               TIMEOUT = 0;
 018D 62D000            mov REG[0xd0],>_TIMEOUT
 0190 550100            mov [_TIMEOUT+1],0
 0193 550000            mov [_TIMEOUT],0
 0196                   .dbline 300
 0196           ;               
 0196           ;               // Start listening for a response through child port 2.
 0196           ;               CHILD_2_Start(CHILD_2_PARITY_NONE);
 0196 10                push X
 0197 5000              mov A,0
 0199 7C0000            xcall _CHILD_2_Start
 019C                   .dbline 302
 019C           ;               
 019C           ;               CHILD_2_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 019C 7C0000            xcall _CHILD_2_TIMEOUT_EnableInt
 019F                   .dbline 303
 019F           ;               CHILD_2_TIMEOUT_Start();                        // Start the timer.
 019F 7C0000            xcall _CHILD_2_TIMEOUT_Start
 01A2 20                pop X
 01A3                   .dbline 306
 01A3           ;               
 01A3           ;               // Set the current state.
 01A3           ;               STATE = RESPONSE_2;
 01A3 62D000            mov REG[0xd0],>_STATE
 01A6 550104            mov [_STATE+1],4
 01A9 550000            mov [_STATE],0
 01AC                   .dbline 307
 01AC           ;       }
 01AC 80F4              xjmp L24
 01AE           L23:
 01AE                   .dbline 308
 01AE           ;       else if(mode == RESPONSE_3)
 01AE 3DFB00            cmp [X-5],0
 01B1 B02A              jnz L25
 01B3 3DFC05            cmp [X-4],5
 01B6 B025              jnz L25
 01B8           X8:
 01B8                   .dbline 309
 01B8           ;       {
 01B8                   .dbline 311
 01B8           ;               // Load the response wait on port 3.
 01B8           ;               LoadConfig_response3();
 01B8 7C0000            xcall _LoadConfig_response3
 01BB                   .dbline 314
 01BB           ;               
 01BB           ;               // Clear the timeout flag.
 01BB           ;               TIMEOUT = 0;
 01BB 62D000            mov REG[0xd0],>_TIMEOUT
 01BE 550100            mov [_TIMEOUT+1],0
 01C1 550000            mov [_TIMEOUT],0
 01C4                   .dbline 317
 01C4           ;               
 01C4           ;               // Start listening for a response through child port 3.
 01C4           ;               CHILD_3_Start(CHILD_3_PARITY_NONE);
 01C4 10                push X
 01C5 5000              mov A,0
 01C7 7C0000            xcall _CHILD_3_Start
 01CA                   .dbline 319
 01CA           ;               
 01CA           ;               CHILD_3_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 01CA 7C0000            xcall _CHILD_3_TIMEOUT_EnableInt
 01CD                   .dbline 320
 01CD           ;               CHILD_3_TIMEOUT_Start();                        // Start the timer.
 01CD 7C0000            xcall _CHILD_3_TIMEOUT_Start
 01D0 20                pop X
 01D1                   .dbline 323
 01D1           ;               
 01D1           ;               // Set the current state.
 01D1           ;               STATE = RESPONSE_3;
 01D1 62D000            mov REG[0xd0],>_STATE
 01D4 550105            mov [_STATE+1],5
 01D7 550000            mov [_STATE],0
 01DA                   .dbline 324
 01DA           ;       }
 01DA 80C6              xjmp L26
 01DC           L25:
 01DC                   .dbline 325
 01DC           ;       else if(mode == RESPONSE_4)
 01DC 3DFB00            cmp [X-5],0
 01DF B02A              jnz L27
 01E1 3DFC06            cmp [X-4],6
 01E4 B025              jnz L27
 01E6           X9:
 01E6                   .dbline 326
 01E6           ;       {
 01E6                   .dbline 328
 01E6           ;               // Load the response wait on port 4.
 01E6           ;               LoadConfig_response4();
 01E6 7C0000            xcall _LoadConfig_response4
 01E9                   .dbline 331
 01E9           ;               
 01E9           ;               // Clear the timeout flag.
 01E9           ;               TIMEOUT = 0;
 01E9 62D000            mov REG[0xd0],>_TIMEOUT
 01EC 550100            mov [_TIMEOUT+1],0
 01EF 550000            mov [_TIMEOUT],0
 01F2                   .dbline 334
 01F2           ;               
 01F2           ;               // Start listening for a response through child port 4.
 01F2           ;               CHILD_4_Start(CHILD_4_PARITY_NONE);
 01F2 10                push X
 01F3 5000              mov A,0
 01F5 7C0000            xcall _CHILD_4_Start
 01F8                   .dbline 336
 01F8           ;               
 01F8           ;               CHILD_4_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 01F8 7C0000            xcall _CHILD_4_TIMEOUT_EnableInt
 01FB                   .dbline 337
 01FB           ;               CHILD_4_TIMEOUT_Start();                        // Start the timer.
 01FB 7C0000            xcall _CHILD_4_TIMEOUT_Start
 01FE 20                pop X
 01FF                   .dbline 340
 01FF           ;               
 01FF           ;               // Set the current state.
 01FF           ;               STATE = RESPONSE_4;
 01FF 62D000            mov REG[0xd0],>_STATE
 0202 550106            mov [_STATE+1],6
 0205 550000            mov [_STATE],0
 0208                   .dbline 341
 0208           ;       }
 0208 8098              xjmp L28
 020A           L27:
 020A                   .dbline 342
 020A           ;       else if(mode == HELLO_MODE)
 020A 3DFB00            cmp [X-5],0
 020D B03F              jnz L29
 020F 3DFC07            cmp [X-4],7
 0212 B03A              jnz L29
 0214           X10:
 0214                   .dbline 343
 0214           ;       {
 0214                   .dbline 345
 0214           ;               // Load the hello wait mode. This is for listening on all ports for a hello response.
 0214           ;               LoadConfig_hello();
 0214 7C0000            xcall _LoadConfig_hello
 0217                   .dbline 348
 0217           ;               
 0217           ;               // Clear the timeout flag.
 0217           ;               TIMEOUT = 0;
 0217 62D000            mov REG[0xd0],>_TIMEOUT
 021A 550100            mov [_TIMEOUT+1],0
 021D 550000            mov [_TIMEOUT],0
 0220                   .dbline 352
 0220           ;               
 0220           ;               // The seemingly unnecessary brackets around each line are unfortunately needed.
 0220           ;       
 0220           ;               {
 0220                   .dbline 354
 0220           ;               // Start listening for a response through child port 1.
 0220           ;               HELLO_1_Start(HELLO_1_PARITY_NONE);
 0220 10                push X
 0221 5000              mov A,0
 0223 7C0000            xcall _HELLO_1_Start
 0226 20                pop X
 0227                   .dbline 355
 0227           ;               }
 0227                   .dbline 357
 0227           ;               
 0227           ;               {
 0227                   .dbline 359
 0227           ;               // Start listening for a response through child port 2.
 0227           ;               HELLO_2_Start(HELLO_2_PARITY_NONE);
 0227 10                push X
 0228 5000              mov A,0
 022A 7C0000            xcall _HELLO_2_Start
 022D 20                pop X
 022E                   .dbline 360
 022E           ;               }
 022E                   .dbline 362
 022E           ;               
 022E           ;               {
 022E                   .dbline 364
 022E           ;               // Start listening for a response through child port 3.
 022E           ;               HELLO_3_Start(HELLO_3_PARITY_NONE);
 022E 10                push X
 022F 5000              mov A,0
 0231 7C0000            xcall _HELLO_3_Start
 0234 20                pop X
 0235                   .dbline 365
 0235           ;               }
 0235                   .dbline 367
 0235           ;               
 0235           ;               {
 0235                   .dbline 369
 0235           ;               // Start listening for a response through child port 4.
 0235           ;               HELLO_4_Start(HELLO_4_PARITY_NONE);
 0235 10                push X
 0236 5000              mov A,0
 0238 7C0000            xcall _HELLO_4_Start
 023B                   .dbline 370
 023B           ;               }
 023B                   .dbline 372
 023B           ;               
 023B           ;               HELLO_TIMEOUT_EnableInt();      // Make sure interrupts are enabled.
 023B 7C0000            xcall _HELLO_TIMEOUT_EnableInt
 023E                   .dbline 373
 023E           ;               HELLO_TIMEOUT_Start();          // Start the timer.
 023E 7C0000            xcall _HELLO_TIMEOUT_Start
 0241 20                pop X
 0242                   .dbline 376
 0242           ;               
 0242           ;               // Set the current state.
 0242           ;               STATE = HELLO_MODE;
 0242 62D000            mov REG[0xd0],>_STATE
 0245 550107            mov [_STATE+1],7
 0248 550000            mov [_STATE],0
 024B                   .dbline 377
 024B           ;       }
 024B 8055              xjmp L30
 024D           L29:
 024D                   .dbline 378
 024D           ;       else if(mode == INITIALIZE)
 024D 3DFB00            cmp [X-5],0
 0250 B02A              jnz L31
 0252 3DFC08            cmp [X-4],8
 0255 B025              jnz L31
 0257           X11:
 0257                   .dbline 379
 0257           ;       {
 0257                   .dbline 381
 0257           ;               // Load the configuration for initialization. This config listens but does not forward.
 0257           ;               LoadConfig_initial();
 0257 7C0000            xcall _LoadConfig_initial
 025A                   .dbline 384
 025A           ;               
 025A           ;               // Clear the timeout flag.
 025A           ;               TIMEOUT = 0;
 025A 62D000            mov REG[0xd0],>_TIMEOUT
 025D 550100            mov [_TIMEOUT+1],0
 0260 550000            mov [_TIMEOUT],0
 0263                   .dbline 387
 0263           ;               
 0263           ;               // Start the receiver.
 0263           ;               INIT_RX_Start(INIT_RX_PARITY_NONE);
 0263 10                push X
 0264 5000              mov A,0
 0266 7C0000            xcall _INIT_RX_Start
 0269                   .dbline 389
 0269           ;               
 0269           ;               INIT_TIMEOUT_EnableInt();       // Make sure interrupts are enabled.
 0269 7C0000            xcall _INIT_TIMEOUT_EnableInt
 026C                   .dbline 390
 026C           ;               INIT_TIMEOUT_Start();           // Start the timer.
 026C 7C0000            xcall _INIT_TIMEOUT_Start
 026F 20                pop X
 0270                   .dbline 393
 0270           ;               
 0270           ;               // Set the current state.
 0270           ;               STATE = INITIALIZE;
 0270 62D000            mov REG[0xd0],>_STATE
 0273 550108            mov [_STATE+1],8
 0276 550000            mov [_STATE],0
 0279                   .dbline 394
 0279           ;       }
 0279 8027              xjmp L32
 027B           L31:
 027B                   .dbline 395
 027B           ;       else if(mode == SERVO_COMM)
 027B 3DFB00            cmp [X-5],0
 027E B022              jnz L33
 0280 3DFC09            cmp [X-4],9
 0283 B01D              jnz L33
 0285           X12:
 0285                   .dbline 396
 0285           ;       {
 0285                   .dbline 398
 0285           ;               // Load the configuration for servo communication. This config only transmits on P00.
 0285           ;               LoadConfig_servo_transmit();
 0285 7C0000            xcall _LoadConfig_servo_transmit
 0288                   .dbline 401
 0288           ;               
 0288           ;               // Clear the timeout flag.
 0288           ;               TIMEOUT = 0;
 0288 62D000            mov REG[0xd0],>_TIMEOUT
 028B 550100            mov [_TIMEOUT+1],0
 028E 550000            mov [_TIMEOUT],0
 0291                   .dbline 404
 0291           ;               
 0291           ;               // Start the transmitter.
 0291           ;               SERVO_TX_Start(SERVO_TX_PARITY_NONE);
 0291 10                push X
 0292 5000              mov A,0
 0294 7C0000            xcall _SERVO_TX_Start
 0297 20                pop X
 0298                   .dbline 407
 0298           ;       
 0298           ;               // Set the current state.
 0298           ;               STATE = SERVO_COMM;
 0298 62D000            mov REG[0xd0],>_STATE
 029B 550109            mov [_STATE+1],9
 029E 550000            mov [_STATE],0
 02A1                   .dbline 408
 02A1           ;       }
 02A1           L33:
 02A1           L32:
 02A1           L30:
 02A1           L28:
 02A1           L26:
 02A1           L24:
 02A1           L22:
 02A1           L17:
 02A1           L15:
 02A1                   .dbline 411
 02A1           ;       
 02A1           ;       // If this module is configured, talk on all pins for potential children.
 02A1           ;       if(CONFIGURED)
 02A1 62D000            mov REG[0xd0],>_CONFIGURED
 02A4 3C0000            cmp [_CONFIGURED],0
 02A7 B006              jnz X13
 02A9 3C0100            cmp [_CONFIGURED+1],0
 02AC A009              jz L35
 02AE           X13:
 02AE                   .dbline 412
 02AE           ;       {
 02AE                   .dbline 413
 02AE           ;               PRT0GS |= 0b00011111;   // Connect all pins to the global bus.
 02AE 43021F            or REG[0x2],31
 02B1                   .dbline 414
 02B1           ;               PRT2DR &= 0b11111110;   // Turn on the LED (active low).
 02B1 4108FE            and REG[0x8],-2
 02B4                   .dbline 415
 02B4           ;       }
 02B4 8007              xjmp L36
 02B6           L35:
 02B6                   .dbline 417
 02B6           ;       else
 02B6           ;       {
 02B6                   .dbline 418
 02B6           ;               PRT0GS |= 0b00000001;   // Just connect pin 0;
 02B6 430201            or REG[0x2],1
 02B9                   .dbline 419
 02B9           ;               PRT2DR |= 0b00000001;   // Turn off the LED (active low).
 02B9 430801            or REG[0x8],1
 02BC                   .dbline 420
 02BC           ;       }
 02BC           L36:
 02BC                   .dbline -2
 02BC           L11:
 02BC 20                pop X
 02BD                   .dbline 0 ; func end
 02BD 7F                ret
 02BE                   .dbsym l mode -5 I
 02BE                   .dbend
 02BE                   .dbfunc e commandReady _commandReady fI
 02BE           ;   runningTotal -> X+3
 02BE           ;              i -> X+1
 02BE           ;       tempByte -> X+0
 02BE           _commandReady::
 02BE                   .dbline -1
 02BE 10                push X
 02BF 4F                mov X,SP
 02C0 3805              add SP,5
 02C2                   .dbline 427
 02C2           ; }
 02C2           ; 
 02C2           ; // This function checks the current hardware configuration state. Once it finds this state, it
 02C2           ; // uses the receivers that are in that configuration in the way they are intended to grab the
 02C2           ; // transmission information that we require (or just let commands pass through if we don't care).
 02C2           ; int commandReady(void)
 02C2           ; {
 02C2                   .dbline 428
 02C2           ;       int i = 0;                      // This integer is used for looping through the remaining bytes of commands.
 02C2 560200            mov [X+2],0
 02C5 560100            mov [X+1],0
 02C8                   .dbline 429
 02C8           ;       char tempByte = 0;      // This byte is used to store each byte for comparison as it comes in.
 02C8 560000            mov [X+0],0
 02CB                   .dbline 431
 02CB           ;       
 02CB           ;       int runningTotal = 0;   // This is used to check for a checksum in the case of a servo transmit.
 02CB 560400            mov [X+4],0
 02CE 560300            mov [X+3],0
 02D1                   .dbline 435
 02D1           ;       
 02D1           ;       // This conditional checks which configuration is loaded and uses the proper devices to
 02D1           ;       // read a transmission and store the important information from that transmission.
 02D1           ;       if(STATE == WAIT)
 02D1 62D000            mov REG[0xd0],>_STATE
 02D4 3C0000            cmp [_STATE],0
 02D7 B0D4              jnz L38
 02D9 3C0101            cmp [_STATE+1],1
 02DC B0CF              jnz L38
 02DE           X14:
 02DE                   .dbline 436
 02DE           ;       {       
 02DE                   .dbline 439
 02DE           ;               // In wait mode, the only thing that progresses things forward is a master node transmission.
 02DE           ;               // With this being the case, we use a blocking operation to sit and wait for a byte.
 02DE           ;               tempByte = WAIT_RECV_cGetChar();
 02DE 10                push X
 02DF 7C0000            xcall _WAIT_RECV_cGetChar
 02E2 62D000            mov REG[0xd0],>__r0
 02E5 20                pop X
 02E6 5400              mov [X+0],A
 02E8                   .dbline 442
 02E8           ;               
 02E8           ;               // If a transmission has started for either a controller or a servo...
 02E8           ;               if(tempByte == START_TRANSMIT)
 02E8 3D00FC            cmp [X+0],-4
 02EB B047              jnz L40
 02ED                   .dbline 443
 02ED           ;               {
 02ED 800B              xjmp L43
 02EF           L42:
 02EF                   .dbline 446
 02EF           ;                       // While we keep reading start bytes, sit and spin.
 02EF           ;                       while(tempByte == START_TRANSMIT)
 02EF           ;                       {
 02EF                   .dbline 447
 02EF           ;                               tempByte = WAIT_RECV_cGetChar();
 02EF 10                push X
 02F0 7C0000            xcall _WAIT_RECV_cGetChar
 02F3 62D000            mov REG[0xd0],>__r0
 02F6 20                pop X
 02F7 5400              mov [X+0],A
 02F9                   .dbline 448
 02F9           ;                       }
 02F9           L43:
 02F9                   .dbline 445
 02F9 3D00FC            cmp [X+0],-4
 02FC AFF2              jz L42
 02FE                   .dbline 451
 02FE           ;                       
 02FE           ;                       // The tempByte variable contains the source ID. If the source is good, store all bytes.
 02FE           ;                       if(tempByte == MASTER_ID)
 02FE 3D0000            cmp [X+0],0
 0301 B4EA              jnz L39
 0303                   .dbline 452
 0303           ;                       {
 0303                   .dbline 453
 0303           ;                               COMMAND_SOURCE = tempByte;
 0303 5200              mov A,[X+0]
 0305 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0308 5300              mov [_COMMAND_SOURCE],A
 030A                   .dbline 454
 030A           ;                               COMMAND_DESTINATION = WAIT_RECV_cGetChar();
 030A 10                push X
 030B 7C0000            xcall _WAIT_RECV_cGetChar
 030E 20                pop X
 030F 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0312 5300              mov [_COMMAND_DESTINATION],A
 0314                   .dbline 455
 0314           ;                               COMMAND_TYPE = WAIT_RECV_cGetChar();
 0314 10                push X
 0315 7C0000            xcall _WAIT_RECV_cGetChar
 0318 20                pop X
 0319 62D000            mov REG[0xd0],>_COMMAND_TYPE
 031C 5300              mov [_COMMAND_TYPE],A
 031E                   .dbline 456
 031E           ;                               COMMAND_PARAM = WAIT_RECV_cGetChar();
 031E 10                push X
 031F 7C0000            xcall _WAIT_RECV_cGetChar
 0322 20                pop X
 0323 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0326 5300              mov [_COMMAND_PARAM],A
 0328                   .dbline 458
 0328           ;                               
 0328           ;                               return 1;
 0328 62D000            mov REG[0xd0],>__r0
 032B 550001            mov [__r1],1
 032E 550000            mov [__r0],0
 0331 84C3              xjmp L37
 0333           L40:
 0333                   .dbline 461
 0333           ;                       }
 0333           ;               }
 0333           ;               else if(tempByte == SERVO_START)
 0333 3D00FF            cmp [X+0],-1
 0336 B4B5              jnz L39
 0338                   .dbline 462
 0338           ;               {
 0338 800B              xjmp L50
 033A           L49:
 033A                   .dbline 465
 033A           ;                       // While we keep reading start bytes, sit and spin.
 033A           ;                       while(tempByte == SERVO_START)
 033A           ;                       {
 033A                   .dbline 466
 033A           ;                               tempByte = WAIT_RECV_cGetChar();
 033A 10                push X
 033B 7C0000            xcall _WAIT_RECV_cGetChar
 033E 62D000            mov REG[0xd0],>__r0
 0341 20                pop X
 0342 5400              mov [X+0],A
 0344                   .dbline 467
 0344           ;                       }
 0344           L50:
 0344                   .dbline 464
 0344 3D00FF            cmp [X+0],-1
 0347 AFF2              jz L49
 0349                   .dbline 470
 0349           ;                       
 0349           ;                       // We assume (and hopefully rightly so) that this is a command from master.
 0349           ;                       COMMAND_SOURCE = MASTER_ID;
 0349 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 034C 550000            mov [_COMMAND_SOURCE],0
 034F                   .dbline 472
 034F           ;                       // The first parameter after the servo start is the destination.
 034F           ;                       COMMAND_DESTINATION = tempByte;
 034F 5200              mov A,[X+0]
 0351 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0354 5300              mov [_COMMAND_DESTINATION],A
 0356                   .dbline 477
 0356           ;                       // The second parameter after the servo start is the command length.
 0356           ;                       // We don't need it to wait for the transmission to go through since the
 0356           ;                       // transmission goes through the chip with a delay of approximately 100 ns
 0356           ;                       // (it is already in and out by the time you read this byte).
 0356           ;                       tempByte = WAIT_RECV_cGetChar();
 0356 10                push X
 0357 7C0000            xcall _WAIT_RECV_cGetChar
 035A 62D000            mov REG[0xd0],>__r0
 035D 20                pop X
 035E 5400              mov [X+0],A
 0360                   .dbline 480
 0360           ;                       // Now we store the command type. Depending on what the status return level
 0360           ;                       // is, we have special duties.
 0360           ;                       COMMAND_TYPE = WAIT_RECV_cGetChar();
 0360 10                push X
 0361 7C0000            xcall _WAIT_RECV_cGetChar
 0364 20                pop X
 0365 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0368 5300              mov [_COMMAND_TYPE],A
 036A                   .dbline 483
 036A           ;                       
 036A           ;                       // This basically waits for the rest of the command to pass through.
 036A           ;                       for(i = 0; i < (tempByte - 1); i++)
 036A 560200            mov [X+2],0
 036D 560100            mov [X+1],0
 0370 800E              xjmp L55
 0372           L52:
 0372                   .dbline 484
 0372           ;                       {
 0372                   .dbline 485
 0372           ;                               WAIT_RECV_cGetChar();
 0372 10                push X
 0373 7C0000            xcall _WAIT_RECV_cGetChar
 0376 62D000            mov REG[0xd0],>__r0
 0379 20                pop X
 037A                   .dbline 486
 037A           ;                       }
 037A           L53:
 037A                   .dbline 483
 037A 7702              inc [X+2]
 037C 0F0100            adc [X+1],0
 037F           L55:
 037F                   .dbline 483
 037F 62D000            mov REG[0xd0],>__r0
 0382 5200              mov A,[X+0]
 0384 5300              mov [__r1],A
 0386 550000            mov [__r0],0
 0389 160001            sub [__r1],1
 038C 1E0000            sbb [__r0],0
 038F 5202              mov A,[X+2]
 0391 1200              sub A,[__r1]
 0393 5100              mov A,[__r0]
 0395 3180              xor A,-128
 0397 5300              mov [__rX],A
 0399 5201              mov A,[X+1]
 039B 3180              xor A,-128
 039D 1A00              sbb A,[__rX]
 039F CFD2              jc L52
 03A1           X15:
 03A1                   .dbline 488
 03A1           ;                               
 03A1           ;                       return 1;
 03A1 62D000            mov REG[0xd0],>__r0
 03A4 550001            mov [__r1],1
 03A7 550000            mov [__r0],0
 03AA 844A              xjmp L37
 03AC           L38:
 03AC                   .dbline 491
 03AC           ;               }
 03AC           ;       }
 03AC           ;       else if(STATE == HELLO_MODE)
 03AC 62D000            mov REG[0xd0],>_STATE
 03AF 3C0000            cmp [_STATE],0
 03B2 B06E              jnz L56
 03B4 3C0107            cmp [_STATE+1],7
 03B7 B069              jnz L56
 03B9           X16:
 03B9                   .dbline 492
 03B9           ;       {
 03B9                   .dbline 494
 03B9           ;               // Check all of the ports for a start byte. Only one port will produce one.
 03B9           ;               if(HELLO_1_cReadChar() == START_TRANSMIT)
 03B9 10                push X
 03BA 7C0000            xcall _HELLO_1_cReadChar
 03BD 20                pop X
 03BE 39FC              cmp A,-4
 03C0 B012              jnz L58
 03C2                   .dbline 495
 03C2           ;               {               
 03C2                   .dbline 496
 03C2           ;                       CHILD = PORT_1;
 03C2 62D000            mov REG[0xd0],>_CHILD
 03C5 550031            mov [_CHILD],49
 03C8                   .dbline 498
 03C8           ;                       
 03C8           ;                       return 1;
 03C8 62D000            mov REG[0xd0],>__r0
 03CB 550001            mov [__r1],1
 03CE 550000            mov [__r0],0
 03D1 8423              xjmp L37
 03D3           L58:
 03D3                   .dbline 500
 03D3           ;               }
 03D3           ;               else if(HELLO_2_cReadChar() == START_TRANSMIT)
 03D3 10                push X
 03D4 7C0000            xcall _HELLO_2_cReadChar
 03D7 20                pop X
 03D8 39FC              cmp A,-4
 03DA B012              jnz L60
 03DC                   .dbline 501
 03DC           ;               {               
 03DC                   .dbline 502
 03DC           ;                       CHILD = PORT_2;
 03DC 62D000            mov REG[0xd0],>_CHILD
 03DF 550032            mov [_CHILD],50
 03E2                   .dbline 504
 03E2           ;                       
 03E2           ;                       return 1;
 03E2 62D000            mov REG[0xd0],>__r0
 03E5 550001            mov [__r1],1
 03E8 550000            mov [__r0],0
 03EB 8409              xjmp L37
 03ED           L60:
 03ED                   .dbline 506
 03ED           ;               }
 03ED           ;               else if(HELLO_3_cReadChar() == START_TRANSMIT)
 03ED 10                push X
 03EE 7C0000            xcall _HELLO_3_cReadChar
 03F1 20                pop X
 03F2 39FC              cmp A,-4
 03F4 B012              jnz L62
 03F6                   .dbline 507
 03F6           ;               {
 03F6                   .dbline 508
 03F6           ;                       CHILD = PORT_3;
 03F6 62D000            mov REG[0xd0],>_CHILD
 03F9 550033            mov [_CHILD],51
 03FC                   .dbline 510
 03FC           ;                       
 03FC           ;                       return 1;
 03FC 62D000            mov REG[0xd0],>__r0
 03FF 550001            mov [__r1],1
 0402 550000            mov [__r0],0
 0405 83EF              xjmp L37
 0407           L62:
 0407                   .dbline 512
 0407           ;               }
 0407           ;               else if(HELLO_4_cReadChar() == START_TRANSMIT)
 0407 10                push X
 0408 7C0000            xcall _HELLO_4_cReadChar
 040B 20                pop X
 040C 39FC              cmp A,-4
 040E B3DD              jnz L57
 0410                   .dbline 513
 0410           ;               {
 0410                   .dbline 514
 0410           ;                       CHILD = PORT_4;
 0410 62D000            mov REG[0xd0],>_CHILD
 0413 550034            mov [_CHILD],52
 0416                   .dbline 516
 0416           ;                       
 0416           ;                       return 1;
 0416 62D000            mov REG[0xd0],>__r0
 0419 550001            mov [__r1],1
 041C 550000            mov [__r0],0
 041F 83D5              xjmp L37
 0421           L56:
 0421                   .dbline 519
 0421           ;               }
 0421           ;       }
 0421           ;       else if(STATE == RESPONSE_1)
 0421 62D000            mov REG[0xd0],>_STATE
 0424 3C0000            cmp [_STATE],0
 0427 B0D2              jnz L66
 0429 3C0103            cmp [_STATE+1],3
 042C B0CD              jnz L66
 042E           X17:
 042E                   .dbline 520
 042E           ;       {
 042E                   .dbline 521
 042E           ;               if(tempByte = CHILD_1_cReadChar())
 042E 10                push X
 042F 7C0000            xcall _CHILD_1_cReadChar
 0432 62D000            mov REG[0xd0],>__r0
 0435 20                pop X
 0436 5400              mov [X+0],A
 0438 3900              cmp A,0
 043A A3B1              jz L67
 043C                   .dbline 522
 043C           ;               {
 043C                   .dbline 523
 043C           ;                       if(tempByte == SERVO_START)             // We have a servo response coming.
 043C 3D00FF            cmp [X+0],-1
 043F B090              jnz L70
 0441                   .dbline 524
 0441           ;                       {
 0441 807F              xjmp L73
 0443           L72:
 0443                   .dbline 527
 0443           ;                               // While we have not timed out, try to let all of the bytes through.
 0443           ;                               while(!TIMEOUT)
 0443           ;                               {
 0443                   .dbline 529
 0443           ;                                       // Eat the remaining servo start bytes.
 0443           ;                                       if(tempByte = CHILD_1_cReadChar())
 0443 10                push X
 0444 7C0000            xcall _CHILD_1_cReadChar
 0447 62D000            mov REG[0xd0],>__r0
 044A 20                pop X
 044B 5400              mov [X+0],A
 044D 3900              cmp A,0
 044F A071              jz L75
 0451                   .dbline 530
 0451           ;                                       {
 0451                   .dbline 533
 0451           ;                                               // Once we get past the start bytes, we can start adding the
 0451           ;                                               // bytes to our running total and searching for a checksum.
 0451           ;                                               if(tempByte != SERVO_START)
 0451 3D00FF            cmp [X+0],-1
 0454 A06C              jz L77
 0456                   .dbline 534
 0456           ;                                               {
 0456                   .dbline 536
 0456           ;                                                       // Add to the running total.
 0456           ;                                                       runningTotal += tempByte;
 0456 5200              mov A,[X+0]
 0458 0504              add [X+4],A
 045A 0F0300            adc [X+3],0
 045D 8056              xjmp L80
 045F           L79:
 045F                   .dbline 540
 045F           ;                                                       
 045F           ;                                                       // Either find a checksum or time out. Either way we're not stuck.
 045F           ;                                                       while(!TIMEOUT)
 045F           ;                                                       {
 045F                   .dbline 542
 045F           ;                                                               // If a nonzero byte has arrived...
 045F           ;                                                               if(tempByte = CHILD_1_cReadChar())
 045F 10                push X
 0460 7C0000            xcall _CHILD_1_cReadChar
 0463 62D000            mov REG[0xd0],>__r0
 0466 20                pop X
 0467 5400              mov [X+0],A
 0469 3900              cmp A,0
 046B A048              jz L82
 046D                   .dbline 543
 046D           ;                                                               {
 046D                   .dbline 545
 046D           ;                                                                       // Check to see if it is a checksum.
 046D           ;                                                                       if((runningTotal%256) == (255-tempByte))
 046D 5200              mov A,[X+0]
 046F 5300              mov [__r1],A
 0471 550000            mov [__r0],0
 0474 50FF              mov A,-1
 0476 1200              sub A,[__r1]
 0478 5300              mov [__r1],A
 047A 5000              mov A,0
 047C 1A00              sbb A,[__r0]
 047E 5300              mov [__r0],A
 0480 5001              mov A,1
 0482 08                push A
 0483 5000              mov A,0
 0485 08                push A
 0486 5203              mov A,[X+3]
 0488 08                push A
 0489 5204              mov A,[X+4]
 048B 08                push A
 048C 7C0000            xcall __divmod_16X16_16
 048F 38FE              add SP,-2
 0491 18                pop A
 0492 5300              mov [__r3],A
 0494 18                pop A
 0495 3A00              cmp A,[__r0]
 0497 B012              jnz L84
 0499 5100              mov A,[__r3]
 049B 3A00              cmp A,[__r1]
 049D B00C              jnz L84
 049F           X18:
 049F                   .dbline 546
 049F           ;                                                                       {
 049F                   .dbline 547
 049F           ;                                                                               return 1;
 049F 62D000            mov REG[0xd0],>__r0
 04A2 550001            mov [__r1],1
 04A5 550000            mov [__r0],0
 04A8 834C              xjmp L37
 04AA           L84:
 04AA                   .dbline 550
 04AA           ;                                                                       }
 04AA           ;                                                                       else
 04AA           ;                                                                       {
 04AA                   .dbline 551
 04AA           ;                                                                               runningTotal += tempByte;
 04AA 62D000            mov REG[0xd0],>__r0
 04AD 5200              mov A,[X+0]
 04AF 0504              add [X+4],A
 04B1 0F0300            adc [X+3],0
 04B4                   .dbline 552
 04B4           ;                                                                       }
 04B4                   .dbline 553
 04B4           ;                                                               }
 04B4           L82:
 04B4                   .dbline 554
 04B4           ;                                                       }
 04B4           L80:
 04B4                   .dbline 539
 04B4 62D000            mov REG[0xd0],>_TIMEOUT
 04B7 3C0000            cmp [_TIMEOUT],0
 04BA B006              jnz X19
 04BC 3C0100            cmp [_TIMEOUT+1],0
 04BF AF9F              jz L79
 04C1           X19:
 04C1                   .dbline 555
 04C1           ;                                               }
 04C1           L77:
 04C1                   .dbline 556
 04C1           ;                                       }
 04C1           L75:
 04C1                   .dbline 557
 04C1           ;                               }
 04C1           L73:
 04C1                   .dbline 526
 04C1 62D000            mov REG[0xd0],>_TIMEOUT
 04C4 3C0000            cmp [_TIMEOUT],0
 04C7 B006              jnz X20
 04C9 3C0100            cmp [_TIMEOUT+1],0
 04CC AF76              jz L72
 04CE           X20:
 04CE                   .dbline 558
 04CE           ;                       }
 04CE 831D              xjmp L67
 04D0           L70:
 04D0                   .dbline 559
 04D0           ;                       else if(tempByte == START_TRANSMIT)     // We have a controller response coming.
 04D0 3D00FC            cmp [X+0],-4
 04D3 B318              jnz L67
 04D5                   .dbline 560
 04D5           ;                       {
 04D5 8015              xjmp L89
 04D7           L88:
 04D7                   .dbline 563
 04D7           ;                               // We simply wait for the end transmit indicator.
 04D7           ;                               while(!TIMEOUT)
 04D7           ;                               {
 04D7                   .dbline 564
 04D7           ;                                       if(CHILD_1_cReadChar() == END_TRANSMIT)
 04D7 10                push X
 04D8 7C0000            xcall _CHILD_1_cReadChar
 04DB 62D000            mov REG[0xd0],>__r0
 04DE 20                pop X
 04DF 39FD              cmp A,-3
 04E1 B009              jnz L91
 04E3                   .dbline 565
 04E3           ;                                       {
 04E3                   .dbline 566
 04E3           ;                                               return 1;
 04E3 550001            mov [__r1],1
 04E6 550000            mov [__r0],0
 04E9 830B              xjmp L37
 04EB           L91:
 04EB                   .dbline 568
 04EB           ;                                       }
 04EB           ;                               }
 04EB           L89:
 04EB                   .dbline 562
 04EB 62D000            mov REG[0xd0],>_TIMEOUT
 04EE 3C0000            cmp [_TIMEOUT],0
 04F1 B006              jnz X21
 04F3 3C0100            cmp [_TIMEOUT+1],0
 04F6 AFE0              jz L88
 04F8           X21:
 04F8                   .dbline 569
 04F8           ;                       }
 04F8                   .dbline 570
 04F8           ;               }
 04F8                   .dbline 571
 04F8           ;       }
 04F8 82F3              xjmp L67
 04FA           L66:
 04FA                   .dbline 572
 04FA           ;       else if(STATE == RESPONSE_2)
 04FA 62D000            mov REG[0xd0],>_STATE
 04FD 3C0000            cmp [_STATE],0
 0500 B0D2              jnz L93
 0502 3C0104            cmp [_STATE+1],4
 0505 B0CD              jnz L93
 0507           X22:
 0507                   .dbline 573
 0507           ;       {
 0507                   .dbline 574
 0507           ;               if(tempByte = CHILD_2_cReadChar())
 0507 10                push X
 0508 7C0000            xcall _CHILD_2_cReadChar
 050B 62D000            mov REG[0xd0],>__r0
 050E 20                pop X
 050F 5400              mov [X+0],A
 0511 3900              cmp A,0
 0513 A2D8              jz L94
 0515                   .dbline 575
 0515           ;               {
 0515                   .dbline 576
 0515           ;                       if(tempByte == SERVO_START)             // We have a servo response coming.
 0515 3D00FF            cmp [X+0],-1
 0518 B090              jnz L97
 051A                   .dbline 577
 051A           ;                       {
 051A 807F              xjmp L100
 051C           L99:
 051C                   .dbline 580
 051C           ;                               // While we have not timed out, try to let all of the bytes through.
 051C           ;                               while(!TIMEOUT)
 051C           ;                               {
 051C                   .dbline 582
 051C           ;                                       // Eat the remaining servo start bytes.
 051C           ;                                       if(tempByte = CHILD_2_cReadChar())
 051C 10                push X
 051D 7C0000            xcall _CHILD_2_cReadChar
 0520 62D000            mov REG[0xd0],>__r0
 0523 20                pop X
 0524 5400              mov [X+0],A
 0526 3900              cmp A,0
 0528 A071              jz L102
 052A                   .dbline 583
 052A           ;                                       {
 052A                   .dbline 586
 052A           ;                                               // Once we get past the start bytes, we can start adding the
 052A           ;                                               // bytes to our running total and searching for a checksum.
 052A           ;                                               if(tempByte != SERVO_START)
 052A 3D00FF            cmp [X+0],-1
 052D A06C              jz L104
 052F                   .dbline 587
 052F           ;                                               {
 052F                   .dbline 589
 052F           ;                                                       // Add to the running total.
 052F           ;                                                       runningTotal += tempByte;
 052F 5200              mov A,[X+0]
 0531 0504              add [X+4],A
 0533 0F0300            adc [X+3],0
 0536 8056              xjmp L107
 0538           L106:
 0538                   .dbline 593
 0538           ;                                                       
 0538           ;                                                       // Either find a checksum or time out. Either way we're not stuck.
 0538           ;                                                       while(!TIMEOUT)
 0538           ;                                                       {
 0538                   .dbline 595
 0538           ;                                                               // If a nonzero byte has arrived...
 0538           ;                                                               if(tempByte = CHILD_2_cReadChar())
 0538 10                push X
 0539 7C0000            xcall _CHILD_2_cReadChar
 053C 62D000            mov REG[0xd0],>__r0
 053F 20                pop X
 0540 5400              mov [X+0],A
 0542 3900              cmp A,0
 0544 A048              jz L109
 0546                   .dbline 596
 0546           ;                                                               {
 0546                   .dbline 598
 0546           ;                                                                       // Check to see if it is a checksum.
 0546           ;                                                                       if((runningTotal%256) == (255-tempByte))
 0546 5200              mov A,[X+0]
 0548 5300              mov [__r1],A
 054A 550000            mov [__r0],0
 054D 50FF              mov A,-1
 054F 1200              sub A,[__r1]
 0551 5300              mov [__r1],A
 0553 5000              mov A,0
 0555 1A00              sbb A,[__r0]
 0557 5300              mov [__r0],A
 0559 5001              mov A,1
 055B 08                push A
 055C 5000              mov A,0
 055E 08                push A
 055F 5203              mov A,[X+3]
 0561 08                push A
 0562 5204              mov A,[X+4]
 0564 08                push A
 0565 7C0000            xcall __divmod_16X16_16
 0568 38FE              add SP,-2
 056A 18                pop A
 056B 5300              mov [__r3],A
 056D 18                pop A
 056E 3A00              cmp A,[__r0]
 0570 B012              jnz L111
 0572 5100              mov A,[__r3]
 0574 3A00              cmp A,[__r1]
 0576 B00C              jnz L111
 0578           X23:
 0578                   .dbline 599
 0578           ;                                                                       {
 0578                   .dbline 600
 0578           ;                                                                               return 1;
 0578 62D000            mov REG[0xd0],>__r0
 057B 550001            mov [__r1],1
 057E 550000            mov [__r0],0
 0581 8273              xjmp L37
 0583           L111:
 0583                   .dbline 603
 0583           ;                                                                       }
 0583           ;                                                                       else
 0583           ;                                                                       {
 0583                   .dbline 604
 0583           ;                                                                               runningTotal += tempByte;
 0583 62D000            mov REG[0xd0],>__r0
 0586 5200              mov A,[X+0]
 0588 0504              add [X+4],A
 058A 0F0300            adc [X+3],0
 058D                   .dbline 605
 058D           ;                                                                       }
 058D                   .dbline 606
 058D           ;                                                               }
 058D           L109:
 058D                   .dbline 607
 058D           ;                                                       }
 058D           L107:
 058D                   .dbline 592
 058D 62D000            mov REG[0xd0],>_TIMEOUT
 0590 3C0000            cmp [_TIMEOUT],0
 0593 B006              jnz X24
 0595 3C0100            cmp [_TIMEOUT+1],0
 0598 AF9F              jz L106
 059A           X24:
 059A                   .dbline 608
 059A           ;                                               }
 059A           L104:
 059A                   .dbline 609
 059A           ;                                       }
 059A           L102:
 059A                   .dbline 610
 059A           ;                               }
 059A           L100:
 059A                   .dbline 579
 059A 62D000            mov REG[0xd0],>_TIMEOUT
 059D 3C0000            cmp [_TIMEOUT],0
 05A0 B006              jnz X25
 05A2 3C0100            cmp [_TIMEOUT+1],0
 05A5 AF76              jz L99
 05A7           X25:
 05A7                   .dbline 611
 05A7           ;                       }
 05A7 8244              xjmp L94
 05A9           L97:
 05A9                   .dbline 612
 05A9           ;                       else if(tempByte == START_TRANSMIT)     // We have a controller response coming.
 05A9 3D00FC            cmp [X+0],-4
 05AC B23F              jnz L94
 05AE                   .dbline 613
 05AE           ;                       {
 05AE 8015              xjmp L116
 05B0           L115:
 05B0                   .dbline 616
 05B0           ;                               // We simply wait for the end transmit indicator.
 05B0           ;                               while(!TIMEOUT)
 05B0           ;                               {
 05B0                   .dbline 617
 05B0           ;                                       if(CHILD_2_cReadChar() == END_TRANSMIT)
 05B0 10                push X
 05B1 7C0000            xcall _CHILD_2_cReadChar
 05B4 62D000            mov REG[0xd0],>__r0
 05B7 20                pop X
 05B8 39FD              cmp A,-3
 05BA B009              jnz L118
 05BC                   .dbline 618
 05BC           ;                                       {
 05BC                   .dbline 619
 05BC           ;                                               return 1;
 05BC 550001            mov [__r1],1
 05BF 550000            mov [__r0],0
 05C2 8232              xjmp L37
 05C4           L118:
 05C4                   .dbline 621
 05C4           ;                                       }
 05C4           ;                               }
 05C4           L116:
 05C4                   .dbline 615
 05C4 62D000            mov REG[0xd0],>_TIMEOUT
 05C7 3C0000            cmp [_TIMEOUT],0
 05CA B006              jnz X26
 05CC 3C0100            cmp [_TIMEOUT+1],0
 05CF AFE0              jz L115
 05D1           X26:
 05D1                   .dbline 622
 05D1           ;                       }
 05D1                   .dbline 623
 05D1           ;               }
 05D1                   .dbline 624
 05D1           ;       }
 05D1 821A              xjmp L94
 05D3           L93:
 05D3                   .dbline 625
 05D3           ;       else if(STATE == RESPONSE_3)
 05D3 62D000            mov REG[0xd0],>_STATE
 05D6 3C0000            cmp [_STATE],0
 05D9 B0D2              jnz L120
 05DB 3C0105            cmp [_STATE+1],5
 05DE B0CD              jnz L120
 05E0           X27:
 05E0                   .dbline 626
 05E0           ;       {
 05E0                   .dbline 627
 05E0           ;               if(tempByte = CHILD_3_cReadChar())
 05E0 10                push X
 05E1 7C0000            xcall _CHILD_3_cReadChar
 05E4 62D000            mov REG[0xd0],>__r0
 05E7 20                pop X
 05E8 5400              mov [X+0],A
 05EA 3900              cmp A,0
 05EC A1FF              jz L121
 05EE                   .dbline 628
 05EE           ;               {
 05EE                   .dbline 629
 05EE           ;                       if(tempByte == SERVO_START)             // We have a servo response coming.
 05EE 3D00FF            cmp [X+0],-1
 05F1 B090              jnz L124
 05F3                   .dbline 630
 05F3           ;                       {
 05F3 807F              xjmp L127
 05F5           L126:
 05F5                   .dbline 633
 05F5           ;                               // While we have not timed out, try to let all of the bytes through.
 05F5           ;                               while(!TIMEOUT)
 05F5           ;                               {
 05F5                   .dbline 635
 05F5           ;                                       // Eat the remaining servo start bytes.
 05F5           ;                                       if(tempByte = CHILD_3_cReadChar())
 05F5 10                push X
 05F6 7C0000            xcall _CHILD_3_cReadChar
 05F9 62D000            mov REG[0xd0],>__r0
 05FC 20                pop X
 05FD 5400              mov [X+0],A
 05FF 3900              cmp A,0
 0601 A071              jz L129
 0603                   .dbline 636
 0603           ;                                       {
 0603                   .dbline 639
 0603           ;                                               // Once we get past the start bytes, we can start adding the
 0603           ;                                               // bytes to our running total and searching for a checksum.
 0603           ;                                               if(tempByte != SERVO_START)
 0603 3D00FF            cmp [X+0],-1
 0606 A06C              jz L131
 0608                   .dbline 640
 0608           ;                                               {
 0608                   .dbline 642
 0608           ;                                                       // Add to the running total.
 0608           ;                                                       runningTotal += tempByte;
 0608 5200              mov A,[X+0]
 060A 0504              add [X+4],A
 060C 0F0300            adc [X+3],0
 060F 8056              xjmp L134
 0611           L133:
 0611                   .dbline 646
 0611           ;                                                       
 0611           ;                                                       // Either find a checksum or time out. Either way we're not stuck.
 0611           ;                                                       while(!TIMEOUT)
 0611           ;                                                       {
 0611                   .dbline 648
 0611           ;                                                               // If a nonzero byte has arrived...
 0611           ;                                                               if(tempByte = CHILD_3_cReadChar())
 0611 10                push X
 0612 7C0000            xcall _CHILD_3_cReadChar
 0615 62D000            mov REG[0xd0],>__r0
 0618 20                pop X
 0619 5400              mov [X+0],A
 061B 3900              cmp A,0
 061D A048              jz L136
 061F                   .dbline 649
 061F           ;                                                               {
 061F                   .dbline 651
 061F           ;                                                                       // Check to see if it is a checksum.
 061F           ;                                                                       if((runningTotal%256) == (255-tempByte))
 061F 5200              mov A,[X+0]
 0621 5300              mov [__r1],A
 0623 550000            mov [__r0],0
 0626 50FF              mov A,-1
 0628 1200              sub A,[__r1]
 062A 5300              mov [__r1],A
 062C 5000              mov A,0
 062E 1A00              sbb A,[__r0]
 0630 5300              mov [__r0],A
 0632 5001              mov A,1
 0634 08                push A
 0635 5000              mov A,0
 0637 08                push A
 0638 5203              mov A,[X+3]
 063A 08                push A
 063B 5204              mov A,[X+4]
 063D 08                push A
 063E 7C0000            xcall __divmod_16X16_16
 0641 38FE              add SP,-2
 0643 18                pop A
 0644 5300              mov [__r3],A
 0646 18                pop A
 0647 3A00              cmp A,[__r0]
 0649 B012              jnz L138
 064B 5100              mov A,[__r3]
 064D 3A00              cmp A,[__r1]
 064F B00C              jnz L138
 0651           X28:
 0651                   .dbline 652
 0651           ;                                                                       {
 0651                   .dbline 653
 0651           ;                                                                               return 1;
 0651 62D000            mov REG[0xd0],>__r0
 0654 550001            mov [__r1],1
 0657 550000            mov [__r0],0
 065A 819A              xjmp L37
 065C           L138:
 065C                   .dbline 656
 065C           ;                                                                       }
 065C           ;                                                                       else
 065C           ;                                                                       {
 065C                   .dbline 657
 065C           ;                                                                               runningTotal += tempByte;
 065C 62D000            mov REG[0xd0],>__r0
 065F 5200              mov A,[X+0]
 0661 0504              add [X+4],A
 0663 0F0300            adc [X+3],0
 0666                   .dbline 658
 0666           ;                                                                       }
 0666                   .dbline 659
 0666           ;                                                               }
 0666           L136:
 0666                   .dbline 660
 0666           ;                                                       }
 0666           L134:
 0666                   .dbline 645
 0666 62D000            mov REG[0xd0],>_TIMEOUT
 0669 3C0000            cmp [_TIMEOUT],0
 066C B006              jnz X29
 066E 3C0100            cmp [_TIMEOUT+1],0
 0671 AF9F              jz L133
 0673           X29:
 0673                   .dbline 661
 0673           ;                                               }
 0673           L131:
 0673                   .dbline 662
 0673           ;                                       }
 0673           L129:
 0673                   .dbline 663
 0673           ;                               }
 0673           L127:
 0673                   .dbline 632
 0673 62D000            mov REG[0xd0],>_TIMEOUT
 0676 3C0000            cmp [_TIMEOUT],0
 0679 B006              jnz X30
 067B 3C0100            cmp [_TIMEOUT+1],0
 067E AF76              jz L126
 0680           X30:
 0680                   .dbline 664
 0680           ;                       }
 0680 816B              xjmp L121
 0682           L124:
 0682                   .dbline 665
 0682           ;                       else if(tempByte == START_TRANSMIT)     // We have a controller response coming.
 0682 3D00FC            cmp [X+0],-4
 0685 B166              jnz L121
 0687                   .dbline 666
 0687           ;                       {
 0687 8015              xjmp L143
 0689           L142:
 0689                   .dbline 669
 0689           ;                               // We simply wait for the end transmit indicator.
 0689           ;                               while(!TIMEOUT)
 0689           ;                               {
 0689                   .dbline 670
 0689           ;                                       if(CHILD_3_cReadChar() == END_TRANSMIT)
 0689 10                push X
 068A 7C0000            xcall _CHILD_3_cReadChar
 068D 62D000            mov REG[0xd0],>__r0
 0690 20                pop X
 0691 39FD              cmp A,-3
 0693 B009              jnz L145
 0695                   .dbline 671
 0695           ;                                       {
 0695                   .dbline 672
 0695           ;                                               return 1;
 0695 550001            mov [__r1],1
 0698 550000            mov [__r0],0
 069B 8159              xjmp L37
 069D           L145:
 069D                   .dbline 674
 069D           ;                                       }
 069D           ;                               }
 069D           L143:
 069D                   .dbline 668
 069D 62D000            mov REG[0xd0],>_TIMEOUT
 06A0 3C0000            cmp [_TIMEOUT],0
 06A3 B006              jnz X31
 06A5 3C0100            cmp [_TIMEOUT+1],0
 06A8 AFE0              jz L142
 06AA           X31:
 06AA                   .dbline 675
 06AA           ;                       }
 06AA                   .dbline 676
 06AA           ;               }
 06AA                   .dbline 677
 06AA           ;       }
 06AA 8141              xjmp L121
 06AC           L120:
 06AC                   .dbline 678
 06AC           ;       else if(STATE == RESPONSE_4)
 06AC 62D000            mov REG[0xd0],>_STATE
 06AF 3C0000            cmp [_STATE],0
 06B2 B0D2              jnz L147
 06B4 3C0106            cmp [_STATE+1],6
 06B7 B0CD              jnz L147
 06B9           X32:
 06B9                   .dbline 679
 06B9           ;       {
 06B9                   .dbline 680
 06B9           ;               if(tempByte = CHILD_4_cReadChar())
 06B9 10                push X
 06BA 7C0000            xcall _CHILD_4_cReadChar
 06BD 62D000            mov REG[0xd0],>__r0
 06C0 20                pop X
 06C1 5400              mov [X+0],A
 06C3 3900              cmp A,0
 06C5 A126              jz L148
 06C7                   .dbline 681
 06C7           ;               {
 06C7                   .dbline 682
 06C7           ;                       if(tempByte == SERVO_START)             // We have a servo response coming.
 06C7 3D00FF            cmp [X+0],-1
 06CA B090              jnz L151
 06CC                   .dbline 683
 06CC           ;                       {
 06CC 807F              xjmp L154
 06CE           L153:
 06CE                   .dbline 686
 06CE           ;                               // While we have not timed out, try to let all of the bytes through.
 06CE           ;                               while(!TIMEOUT)
 06CE           ;                               {
 06CE                   .dbline 688
 06CE           ;                                       // Eat the remaining servo start bytes.
 06CE           ;                                       if(tempByte = CHILD_4_cReadChar())
 06CE 10                push X
 06CF 7C0000            xcall _CHILD_4_cReadChar
 06D2 62D000            mov REG[0xd0],>__r0
 06D5 20                pop X
 06D6 5400              mov [X+0],A
 06D8 3900              cmp A,0
 06DA A071              jz L156
 06DC                   .dbline 689
 06DC           ;                                       {
 06DC                   .dbline 692
 06DC           ;                                               // Once we get past the start bytes, we can start adding the
 06DC           ;                                               // bytes to our running total and searching for a checksum.
 06DC           ;                                               if(tempByte != SERVO_START)
 06DC 3D00FF            cmp [X+0],-1
 06DF A06C              jz L158
 06E1                   .dbline 693
 06E1           ;                                               {
 06E1                   .dbline 695
 06E1           ;                                                       // Add to the running total.
 06E1           ;                                                       runningTotal += tempByte;
 06E1 5200              mov A,[X+0]
 06E3 0504              add [X+4],A
 06E5 0F0300            adc [X+3],0
 06E8 8056              xjmp L161
 06EA           L160:
 06EA                   .dbline 699
 06EA           ;                                                       
 06EA           ;                                                       // Either find a checksum or time out. Either way we're not stuck.
 06EA           ;                                                       while(!TIMEOUT)
 06EA           ;                                                       {
 06EA                   .dbline 701
 06EA           ;                                                               // If a nonzero byte has arrived...
 06EA           ;                                                               if(tempByte = CHILD_4_cReadChar())
 06EA 10                push X
 06EB 7C0000            xcall _CHILD_4_cReadChar
 06EE 62D000            mov REG[0xd0],>__r0
 06F1 20                pop X
 06F2 5400              mov [X+0],A
 06F4 3900              cmp A,0
 06F6 A048              jz L163
 06F8                   .dbline 702
 06F8           ;                                                               {
 06F8                   .dbline 704
 06F8           ;                                                                       // Check to see if it is a checksum.
 06F8           ;                                                                       if((runningTotal%256) == (255-tempByte))
 06F8 5200              mov A,[X+0]
 06FA 5300              mov [__r1],A
 06FC 550000            mov [__r0],0
 06FF 50FF              mov A,-1
 0701 1200              sub A,[__r1]
 0703 5300              mov [__r1],A
 0705 5000              mov A,0
 0707 1A00              sbb A,[__r0]
 0709 5300              mov [__r0],A
 070B 5001              mov A,1
 070D 08                push A
 070E 5000              mov A,0
 0710 08                push A
 0711 5203              mov A,[X+3]
 0713 08                push A
 0714 5204              mov A,[X+4]
 0716 08                push A
 0717 7C0000            xcall __divmod_16X16_16
 071A 38FE              add SP,-2
 071C 18                pop A
 071D 5300              mov [__r3],A
 071F 18                pop A
 0720 3A00              cmp A,[__r0]
 0722 B012              jnz L165
 0724 5100              mov A,[__r3]
 0726 3A00              cmp A,[__r1]
 0728 B00C              jnz L165
 072A           X33:
 072A                   .dbline 705
 072A           ;                                                                       {
 072A                   .dbline 706
 072A           ;                                                                               return 1;
 072A 62D000            mov REG[0xd0],>__r0
 072D 550001            mov [__r1],1
 0730 550000            mov [__r0],0
 0733 80C1              xjmp L37
 0735           L165:
 0735                   .dbline 709
 0735           ;                                                                       }
 0735           ;                                                                       else
 0735           ;                                                                       {
 0735                   .dbline 710
 0735           ;                                                                               runningTotal += tempByte;
 0735 62D000            mov REG[0xd0],>__r0
 0738 5200              mov A,[X+0]
 073A 0504              add [X+4],A
 073C 0F0300            adc [X+3],0
 073F                   .dbline 711
 073F           ;                                                                       }
 073F                   .dbline 712
 073F           ;                                                               }
 073F           L163:
 073F                   .dbline 713
 073F           ;                                                       }
 073F           L161:
 073F                   .dbline 698
 073F 62D000            mov REG[0xd0],>_TIMEOUT
 0742 3C0000            cmp [_TIMEOUT],0
 0745 B006              jnz X34
 0747 3C0100            cmp [_TIMEOUT+1],0
 074A AF9F              jz L160
 074C           X34:
 074C                   .dbline 714
 074C           ;                                               }
 074C           L158:
 074C                   .dbline 715
 074C           ;                                       }
 074C           L156:
 074C                   .dbline 716
 074C           ;                               }
 074C           L154:
 074C                   .dbline 685
 074C 62D000            mov REG[0xd0],>_TIMEOUT
 074F 3C0000            cmp [_TIMEOUT],0
 0752 B006              jnz X35
 0754 3C0100            cmp [_TIMEOUT+1],0
 0757 AF76              jz L153
 0759           X35:
 0759                   .dbline 717
 0759           ;                       }
 0759 8092              xjmp L148
 075B           L151:
 075B                   .dbline 718
 075B           ;                       else if(tempByte == START_TRANSMIT)     // We have a controller response coming.
 075B 3D00FC            cmp [X+0],-4
 075E B08D              jnz L148
 0760                   .dbline 719
 0760           ;                       {
 0760 8015              xjmp L170
 0762           L169:
 0762                   .dbline 722
 0762           ;                               // We simply wait for the end transmit indicator.
 0762           ;                               while(!TIMEOUT)
 0762           ;                               {
 0762                   .dbline 723
 0762           ;                                       if(CHILD_4_cReadChar() == END_TRANSMIT)
 0762 10                push X
 0763 7C0000            xcall _CHILD_4_cReadChar
 0766 62D000            mov REG[0xd0],>__r0
 0769 20                pop X
 076A 39FD              cmp A,-3
 076C B009              jnz L172
 076E                   .dbline 724
 076E           ;                                       {
 076E                   .dbline 725
 076E           ;                                               return 1;
 076E 550001            mov [__r1],1
 0771 550000            mov [__r0],0
 0774 8080              xjmp L37
 0776           L172:
 0776                   .dbline 727
 0776           ;                                       }
 0776           ;                               }
 0776           L170:
 0776                   .dbline 721
 0776 62D000            mov REG[0xd0],>_TIMEOUT
 0779 3C0000            cmp [_TIMEOUT],0
 077C B006              jnz X36
 077E 3C0100            cmp [_TIMEOUT+1],0
 0781 AFE0              jz L169
 0783           X36:
 0783                   .dbline 728
 0783           ;                       }
 0783                   .dbline 729
 0783           ;               }
 0783                   .dbline 730
 0783           ;       }
 0783 8068              xjmp L148
 0785           L147:
 0785                   .dbline 731
 0785           ;       else if(STATE == INITIALIZE)
 0785 62D000            mov REG[0xd0],>_STATE
 0788 3C0000            cmp [_STATE],0
 078B B060              jnz L174
 078D 3C0108            cmp [_STATE+1],8
 0790 B05B              jnz L174
 0792           X37:
 0792                   .dbline 732
 0792           ;       {
 0792                   .dbline 733
 0792           ;               if(INIT_RX_cReadChar() == SERVO_START)
 0792 10                push X
 0793 7C0000            xcall _INIT_RX_cReadChar
 0796 62D000            mov REG[0xd0],>__r0
 0799 20                pop X
 079A 39FF              cmp A,-1
 079C B04F              jnz L176
 079E                   .dbline 734
 079E           ;               {
 079E 8040              xjmp L179
 07A0           L178:
 07A0                   .dbline 736
 07A0           ;                       while(!TIMEOUT)
 07A0           ;                       {
 07A0                   .dbline 738
 07A0           ;                               // We officially have a transmission.
 07A0           ;                               if(INIT_RX_cReadChar() == SERVO_START)
 07A0 10                push X
 07A1 7C0000            xcall _INIT_RX_cReadChar
 07A4 62D000            mov REG[0xd0],>__r0
 07A7 20                pop X
 07A8 39FF              cmp A,-1
 07AA B034              jnz L181
 07AC                   .dbline 739
 07AC           ;                               {
 07AC                   .dbline 742
 07AC           ;                                       // If we definitely have a transmission starting, grab all bytes from the rx buffer
 07AC           ;                                       // and store them in the proper variables for actions to be taken later.
 07AC           ;                                       COMMAND_SOURCE = INIT_RX_cGetChar();
 07AC 10                push X
 07AD 7C0000            xcall _INIT_RX_cGetChar
 07B0 20                pop X
 07B1 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 07B4 5300              mov [_COMMAND_SOURCE],A
 07B6                   .dbline 743
 07B6           ;                                       COMMAND_LENGTH = INIT_RX_cGetChar();
 07B6 10                push X
 07B7 7C0000            xcall _INIT_RX_cGetChar
 07BA 20                pop X
 07BB 62D000            mov REG[0xd0],>_COMMAND_LENGTH
 07BE 5300              mov [_COMMAND_LENGTH],A
 07C0                   .dbline 744
 07C0           ;                                       COMMAND_ERROR = INIT_RX_cGetChar();
 07C0 10                push X
 07C1 7C0000            xcall _INIT_RX_cGetChar
 07C4 20                pop X
 07C5 62D000            mov REG[0xd0],>_COMMAND_ERROR
 07C8 5300              mov [_COMMAND_ERROR],A
 07CA                   .dbline 745
 07CA           ;                                       COMMAND_PARAM = INIT_RX_cGetChar();
 07CA 10                push X
 07CB 7C0000            xcall _INIT_RX_cGetChar
 07CE 20                pop X
 07CF 62D000            mov REG[0xd0],>_COMMAND_PARAM
 07D2 5300              mov [_COMMAND_PARAM],A
 07D4                   .dbline 747
 07D4           ;                                       
 07D4           ;                                       return 1;
 07D4 62D000            mov REG[0xd0],>__r0
 07D7 550001            mov [__r1],1
 07DA 550000            mov [__r0],0
 07DD 8017              xjmp L37
 07DF           L181:
 07DF                   .dbline 749
 07DF           ;                               }
 07DF           ;                       }
 07DF           L179:
 07DF                   .dbline 735
 07DF 62D000            mov REG[0xd0],>_TIMEOUT
 07E2 3C0000            cmp [_TIMEOUT],0
 07E5 B006              jnz X38
 07E7 3C0100            cmp [_TIMEOUT+1],0
 07EA AFB5              jz L178
 07EC           X38:
 07EC                   .dbline 750
 07EC           ;               }
 07EC           L176:
 07EC                   .dbline 751
 07EC           ;       }
 07EC           L174:
 07EC           L148:
 07EC           L121:
 07EC           L94:
 07EC           L67:
 07EC           L57:
 07EC           L39:
 07EC                   .dbline 753
 07EC           ;       
 07EC           ;       return 0;
 07EC 62D000            mov REG[0xd0],>__r0
 07EF 550000            mov [__r1],0
 07F2 550000            mov [__r0],0
 07F5                   .dbline -2
 07F5           L37:
 07F5 38FB              add SP,-5
 07F7 20                pop X
 07F8                   .dbline 0 ; func end
 07F8 7F                ret
 07F9                   .dbsym l runningTotal 3 I
 07F9                   .dbsym l i 1 I
 07F9                   .dbsym l tempByte 0 c
 07F9                   .dbend
 07F9                   .dbfunc e takeAction _takeAction fV
 07F9           ;              j -> X+7
 07F9           ;              i -> X+5
 07F9           ;   runningTotal -> X+3
 07F9           ;       tempByte -> X+2
 07F9           ;              i -> X+0
 07F9           _takeAction::
 07F9                   .dbline -1
 07F9 10                push X
 07FA 4F                mov X,SP
 07FB 3809              add SP,9
 07FD                   .dbline 759
 07FD           ; }
 07FD           ; 
 07FD           ; // This function interprets what has been read by the command ready function
 07FD           ; // and performs the appropriate action.
 07FD           ; void takeAction(void)
 07FD           ; {
 07FD                   .dbline 760
 07FD           ;       int i = 0;                                                      // An index variable for looping.
 07FD 560100            mov [X+1],0
 0800 560000            mov [X+0],0
 0803                   .dbline 761
 0803           ;       char tempByte = 0;                                      // A temporary byte storage variable.
 0803 560200            mov [X+2],0
 0806                   .dbline 762
 0806           ;       int runningTotal = 0;                           // A running total of bytes to check against a checksum.
 0806 560400            mov [X+4],0
 0809 560300            mov [X+3],0
 080C                   .dbline 764
 080C           ;       
 080C           ;       if(COMMAND_TYPE == HELLO_BYTE)          // The master is probing for new modules.
 080C 62D000            mov REG[0xd0],>_COMMAND_TYPE
 080F 3C00C8            cmp [_COMMAND_TYPE],-56
 0812 B039              jnz L184
 0814                   .dbline 765
 0814           ;       {
 0814                   .dbline 766
 0814           ;               if(!CONFIGURED)
 0814 62D000            mov REG[0xd0],>_CONFIGURED
 0817 3C0000            cmp [_CONFIGURED],0
 081A B00A              jnz L186
 081C 3C0100            cmp [_CONFIGURED+1],0
 081F B005              jnz L186
 0821           X39:
 0821                   .dbline 767
 0821           ;               {
 0821                   .dbline 769
 0821           ;                       // Announce this module's presence if not configured.
 0821           ;                       sayHello();
 0821 982C              xcall _sayHello
 0823                   .dbline 770
 0823           ;               }
 0823 8183              xjmp L185
 0825           L186:
 0825                   .dbline 771
 0825           ;               else if(!CHILD)
 0825 62D000            mov REG[0xd0],>_CHILD
 0828 3C0000            cmp [_CHILD],0
 082B B014              jnz L188
 082D                   .dbline 772
 082D           ;               {
 082D                   .dbline 774
 082D           ;                       // Listen for children if we have none.
 082D           ;                       if(childListen())
 082D 9381              xcall _childListen
 082F 62D000            mov REG[0xd0],>__r0
 0832 3C0000            cmp [__r0],0
 0835 B006              jnz X40
 0837 3C0000            cmp [__r1],0
 083A A16C              jz L185
 083C           X40:
 083C                   .dbline 775
 083C           ;                       {
 083C                   .dbline 777
 083C           ;                               // If a child was heard saying hello, forward the command with the port number added.
 083C           ;                               sayHello();
 083C 9811              xcall _sayHello
 083E                   .dbline 778
 083E           ;                       }
 083E                   .dbline 779
 083E           ;               }
 083E 8168              xjmp L185
 0840           L188:
 0840                   .dbline 780
 0840           ;               else if(CHILD)
 0840 62D000            mov REG[0xd0],>_CHILD
 0843 3C0000            cmp [_CHILD],0
 0846 A160              jz L185
 0848                   .dbline 781
 0848           ;               {
 0848                   .dbline 783
 0848           ;                       // If you have a child established, listen to that child.
 0848           ;                       childResponse();
 0848 93BE              xcall _childResponse
 084A                   .dbline 784
 084A           ;               }
 084A                   .dbline 785
 084A           ;       }
 084A 815C              xjmp L185
 084C           L184:
 084C                   .dbline 786
 084C           ;       else if(COMMAND_TYPE == PING)           // The master is trying to find a module that is configured.
 084C 62D000            mov REG[0xd0],>_COMMAND_TYPE
 084F 3C00CB            cmp [_COMMAND_TYPE],-53
 0852 B021              jnz L194
 0854                   .dbline 787
 0854           ;       {
 0854                   .dbline 789
 0854           ;               // If this is to me, act accordingly.
 0854           ;               if(COMMAND_DESTINATION == ID)
 0854 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0857 5100              mov A,[_COMMAND_DESTINATION]
 0859 62D000            mov REG[0xd0],>_ID
 085C 3A00              cmp A,[_ID]
 085E B005              jnz L196
 0860                   .dbline 790
 0860           ;               {
 0860                   .dbline 792
 0860           ;                       // Ping back to the master.
 0860           ;                       pingResponse();
 0860 9149              xcall _pingResponse
 0862                   .dbline 793
 0862           ;               }
 0862 8144              xjmp L195
 0864           L196:
 0864                   .dbline 794
 0864           ;               else if(COMMAND_DESTINATION > ID)
 0864 62D000            mov REG[0xd0],>_ID
 0867 5100              mov A,[_ID]
 0869 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 086C 3A00              cmp A,[_COMMAND_DESTINATION]
 086E D138              jnc L195
 0870           X41:
 0870                   .dbline 795
 0870           ;               {
 0870                   .dbline 797
 0870           ;                       // If you have a child established, listen to that child.
 0870           ;                       childResponse();
 0870 9396              xcall _childResponse
 0872                   .dbline 798
 0872           ;               }
 0872                   .dbline 799
 0872           ;       }
 0872 8134              xjmp L195
 0874           L194:
 0874                   .dbline 800
 0874           ;       else if(COMMAND_TYPE == ID_ASSIGNMENT)  // The master is assigning an ID to someone.
 0874 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0877 3C00C9            cmp [_COMMAND_TYPE],-55
 087A B111              jnz L200
 087C                   .dbline 801
 087C           ;       {
 087C                   .dbline 803
 087C           ;               // If this is meant for me, change my ID.
 087C           ;               if(COMMAND_DESTINATION == ID)
 087C 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 087F 5100              mov A,[_COMMAND_DESTINATION]
 0881 62D000            mov REG[0xd0],>_ID
 0884 3A00              cmp A,[_ID]
 0886 B0F5              jnz L202
 0888                   .dbline 804
 0888           ;               {
 0888                   .dbline 805
 0888           ;                       if((COMMAND_PARAM > MASTER_ID) && (COMMAND_PARAM < DEFAULT_ID))
 0888 62D000            mov REG[0xd0],>_COMMAND_PARAM
 088B 5000              mov A,0
 088D 3A00              cmp A,[_COMMAND_PARAM]
 088F D117              jnc L201
 0891           X42:
 0891 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0894 3C00FB            cmp [_COMMAND_PARAM],-5
 0897 D10F              jnc L201
 0899           X43:
 0899                   .dbline 806
 0899           ;                       {
 0899                   .dbline 808
 0899           ;                               // Assign this module the ID that has been passed by the master.
 0899           ;                               ID = COMMAND_PARAM;
 0899 62D000            mov REG[0xd0],>_COMMAND_PARAM
 089C 5100              mov A,[_COMMAND_PARAM]
 089E 62D000            mov REG[0xd0],>_ID
 08A1 5300              mov [_ID],A
 08A3                   .dbline 811
 08A3           ;                               
 08A3           ;                               // This module is now configured.
 08A3           ;                               CONFIGURED = 1;
 08A3 62D000            mov REG[0xd0],>_CONFIGURED
 08A6 550101            mov [_CONFIGURED+1],1
 08A9 550000            mov [_CONFIGURED],0
 08AC                   .dbline 814
 08AC           ;                               
 08AC           ;                               // If the servo ID doesn't match what we want, change it to match.
 08AC           ;                               if(ID != SERVO_ID)
 08AC 62D000            mov REG[0xd0],>_ID
 08AF 5100              mov A,[_ID]
 08B1 62D000            mov REG[0xd0],>_SERVO_ID
 08B4 3A00              cmp A,[_SERVO_ID]
 08B6 A0A8              jz L206
 08B8                   .dbline 815
 08B8           ;                               {
 08B8                   .dbline 822
 08B8           ;                                       // These are our index variables for communication attempt timeouts.
 08B8           ;                                       int i;
 08B8           ;                                       int j;
 08B8           ;                                       
 08B8           ;                                       //while(ID != SERVO_ID)
 08B8           ;                                       
 08B8           ;                                       for(j = 0; j < SERVO_COMM_LOOPS; j++)
 08B8 560800            mov [X+8],0
 08BB 560700            mov [X+7],0
 08BE           L208:
 08BE                   .dbline 823
 08BE           ;                                       {       
 08BE                   .dbline 825
 08BE           ;                                               // Send a request to change the servo ID to match the controller ID.
 08BE           ;                                               servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, ID_ADDRESS, ID);
 08BE 62D000            mov REG[0xd0],>_ID
 08C1 5100              mov A,[_ID]
 08C3 08                push A
 08C4 5003              mov A,3
 08C6 08                push A
 08C7 08                push A
 08C8 5004              mov A,4
 08CA 08                push A
 08CB 62D000            mov REG[0xd0],>_SERVO_ID
 08CE 5100              mov A,[_SERVO_ID]
 08D0 08                push A
 08D1 95E2              xcall _servoInstruction
 08D3 38FB              add SP,-5
 08D5                   .dbline 828
 08D5           ;                                       
 08D5           ;                                               // Try to read the servo's ID several times.
 08D5           ;                                               for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 08D5 560600            mov [X+6],0
 08D8 560500            mov [X+5],0
 08DB           L212:
 08DB                   .dbline 829
 08DB           ;                                               {
 08DB                   .dbline 831
 08DB           ;                                                       // Send a request for the servo ID, which is presumably now equal to ID.
 08DB           ;                                                       servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
 08DB 5000              mov A,0
 08DD 08                push A
 08DE 08                push A
 08DF 5001              mov A,1
 08E1 08                push A
 08E2 5002              mov A,2
 08E4 08                push A
 08E5 50FE              mov A,-2
 08E7 08                push A
 08E8 95CB              xcall _servoInstruction
 08EA 38FB              add SP,-5
 08EC 8043              xjmp L217
 08EE           L216:
 08EE                   .dbline 835
 08EE           ;                                                       
 08EE           ;                                                       // Wait for either a timeout or an indication that we want to exit the loop.
 08EE           ;                                                       while(!TIMEOUT)
 08EE           ;                                                       {
 08EE                   .dbline 837
 08EE           ;                                                               // If we have a command to interpret, read it.
 08EE           ;                                                               if(commandReady())
 08EE 99CE              xcall _commandReady
 08F0 62D000            mov REG[0xd0],>__r0
 08F3 3C0000            cmp [__r0],0
 08F6 B006              jnz X44
 08F8 3C0000            cmp [__r1],0
 08FB A034              jz L219
 08FD           X44:
 08FD                   .dbline 838
 08FD           ;                                                               {
 08FD                   .dbline 839
 08FD           ;                                                                       if(!COMMAND_ERROR)
 08FD 62D000            mov REG[0xd0],>_COMMAND_ERROR
 0900 3C0000            cmp [_COMMAND_ERROR],0
 0903 B02C              jnz L221
 0905                   .dbline 840
 0905           ;                                                                       {
 0905                   .dbline 842
 0905           ;                                                                               // If we have a valid servo ID, exit the loop.
 0905           ;                                                                               if(COMMAND_SOURCE == ID)
 0905 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0908 5100              mov A,[_COMMAND_SOURCE]
 090A 62D000            mov REG[0xd0],>_ID
 090D 3A00              cmp A,[_ID]
 090F B020              jnz L223
 0911                   .dbline 843
 0911           ;                                                                               {
 0911                   .dbline 845
 0911           ;                                                                                       // Set the timeout flag to exit the while loop.
 0911           ;                                                                                       TIMEOUT = 1;
 0911 62D000            mov REG[0xd0],>_TIMEOUT
 0914 550101            mov [_TIMEOUT+1],1
 0917 550000            mov [_TIMEOUT],0
 091A                   .dbline 847
 091A           ;                                                                                       // Set i such that the for loop is exited.
 091A           ;                                                                                       i = SERVO_COMM_ATTEMPTS;
 091A 56060A            mov [X+6],10
 091D 560500            mov [X+5],0
 0920                   .dbline 849
 0920           ;                                                                                       // Set j such that we exit the outer loop as well.
 0920           ;                                                                                       j = SERVO_COMM_LOOPS;
 0920 560802            mov [X+8],2
 0923 560700            mov [X+7],0
 0926                   .dbline 851
 0926           ;                                                                                       // Store the ID value.
 0926           ;                                                                                       SERVO_ID = ID;
 0926 62D000            mov REG[0xd0],>_ID
 0929 5100              mov A,[_ID]
 092B 62D000            mov REG[0xd0],>_SERVO_ID
 092E 5300              mov [_SERVO_ID],A
 0930                   .dbline 852
 0930           ;                                                                               }
 0930           L223:
 0930                   .dbline 853
 0930           ;                                                                       }
 0930           L221:
 0930                   .dbline 854
 0930           ;                                                               }
 0930           L219:
 0930                   .dbline 855
 0930           ;                                                       }
 0930           L217:
 0930                   .dbline 834
 0930 62D000            mov REG[0xd0],>_TIMEOUT
 0933 3C0000            cmp [_TIMEOUT],0
 0936 B006              jnz X45
 0938 3C0100            cmp [_TIMEOUT+1],0
 093B AFB2              jz L216
 093D           X45:
 093D                   .dbline 856
 093D           ;                                               }
 093D           L213:
 093D                   .dbline 828
 093D 7706              inc [X+6]
 093F 0F0500            adc [X+5],0
 0942                   .dbline 828
 0942 5206              mov A,[X+6]
 0944 110A              sub A,10
 0946 5205              mov A,[X+5]
 0948 3180              xor A,-128
 094A 1980              sbb A,(0 ^ 0x80)
 094C CF8E              jc L212
 094E           X46:
 094E                   .dbline 857
 094E           ;                                       }       
 094E           L209:
 094E                   .dbline 822
 094E 7708              inc [X+8]
 0950 0F0700            adc [X+7],0
 0953                   .dbline 822
 0953 5208              mov A,[X+8]
 0955 1102              sub A,2
 0957 5207              mov A,[X+7]
 0959 3180              xor A,-128
 095B 1980              sbb A,(0 ^ 0x80)
 095D CF60              jc L208
 095F           X47:
 095F                   .dbline 858
 095F           ;                               }
 095F           L206:
 095F                   .dbline 860
 095F           ;                               
 095F           ;                               if(ID != SERVO_ID)
 095F 62D000            mov REG[0xd0],>_ID
 0962 5100              mov A,[_ID]
 0964 62D000            mov REG[0xd0],>_SERVO_ID
 0967 3A00              cmp A,[_SERVO_ID]
 0969 A00E              jz L225
 096B                   .dbline 861
 096B           ;                               {
 096B                   .dbline 863
 096B           ;                                       // Toggle back to normal wait mode.
 096B           ;                                       configToggle(WAIT);
 096B 5000              mov A,0
 096D 08                push A
 096E 5001              mov A,1
 0970 08                push A
 0971 7C00B4            xcall _configToggle
 0974 38FE              add SP,-2
 0976                   .dbline 864
 0976           ;                               }
 0976 8030              xjmp L201
 0978           L225:
 0978                   .dbline 866
 0978           ;                               else
 0978           ;                               {
 0978                   .dbline 868
 0978           ;                                       // Let the master node know that you got the ID assignment.
 0978           ;                                       assignedID();
 0978 9197              xcall _assignedID
 097A                   .dbline 869
 097A           ;                               }
 097A                   .dbline 870
 097A           ;                       }
 097A                   .dbline 871
 097A           ;               }
 097A 802C              xjmp L201
 097C           L202:
 097C                   .dbline 872
 097C           ;               else if(COMMAND_DESTINATION > ID)
 097C 62D000            mov REG[0xd0],>_ID
 097F 5100              mov A,[_ID]
 0981 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0984 3A00              cmp A,[_COMMAND_DESTINATION]
 0986 D020              jnc L201
 0988           X48:
 0988                   .dbline 873
 0988           ;               {
 0988                   .dbline 875
 0988           ;                       // Switch to listen to your child.
 0988           ;                       childResponse();
 0988 927E              xcall _childResponse
 098A                   .dbline 876
 098A           ;               }
 098A                   .dbline 877
 098A           ;       }
 098A 801C              xjmp L201
 098C           L200:
 098C                   .dbline 878
 098C           ;       else if((COMMAND_TYPE == PING_SERVO) || (COMMAND_TYPE == READ_SERVO))
 098C 62D000            mov REG[0xd0],>_COMMAND_TYPE
 098F 3C0001            cmp [_COMMAND_TYPE],1
 0992 A006              jz L231
 0994 3C0002            cmp [_COMMAND_TYPE],2
 0997 B00F              jnz L229
 0999           L231:
 0999                   .dbline 879
 0999           ;       {
 0999                   .dbline 880
 0999           ;               if(COMMAND_DESTINATION > ID)
 0999 62D000            mov REG[0xd0],>_ID
 099C 5100              mov A,[_ID]
 099E 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 09A1 3A00              cmp A,[_COMMAND_DESTINATION]
 09A3 D003              jnc L232
 09A5           X49:
 09A5                   .dbline 881
 09A5           ;               {
 09A5                   .dbline 883
 09A5           ;                       // Allow the child response through.
 09A5           ;                       childResponse();
 09A5 9261              xcall _childResponse
 09A7                   .dbline 884
 09A7           ;               }
 09A7           L232:
 09A7                   .dbline 885
 09A7           ;       }
 09A7           L229:
 09A7           L201:
 09A7           L195:
 09A7           L185:
 09A7                   .dbline -2
 09A7           L183:
 09A7 38F7              add SP,-9
 09A9 20                pop X
 09AA                   .dbline 0 ; func end
 09AA 7F                ret
 09AB                   .dbsym l j 7 I
 09AB                   .dbsym l i 5 I
 09AB                   .dbsym l runningTotal 3 I
 09AB                   .dbsym l tempByte 2 c
 09AB                   .dbsym l i 0 I
 09AB                   .dbend
 09AB                   .dbfunc e pingResponse _pingResponse fV
 09AB           _pingResponse::
 09AB                   .dbline -1
 09AB                   .dbline 890
 09AB           ; }
 09AB           ; 
 09AB           ; // This function sends out a ping response for everyone to hear.
 09AB           ; void pingResponse(void)
 09AB           ; {
 09AB                   .dbline 891
 09AB           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 09AB 5000              mov A,0
 09AD 08                push A
 09AE 5002              mov A,2
 09B0 08                push A
 09B1 7C00B4            xcall _configToggle
 09B4 38FE              add SP,-2
 09B6                   .dbline 894
 09B6           ;       
 09B6           ;       // Transmit a ping to everyone.
 09B6           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 09B6 10                push X
 09B7 50FC              mov A,-4
 09B9 7C0000            xcall _TX_014_PutChar
 09BC 20                pop X
 09BD                   .dbline 895
 09BD           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 09BD 10                push X
 09BE 50FC              mov A,-4
 09C0 7C0000            xcall _TX_23_PutChar
 09C3 20                pop X
 09C4                   .dbline 896
 09C4           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 09C4 10                push X
 09C5 50FC              mov A,-4
 09C7 7C0000            xcall _TX_014_PutChar
 09CA 20                pop X
 09CB                   .dbline 897
 09CB           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 09CB 10                push X
 09CC 50FC              mov A,-4
 09CE 7C0000            xcall _TX_23_PutChar
 09D1 20                pop X
 09D2                   .dbline 898
 09D2           ;       TX_014_PutChar(ID);                             // My ID
 09D2 10                push X
 09D3 62D000            mov REG[0xd0],>_ID
 09D6 5100              mov A,[_ID]
 09D8 7C0000            xcall _TX_014_PutChar
 09DB 20                pop X
 09DC                   .dbline 899
 09DC           ;       TX_23_PutChar(ID);                              // My ID
 09DC 10                push X
 09DD 62D000            mov REG[0xd0],>_ID
 09E0 5100              mov A,[_ID]
 09E2 7C0000            xcall _TX_23_PutChar
 09E5 20                pop X
 09E6                   .dbline 900
 09E6           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 09E6 10                push X
 09E7 5000              mov A,0
 09E9 7C0000            xcall _TX_014_PutChar
 09EC 20                pop X
 09ED                   .dbline 901
 09ED           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 09ED 10                push X
 09EE 5000              mov A,0
 09F0 7C0000            xcall _TX_23_PutChar
 09F3 20                pop X
 09F4                   .dbline 902
 09F4           ;       TX_014_PutChar(PING);                   // This is a ping response
 09F4 10                push X
 09F5 50CB              mov A,-53
 09F7 7C0000            xcall _TX_014_PutChar
 09FA 20                pop X
 09FB                   .dbline 903
 09FB           ;       TX_23_PutChar(PING);                    // This is a ping response
 09FB 10                push X
 09FC 50CB              mov A,-53
 09FE 7C0000            xcall _TX_23_PutChar
 0A01 20                pop X
 0A02                   .dbline 904
 0A02           ;       TX_014_PutChar(TYPE);                   // This is the module type
 0A02 10                push X
 0A03 5001              mov A,1
 0A05 7C0000            xcall _TX_014_PutChar
 0A08 20                pop X
 0A09                   .dbline 905
 0A09           ;       TX_23_PutChar(TYPE);                    // This is the module type
 0A09 10                push X
 0A0A 5001              mov A,1
 0A0C 7C0000            xcall _TX_23_PutChar
 0A0F 20                pop X
 0A10                   .dbline 906
 0A10           ;       TX_014_PutChar(CHILD);                  // This is the child-connected port
 0A10 10                push X
 0A11 62D000            mov REG[0xd0],>_CHILD
 0A14 5100              mov A,[_CHILD]
 0A16 7C0000            xcall _TX_014_PutChar
 0A19 20                pop X
 0A1A                   .dbline 907
 0A1A           ;       TX_23_PutChar(CHILD);                   // This is the child-connected port
 0A1A 10                push X
 0A1B 62D000            mov REG[0xd0],>_CHILD
 0A1E 5100              mov A,[_CHILD]
 0A20 7C0000            xcall _TX_23_PutChar
 0A23 20                pop X
 0A24                   .dbline 908
 0A24           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0A24 10                push X
 0A25 50FD              mov A,-3
 0A27 7C0000            xcall _TX_014_PutChar
 0A2A 20                pop X
 0A2B                   .dbline 909
 0A2B           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0A2B 10                push X
 0A2C 50FD              mov A,-3
 0A2E 7C0000            xcall _TX_23_PutChar
 0A31 20                pop X
 0A32                   .dbline 910
 0A32           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0A32 10                push X
 0A33 50FD              mov A,-3
 0A35 7C0000            xcall _TX_014_PutChar
 0A38 20                pop X
 0A39                   .dbline 911
 0A39           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0A39 10                push X
 0A3A 50FD              mov A,-3
 0A3C 7C0000            xcall _TX_23_PutChar
 0A3F 20                pop X
 0A40           L235:
 0A40                   .dbline 914
 0A40           ;       
 0A40           ;       // Wait for the transmission to finish.
 0A40           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0A40           L236:
 0A40                   .dbline 914
 0A40 10                push X
 0A41 7C0000            xcall _TX_014_bReadTxStatus
 0A44 62D000            mov REG[0xd0],>__r0
 0A47 20                pop X
 0A48 5300              mov [__r0],A
 0A4A 470020            tst [__r0],32
 0A4D AFF2              jz L235
 0A4F           L238:
 0A4F                   .dbline 915
 0A4F           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 0A4F           L239:
 0A4F                   .dbline 915
 0A4F 10                push X
 0A50 7C0000            xcall _TX_23_bReadTxStatus
 0A53 62D000            mov REG[0xd0],>__r0
 0A56 20                pop X
 0A57 5300              mov [__r0],A
 0A59 470020            tst [__r0],32
 0A5C AFF2              jz L238
 0A5E                   .dbline 918
 0A5E           ;       
 0A5E           ;       // Make completely sure we're done.
 0A5E           ;       xmitWait();
 0A5E 9533              xcall _xmitWait
 0A60                   .dbline 920
 0A60           ;       
 0A60           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0A60 5000              mov A,0
 0A62 08                push A
 0A63 5001              mov A,1
 0A65 08                push A
 0A66 7C00B4            xcall _configToggle
 0A69 38FE              add SP,-2
 0A6B                   .dbline -2
 0A6B           L234:
 0A6B                   .dbline 0 ; func end
 0A6B 7F                ret
 0A6C                   .dbend
 0A6C                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0A6C           _unloadAllConfigs::
 0A6C                   .dbline -1
 0A6C                   .dbline 926
 0A6C           ; }
 0A6C           ; 
 0A6C           ; // This function blindly unloads all user configurations. This will be called once,
 0A6C           ; // when the system initially has no known state.
 0A6C           ; void unloadAllConfigs(void)
 0A6C           ; {
 0A6C                   .dbline 927
 0A6C           ;       UnloadConfig_waiting();
 0A6C 7C0000            xcall _UnloadConfig_waiting
 0A6F                   .dbline 928
 0A6F           ;       UnloadConfig_hello();
 0A6F 7C0000            xcall _UnloadConfig_hello
 0A72                   .dbline 929
 0A72           ;       UnloadConfig_my_response();
 0A72 7C0000            xcall _UnloadConfig_my_response
 0A75                   .dbline 930
 0A75           ;       UnloadConfig_response1();
 0A75 7C0000            xcall _UnloadConfig_response1
 0A78                   .dbline 931
 0A78           ;       UnloadConfig_response2();
 0A78 7C0000            xcall _UnloadConfig_response2
 0A7B                   .dbline 932
 0A7B           ;       UnloadConfig_response3();
 0A7B 7C0000            xcall _UnloadConfig_response3
 0A7E                   .dbline 933
 0A7E           ;       UnloadConfig_response4();
 0A7E 7C0000            xcall _UnloadConfig_response4
 0A81                   .dbline 934
 0A81           ;       UnloadConfig_initial();
 0A81 7C0000            xcall _UnloadConfig_initial
 0A84                   .dbline 935
 0A84           ;       UnloadConfig_servo_transmit();
 0A84 7C0000            xcall _UnloadConfig_servo_transmit
 0A87                   .dbline -2
 0A87           L241:
 0A87                   .dbline 0 ; func end
 0A87 7F                ret
 0A88                   .dbend
 0A88                   .dbfunc e unloadConfig _unloadConfig fV
 0A88           ;     config_num -> X-5
 0A88           _unloadConfig::
 0A88                   .dbline -1
 0A88 10                push X
 0A89 4F                mov X,SP
 0A8A                   .dbline 941
 0A8A           ; }
 0A8A           ; 
 0A8A           ; // This function unloads the configuration corresponding to the config number passed to it.
 0A8A           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0A8A           ; void unloadConfig(int config_num)
 0A8A           ; {
 0A8A                   .dbline 942
 0A8A           ;       if(config_num == WAIT)
 0A8A 3DFB00            cmp [X-5],0
 0A8D B00B              jnz L243
 0A8F 3DFC01            cmp [X-4],1
 0A92 B006              jnz L243
 0A94           X50:
 0A94                   .dbline 943
 0A94           ;       {
 0A94                   .dbline 944
 0A94           ;               UnloadConfig_waiting();
 0A94 7C0000            xcall _UnloadConfig_waiting
 0A97                   .dbline 945
 0A97           ;       }
 0A97 8077              xjmp L244
 0A99           L243:
 0A99                   .dbline 946
 0A99           ;       else if(config_num == HELLO_MODE)
 0A99 3DFB00            cmp [X-5],0
 0A9C B00B              jnz L245
 0A9E 3DFC07            cmp [X-4],7
 0AA1 B006              jnz L245
 0AA3           X51:
 0AA3                   .dbline 947
 0AA3           ;       {
 0AA3                   .dbline 948
 0AA3           ;               UnloadConfig_hello();
 0AA3 7C0000            xcall _UnloadConfig_hello
 0AA6                   .dbline 949
 0AA6           ;       }
 0AA6 8068              xjmp L246
 0AA8           L245:
 0AA8                   .dbline 950
 0AA8           ;       else if(config_num == MY_RESPONSE)
 0AA8 3DFB00            cmp [X-5],0
 0AAB B00B              jnz L247
 0AAD 3DFC02            cmp [X-4],2
 0AB0 B006              jnz L247
 0AB2           X52:
 0AB2                   .dbline 951
 0AB2           ;       {
 0AB2                   .dbline 952
 0AB2           ;               UnloadConfig_my_response();
 0AB2 7C0000            xcall _UnloadConfig_my_response
 0AB5                   .dbline 953
 0AB5           ;       }
 0AB5 8059              xjmp L248
 0AB7           L247:
 0AB7                   .dbline 954
 0AB7           ;       else if(config_num == RESPONSE_1)
 0AB7 3DFB00            cmp [X-5],0
 0ABA B00B              jnz L249
 0ABC 3DFC03            cmp [X-4],3
 0ABF B006              jnz L249
 0AC1           X53:
 0AC1                   .dbline 955
 0AC1           ;       {
 0AC1                   .dbline 956
 0AC1           ;               UnloadConfig_response1();
 0AC1 7C0000            xcall _UnloadConfig_response1
 0AC4                   .dbline 957
 0AC4           ;       }
 0AC4 804A              xjmp L250
 0AC6           L249:
 0AC6                   .dbline 958
 0AC6           ;       else if(config_num == RESPONSE_2)
 0AC6 3DFB00            cmp [X-5],0
 0AC9 B00B              jnz L251
 0ACB 3DFC04            cmp [X-4],4
 0ACE B006              jnz L251
 0AD0           X54:
 0AD0                   .dbline 959
 0AD0           ;       {
 0AD0                   .dbline 960
 0AD0           ;               UnloadConfig_response2();
 0AD0 7C0000            xcall _UnloadConfig_response2
 0AD3                   .dbline 961
 0AD3           ;       }
 0AD3 803B              xjmp L252
 0AD5           L251:
 0AD5                   .dbline 962
 0AD5           ;       else if(config_num == RESPONSE_3)
 0AD5 3DFB00            cmp [X-5],0
 0AD8 B00B              jnz L253
 0ADA 3DFC05            cmp [X-4],5
 0ADD B006              jnz L253
 0ADF           X55:
 0ADF                   .dbline 963
 0ADF           ;       {
 0ADF                   .dbline 964
 0ADF           ;               UnloadConfig_response3();
 0ADF 7C0000            xcall _UnloadConfig_response3
 0AE2                   .dbline 965
 0AE2           ;       }
 0AE2 802C              xjmp L254
 0AE4           L253:
 0AE4                   .dbline 966
 0AE4           ;       else if(config_num == RESPONSE_4)
 0AE4 3DFB00            cmp [X-5],0
 0AE7 B00B              jnz L255
 0AE9 3DFC06            cmp [X-4],6
 0AEC B006              jnz L255
 0AEE           X56:
 0AEE                   .dbline 967
 0AEE           ;       {
 0AEE                   .dbline 968
 0AEE           ;               UnloadConfig_response4();
 0AEE 7C0000            xcall _UnloadConfig_response4
 0AF1                   .dbline 969
 0AF1           ;       }
 0AF1 801D              xjmp L256
 0AF3           L255:
 0AF3                   .dbline 970
 0AF3           ;       else if(config_num == INITIALIZE)
 0AF3 3DFB00            cmp [X-5],0
 0AF6 B00B              jnz L257
 0AF8 3DFC08            cmp [X-4],8
 0AFB B006              jnz L257
 0AFD           X57:
 0AFD                   .dbline 971
 0AFD           ;       {
 0AFD                   .dbline 972
 0AFD           ;               UnloadConfig_initial();
 0AFD 7C0000            xcall _UnloadConfig_initial
 0B00                   .dbline 973
 0B00           ;       }
 0B00 800E              xjmp L258
 0B02           L257:
 0B02                   .dbline 974
 0B02           ;       else if(config_num == SERVO_COMM)
 0B02 3DFB00            cmp [X-5],0
 0B05 B009              jnz L259
 0B07 3DFC09            cmp [X-4],9
 0B0A B004              jnz L259
 0B0C           X58:
 0B0C                   .dbline 975
 0B0C           ;       {
 0B0C                   .dbline 976
 0B0C           ;               UnloadConfig_servo_transmit();
 0B0C 7C0000            xcall _UnloadConfig_servo_transmit
 0B0F                   .dbline 977
 0B0F           ;       }
 0B0F           L259:
 0B0F           L258:
 0B0F           L256:
 0B0F           L254:
 0B0F           L252:
 0B0F           L250:
 0B0F           L248:
 0B0F           L246:
 0B0F           L244:
 0B0F                   .dbline -2
 0B0F           L242:
 0B0F 20                pop X
 0B10                   .dbline 0 ; func end
 0B10 7F                ret
 0B11                   .dbsym l config_num -5 I
 0B11                   .dbend
 0B11                   .dbfunc e assignedID _assignedID fV
 0B11           _assignedID::
 0B11                   .dbline -1
 0B11                   .dbline 982
 0B11           ; }
 0B11           ; 
 0B11           ; // This function responds that an ID has been assigned to it.
 0B11           ; void assignedID(void)
 0B11           ; {
 0B11                   .dbline 983
 0B11           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 0B11 5000              mov A,0
 0B13 08                push A
 0B14 5002              mov A,2
 0B16 08                push A
 0B17 7C00B4            xcall _configToggle
 0B1A 38FE              add SP,-2
 0B1C                   .dbline 986
 0B1C           ;       
 0B1C           ;       // Transmit a ping to everyone.
 0B1C           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 0B1C 10                push X
 0B1D 50FC              mov A,-4
 0B1F 7C0000            xcall _TX_014_PutChar
 0B22 20                pop X
 0B23                   .dbline 987
 0B23           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 0B23 10                push X
 0B24 50FC              mov A,-4
 0B26 7C0000            xcall _TX_23_PutChar
 0B29 20                pop X
 0B2A                   .dbline 988
 0B2A           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 0B2A 10                push X
 0B2B 50FC              mov A,-4
 0B2D 7C0000            xcall _TX_014_PutChar
 0B30 20                pop X
 0B31                   .dbline 989
 0B31           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 0B31 10                push X
 0B32 50FC              mov A,-4
 0B34 7C0000            xcall _TX_23_PutChar
 0B37 20                pop X
 0B38                   .dbline 990
 0B38           ;       TX_014_PutChar(ID);                             // My ID
 0B38 10                push X
 0B39 62D000            mov REG[0xd0],>_ID
 0B3C 5100              mov A,[_ID]
 0B3E 7C0000            xcall _TX_014_PutChar
 0B41 20                pop X
 0B42                   .dbline 991
 0B42           ;       TX_23_PutChar(ID);                              // My ID
 0B42 10                push X
 0B43 62D000            mov REG[0xd0],>_ID
 0B46 5100              mov A,[_ID]
 0B48 7C0000            xcall _TX_23_PutChar
 0B4B 20                pop X
 0B4C                   .dbline 992
 0B4C           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 0B4C 10                push X
 0B4D 5000              mov A,0
 0B4F 7C0000            xcall _TX_014_PutChar
 0B52 20                pop X
 0B53                   .dbline 993
 0B53           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 0B53 10                push X
 0B54 5000              mov A,0
 0B56 7C0000            xcall _TX_23_PutChar
 0B59 20                pop X
 0B5A                   .dbline 994
 0B5A           ;       TX_014_PutChar(ID_ASSIGN_OK);   // This is an assignment ack response
 0B5A 10                push X
 0B5B 50CA              mov A,-54
 0B5D 7C0000            xcall _TX_014_PutChar
 0B60 20                pop X
 0B61                   .dbline 995
 0B61           ;       TX_23_PutChar(ID_ASSIGN_OK);    // This is an assignment ack response
 0B61 10                push X
 0B62 50CA              mov A,-54
 0B64 7C0000            xcall _TX_23_PutChar
 0B67 20                pop X
 0B68                   .dbline 996
 0B68           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0B68 10                push X
 0B69 50FD              mov A,-3
 0B6B 7C0000            xcall _TX_014_PutChar
 0B6E 20                pop X
 0B6F                   .dbline 997
 0B6F           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0B6F 10                push X
 0B70 50FD              mov A,-3
 0B72 7C0000            xcall _TX_23_PutChar
 0B75 20                pop X
 0B76                   .dbline 998
 0B76           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0B76 10                push X
 0B77 50FD              mov A,-3
 0B79 7C0000            xcall _TX_014_PutChar
 0B7C 20                pop X
 0B7D                   .dbline 999
 0B7D           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0B7D 10                push X
 0B7E 50FD              mov A,-3
 0B80 7C0000            xcall _TX_23_PutChar
 0B83 20                pop X
 0B84           L262:
 0B84                   .dbline 1002
 0B84           ;       
 0B84           ;       // Wait for the transmission to finish.
 0B84           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0B84           L263:
 0B84                   .dbline 1002
 0B84 10                push X
 0B85 7C0000            xcall _TX_014_bReadTxStatus
 0B88 62D000            mov REG[0xd0],>__r0
 0B8B 20                pop X
 0B8C 5300              mov [__r0],A
 0B8E 470020            tst [__r0],32
 0B91 AFF2              jz L262
 0B93           L265:
 0B93                   .dbline 1003
 0B93           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 0B93           L266:
 0B93                   .dbline 1003
 0B93 10                push X
 0B94 7C0000            xcall _TX_23_bReadTxStatus
 0B97 62D000            mov REG[0xd0],>__r0
 0B9A 20                pop X
 0B9B 5300              mov [__r0],A
 0B9D 470020            tst [__r0],32
 0BA0 AFF2              jz L265
 0BA2                   .dbline 1006
 0BA2           ;       
 0BA2           ;       // Make completely sure we're done.
 0BA2           ;       xmitWait();
 0BA2 93EF              xcall _xmitWait
 0BA4                   .dbline 1008
 0BA4           ;       
 0BA4           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0BA4 5000              mov A,0
 0BA6 08                push A
 0BA7 5001              mov A,1
 0BA9 08                push A
 0BAA 7C00B4            xcall _configToggle
 0BAD 38FE              add SP,-2
 0BAF                   .dbline -2
 0BAF           L261:
 0BAF                   .dbline 0 ; func end
 0BAF 7F                ret
 0BB0                   .dbend
 0BB0                   .dbfunc e childListen _childListen fI
 0BB0           _childListen::
 0BB0                   .dbline -1
 0BB0                   .dbline 1013
 0BB0           ; }
 0BB0           ; 
 0BB0           ; // This function listens for children and registers the port that they talk to.
 0BB0           ; int childListen(void)
 0BB0           ; {
 0BB0                   .dbline 1014
 0BB0           ;       configToggle(HELLO_MODE);       // Switch to listen for hellos on every port.
 0BB0 5000              mov A,0
 0BB2 08                push A
 0BB3 5007              mov A,7
 0BB5 08                push A
 0BB6 7C00B4            xcall _configToggle
 0BB9 38FE              add SP,-2
 0BBB 801C              xjmp L270
 0BBD           L269:
 0BBD                   .dbline 1018
 0BBD           ;       
 0BBD           ;       // Wait to either hear a child or time out.
 0BBD           ;       while(!TIMEOUT)
 0BBD           ;       {               
 0BBD                   .dbline 1019
 0BBD           ;               if(commandReady())
 0BBD 7C02BE            xcall _commandReady
 0BC0 62D000            mov REG[0xd0],>__r0
 0BC3 3C0000            cmp [__r0],0
 0BC6 B006              jnz X59
 0BC8 3C0000            cmp [__r1],0
 0BCB A00C              jz L272
 0BCD           X59:
 0BCD                   .dbline 1020
 0BCD           ;               {
 0BCD                   .dbline 1021
 0BCD           ;                       return 1;
 0BCD 62D000            mov REG[0xd0],>__r0
 0BD0 550001            mov [__r1],1
 0BD3 550000            mov [__r0],0
 0BD6 8030              xjmp L268
 0BD8           L272:
 0BD8                   .dbline 1023
 0BD8           ;               }
 0BD8           ;       }
 0BD8           L270:
 0BD8                   .dbline 1017
 0BD8 62D000            mov REG[0xd0],>_TIMEOUT
 0BDB 3C0000            cmp [_TIMEOUT],0
 0BDE B006              jnz X60
 0BE0 3C0100            cmp [_TIMEOUT+1],0
 0BE3 AFD9              jz L269
 0BE5           X60:
 0BE5                   .dbline 1025
 0BE5           ;       
 0BE5           ;       HELLO_TIMEOUT_Stop();           // Stop the timer.
 0BE5 10                push X
 0BE6 7C0000            xcall _HELLO_TIMEOUT_Stop
 0BE9 20                pop X
 0BEA                   .dbline 1026
 0BEA           ;       TIMEOUT = 0;                            // Clear the timeout flag.
 0BEA 62D000            mov REG[0xd0],>_TIMEOUT
 0BED 550100            mov [_TIMEOUT+1],0
 0BF0 550000            mov [_TIMEOUT],0
 0BF3                   .dbline 1028
 0BF3           ;       
 0BF3           ;       configToggle(WAIT);                     // Switch back to wait for a master response.
 0BF3 5000              mov A,0
 0BF5 08                push A
 0BF6 5001              mov A,1
 0BF8 08                push A
 0BF9 7C00B4            xcall _configToggle
 0BFC 38FE              add SP,-2
 0BFE                   .dbline 1030
 0BFE           ;       
 0BFE           ;       return 0;                                       // Return the result of our listening session.
 0BFE 62D000            mov REG[0xd0],>__r0
 0C01 550000            mov [__r1],0
 0C04 550000            mov [__r0],0
 0C07                   .dbline -2
 0C07           L268:
 0C07                   .dbline 0 ; func end
 0C07 7F                ret
 0C08                   .dbend
 0C08                   .dbfunc e childResponse _childResponse fI
 0C08           ; child_responded -> X+0
 0C08           _childResponse::
 0C08                   .dbline -1
 0C08 10                push X
 0C09 4F                mov X,SP
 0C0A 3802              add SP,2
 0C0C                   .dbline 1035
 0C0C           ; }
 0C0C           ; 
 0C0C           ; // This function waits for a known child's response.
 0C0C           ; int childResponse(void)
 0C0C           ; {
 0C0C                   .dbline 1036
 0C0C           ;       int child_responded = 0;
 0C0C 560100            mov [X+1],0
 0C0F 560000            mov [X+0],0
 0C12                   .dbline 1039
 0C12           ;       
 0C12           ;       // Switch to the right port.
 0C12           ;       if(CHILD == PORT_1)
 0C12 62D000            mov REG[0xd0],>_CHILD
 0C15 3C0031            cmp [_CHILD],49
 0C18 B00E              jnz L275
 0C1A                   .dbline 1040
 0C1A           ;       {
 0C1A                   .dbline 1041
 0C1A           ;               configToggle(RESPONSE_1);
 0C1A 5000              mov A,0
 0C1C 08                push A
 0C1D 5003              mov A,3
 0C1F 08                push A
 0C20 7C00B4            xcall _configToggle
 0C23 38FE              add SP,-2
 0C25                   .dbline 1042
 0C25           ;       }
 0C25 8056              xjmp L284
 0C27           L275:
 0C27                   .dbline 1043
 0C27           ;       else if(CHILD == PORT_2)
 0C27 62D000            mov REG[0xd0],>_CHILD
 0C2A 3C0032            cmp [_CHILD],50
 0C2D B00E              jnz L277
 0C2F                   .dbline 1044
 0C2F           ;       {
 0C2F                   .dbline 1045
 0C2F           ;               configToggle(RESPONSE_2);
 0C2F 5000              mov A,0
 0C31 08                push A
 0C32 5004              mov A,4
 0C34 08                push A
 0C35 7C00B4            xcall _configToggle
 0C38 38FE              add SP,-2
 0C3A                   .dbline 1046
 0C3A           ;       }
 0C3A 8041              xjmp L284
 0C3C           L277:
 0C3C                   .dbline 1047
 0C3C           ;       else if(CHILD == PORT_3)
 0C3C 62D000            mov REG[0xd0],>_CHILD
 0C3F 3C0033            cmp [_CHILD],51
 0C42 B00E              jnz L279
 0C44                   .dbline 1048
 0C44           ;       {
 0C44                   .dbline 1049
 0C44           ;               configToggle(RESPONSE_3);
 0C44 5000              mov A,0
 0C46 08                push A
 0C47 5005              mov A,5
 0C49 08                push A
 0C4A 7C00B4            xcall _configToggle
 0C4D 38FE              add SP,-2
 0C4F                   .dbline 1050
 0C4F           ;       }
 0C4F 802C              xjmp L284
 0C51           L279:
 0C51                   .dbline 1051
 0C51           ;       else if(CHILD == PORT_4)
 0C51 62D000            mov REG[0xd0],>_CHILD
 0C54 3C0034            cmp [_CHILD],52
 0C57 B024              jnz L284
 0C59                   .dbline 1052
 0C59           ;       {
 0C59                   .dbline 1053
 0C59           ;               configToggle(RESPONSE_4);
 0C59 5000              mov A,0
 0C5B 08                push A
 0C5C 5006              mov A,6
 0C5E 08                push A
 0C5F 7C00B4            xcall _configToggle
 0C62 38FE              add SP,-2
 0C64                   .dbline 1054
 0C64           ;       }
 0C64 8017              xjmp L284
 0C66           L283:
 0C66                   .dbline 1058
 0C66           ;       
 0C66           ;       // Wait for a response or a timeout.
 0C66           ;       while((!child_responded) && (!TIMEOUT))
 0C66           ;       {
 0C66                   .dbline 1059
 0C66           ;               if(commandReady())
 0C66 7C02BE            xcall _commandReady
 0C69 62D000            mov REG[0xd0],>__r0
 0C6C 3C0000            cmp [__r0],0
 0C6F B006              jnz X61
 0C71 3C0000            cmp [__r1],0
 0C74 A007              jz L286
 0C76           X61:
 0C76                   .dbline 1060
 0C76           ;               {
 0C76                   .dbline 1061
 0C76           ;                       child_responded = 1;
 0C76 560101            mov [X+1],1
 0C79 560000            mov [X+0],0
 0C7C                   .dbline 1062
 0C7C           ;               }
 0C7C           L286:
 0C7C                   .dbline 1063
 0C7C           ;       }
 0C7C           L284:
 0C7C                   .dbline 1057
 0C7C 3D0000            cmp [X+0],0
 0C7F B013              jnz L288
 0C81 3D0100            cmp [X+1],0
 0C84 B00E              jnz L288
 0C86           X62:
 0C86 62D000            mov REG[0xd0],>_TIMEOUT
 0C89 3C0000            cmp [_TIMEOUT],0
 0C8C B006              jnz X63
 0C8E 3C0100            cmp [_TIMEOUT+1],0
 0C91 AFD4              jz L283
 0C93           X63:
 0C93           L288:
 0C93                   .dbline 1066
 0C93           ;       
 0C93           ;       // Stop the right timer.
 0C93           ;       if(CHILD == PORT_1)
 0C93 62D000            mov REG[0xd0],>_CHILD
 0C96 3C0031            cmp [_CHILD],49
 0C99 B008              jnz L289
 0C9B                   .dbline 1067
 0C9B           ;       {
 0C9B                   .dbline 1068
 0C9B           ;               CHILD_1_TIMEOUT_Stop();
 0C9B 10                push X
 0C9C 7C0000            xcall _CHILD_1_TIMEOUT_Stop
 0C9F 20                pop X
 0CA0                   .dbline 1069
 0CA0           ;       }
 0CA0 802C              xjmp L290
 0CA2           L289:
 0CA2                   .dbline 1070
 0CA2           ;       else if(CHILD == PORT_2)
 0CA2 62D000            mov REG[0xd0],>_CHILD
 0CA5 3C0032            cmp [_CHILD],50
 0CA8 B008              jnz L291
 0CAA                   .dbline 1071
 0CAA           ;       {
 0CAA                   .dbline 1072
 0CAA           ;               CHILD_2_TIMEOUT_Stop();
 0CAA 10                push X
 0CAB 7C0000            xcall _CHILD_2_TIMEOUT_Stop
 0CAE 20                pop X
 0CAF                   .dbline 1073
 0CAF           ;       }
 0CAF 801D              xjmp L292
 0CB1           L291:
 0CB1                   .dbline 1074
 0CB1           ;       else if(CHILD == PORT_3)
 0CB1 62D000            mov REG[0xd0],>_CHILD
 0CB4 3C0033            cmp [_CHILD],51
 0CB7 B008              jnz L293
 0CB9                   .dbline 1075
 0CB9           ;       {
 0CB9                   .dbline 1076
 0CB9           ;               CHILD_3_TIMEOUT_Stop();
 0CB9 10                push X
 0CBA 7C0000            xcall _CHILD_3_TIMEOUT_Stop
 0CBD 20                pop X
 0CBE                   .dbline 1077
 0CBE           ;       }
 0CBE 800E              xjmp L294
 0CC0           L293:
 0CC0                   .dbline 1078
 0CC0           ;       else if(CHILD == PORT_4)
 0CC0 62D000            mov REG[0xd0],>_CHILD
 0CC3 3C0034            cmp [_CHILD],52
 0CC6 B006              jnz L295
 0CC8                   .dbline 1079
 0CC8           ;       {
 0CC8                   .dbline 1080
 0CC8           ;               CHILD_4_TIMEOUT_Stop();
 0CC8 10                push X
 0CC9 7C0000            xcall _CHILD_4_TIMEOUT_Stop
 0CCC 20                pop X
 0CCD                   .dbline 1081
 0CCD           ;       }
 0CCD           L295:
 0CCD           L294:
 0CCD           L292:
 0CCD           L290:
 0CCD                   .dbline 1083
 0CCD           ;       
 0CCD           ;       TIMEOUT = 0;                                    // Reset the timeout flag.
 0CCD 62D000            mov REG[0xd0],>_TIMEOUT
 0CD0 550100            mov [_TIMEOUT+1],0
 0CD3 550000            mov [_TIMEOUT],0
 0CD6                   .dbline 1085
 0CD6           ;       
 0CD6           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0CD6 5000              mov A,0
 0CD8 08                push A
 0CD9 5001              mov A,1
 0CDB 08                push A
 0CDC 7C00B4            xcall _configToggle
 0CDF 38FE              add SP,-2
 0CE1                   .dbline 1087
 0CE1           ;       
 0CE1           ;       return child_responded;
 0CE1 62D000            mov REG[0xd0],>__r0
 0CE4 5201              mov A,[X+1]
 0CE6 5300              mov [__r1],A
 0CE8 5200              mov A,[X+0]
 0CEA 5300              mov [__r0],A
 0CEC                   .dbline -2
 0CEC           L274:
 0CEC 38FE              add SP,-2
 0CEE 20                pop X
 0CEF                   .dbline 0 ; func end
 0CEF 7F                ret
 0CF0                   .dbsym l child_responded 0 I
 0CF0                   .dbend
 0CF0                   .dbfunc e servoFinder _servoFinder fV
 0CF0           ;     flashWrite -> X+7
 0CF0           ; status_return_level -> X+6
 0CF0           ; total_attempts -> X+4
 0CF0           ;              j -> X+2
 0CF0           ;              i -> X+0
 0CF0           _servoFinder::
 0CF0                   .dbline -1
 0CF0 10                push X
 0CF1 4F                mov X,SP
 0CF2 3809              add SP,9
 0CF4                   .dbline 1094
 0CF4           ; }
 0CF4           ; 
 0CF4           ; // This function is used to find the servo that is directly connected to this module's controller.
 0CF4           ; // After the servo ID is found, the status return level is changed so that packets are only
 0CF4           ; // returned for the desired status return level defined at the top of this file.
 0CF4           ; void servoFinder(void)
 0CF4           ; {                             
 0CF4                   .dbline 1096
 0CF4           ;       // Index variables for incrementing and checking against the maximum servo comm attempts.
 0CF4           ;       int i = 0;
 0CF4 560100            mov [X+1],0
 0CF7 560000            mov [X+0],0
 0CFA                   .dbline 1097
 0CFA           ;       int j = 0;
 0CFA 560300            mov [X+3],0
 0CFD 560200            mov [X+2],0
 0D00                   .dbline 1099
 0D00           ;       
 0D00           ;       int total_attempts = 0;
 0D00 560500            mov [X+5],0
 0D03 560400            mov [X+4],0
 0D06                   .dbline 1102
 0D06           ;       
 0D06           ;       // Integer used as a flag so that EEPROM writes aren't done more than once.
 0D06           ;       int flashWrite = 0;
 0D06 560800            mov [X+8],0
 0D09 560700            mov [X+7],0
 0D0C                   .dbline 1105
 0D0C           ;       
 0D0C           ;       // Create a status return level variable and set it to an out of range value initially.
 0D0C           ;       char status_return_level = 3;
 0D0C 560603            mov [X+6],3
 0D0F                   .dbline 1108
 0D0F           ;       
 0D0F           ;       // Start with a servo ID of 255 (out of valid range).
 0D0F           ;       SERVO_ID = SERVO_START;
 0D0F 62D000            mov REG[0xd0],>_SERVO_ID
 0D12 5500FF            mov [_SERVO_ID],-1
 0D15                   .dbline 1117
 0D15           ; 
 0D15           ;       // This for loop will loop SERVO_COMM_LOOPS number of times and ping the servo SERVO_COMM_ATTEMPTS
 0D15           ;       // number of times in each loop (unless stopped short due to early success). If this fails for the
 0D15           ;       // first round of pings, a broadcast reset will be performed to reset the servo. This is done
 0D15           ;       // because we assume that the baud rate is matching up, but the servo's return delay time is too
 0D15           ;       // fast for the controller to switch into receive mode to read the response. The default return
 0D15           ;       // delay time is 500 microseconds. If we loop for SERVO_COMM_LOOPS number of times and still don't
 0D15           ;       // see anything, we assume that there is something is too wrong for us to fix.
 0D15           ;       for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0D15 560300            mov [X+3],0
 0D18 560200            mov [X+2],0
 0D1B           L298:
 0D1B                   .dbline 1118
 0D1B           ;       {       
 0D1B                   .dbline 1120
 0D1B           ;               // Ping SERVO_COMM_ATTEMPTS times to try and extract the servo ID.
 0D1B           ;               for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0D1B 560100            mov [X+1],0
 0D1E 560000            mov [X+0],0
 0D21           L302:
 0D21                   .dbline 1121
 0D21           ;               {
 0D21                   .dbline 1123
 0D21           ;                       // Send a ping out for any servo connected to me (will only be one).
 0D21           ;                       servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
 0D21 5000              mov A,0
 0D23 08                push A
 0D24 08                push A
 0D25 5001              mov A,1
 0D27 08                push A
 0D28 5002              mov A,2
 0D2A 08                push A
 0D2B 50FE              mov A,-2
 0D2D 08                push A
 0D2E 9185              xcall _servoInstruction
 0D30 38FB              add SP,-5
 0D32                   .dbline 1125
 0D32           ;                       
 0D32           ;                       total_attempts++;
 0D32 7705              inc [X+5]
 0D34 0F0400            adc [X+4],0
 0D37 804C              xjmp L307
 0D39           L306:
 0D39                   .dbline 1129
 0D39           ;                       
 0D39           ;                       // Wait for either a timeout or a valid servo ID (which will trigger a timeout).
 0D39           ;                       while(!TIMEOUT)
 0D39           ;                       {       
 0D39                   .dbline 1130
 0D39           ;                               if(commandReady())
 0D39 7C02BE            xcall _commandReady
 0D3C 62D000            mov REG[0xd0],>__r0
 0D3F 3C0000            cmp [__r0],0
 0D42 B006              jnz X64
 0D44 3C0000            cmp [__r1],0
 0D47 A03C              jz L309
 0D49           X64:
 0D49                   .dbline 1131
 0D49           ;                               {
 0D49                   .dbline 1133
 0D49           ;                                       // If we read a source ID within the range, exit the loop.
 0D49           ;                                       if((COMMAND_SOURCE >= SERVO_ID_MIN) && (COMMAND_SOURCE <= SERVO_ID_MAX))
 0D49 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0D4C 3C0000            cmp [_COMMAND_SOURCE],0
 0D4F C02B              jc L311
 0D51           X65:
 0D51 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0D54 50FD              mov A,-3
 0D56 3A00              cmp A,[_COMMAND_SOURCE]
 0D58 C022              jc L311
 0D5A           X66:
 0D5A                   .dbline 1134
 0D5A           ;                                       {       
 0D5A                   .dbline 1136
 0D5A           ;                                               // Exit this while loop by setting the timeout flag.
 0D5A           ;                                               TIMEOUT = 1;
 0D5A 62D000            mov REG[0xd0],>_TIMEOUT
 0D5D 550101            mov [_TIMEOUT+1],1
 0D60 550000            mov [_TIMEOUT],0
 0D63                   .dbline 1138
 0D63           ;                                               // Set the servo ID variable to where the ping came from.
 0D63           ;                                               SERVO_ID = COMMAND_SOURCE;
 0D63 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0D66 5100              mov A,[_COMMAND_SOURCE]
 0D68 62D000            mov REG[0xd0],>_SERVO_ID
 0D6B 5300              mov [_SERVO_ID],A
 0D6D                   .dbline 1140
 0D6D           ;                                               // Set the index variable such that the for loop exits.
 0D6D           ;                                               i = SERVO_COMM_ATTEMPTS;
 0D6D 56010A            mov [X+1],10
 0D70 560000            mov [X+0],0
 0D73                   .dbline 1142
 0D73           ;                                               // Set the outer index variable to 2 to not attempt again for no reason.
 0D73           ;                                               j = SERVO_COMM_LOOPS;
 0D73 560302            mov [X+3],2
 0D76 560200            mov [X+2],0
 0D79                   .dbline 1143
 0D79           ;                                       }
 0D79 800A              xjmp L312
 0D7B           L311:
 0D7B                   .dbline 1145
 0D7B           ;                                       else
 0D7B           ;                                       {
 0D7B                   .dbline 1147
 0D7B           ;                                               // Exit this while loop and try to ping again.
 0D7B           ;                                               TIMEOUT = 1;
 0D7B 62D000            mov REG[0xd0],>_TIMEOUT
 0D7E 550101            mov [_TIMEOUT+1],1
 0D81 550000            mov [_TIMEOUT],0
 0D84                   .dbline 1148
 0D84           ;                                       }
 0D84           L312:
 0D84                   .dbline 1149
 0D84           ;                               }
 0D84           L309:
 0D84                   .dbline 1150
 0D84           ;                       }
 0D84           L307:
 0D84                   .dbline 1128
 0D84 62D000            mov REG[0xd0],>_TIMEOUT
 0D87 3C0000            cmp [_TIMEOUT],0
 0D8A B006              jnz X67
 0D8C 3C0100            cmp [_TIMEOUT+1],0
 0D8F AFA9              jz L306
 0D91           X67:
 0D91                   .dbline 1151
 0D91           ;               }
 0D91           L303:
 0D91                   .dbline 1120
 0D91 7701              inc [X+1]
 0D93 0F0000            adc [X+0],0
 0D96                   .dbline 1120
 0D96 5201              mov A,[X+1]
 0D98 110A              sub A,10
 0D9A 5200              mov A,[X+0]
 0D9C 3180              xor A,-128
 0D9E 1980              sbb A,(0 ^ 0x80)
 0DA0 CF80              jc L302
 0DA2           X68:
 0DA2                   .dbline 1155
 0DA2           ;               
 0DA2           ;               // If we didn't get a response and haven't written to the flash of the
 0DA2           ;               // servo (first time through), send out a broadcast reset.
 0DA2           ;               if((SERVO_ID == SERVO_START) && (!flashWrite))
 0DA2 62D000            mov REG[0xd0],>_SERVO_ID
 0DA5 3C00FF            cmp [_SERVO_ID],-1
 0DA8 B022              jnz L313
 0DAA 3D0700            cmp [X+7],0
 0DAD B01D              jnz L313
 0DAF 3D0800            cmp [X+8],0
 0DB2 B018              jnz L313
 0DB4           X69:
 0DB4                   .dbline 1156
 0DB4           ;               {
 0DB4                   .dbline 1158
 0DB4           ;                       // Set the flash write flag so that we only do this once per power cycle.
 0DB4           ;                       flashWrite = 1;
 0DB4 560801            mov [X+8],1
 0DB7 560700            mov [X+7],0
 0DBA                   .dbline 1162
 0DBA           ;                       
 0DBA           ;                       // Send out a broadcast reset so that we know that the response time interval
 0DBA           ;                       // is large enough (default delay time for a servo is 500 microseconds).
 0DBA           ;                       servoInstruction(BROADCAST, RESET_LENGTH, RESET_SERVO, 0, 0);
 0DBA 5000              mov A,0
 0DBC 08                push A
 0DBD 08                push A
 0DBE 5006              mov A,6
 0DC0 08                push A
 0DC1 5002              mov A,2
 0DC3 08                push A
 0DC4 50FE              mov A,-2
 0DC6 08                push A
 0DC7 90EC              xcall _servoInstruction
 0DC9 38FB              add SP,-5
 0DCB                   .dbline 1163
 0DCB           ;               }
 0DCB           L313:
 0DCB                   .dbline 1164
 0DCB           ;       }
 0DCB           L299:
 0DCB                   .dbline 1117
 0DCB 7703              inc [X+3]
 0DCD 0F0200            adc [X+2],0
 0DD0                   .dbline 1117
 0DD0 5203              mov A,[X+3]
 0DD2 1102              sub A,2
 0DD4 5202              mov A,[X+2]
 0DD6 3180              xor A,-128
 0DD8 1980              sbb A,(0 ^ 0x80)
 0DDA CF40              jc L298
 0DDC           X70:
 0DDC                   .dbline 1167
 0DDC           ; 
 0DDC           ;       // Reset flash write flag.
 0DDC           ;       flashWrite = 0;
 0DDC 560800            mov [X+8],0
 0DDF 560700            mov [X+7],0
 0DE2                   .dbline 1171
 0DE2           ;       
 0DE2           ;       // If we have a valid servo ID, set the status return level. If we don't, just skip this
 0DE2           ;       // because all hope is lost.
 0DE2           ;       if(SERVO_ID < BROADCAST)
 0DE2 62D000            mov REG[0xd0],>_SERVO_ID
 0DE5 3C00FE            cmp [_SERVO_ID],-2
 0DE8 D0C6              jnc L315
 0DEA           X71:
 0DEA                   .dbline 1172
 0DEA           ;       {
 0DEA                   .dbline 1177
 0DEA           ;               // This for loop will loop SERVO_COMM_LOOPS number of times and poll for the servo's status
 0DEA           ;               // return level SERVO_COMM_ATTEMPTS number of times in each loop (unless stopped short due
 0DEA           ;               // to early success). If this fails for the first iteration, or we read a status return level
 0DEA           ;               // other than what we want, we will attempt to write the desired status return level onto the servo.
 0DEA           ;               for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0DEA 560300            mov [X+3],0
 0DED 560200            mov [X+2],0
 0DF0           L317:
 0DF0                   .dbline 1178
 0DF0           ;               {
 0DF0                   .dbline 1180
 0DF0           ;                       // Attempt to read the status return level for the defined number of attempts.
 0DF0           ;                       for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0DF0 560100            mov [X+1],0
 0DF3 560000            mov [X+0],0
 0DF6           L321:
 0DF6                   .dbline 1181
 0DF6           ;                       {
 0DF6                   .dbline 1183
 0DF6           ;                               // Send a request for the servo's status return level.
 0DF6           ;                               servoInstruction(SERVO_ID, READ_LENGTH, READ_SERVO, STATUS_RET_ADDRESS, 1);
 0DF6 5001              mov A,1
 0DF8 08                push A
 0DF9 5010              mov A,16
 0DFB 08                push A
 0DFC 5002              mov A,2
 0DFE 08                push A
 0DFF 5004              mov A,4
 0E01 08                push A
 0E02 62D000            mov REG[0xd0],>_SERVO_ID
 0E05 5100              mov A,[_SERVO_ID]
 0E07 08                push A
 0E08 90AB              xcall _servoInstruction
 0E0A 38FB              add SP,-5
 0E0C 8048              xjmp L326
 0E0E           L325:
 0E0E                   .dbline 1187
 0E0E           ;                               
 0E0E           ;                               // Wait for either a timeout or an indication that we want to exit the loop.
 0E0E           ;                               while(!TIMEOUT)
 0E0E           ;                               {
 0E0E                   .dbline 1189
 0E0E           ;                                       // If a valid command is ready, interpret it.
 0E0E           ;                                       if(commandReady())
 0E0E 7C02BE            xcall _commandReady
 0E11 62D000            mov REG[0xd0],>__r0
 0E14 3C0000            cmp [__r0],0
 0E17 B006              jnz X72
 0E19 3C0000            cmp [__r1],0
 0E1C A038              jz L328
 0E1E           X72:
 0E1E                   .dbline 1190
 0E1E           ;                                       {
 0E1E                   .dbline 1191
 0E1E           ;                                               if(!COMMAND_ERROR)
 0E1E 62D000            mov REG[0xd0],>_COMMAND_ERROR
 0E21 3C0000            cmp [_COMMAND_ERROR],0
 0E24 B030              jnz L330
 0E26                   .dbline 1192
 0E26           ;                                               {
 0E26                   .dbline 1194
 0E26           ;                                                       // If the return level is equal to what is desired, store it.
 0E26           ;                                                       if(COMMAND_PARAM == STATUS_RET_LEVEL)
 0E26 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0E29 3C0001            cmp [_COMMAND_PARAM],1
 0E2C B01F              jnz L332
 0E2E                   .dbline 1195
 0E2E           ;                                                       {
 0E2E                   .dbline 1197
 0E2E           ;                                                               // Set the timeout flag to exit the loop.
 0E2E           ;                                                               TIMEOUT = 1;
 0E2E 62D000            mov REG[0xd0],>_TIMEOUT
 0E31 550101            mov [_TIMEOUT+1],1
 0E34 550000            mov [_TIMEOUT],0
 0E37                   .dbline 1199
 0E37           ;                                                               // Store the status return level.
 0E37           ;                                                               status_return_level = COMMAND_PARAM;
 0E37 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0E3A 5100              mov A,[_COMMAND_PARAM]
 0E3C 5406              mov [X+6],A
 0E3E                   .dbline 1201
 0E3E           ;                                                               // Set i so that we exit the for loop.
 0E3E           ;                                                               i = SERVO_COMM_ATTEMPTS;
 0E3E 56010A            mov [X+1],10
 0E41 560000            mov [X+0],0
 0E44                   .dbline 1203
 0E44           ;                                                               // Set the outer loop's variable so that we don't loop again.
 0E44           ;                                                               j = SERVO_COMM_LOOPS;
 0E44 560302            mov [X+3],2
 0E47 560200            mov [X+2],0
 0E4A                   .dbline 1204
 0E4A           ;                                                       }
 0E4A 800A              xjmp L333
 0E4C           L332:
 0E4C                   .dbline 1206
 0E4C           ;                                                       else
 0E4C           ;                                                       {       
 0E4C                   .dbline 1208
 0E4C           ;                                                               // Set the timeout flag to exit the loop.
 0E4C           ;                                                               TIMEOUT = 1;
 0E4C 62D000            mov REG[0xd0],>_TIMEOUT
 0E4F 550101            mov [_TIMEOUT+1],1
 0E52 550000            mov [_TIMEOUT],0
 0E55                   .dbline 1209
 0E55           ;                                                       }
 0E55           L333:
 0E55                   .dbline 1210
 0E55           ;                                               }
 0E55           L330:
 0E55                   .dbline 1211
 0E55           ;                                       }
 0E55           L328:
 0E55                   .dbline 1212
 0E55           ;                               }
 0E55           L326:
 0E55                   .dbline 1186
 0E55 62D000            mov REG[0xd0],>_TIMEOUT
 0E58 3C0000            cmp [_TIMEOUT],0
 0E5B B006              jnz X73
 0E5D 3C0100            cmp [_TIMEOUT+1],0
 0E60 AFAD              jz L325
 0E62           X73:
 0E62                   .dbline 1213
 0E62           ;                       }
 0E62           L322:
 0E62                   .dbline 1180
 0E62 7701              inc [X+1]
 0E64 0F0000            adc [X+0],0
 0E67                   .dbline 1180
 0E67 5201              mov A,[X+1]
 0E69 110A              sub A,10
 0E6B 5200              mov A,[X+0]
 0E6D 3180              xor A,-128
 0E6F 1980              sbb A,(0 ^ 0x80)
 0E71 CF84              jc L321
 0E73           X74:
 0E73                   .dbline 1217
 0E73           ;               
 0E73           ;                       // If we didn't get a good response and haven't written to the flash of the servo,
 0E73           ;                       // force a change in the status return level with an EEPROM write.
 0E73           ;                       if((status_return_level != STATUS_RET_LEVEL) && (!flashWrite))
 0E73 3D0601            cmp [X+6],1
 0E76 A027              jz L334
 0E78 3D0700            cmp [X+7],0
 0E7B B022              jnz L334
 0E7D 3D0800            cmp [X+8],0
 0E80 B01D              jnz L334
 0E82           X75:
 0E82                   .dbline 1218
 0E82           ;                       {       
 0E82                   .dbline 1219
 0E82           ;                               flashWrite = 1;
 0E82 560801            mov [X+8],1
 0E85 560700            mov [X+7],0
 0E88                   .dbline 1222
 0E88           ;                               
 0E88           ;                               // Try to force the return status to what we want.
 0E88           ;                               servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, STATUS_RET_ADDRESS, STATUS_RET_LEVEL);
 0E88 5001              mov A,1
 0E8A 08                push A
 0E8B 5010              mov A,16
 0E8D 08                push A
 0E8E 5003              mov A,3
 0E90 08                push A
 0E91 5004              mov A,4
 0E93 08                push A
 0E94 62D000            mov REG[0xd0],>_SERVO_ID
 0E97 5100              mov A,[_SERVO_ID]
 0E99 08                push A
 0E9A 9019              xcall _servoInstruction
 0E9C 38FB              add SP,-5
 0E9E                   .dbline 1223
 0E9E           ;                       }
 0E9E           L334:
 0E9E                   .dbline 1224
 0E9E           ;               }
 0E9E           L318:
 0E9E                   .dbline 1177
 0E9E 7703              inc [X+3]
 0EA0 0F0200            adc [X+2],0
 0EA3                   .dbline 1177
 0EA3 5203              mov A,[X+3]
 0EA5 1102              sub A,2
 0EA7 5202              mov A,[X+2]
 0EA9 3180              xor A,-128
 0EAB 1980              sbb A,(0 ^ 0x80)
 0EAD CF42              jc L317
 0EAF           X76:
 0EAF                   .dbline 1225
 0EAF           ;       }
 0EAF           L315:
 0EAF                   .dbline 1228
 0EAF           ;       
 0EAF           ;       // Wait for the other controllers to find their servos.
 0EAF           ;       servoConfigWait();
 0EAF 9155              xcall _servoConfigWait
 0EB1                   .dbline -2
 0EB1           L297:
 0EB1 38F7              add SP,-9
 0EB3 20                pop X
 0EB4                   .dbline 0 ; func end
 0EB4 7F                ret
 0EB5                   .dbsym l flashWrite 7 I
 0EB5                   .dbsym l status_return_level 6 c
 0EB5                   .dbsym l total_attempts 4 I
 0EB5                   .dbsym l j 2 I
 0EB5                   .dbsym l i 0 I
 0EB5                   .dbend
 0EB5                   .dbfunc e servoInstruction _servoInstruction fV
 0EB5           ;       checksum -> X+0
 0EB5           ;          value -> X-8
 0EB5           ;        address -> X-7
 0EB5           ;    instruction -> X-6
 0EB5           ;         length -> X-5
 0EB5           ;             id -> X-4
 0EB5           _servoInstruction::
 0EB5                   .dbline -1
 0EB5 10                push X
 0EB6 4F                mov X,SP
 0EB7 3801              add SP,1
 0EB9                   .dbline 1234
 0EB9           ; }
 0EB9           ; 
 0EB9           ; // This function receives a destination, command length, instruction type, address, and value.
 0EB9           ; // With these parameters, the function sends a packet to the communication bus.
 0EB9           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 0EB9           ; {
 0EB9                   .dbline 1238
 0EB9           ;       char checksum;
 0EB9           ;       
 0EB9           ;       // Toggle into transmit mode.
 0EB9           ;       configToggle(SERVO_COMM);
 0EB9 5000              mov A,0
 0EBB 08                push A
 0EBC 5009              mov A,9
 0EBE 08                push A
 0EBF 7C00B4            xcall _configToggle
 0EC2 38FE              add SP,-2
 0EC4                   .dbline 1241
 0EC4           ;       
 0EC4           ;       // Calculate the checksum value for our servo communication.
 0EC4           ;       checksum = 255-((id + length + instruction + address + value)%256);
 0EC4 62D000            mov REG[0xd0],>__r0
 0EC7 52FB              mov A,[X-5]
 0EC9 5300              mov [__r1],A
 0ECB 550000            mov [__r0],0
 0ECE 52FC              mov A,[X-4]
 0ED0 0200              add A,[__r1]
 0ED2 5300              mov [__r1],A
 0ED4 5000              mov A,0
 0ED6 0A00              adc A,[__r0]
 0ED8 5300              mov [__r0],A
 0EDA 52FA              mov A,[X-6]
 0EDC 0400              add [__r1],A
 0EDE 0E0000            adc [__r0],0
 0EE1 52F9              mov A,[X-7]
 0EE3 0400              add [__r1],A
 0EE5 0E0000            adc [__r0],0
 0EE8 52F8              mov A,[X-8]
 0EEA 0400              add [__r1],A
 0EEC 0E0000            adc [__r0],0
 0EEF 5001              mov A,1
 0EF1 08                push A
 0EF2 5000              mov A,0
 0EF4 08                push A
 0EF5 5100              mov A,[__r0]
 0EF7 08                push A
 0EF8 5100              mov A,[__r1]
 0EFA 08                push A
 0EFB 7C0000            xcall __divmod_16X16_16
 0EFE 38FE              add SP,-2
 0F00 18                pop A
 0F01 5300              mov [__r1],A
 0F03 18                pop A
 0F04 50FF              mov A,-1
 0F06 1200              sub A,[__r1]
 0F08 5400              mov [X+0],A
 0F0A                   .dbline 1244
 0F0A           ;       
 0F0A           ;       // Talk to the servo.
 0F0A           ;       if(instruction == PING_SERVO)
 0F0A 3DFA01            cmp [X-6],1
 0F0D B02D              jnz L337
 0F0F                   .dbline 1245
 0F0F           ;       {
 0F0F                   .dbline 1246
 0F0F           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte one
 0F0F 10                push X
 0F10 50FF              mov A,-1
 0F12 7C0000            xcall _SERVO_TX_PutChar
 0F15 20                pop X
 0F16                   .dbline 1247
 0F16           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte two
 0F16 10                push X
 0F17 50FF              mov A,-1
 0F19 7C0000            xcall _SERVO_TX_PutChar
 0F1C 20                pop X
 0F1D                   .dbline 1248
 0F1D           ;               SERVO_TX_PutChar(id);                   // Servo ID
 0F1D 10                push X
 0F1E 52FC              mov A,[X-4]
 0F20 7C0000            xcall _SERVO_TX_PutChar
 0F23 20                pop X
 0F24                   .dbline 1249
 0F24           ;               SERVO_TX_PutChar(length);               // The instruction length.
 0F24 10                push X
 0F25 52FB              mov A,[X-5]
 0F27 7C0000            xcall _SERVO_TX_PutChar
 0F2A 20                pop X
 0F2B                   .dbline 1250
 0F2B           ;               SERVO_TX_PutChar(instruction);  // The instruction to carry out.
 0F2B 10                push X
 0F2C 52FA              mov A,[X-6]
 0F2E 7C0000            xcall _SERVO_TX_PutChar
 0F31 20                pop X
 0F32                   .dbline 1251
 0F32           ;               SERVO_TX_PutChar(checksum);             // This is the checksum.
 0F32 10                push X
 0F33 5200              mov A,[X+0]
 0F35 7C0000            xcall _SERVO_TX_PutChar
 0F38 20                pop X
 0F39                   .dbline 1252
 0F39           ;       }
 0F39 8039              xjmp L340
 0F3B           L337:
 0F3B                   .dbline 1254
 0F3B           ;       else
 0F3B           ;       {
 0F3B                   .dbline 1255
 0F3B           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte one
 0F3B 10                push X
 0F3C 50FF              mov A,-1
 0F3E 7C0000            xcall _SERVO_TX_PutChar
 0F41 20                pop X
 0F42                   .dbline 1256
 0F42           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte two
 0F42 10                push X
 0F43 50FF              mov A,-1
 0F45 7C0000            xcall _SERVO_TX_PutChar
 0F48 20                pop X
 0F49                   .dbline 1257
 0F49           ;               SERVO_TX_PutChar(id);                   // Servo ID
 0F49 10                push X
 0F4A 52FC              mov A,[X-4]
 0F4C 7C0000            xcall _SERVO_TX_PutChar
 0F4F 20                pop X
 0F50                   .dbline 1258
 0F50           ;               SERVO_TX_PutChar(length);               // The instruction length.
 0F50 10                push X
 0F51 52FB              mov A,[X-5]
 0F53 7C0000            xcall _SERVO_TX_PutChar
 0F56 20                pop X
 0F57                   .dbline 1259
 0F57           ;               SERVO_TX_PutChar(instruction);  // The instruction to carry out.
 0F57 10                push X
 0F58 52FA              mov A,[X-6]
 0F5A 7C0000            xcall _SERVO_TX_PutChar
 0F5D 20                pop X
 0F5E                   .dbline 1260
 0F5E           ;               SERVO_TX_PutChar(address);              // The address to read/write from/to.
 0F5E 10                push X
 0F5F 52F9              mov A,[X-7]
 0F61 7C0000            xcall _SERVO_TX_PutChar
 0F64 20                pop X
 0F65                   .dbline 1261
 0F65           ;               SERVO_TX_PutChar(value);                // The value to write or number of bytes to read.
 0F65 10                push X
 0F66 52F8              mov A,[X-8]
 0F68 7C0000            xcall _SERVO_TX_PutChar
 0F6B 20                pop X
 0F6C                   .dbline 1262
 0F6C           ;               SERVO_TX_PutChar(checksum);             // This is the checksum.
 0F6C 10                push X
 0F6D 5200              mov A,[X+0]
 0F6F 7C0000            xcall _SERVO_TX_PutChar
 0F72 20                pop X
 0F73                   .dbline 1263
 0F73           ;       }
 0F73           L339:
 0F73                   .dbline 1266
 0F73           ;       
 0F73           ;       // Wait for the transmission to finish.
 0F73           ;       while(!(SERVO_TX_bReadTxStatus() & SERVO_TX_TX_COMPLETE));
 0F73           L340:
 0F73                   .dbline 1266
 0F73 10                push X
 0F74 7C0000            xcall _SERVO_TX_bReadTxStatus
 0F77 62D000            mov REG[0xd0],>__r0
 0F7A 20                pop X
 0F7B 5300              mov [__r0],A
 0F7D 470020            tst [__r0],32
 0F80 AFF2              jz L339
 0F82                   .dbline 1269
 0F82           ;       
 0F82           ;       // Make completely sure we're done.
 0F82           ;       xmitWait();
 0F82 900F              xcall _xmitWait
 0F84                   .dbline 1272
 0F84           ;       
 0F84           ;       // Switch back to wait for a servo response.
 0F84           ;       configToggle(INITIALIZE);
 0F84 5000              mov A,0
 0F86 08                push A
 0F87 5008              mov A,8
 0F89 08                push A
 0F8A 7C00B4            xcall _configToggle
 0F8D 38FE              add SP,-2
 0F8F                   .dbline -2
 0F8F           L336:
 0F8F 38FF              add SP,-1
 0F91 20                pop X
 0F92                   .dbline 0 ; func end
 0F92 7F                ret
 0F93                   .dbsym l checksum 0 c
 0F93                   .dbsym l value -8 c
 0F93                   .dbsym l address -7 c
 0F93                   .dbsym l instruction -6 c
 0F93                   .dbsym l length -5 c
 0F93                   .dbsym l id -4 c
 0F93                   .dbend
 0F93                   .dbfunc e xmitWait _xmitWait fV
 0F93           ;              i -> X+0
 0F93           _xmitWait::
 0F93                   .dbline -1
 0F93 10                push X
 0F94 4F                mov X,SP
 0F95 3802              add SP,2
 0F97                   .dbline 1278
 0F97           ; }
 0F97           ; 
 0F97           ; // This function is used in various ways to create a period of nothingness. Mostly,
 0F97           ; // it is used to allow the controller enough time to transmit bytes (as its name suggests).
 0F97           ; void xmitWait(void)
 0F97           ; {
 0F97                   .dbline 1281
 0F97           ;       int i;
 0F97           ;       
 0F97           ;       for(i = 0; i < 25; i++)
 0F97 560100            mov [X+1],0
 0F9A 560000            mov [X+0],0
 0F9D           L343:
 0F9D                   .dbline 1282
 0F9D           ;       {
 0F9D                   .dbline 1284
 0F9D           ;               // Does nothing and wastes approximately 50 microseconds.
 0F9D           ;       }
 0F9D           L344:
 0F9D                   .dbline 1281
 0F9D 7701              inc [X+1]
 0F9F 0F0000            adc [X+0],0
 0FA2                   .dbline 1281
 0FA2 5201              mov A,[X+1]
 0FA4 1119              sub A,25
 0FA6 5200              mov A,[X+0]
 0FA8 3180              xor A,-128
 0FAA 1980              sbb A,(0 ^ 0x80)
 0FAC CFF0              jc L343
 0FAE           X77:
 0FAE                   .dbline -2
 0FAE           L342:
 0FAE 38FE              add SP,-2
 0FB0 20                pop X
 0FB1                   .dbline 0 ; func end
 0FB1 7F                ret
 0FB2                   .dbsym l i 0 I
 0FB2                   .dbend
 0FB2                   .dbfunc e servoBootWait _servoBootWait fV
 0FB2           ;              i -> X+0
 0FB2           _servoBootWait::
 0FB2                   .dbline -1
 0FB2 10                push X
 0FB3 4F                mov X,SP
 0FB4 3802              add SP,2
 0FB6                   .dbline 1292
 0FB6           ; }
 0FB6           ; 
 0FB6           ; // This function wastes time while the servo that is attached to this controller boots up.
 0FB6           ; // Once that happens, communications should happen quickly and reliably. The estimated boot
 0FB6           ; // time in testing was approximately 120 ms. This means that the define SERVO_BOOT_TIMEOUTS
 0FB6           ; // at the top must be a minimum of 60 since timeout periods are in 2 ms intervals.
 0FB6           ; void servoBootWait(void)
 0FB6           ; {
 0FB6                   .dbline 1293
 0FB6           ;       int i = 0;                                      // Index integer used for looping.
 0FB6 560100            mov [X+1],0
 0FB9 560000            mov [X+0],0
 0FBC                   .dbline 1295
 0FBC           ; 
 0FBC           ;       configToggle(INITIALIZE);       // Switch to initialize mode to do this timeout routine.
 0FBC 5000              mov A,0
 0FBE 08                push A
 0FBF 5008              mov A,8
 0FC1 08                push A
 0FC2 7C00B4            xcall _configToggle
 0FC5 38FE              add SP,-2
 0FC7                   .dbline 1298
 0FC7           ;       
 0FC7           ;       // Loop and wait for enough timeouts to happen before we talk to the servo.
 0FC7           ;       for(i = 0; i < SERVO_BOOT_TIMEOUTS; i++)
 0FC7 560100            mov [X+1],0
 0FCA 560000            mov [X+0],0
 0FCD                   .dbline 1299
 0FCD           ;       {
 0FCD           L352:
 0FCD                   .dbline 1300
 0FCD           ;               while(!TIMEOUT) { }             // Do nothing while we wait for one timeout period.
 0FCD                   .dbline 1300
 0FCD           L353:
 0FCD                   .dbline 1300
 0FCD 62D000            mov REG[0xd0],>_TIMEOUT
 0FD0 3C0000            cmp [_TIMEOUT],0
 0FD3 B006              jnz X78
 0FD5 3C0100            cmp [_TIMEOUT+1],0
 0FD8 AFF4              jz L352
 0FDA           X78:
 0FDA                   .dbline 1301
 0FDA           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 0FDA 62D000            mov REG[0xd0],>_TIMEOUT
 0FDD 550100            mov [_TIMEOUT+1],0
 0FE0 550000            mov [_TIMEOUT],0
 0FE3                   .dbline 1302
 0FE3           ;       }
 0FE3           L349:
 0FE3                   .dbline 1298
 0FE3 7701              inc [X+1]
 0FE5 0F0000            adc [X+0],0
 0FE8                   .dbline 1298
 0FE8 5201              mov A,[X+1]
 0FEA 114B              sub A,75
 0FEC 5200              mov A,[X+0]
 0FEE 3180              xor A,-128
 0FF0 1980              sbb A,(0 ^ 0x80)
 0FF2 CFDA              jc L353
 0FF4           X79:
 0FF4                   .dbline 1304
 0FF4           ;       
 0FF4           ;       INIT_TIMEOUT_Stop();            // Stop the timeout timer.
 0FF4 10                push X
 0FF5 7C0000            xcall _INIT_TIMEOUT_Stop
 0FF8 20                pop X
 0FF9                   .dbline 1305
 0FF9           ;       TIMEOUT = 0;                            // Clear the timeout flag.
 0FF9 62D000            mov REG[0xd0],>_TIMEOUT
 0FFC 550100            mov [_TIMEOUT+1],0
 0FFF 550000            mov [_TIMEOUT],0
 1002                   .dbline -2
 1002           L347:
 1002 38FE              add SP,-2
 1004 20                pop X
 1005                   .dbline 0 ; func end
 1005 7F                ret
 1006                   .dbsym l i 0 I
 1006                   .dbend
 1006                   .dbfunc e servoConfigWait _servoConfigWait fV
 1006           ;              i -> X+0
 1006           _servoConfigWait::
 1006                   .dbline -1
 1006 10                push X
 1007 4F                mov X,SP
 1008 3802              add SP,2
 100A                   .dbline 1311
 100A           ; }
 100A           ; 
 100A           ; // Sits and spins for the amount of time it takes for a worst case scenario for setup time
 100A           ; // to take place. This allows all other modules to initialize.
 100A           ; void servoConfigWait(void)
 100A           ; {
 100A                   .dbline 1312
 100A           ;       int i = 0;                                      // Index integer for looping purposes.
 100A 560100            mov [X+1],0
 100D 560000            mov [X+0],0
 1010                   .dbline 1314
 1010           ;       
 1010           ;       configToggle(INITIALIZE);       // Switch to initialize mode to do this timeout routine.
 1010 5000              mov A,0
 1012 08                push A
 1013 5008              mov A,8
 1015 08                push A
 1016 7C00B4            xcall _configToggle
 1019 38FE              add SP,-2
 101B                   .dbline 1319
 101B           ;       
 101B           ;       // For SERVO_COMM_ATTEMPTS*SERVO_COMM_LOOPS cycles, let the other controllers find
 101B           ;       // their servos. The reason we loop this many times is to allow for a possible worst
 101B           ;       // case scenario of setup time to complete.
 101B           ;       for(i = 0; i < (SERVO_COMM_ATTEMPTS*SERVO_COMM_LOOPS); i++)
 101B 560100            mov [X+1],0
 101E 560000            mov [X+0],0
 1021                   .dbline 1320
 1021           ;       {
 1021           L360:
 1021                   .dbline 1321
 1021           ;               while(!TIMEOUT) { }             // Do nothing while we wait for one timeout period.
 1021                   .dbline 1321
 1021           L361:
 1021                   .dbline 1321
 1021 62D000            mov REG[0xd0],>_TIMEOUT
 1024 3C0000            cmp [_TIMEOUT],0
 1027 B006              jnz X80
 1029 3C0100            cmp [_TIMEOUT+1],0
 102C AFF4              jz L360
 102E           X80:
 102E                   .dbline 1322
 102E           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 102E 62D000            mov REG[0xd0],>_TIMEOUT
 1031 550100            mov [_TIMEOUT+1],0
 1034 550000            mov [_TIMEOUT],0
 1037                   .dbline 1323
 1037           ;       }
 1037           L357:
 1037                   .dbline 1319
 1037 7701              inc [X+1]
 1039 0F0000            adc [X+0],0
 103C                   .dbline 1319
 103C 5201              mov A,[X+1]
 103E 1114              sub A,20
 1040 5200              mov A,[X+0]
 1042 3180              xor A,-128
 1044 1980              sbb A,(0 ^ 0x80)
 1046 CFDA              jc L361
 1048           X81:
 1048                   .dbline 1325
 1048           ;       
 1048           ;       INIT_TIMEOUT_Stop();            // Stop the timer.
 1048 10                push X
 1049 7C0000            xcall _INIT_TIMEOUT_Stop
 104C 20                pop X
 104D                   .dbline 1326
 104D           ;       TIMEOUT = 0;                            // Reset the timeout flag.
 104D 62D000            mov REG[0xd0],>_TIMEOUT
 1050 550100            mov [_TIMEOUT+1],0
 1053 550000            mov [_TIMEOUT],0
 1056                   .dbline 1328
 1056           ; 
 1056           ;       configToggle(WAIT);                     // Switch to wait for the master node to speak to you.
 1056 5000              mov A,0
 1058 08                push A
 1059 5001              mov A,1
 105B 08                push A
 105C 7C00B4            xcall _configToggle
 105F 38FE              add SP,-2
 1061                   .dbline -2
 1061           L355:
 1061 38FE              add SP,-2
 1063 20                pop X
 1064                   .dbline 0 ; func end
 1064 7F                ret
 1065                   .dbsym l i 0 I
 1065                   .dbend
 1065                   .dbfunc e TX_01234_TIMEOUT_ISR _TX_01234_TIMEOUT_ISR fV
 1065           _TX_01234_TIMEOUT_ISR::
 1065                   .dbline -1
 1065 71C0              or F,-64
 1067 08                push A
 1068 5DD0              mov A,REG[0xd0]
 106A 08                push A
 106B                   .dbline 1336
 106B           ; }
 106B           ; 
 106B           ; // This timeout ISR is for waiting before a transmission is made from this module.
 106B           ; // This is to give all the other modules a chance to set up and clear their buffers.
 106B           ; // It is currently set so that there is 1 ms of down time between the last transmission
 106B           ; // and this module's transmission.
 106B           ; void TX_01234_TIMEOUT_ISR(void)
 106B           ; {
 106B                   .dbline 1337
 106B           ;       TIMEOUT = 1;    // Set the timeout flag.
 106B 62D000            mov REG[0xd0],>_TIMEOUT
 106E 550101            mov [_TIMEOUT+1],1
 1071 550000            mov [_TIMEOUT],0
 1074                   .dbline 1338
 1074           ;       M8C_ClearIntFlag(INT_CLR0,TX_01234_TIMEOUT_INT_MASK);
 1074 62DAFD            mov REG[0xda],-3
 1077                   .dbline -2
 1077           L363:
 1077 18                pop A
 1078 60D0              mov REG[208],A
 107A 18                pop A
 107B                   .dbline 0 ; func end
 107B 7E                reti
 107C                   .dbend
 107C                   .dbfunc e HELLO_TIMEOUT_ISR _HELLO_TIMEOUT_ISR fV
 107C           _HELLO_TIMEOUT_ISR::
 107C                   .dbline -1
 107C 71C0              or F,-64
 107E 08                push A
 107F 5DD0              mov A,REG[0xd0]
 1081 08                push A
 1082                   .dbline 1343
 1082           ; }
 1082           ; 
 1082           ; // This is the ISR for a hello response timeout.
 1082           ; void HELLO_TIMEOUT_ISR(void)
 1082           ; {
 1082                   .dbline 1344
 1082           ;       TIMEOUT = 1;    // Set the timeout flag.
 1082 62D000            mov REG[0xd0],>_TIMEOUT
 1085 550101            mov [_TIMEOUT+1],1
 1088 550000            mov [_TIMEOUT],0
 108B                   .dbline 1345
 108B           ;       M8C_ClearIntFlag(INT_CLR0,HELLO_TIMEOUT_INT_MASK);
 108B 62DAFD            mov REG[0xda],-3
 108E                   .dbline -2
 108E           L364:
 108E 18                pop A
 108F 60D0              mov REG[208],A
 1091 18                pop A
 1092                   .dbline 0 ; func end
 1092 7E                reti
 1093                   .dbend
 1093                   .dbfunc e CHILD_1_TIMEOUT_ISR _CHILD_1_TIMEOUT_ISR fV
 1093           _CHILD_1_TIMEOUT_ISR::
 1093                   .dbline -1
 1093 71C0              or F,-64
 1095 08                push A
 1096 5DD0              mov A,REG[0xd0]
 1098 08                push A
 1099                   .dbline 1350
 1099           ; }
 1099           ; 
 1099           ; // These remaining ISRs are for all the child timeout scenarios.
 1099           ; void CHILD_1_TIMEOUT_ISR(void)
 1099           ; {
 1099                   .dbline 1351
 1099           ;       TIMEOUT = 1;    // Set the timeout flag.
 1099 62D000            mov REG[0xd0],>_TIMEOUT
 109C 550101            mov [_TIMEOUT+1],1
 109F 550000            mov [_TIMEOUT],0
 10A2                   .dbline 1352
 10A2           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_1_TIMEOUT_INT_MASK);
 10A2 62DAFD            mov REG[0xda],-3
 10A5                   .dbline -2
 10A5           L365:
 10A5 18                pop A
 10A6 60D0              mov REG[208],A
 10A8 18                pop A
 10A9                   .dbline 0 ; func end
 10A9 7E                reti
 10AA                   .dbend
 10AA                   .dbfunc e CHILD_2_TIMEOUT_ISR _CHILD_2_TIMEOUT_ISR fV
 10AA           _CHILD_2_TIMEOUT_ISR::
 10AA                   .dbline -1
 10AA 71C0              or F,-64
 10AC 08                push A
 10AD 5DD0              mov A,REG[0xd0]
 10AF 08                push A
 10B0                   .dbline 1356
 10B0           ; }
 10B0           ; 
 10B0           ; void CHILD_2_TIMEOUT_ISR(void)
 10B0           ; {
 10B0                   .dbline 1357
 10B0           ;       TIMEOUT = 1;    // Set the timeout flag.
 10B0 62D000            mov REG[0xd0],>_TIMEOUT
 10B3 550101            mov [_TIMEOUT+1],1
 10B6 550000            mov [_TIMEOUT],0
 10B9                   .dbline 1358
 10B9           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_2_TIMEOUT_INT_MASK);
 10B9 62DAFD            mov REG[0xda],-3
 10BC                   .dbline -2
 10BC           L366:
 10BC 18                pop A
 10BD 60D0              mov REG[208],A
 10BF 18                pop A
 10C0                   .dbline 0 ; func end
 10C0 7E                reti
 10C1                   .dbend
 10C1                   .dbfunc e CHILD_3_TIMEOUT_ISR _CHILD_3_TIMEOUT_ISR fV
 10C1           _CHILD_3_TIMEOUT_ISR::
 10C1                   .dbline -1
 10C1 71C0              or F,-64
 10C3 08                push A
 10C4 5DD0              mov A,REG[0xd0]
 10C6 08                push A
 10C7                   .dbline 1362
 10C7           ; }
 10C7           ; 
 10C7           ; void CHILD_3_TIMEOUT_ISR(void)
 10C7           ; {
 10C7                   .dbline 1363
 10C7           ;       TIMEOUT = 1;    // Set the timeout flag.
 10C7 62D000            mov REG[0xd0],>_TIMEOUT
 10CA 550101            mov [_TIMEOUT+1],1
 10CD 550000            mov [_TIMEOUT],0
 10D0                   .dbline 1364
 10D0           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_3_TIMEOUT_INT_MASK);
 10D0 62DAFD            mov REG[0xda],-3
 10D3                   .dbline -2
 10D3           L367:
 10D3 18                pop A
 10D4 60D0              mov REG[208],A
 10D6 18                pop A
 10D7                   .dbline 0 ; func end
 10D7 7E                reti
 10D8                   .dbend
 10D8                   .dbfunc e CHILD_4_TIMEOUT_ISR _CHILD_4_TIMEOUT_ISR fV
 10D8           _CHILD_4_TIMEOUT_ISR::
 10D8                   .dbline -1
 10D8 71C0              or F,-64
 10DA 08                push A
 10DB 5DD0              mov A,REG[0xd0]
 10DD 08                push A
 10DE                   .dbline 1368
 10DE           ; }
 10DE           ; 
 10DE           ; void CHILD_4_TIMEOUT_ISR(void)
 10DE           ; {
 10DE                   .dbline 1369
 10DE           ;       TIMEOUT = 1;    // Set the timeout flag.
 10DE 62D000            mov REG[0xd0],>_TIMEOUT
 10E1 550101            mov [_TIMEOUT+1],1
 10E4 550000            mov [_TIMEOUT],0
 10E7                   .dbline 1370
 10E7           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_4_TIMEOUT_INT_MASK);
 10E7 62DAFD            mov REG[0xda],-3
 10EA                   .dbline -2
 10EA           L368:
 10EA 18                pop A
 10EB 60D0              mov REG[208],A
 10ED 18                pop A
 10EE                   .dbline 0 ; func end
 10EE 7E                reti
 10EF                   .dbend
 10EF                   .dbfunc e INIT_TIMEOUT_ISR _INIT_TIMEOUT_ISR fV
 10EF           _INIT_TIMEOUT_ISR::
 10EF                   .dbline -1
 10EF 71C0              or F,-64
 10F1 08                push A
 10F2 5DD0              mov A,REG[0xd0]
 10F4 08                push A
 10F5                   .dbline 1374
 10F5           ; }
 10F5           ; 
 10F5           ; void INIT_TIMEOUT_ISR(void)
 10F5           ; {
 10F5                   .dbline 1375
 10F5           ;       TIMEOUT = 1;    // Set the timeout flag.
 10F5 62D000            mov REG[0xd0],>_TIMEOUT
 10F8 550101            mov [_TIMEOUT+1],1
 10FB 550000            mov [_TIMEOUT],0
 10FE                   .dbline 1376
 10FE           ;       M8C_ClearIntFlag(INT_CLR0,INIT_TIMEOUT_INT_MASK);
 10FE 62DAFD            mov REG[0xda],-3
 1101                   .dbline -2
 1101           L369:
 1101 18                pop A
 1102 60D0              mov REG[208],A
 1104 18                pop A
 1105                   .dbline 0 ; func end
 1105 7E                reti
 1106                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _SERVO_ID::
 0000 00                .byte 0
 0001                   .dbsym e SERVO_ID _SERVO_ID c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_ERROR::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_ERROR _COMMAND_ERROR c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_LENGTH::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_LENGTH _COMMAND_LENGTH c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_PARAM::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_PARAM _COMMAND_PARAM c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _CONFIGURED::
 0000 0000              .byte 0,0
 0002                   .dbsym e CONFIGURED _CONFIGURED I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _ID::
 0000 00                .byte 0
 0001                   .dbsym e ID _ID c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _CHILD::
 0000 00                .byte 0
 0001                   .dbsym e CHILD _CHILD c
