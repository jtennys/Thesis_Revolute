 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 159
 0000           ; // Author: Jason Tennyson
 0000           ; // Date: 7-10-11
 0000           ; // File: main.c
 0000           ; //
 0000           ; // This is the design for the revolute modules of Jason Tennyson's Thesis.
 0000           ; // This design is made for a PSoC CY8C28433-24PVXI.
 0000           ; //
 0000           ; // Controller Packet Structure (each field is a byte)
 0000           ; // -----------------------------------------------------
 0000           ; // All Packets:
 0000           ; // START BYTE/START BYTE/SOURCE ID/DESTINATION ID/COMMAND TYPE/PARAM 1/.../PARAM N/END TRANSMIT
 0000           ; //
 0000           ; // Servo Packet Structure (each field is a byte)
 0000           ; // -----------------------------------------------------
 0000           ; // Source Packets:
 0000           ; // START BYTE/START BYTE/DESTINATION ID/LENGTH/COMMAND TYPE/PARAM 1/.../PARAM N/CHECKSUM
 0000           ; //
 0000           ; // Return Packets:
 0000           ; // START BYTE/START BYTE/SOURCE ID/LENGTH/ERROR/PARAM1/.../PARAM N/CHECKSUM
 0000           ; 
 0000           ; #include <m8c.h>              // Part-specific constants and macros.
 0000           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules.
 0000           ; #include "psocdynamic.h"      // Required for dynamically swapping configurations at run time.
 0000           ; 
 0000           ; // These are declarations of all of the timer interrupts that are used for all configurations.
 0000           ; #pragma interrupt_handler TX_01234_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_1_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_2_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_3_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_4_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler HELLO_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler INIT_TIMEOUT_ISR
 0000           ; 
 0000           ; // These defines are used as parameters of the configToggle function. Passing one of
 0000           ; // these identifiers to configToggle will put the chip in that device configuration.
 0000           ; #define               WAIT                                            (1)
 0000           ; #define               MY_RESPONSE                                     (2)
 0000           ; #define       RESPONSE_1                                      (3)
 0000           ; #define       RESPONSE_2                                      (4)
 0000           ; #define       RESPONSE_3                                      (5)
 0000           ; #define       RESPONSE_4                                      (6)
 0000           ; #define               HELLO_MODE                                      (7)
 0000           ; #define               INITIALIZE                                      (8)
 0000           ; #define               SERVO_COMM                                      (9)
 0000           ; 
 0000           ; // These defines are used as comparisons to find what port the next module connected to.
 0000           ; #define               PORT_1                                          ('1')
 0000           ; #define               PORT_2                                          ('2')
 0000           ; #define               PORT_3                                          ('3')
 0000           ; #define               PORT_4                                          ('4')
 0000           ; 
 0000           ; // Module Type
 0000           ; #define               TYPE                                            ('1')
 0000           ; 
 0000           ; // These defines are used as transmission indicators for transmissions between PSoC controllers.
 0000           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0000           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0000           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0000           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0000           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is complete.
 0000           ; #define               PING                                            (203)   // Indicates a ping message to or from the master.
 0000           ; #define               CLEAR                                           (204)   // Indicates the arm values are to be cleared.
 0000           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0000           ; #define               DEFAULT_ID                                      (251)   // The ID that all modules start with.
 0000           ; #define               BROADCAST                                       (254)   // The broadcast ID for all controllers and servos.
 0000           ; 
 0000           ; // SERVO DEFINES
 0000           ; // These numbers can all be found in the AX-12+ datasheet.
 0000           ; // These defines cover the range of IDs these servos are capable of.
 0000           ; #define               SERVO_ID_MIN                            (0)             // This is the lowest servo ID possible.
 0000           ; #define               SERVO_ID_MAX                            (253)   // This is the highest servo ID possible.
 0000           ; // These defines are servo transmission indicators.
 0000           ; #define               SERVO_START                                     (255)   // This is the start byte for a servo transmission.
 0000           ; // These defines are used to fill in the length parameter for a given command type. These are the only
 0000           ; // lengths used by this controller for servo configuration purposes. It is worth noting that any type
 0000           ; // and length of command can be issued from the master after configuration is complete.
 0000           ; #define               READ_LENGTH                                     (4)             // This is the length value for all reads.
 0000           ; #define               WRITE_LENGTH                            (4)             // This is the length value for all writes.
 0000           ; #define               PING_LENGTH                                     (2)             // This is the length value for a ping.
 0000           ; #define               RESET_LENGTH                            (2)             // This is the length value for a reset.
 0000           ; // These defines are used to fill in the servo's EEPROM address parameter for a given command type.
 0000           ; #define               ID_ADDRESS                                      (3)             // This is the address where servo ID is stored.
 0000           ; #define               STATUS_RET_ADDRESS                      (16)    // This is where the status return level is stored.
 0000           ; // These defines are used to fill in the instruction we are using on the servo.
 0000           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0000           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0000           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0000           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0000           ; // These defines cover all of the status return level possibilities.
 0000           ; #define               STATUS_RET_NEVER                        (0)             // Only respond to ping commands.
 0000           ; #define               STATUS_RET_READ                         (1)             // Only respond to read data commands (recommended).
 0000           ; #define               STATUS_RET_ALL                          (2)             // Respond to every command.
 0000           ; 
 0000           ; // This is the status return level, which is set to one of the possible status return values above.
 0000           ; // We want the status return level to be return on read commands only so that we don't have garbage
 0000           ; // return packets flying around every time we tell the servo to move.
 0000           ; #define               STATUS_RET_LEVEL                        (STATUS_RET_READ)
 0000           ; 
 0000           ; // This is the number of attempts we make to contact the servo per sweep of attempts before
 0000           ; // writing to its EEPROM in an attempt to alter settings that keep us from communicating.
 0000           ; #define               SERVO_COMM_ATTEMPTS                     (10)
 0000           ; // This is the number of times we do a loop of SERVO_COMM_ATTEMPTS. We would like this to be at least 2.
 0000           ; // This is because we do an EEPROM write after the first unsuccessful loop of SERVO_COMM_ATTEMPTS.
 0000           ; // If we don't then do at least one more loop, the EEPROM write was done for no reason.
 0000           ; #define               SERVO_COMM_LOOPS                        (3)
 0000           ; // This is the number of timeout periods to wait through while the servo boots up (2 ms per period).
 0000           ; #define               SERVO_BOOT_TIMEOUTS                     (100)
 0000           ; 
 0000           ; // This function receives a mode identifier as a parameter and toggles the system configuration.
 0000           ; void configToggle(int mode);
 0000           ; // This function unloads all configurations. This should only be needed at startup.
 0000           ; void unloadAllConfigs(void);
 0000           ; // This function unloads the configuration corresponding to the number passed to it.
 0000           ; void unloadConfig(int config_num);
 0000           ; // This function is a response to the master sending out a hello message.
 0000           ; void sayHello(void);
 0000           ; // This function looks for commands and returns 1 if a command has been read, 0 if not.
 0000           ; int commandReady(void);
 0000           ; // This function interprets the command that has just been read and performs an action accordingly.
 0000           ; void takeAction(void);
 0000           ; // This function responds to a ping.
 0000           ; void pingResponse(void);
 0000           ; // This function tells the master node that an ID assignment was completed on this module.
 0000           ; void assignedID(void);
 0000           ; // This function listens for children and registers the port that they talk to.
 0000           ; int childListen(void);
 0000           ; // This function waits for a known child's response to a command to that child from the master.
 0000           ; int childResponse(void);
 0000           ; // This function does everything it can to find the servo attached to this controller.
 0000           ; void servoFinder(void);
 0000           ; // This function carries out the passed servo instruction.
 0000           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0000           ; // This function does a simple for loop to stall and make doubly sure that the transmission finished.
 0000           ; // It is meant to be used as a definite amount of wait time after the transmission complete flag is set.
 0000           ; void xmitWait(void);
 0000           ; // This function is called to do nothing while we wait for the servo to boot up.
 0000           ; void servoBootWait(void);
 0000           ; // This function is used to wait for other controllers to find their servos while not
 0000           ; // driving any pins (which would keep a child from talking to its servo).
 0000           ; void servoConfigWait(void);
 0000           ; 
 0000           ; char CHILD;           // Keeps track of where the child is connected.
 0000           ; char ID;              // Stores the ID that the master gives this module.
 0000           ; 
 0000           ; int CONFIGURED;       // Keeps track of whether or not this module has been configured by the master.
 0000           ; int TIMEOUT;  // This flag is set if a timeout occurs.
 0000           ; int STATE;            // This stores the ID of the currently-loaded configuration.
 0000           ; 
 0000           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0000           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0000           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0000           ; char COMMAND_PARAM;                   // Stores a parameter that accompanies the command (if any).
 0000           ; char COMMAND_LENGTH;          // Stores the length parameter of a servo command.
 0000           ; char COMMAND_ERROR;                   // Stores the error code of a servo command.
 0000           ; 
 0000           ; char SERVO_ID;                                // Stores the ID of the servo inside of this module.
 0000           ; 
 0000           ; void main(void)
 0000           ; {     
 0000                   .dbline 161
 0000           ;       // Initial value assignment for variables of importance.
 0000           ;       CHILD = 0;                              // There is no child yet.
 0000 62D000            mov REG[0xd0],>_CHILD
 0003 550000            mov [_CHILD],0
 0006                   .dbline 162
 0006           ;       CONFIGURED = 0;                 // This module is not configured yet.
 0006 62D000            mov REG[0xd0],>_CONFIGURED
 0009 550100            mov [_CONFIGURED+1],0
 000C 550000            mov [_CONFIGURED],0
 000F                   .dbline 163
 000F           ;       TIMEOUT = 0;                    // Set the timeout flag low to start.
 000F 62D000            mov REG[0xd0],>_TIMEOUT
 0012 550100            mov [_TIMEOUT+1],0
 0015 550000            mov [_TIMEOUT],0
 0018                   .dbline 164
 0018           ;       COMMAND_PARAM = 0;              // There is no parameter yet.
 0018 62D000            mov REG[0xd0],>_COMMAND_PARAM
 001B 550000            mov [_COMMAND_PARAM],0
 001E                   .dbline 165
 001E           ;       STATE = 0;                              // There is no state yet.
 001E 62D000            mov REG[0xd0],>_STATE
 0021 550100            mov [_STATE+1],0
 0024 550000            mov [_STATE],0
 0027                   .dbline 166
 0027           ;       ID = DEFAULT_ID;                // Set the ID of this controller to the default to start with.
 0027 62D000            mov REG[0xd0],>_ID
 002A 5500FB            mov [_ID],-5
 002D                   .dbline 168
 002D           ; 
 002D           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); // Activate GPIO ISR
 002D 43E020            or REG[0xe0],32
 0030                   .dbline 170
 0030           ;       
 0030           ;       M8C_EnableGInt;                 // Turn on global interrupts for the transmission timeout timer.
 0030 7101                      or  F, 01h
 0032           
 0032                   .dbline 173
 0032           ;       
 0032           ;       // We have to wait for the servo to power up and get ready for communications.
 0032           ;       servoBootWait();
 0032 7C1114            xcall _servoBootWait
 0035                   .dbline 176
 0035           ;       
 0035           ;       // Find the servo that is inside of this module.
 0035           ;       servoFinder();
 0035 7C0D86            xcall _servoFinder
 0038 8013              xjmp L3
 003A           L2:
 003A                   .dbline 180
 003A           ;       
 003A           ;       // Loop and wait for commands.
 003A           ;       while(1)
 003A           ;       {       
 003A                   .dbline 181
 003A           ;               if(commandReady())
 003A 9283              xcall _commandReady
 003C 62D000            mov REG[0xd0],>__r0
 003F 3C0000            cmp [__r0],0
 0042 B006              jnz X1
 0044 3C0000            cmp [__r1],0
 0047 A004              jz L5
 0049           X1:
 0049                   .dbline 182
 0049           ;               {
 0049                   .dbline 184
 0049           ;                       // If the command is ready, take action.
 0049           ;                       takeAction();
 0049 7C086E            xcall _takeAction
 004C                   .dbline 185
 004C           ;               }
 004C           L5:
 004C                   .dbline 186
 004C           ;       }
 004C           L3:
 004C                   .dbline 179
 004C 8FED              xjmp L2
 004E           X0:
 004E                   .dbline -2
 004E           L1:
 004E                   .dbline 0 ; func end
 004E 8FFF              jmp .
 0050                   .dbend
 0050                   .dbfunc e sayHello _sayHello fV
 0050           _sayHello::
 0050                   .dbline -1
 0050                   .dbline 191
 0050           ; }
 0050           ; 
 0050           ; // This function transmits a response to a hello command from the master.
 0050           ; void sayHello(void)
 0050           ; {     
 0050                   .dbline 192
 0050           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 0050 5000              mov A,0
 0052 08                push A
 0053 5002              mov A,2
 0055 08                push A
 0056 905D              xcall _configToggle
 0058 38FE              add SP,-2
 005A                   .dbline 195
 005A           ;       
 005A           ;       // Transmit a hello response to the master node.
 005A           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 005A 10                push X
 005B 50FC              mov A,-4
 005D 7C0000            xcall _TX_014_PutChar
 0060 20                pop X
 0061                   .dbline 196
 0061           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 0061 10                push X
 0062 50FC              mov A,-4
 0064 7C0000            xcall _TX_014_PutChar
 0067 20                pop X
 0068                   .dbline 197
 0068           ;       TX_014_PutChar(ID);                             // My ID (source)
 0068 10                push X
 0069 62D000            mov REG[0xd0],>_ID
 006C 5100              mov A,[_ID]
 006E 7C0000            xcall _TX_014_PutChar
 0071 20                pop X
 0072                   .dbline 198
 0072           ;       TX_014_PutChar(MASTER_ID);              // Master ID (destination)
 0072 10                push X
 0073 5000              mov A,0
 0075 7C0000            xcall _TX_014_PutChar
 0078 20                pop X
 0079                   .dbline 199
 0079           ;       TX_014_PutChar(HELLO_BYTE);             // This is a hello command.
 0079 10                push X
 007A 50C8              mov A,-56
 007C 7C0000            xcall _TX_014_PutChar
 007F 20                pop X
 0080                   .dbline 200
 0080           ;       TX_014_PutChar(CHILD);                  // Sends child port value, default 0.
 0080 10                push X
 0081 62D000            mov REG[0xd0],>_CHILD
 0084 5100              mov A,[_CHILD]
 0086 7C0000            xcall _TX_014_PutChar
 0089 20                pop X
 008A                   .dbline 201
 008A           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission.
 008A 10                push X
 008B 50FD              mov A,-3
 008D 7C0000            xcall _TX_014_PutChar
 0090 20                pop X
 0091                   .dbline 202
 0091           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission.
 0091 10                push X
 0092 50FD              mov A,-3
 0094 7C0000            xcall _TX_014_PutChar
 0097 20                pop X
 0098           L8:
 0098                   .dbline 205
 0098           ;       
 0098           ;       // Wait for the transmission to finish.
 0098           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0098           L9:
 0098                   .dbline 205
 0098 10                push X
 0099 7C0000            xcall _TX_014_bReadTxStatus
 009C 62D000            mov REG[0xd0],>__r0
 009F 20                pop X
 00A0 5300              mov [__r0],A
 00A2 470020            tst [__r0],32
 00A5 AFF2              jz L8
 00A7                   .dbline 208
 00A7           ;       
 00A7           ;       // Make completely sure we're done.
 00A7           ;       xmitWait();
 00A7 7C10F5            xcall _xmitWait
 00AA                   .dbline 210
 00AA           ; 
 00AA           ;       configToggle(WAIT);                             // Switch back to wait mode.
 00AA 5000              mov A,0
 00AC 08                push A
 00AD 5001              mov A,1
 00AF 08                push A
 00B0 9003              xcall _configToggle
 00B2 38FE              add SP,-2
 00B4                   .dbline -2
 00B4           L7:
 00B4                   .dbline 0 ; func end
 00B4 7F                ret
 00B5                   .dbend
 00B5                   .dbfunc e configToggle _configToggle fV
 00B5           ;           mode -> X-5
 00B5           _configToggle::
 00B5                   .dbline -1
 00B5 10                push X
 00B6 4F                mov X,SP
 00B7                   .dbline 216
 00B7           ; }
 00B7           ; 
 00B7           ; // This function receives a mode flag and switches the microcontroller to the
 00B7           ; // desired hardware configuration.
 00B7           ; void configToggle(int mode)
 00B7           ; {     
 00B7                   .dbline 219
 00B7           ;       // Set the pins high and disconnect from the global bus.
 00B7           ;       // This helps keep false start bits from happening while we swap configs.
 00B7           ;       PRT0DR |= 0b00011111;   // Set pins P00 through P04 high.
 00B7 43001F            or REG[0],31
 00BA                   .dbline 220
 00BA           ;       PRT0GS &= 0b11100000;   // Disconnect pins P00 through P04 from the global bus.
 00BA 4102E0            and REG[0x2],-32
 00BD                   .dbline 224
 00BD           ;       
 00BD           ;       // Unload the configuration of the current state.
 00BD           ;       // If there is no state, blindly wipe all configurations.
 00BD           ;       if(STATE)
 00BD 62D000            mov REG[0xd0],>_STATE
 00C0 3C0000            cmp [_STATE],0
 00C3 B006              jnz X2
 00C5 3C0100            cmp [_STATE+1],0
 00C8 A011              jz L12
 00CA           X2:
 00CA                   .dbline 225
 00CA           ;       {
 00CA                   .dbline 226
 00CA           ;               unloadConfig(STATE);
 00CA 62D000            mov REG[0xd0],>_STATE
 00CD 5100              mov A,[_STATE]
 00CF 08                push A
 00D0 5101              mov A,[_STATE+1]
 00D2 08                push A
 00D3 7C0B1E            xcall _unloadConfig
 00D6 38FE              add SP,-2
 00D8                   .dbline 227
 00D8           ;       }
 00D8 8004              xjmp L13
 00DA           L12:
 00DA                   .dbline 229
 00DA           ;       else
 00DA           ;       {
 00DA                   .dbline 230
 00DA           ;               unloadAllConfigs();
 00DA 7C0B02            xcall _unloadAllConfigs
 00DD                   .dbline 231
 00DD           ;       }
 00DD           L13:
 00DD                   .dbline 235
 00DD           ;       
 00DD           ;       // Go through the list of possible modes until we find the one that was passed in to us.
 00DD           ;       // Then, load that configuration and initialize whatever needs to be initialized.
 00DD           ;       if(mode == WAIT)
 00DD 3DFB00            cmp [X-5],0
 00E0 B022              jnz L14
 00E2 3DFC01            cmp [X-4],1
 00E5 B01D              jnz L14
 00E7           X3:
 00E7                   .dbline 236
 00E7           ;       {
 00E7                   .dbline 239
 00E7           ;               // Load the wait receiver configuration. This is the receiver configuration used after
 00E7           ;               // initialization is complete. It listens and forwards everything it hears.
 00E7           ;               LoadConfig_waiting();
 00E7 7C0000            xcall _LoadConfig_waiting
 00EA                   .dbline 242
 00EA           ;               
 00EA           ;               // Start the receivers.
 00EA           ;               WAIT_RECV_Start(WAIT_RECV_PARITY_NONE);
 00EA 10                push X
 00EB 5000              mov A,0
 00ED 7C0000            xcall _WAIT_RECV_Start
 00F0 20                pop X
 00F1                   .dbline 243
 00F1           ;               RX8_2_Start(RX8_2_PARITY_NONE);
 00F1 10                push X
 00F2 5000              mov A,0
 00F4 7C0000            xcall _RX8_2_Start
 00F7 20                pop X
 00F8                   .dbline 246
 00F8           ;               
 00F8           ;               // Set the current state.
 00F8           ;               STATE = WAIT;
 00F8 62D000            mov REG[0xd0],>_STATE
 00FB 550101            mov [_STATE+1],1
 00FE 550000            mov [_STATE],0
 0101                   .dbline 247
 0101           ;       }
 0101 81A0              xjmp L15
 0103           L14:
 0103                   .dbline 248
 0103           ;       else if(mode == MY_RESPONSE)
 0103 3DFB00            cmp [X-5],0
 0106 B04C              jnz L16
 0108 3DFC02            cmp [X-4],2
 010B B047              jnz L16
 010D           X4:
 010D                   .dbline 249
 010D           ;       {
 010D                   .dbline 251
 010D           ;               // Load the transmitter configuration. This is for transmitting messages on all ports.
 010D           ;               LoadConfig_my_response();
 010D 7C0000            xcall _LoadConfig_my_response
 0110                   .dbline 254
 0110           ;               
 0110           ;               // Clear the timeout flag.
 0110           ;               TIMEOUT = 0;
 0110 62D000            mov REG[0xd0],>_TIMEOUT
 0113 550100            mov [_TIMEOUT+1],0
 0116 550000            mov [_TIMEOUT],0
 0119                   .dbline 257
 0119           ;               
 0119           ;               // Start the transmitters.
 0119           ;               TX_014_Start(TX_014_PARITY_NONE);       // Transmits on P00, P01, and P04.
 0119 10                push X
 011A 5000              mov A,0
 011C 7C0000            xcall _TX_014_Start
 011F 20                pop X
 0120                   .dbline 258
 0120           ;               TX_23_Start(TX_23_PARITY_NONE);         // Transmits on P02 and P03.
 0120 10                push X
 0121 5000              mov A,0
 0123 7C0000            xcall _TX_23_Start
 0126                   .dbline 260
 0126           ;               
 0126           ;               TX_01234_TIMEOUT_EnableInt();           // Make sure interrupts are enabled.
 0126 7C0000            xcall _TX_01234_TIMEOUT_EnableInt
 0129                   .dbline 261
 0129           ;               TX_01234_TIMEOUT_Start();                       // Start the timer.
 0129 7C0000            xcall _TX_01234_TIMEOUT_Start
 012C 20                pop X
 012D           L18:
 012D                   .dbline 265
 012D           ;               
 012D           ;               // Do nothing while we wait for one timeout period (1 ms).
 012D           ;               // This is to allow everyone to get in the right configuration before talking.
 012D           ;               while(!TIMEOUT) { }
 012D                   .dbline 265
 012D           L19:
 012D                   .dbline 265
 012D 62D000            mov REG[0xd0],>_TIMEOUT
 0130 3C0000            cmp [_TIMEOUT],0
 0133 B006              jnz X5
 0135 3C0100            cmp [_TIMEOUT+1],0
 0138 AFF4              jz L18
 013A           X5:
 013A                   .dbline 267
 013A           ;               
 013A           ;               TX_01234_TIMEOUT_Stop();                        // Stop the timer.
 013A 10                push X
 013B 7C0000            xcall _TX_01234_TIMEOUT_Stop
 013E 20                pop X
 013F                   .dbline 268
 013F           ;               TIMEOUT = 0;                                            // Reset the timeout flag.
 013F 62D000            mov REG[0xd0],>_TIMEOUT
 0142 550100            mov [_TIMEOUT+1],0
 0145 550000            mov [_TIMEOUT],0
 0148                   .dbline 271
 0148           ;       
 0148           ;               // Set the current state.
 0148           ;               STATE = MY_RESPONSE;
 0148 62D000            mov REG[0xd0],>_STATE
 014B 550102            mov [_STATE+1],2
 014E 550000            mov [_STATE],0
 0151                   .dbline 272
 0151           ;       }
 0151 8150              xjmp L17
 0153           L16:
 0153                   .dbline 273
 0153           ;       else if(mode == RESPONSE_1)
 0153 3DFB00            cmp [X-5],0
 0156 B02A              jnz L21
 0158 3DFC03            cmp [X-4],3
 015B B025              jnz L21
 015D           X6:
 015D                   .dbline 274
 015D           ;       {
 015D                   .dbline 276
 015D           ;               // Load the response wait on port 1.
 015D           ;               LoadConfig_response1();
 015D 7C0000            xcall _LoadConfig_response1
 0160                   .dbline 279
 0160           ;               
 0160           ;               // Clear the timeout flag.
 0160           ;               TIMEOUT = 0;
 0160 62D000            mov REG[0xd0],>_TIMEOUT
 0163 550100            mov [_TIMEOUT+1],0
 0166 550000            mov [_TIMEOUT],0
 0169                   .dbline 282
 0169           ;               
 0169           ;               // Start listening for a response through child port 1.
 0169           ;               CHILD_1_Start(CHILD_1_PARITY_NONE);
 0169 10                push X
 016A 5000              mov A,0
 016C 7C0000            xcall _CHILD_1_Start
 016F                   .dbline 284
 016F           ;               
 016F           ;               CHILD_1_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 016F 7C0000            xcall _CHILD_1_TIMEOUT_EnableInt
 0172                   .dbline 285
 0172           ;               CHILD_1_TIMEOUT_Start();                        // Start the timer.
 0172 7C0000            xcall _CHILD_1_TIMEOUT_Start
 0175 20                pop X
 0176                   .dbline 288
 0176           ;               
 0176           ;               // Set the current state.
 0176           ;               STATE = RESPONSE_1;
 0176 62D000            mov REG[0xd0],>_STATE
 0179 550103            mov [_STATE+1],3
 017C 550000            mov [_STATE],0
 017F                   .dbline 289
 017F           ;       }
 017F 8122              xjmp L22
 0181           L21:
 0181                   .dbline 290
 0181           ;       else if(mode == RESPONSE_2)
 0181 3DFB00            cmp [X-5],0
 0184 B02A              jnz L23
 0186 3DFC04            cmp [X-4],4
 0189 B025              jnz L23
 018B           X7:
 018B                   .dbline 291
 018B           ;       {
 018B                   .dbline 293
 018B           ;               // Load the response wait on port 2.
 018B           ;               LoadConfig_response2();
 018B 7C0000            xcall _LoadConfig_response2
 018E                   .dbline 296
 018E           ;               
 018E           ;               // Clear the timeout flag.
 018E           ;               TIMEOUT = 0;
 018E 62D000            mov REG[0xd0],>_TIMEOUT
 0191 550100            mov [_TIMEOUT+1],0
 0194 550000            mov [_TIMEOUT],0
 0197                   .dbline 299
 0197           ;               
 0197           ;               // Start listening for a response through child port 2.
 0197           ;               CHILD_2_Start(CHILD_2_PARITY_NONE);
 0197 10                push X
 0198 5000              mov A,0
 019A 7C0000            xcall _CHILD_2_Start
 019D                   .dbline 301
 019D           ;               
 019D           ;               CHILD_2_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 019D 7C0000            xcall _CHILD_2_TIMEOUT_EnableInt
 01A0                   .dbline 302
 01A0           ;               CHILD_2_TIMEOUT_Start();                        // Start the timer.
 01A0 7C0000            xcall _CHILD_2_TIMEOUT_Start
 01A3 20                pop X
 01A4                   .dbline 305
 01A4           ;               
 01A4           ;               // Set the current state.
 01A4           ;               STATE = RESPONSE_2;
 01A4 62D000            mov REG[0xd0],>_STATE
 01A7 550104            mov [_STATE+1],4
 01AA 550000            mov [_STATE],0
 01AD                   .dbline 306
 01AD           ;       }
 01AD 80F4              xjmp L24
 01AF           L23:
 01AF                   .dbline 307
 01AF           ;       else if(mode == RESPONSE_3)
 01AF 3DFB00            cmp [X-5],0
 01B2 B02A              jnz L25
 01B4 3DFC05            cmp [X-4],5
 01B7 B025              jnz L25
 01B9           X8:
 01B9                   .dbline 308
 01B9           ;       {
 01B9                   .dbline 310
 01B9           ;               // Load the response wait on port 3.
 01B9           ;               LoadConfig_response3();
 01B9 7C0000            xcall _LoadConfig_response3
 01BC                   .dbline 313
 01BC           ;               
 01BC           ;               // Clear the timeout flag.
 01BC           ;               TIMEOUT = 0;
 01BC 62D000            mov REG[0xd0],>_TIMEOUT
 01BF 550100            mov [_TIMEOUT+1],0
 01C2 550000            mov [_TIMEOUT],0
 01C5                   .dbline 316
 01C5           ;               
 01C5           ;               // Start listening for a response through child port 3.
 01C5           ;               CHILD_3_Start(CHILD_3_PARITY_NONE);
 01C5 10                push X
 01C6 5000              mov A,0
 01C8 7C0000            xcall _CHILD_3_Start
 01CB                   .dbline 318
 01CB           ;               
 01CB           ;               CHILD_3_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 01CB 7C0000            xcall _CHILD_3_TIMEOUT_EnableInt
 01CE                   .dbline 319
 01CE           ;               CHILD_3_TIMEOUT_Start();                        // Start the timer.
 01CE 7C0000            xcall _CHILD_3_TIMEOUT_Start
 01D1 20                pop X
 01D2                   .dbline 322
 01D2           ;               
 01D2           ;               // Set the current state.
 01D2           ;               STATE = RESPONSE_3;
 01D2 62D000            mov REG[0xd0],>_STATE
 01D5 550105            mov [_STATE+1],5
 01D8 550000            mov [_STATE],0
 01DB                   .dbline 323
 01DB           ;       }
 01DB 80C6              xjmp L26
 01DD           L25:
 01DD                   .dbline 324
 01DD           ;       else if(mode == RESPONSE_4)
 01DD 3DFB00            cmp [X-5],0
 01E0 B02A              jnz L27
 01E2 3DFC06            cmp [X-4],6
 01E5 B025              jnz L27
 01E7           X9:
 01E7                   .dbline 325
 01E7           ;       {
 01E7                   .dbline 327
 01E7           ;               // Load the response wait on port 4.
 01E7           ;               LoadConfig_response4();
 01E7 7C0000            xcall _LoadConfig_response4
 01EA                   .dbline 330
 01EA           ;               
 01EA           ;               // Clear the timeout flag.
 01EA           ;               TIMEOUT = 0;
 01EA 62D000            mov REG[0xd0],>_TIMEOUT
 01ED 550100            mov [_TIMEOUT+1],0
 01F0 550000            mov [_TIMEOUT],0
 01F3                   .dbline 333
 01F3           ;               
 01F3           ;               // Start listening for a response through child port 4.
 01F3           ;               CHILD_4_Start(CHILD_4_PARITY_NONE);
 01F3 10                push X
 01F4 5000              mov A,0
 01F6 7C0000            xcall _CHILD_4_Start
 01F9                   .dbline 335
 01F9           ;               
 01F9           ;               CHILD_4_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 01F9 7C0000            xcall _CHILD_4_TIMEOUT_EnableInt
 01FC                   .dbline 336
 01FC           ;               CHILD_4_TIMEOUT_Start();                        // Start the timer.
 01FC 7C0000            xcall _CHILD_4_TIMEOUT_Start
 01FF 20                pop X
 0200                   .dbline 339
 0200           ;               
 0200           ;               // Set the current state.
 0200           ;               STATE = RESPONSE_4;
 0200 62D000            mov REG[0xd0],>_STATE
 0203 550106            mov [_STATE+1],6
 0206 550000            mov [_STATE],0
 0209                   .dbline 340
 0209           ;       }
 0209 8098              xjmp L28
 020B           L27:
 020B                   .dbline 341
 020B           ;       else if(mode == HELLO_MODE)
 020B 3DFB00            cmp [X-5],0
 020E B03F              jnz L29
 0210 3DFC07            cmp [X-4],7
 0213 B03A              jnz L29
 0215           X10:
 0215                   .dbline 342
 0215           ;       {
 0215                   .dbline 344
 0215           ;               // Load the hello wait mode. This is for listening on all ports for a hello response.
 0215           ;               LoadConfig_hello();
 0215 7C0000            xcall _LoadConfig_hello
 0218                   .dbline 347
 0218           ;               
 0218           ;               // Clear the timeout flag.
 0218           ;               TIMEOUT = 0;
 0218 62D000            mov REG[0xd0],>_TIMEOUT
 021B 550100            mov [_TIMEOUT+1],0
 021E 550000            mov [_TIMEOUT],0
 0221                   .dbline 351
 0221           ;               
 0221           ;               // The seemingly unnecessary brackets around each line are unfortunately needed.
 0221           ;       
 0221           ;               {
 0221                   .dbline 353
 0221           ;               // Start listening for a response through child port 1.
 0221           ;               HELLO_1_Start(HELLO_1_PARITY_NONE);
 0221 10                push X
 0222 5000              mov A,0
 0224 7C0000            xcall _HELLO_1_Start
 0227 20                pop X
 0228                   .dbline 354
 0228           ;               }
 0228                   .dbline 356
 0228           ;               
 0228           ;               {
 0228                   .dbline 358
 0228           ;               // Start listening for a response through child port 2.
 0228           ;               HELLO_2_Start(HELLO_2_PARITY_NONE);
 0228 10                push X
 0229 5000              mov A,0
 022B 7C0000            xcall _HELLO_2_Start
 022E 20                pop X
 022F                   .dbline 359
 022F           ;               }
 022F                   .dbline 361
 022F           ;               
 022F           ;               {
 022F                   .dbline 363
 022F           ;               // Start listening for a response through child port 3.
 022F           ;               HELLO_3_Start(HELLO_3_PARITY_NONE);
 022F 10                push X
 0230 5000              mov A,0
 0232 7C0000            xcall _HELLO_3_Start
 0235 20                pop X
 0236                   .dbline 364
 0236           ;               }
 0236                   .dbline 366
 0236           ;               
 0236           ;               {
 0236                   .dbline 368
 0236           ;               // Start listening for a response through child port 4.
 0236           ;               HELLO_4_Start(HELLO_4_PARITY_NONE);
 0236 10                push X
 0237 5000              mov A,0
 0239 7C0000            xcall _HELLO_4_Start
 023C                   .dbline 369
 023C           ;               }
 023C                   .dbline 371
 023C           ;               
 023C           ;               HELLO_TIMEOUT_EnableInt();      // Make sure interrupts are enabled.
 023C 7C0000            xcall _HELLO_TIMEOUT_EnableInt
 023F                   .dbline 372
 023F           ;               HELLO_TIMEOUT_Start();          // Start the timer.
 023F 7C0000            xcall _HELLO_TIMEOUT_Start
 0242 20                pop X
 0243                   .dbline 375
 0243           ;               
 0243           ;               // Set the current state.
 0243           ;               STATE = HELLO_MODE;
 0243 62D000            mov REG[0xd0],>_STATE
 0246 550107            mov [_STATE+1],7
 0249 550000            mov [_STATE],0
 024C                   .dbline 376
 024C           ;       }
 024C 8055              xjmp L30
 024E           L29:
 024E                   .dbline 377
 024E           ;       else if(mode == INITIALIZE)
 024E 3DFB00            cmp [X-5],0
 0251 B02A              jnz L31
 0253 3DFC08            cmp [X-4],8
 0256 B025              jnz L31
 0258           X11:
 0258                   .dbline 378
 0258           ;       {
 0258                   .dbline 380
 0258           ;               // Load the configuration for initialization. This config listens but does not forward.
 0258           ;               LoadConfig_initial();
 0258 7C0000            xcall _LoadConfig_initial
 025B                   .dbline 383
 025B           ;               
 025B           ;               // Clear the timeout flag.
 025B           ;               TIMEOUT = 0;
 025B 62D000            mov REG[0xd0],>_TIMEOUT
 025E 550100            mov [_TIMEOUT+1],0
 0261 550000            mov [_TIMEOUT],0
 0264                   .dbline 386
 0264           ;               
 0264           ;               // Start the receiver.
 0264           ;               INIT_RX_Start(INIT_RX_PARITY_NONE);
 0264 10                push X
 0265 5000              mov A,0
 0267 7C0000            xcall _INIT_RX_Start
 026A                   .dbline 388
 026A           ;               
 026A           ;               INIT_TIMEOUT_EnableInt();       // Make sure interrupts are enabled.
 026A 7C0000            xcall _INIT_TIMEOUT_EnableInt
 026D                   .dbline 389
 026D           ;               INIT_TIMEOUT_Start();           // Start the timer.
 026D 7C0000            xcall _INIT_TIMEOUT_Start
 0270 20                pop X
 0271                   .dbline 392
 0271           ;               
 0271           ;               // Set the current state.
 0271           ;               STATE = INITIALIZE;
 0271 62D000            mov REG[0xd0],>_STATE
 0274 550108            mov [_STATE+1],8
 0277 550000            mov [_STATE],0
 027A                   .dbline 393
 027A           ;       }
 027A 8027              xjmp L32
 027C           L31:
 027C                   .dbline 394
 027C           ;       else if(mode == SERVO_COMM)
 027C 3DFB00            cmp [X-5],0
 027F B022              jnz L33
 0281 3DFC09            cmp [X-4],9
 0284 B01D              jnz L33
 0286           X12:
 0286                   .dbline 395
 0286           ;       {
 0286                   .dbline 397
 0286           ;               // Load the configuration for servo communication. This config only transmits on P00.
 0286           ;               LoadConfig_servo_transmit();
 0286 7C0000            xcall _LoadConfig_servo_transmit
 0289                   .dbline 400
 0289           ;               
 0289           ;               // Clear the timeout flag.
 0289           ;               TIMEOUT = 0;
 0289 62D000            mov REG[0xd0],>_TIMEOUT
 028C 550100            mov [_TIMEOUT+1],0
 028F 550000            mov [_TIMEOUT],0
 0292                   .dbline 403
 0292           ;               
 0292           ;               // Start the transmitter.
 0292           ;               SERVO_TX_Start(SERVO_TX_PARITY_NONE);
 0292 10                push X
 0293 5000              mov A,0
 0295 7C0000            xcall _SERVO_TX_Start
 0298 20                pop X
 0299                   .dbline 406
 0299           ;       
 0299           ;               // Set the current state.
 0299           ;               STATE = SERVO_COMM;
 0299 62D000            mov REG[0xd0],>_STATE
 029C 550109            mov [_STATE+1],9
 029F 550000            mov [_STATE],0
 02A2                   .dbline 407
 02A2           ;       }
 02A2           L33:
 02A2           L32:
 02A2           L30:
 02A2           L28:
 02A2           L26:
 02A2           L24:
 02A2           L22:
 02A2           L17:
 02A2           L15:
 02A2                   .dbline 410
 02A2           ;       
 02A2           ;       // If this module is configured, talk on all pins for potential children.
 02A2           ;       if(CONFIGURED)
 02A2 62D000            mov REG[0xd0],>_CONFIGURED
 02A5 3C0000            cmp [_CONFIGURED],0
 02A8 B006              jnz X13
 02AA 3C0100            cmp [_CONFIGURED+1],0
 02AD A009              jz L35
 02AF           X13:
 02AF                   .dbline 411
 02AF           ;       {
 02AF                   .dbline 412
 02AF           ;               PRT0GS |= 0b00011111;   // Connect all pins to the global bus.
 02AF 43021F            or REG[0x2],31
 02B2                   .dbline 413
 02B2           ;               PRT2DR &= 0b11111110;   // Turn on the LED (active low).
 02B2 4108FE            and REG[0x8],-2
 02B5                   .dbline 414
 02B5           ;       }
 02B5 8007              xjmp L36
 02B7           L35:
 02B7                   .dbline 416
 02B7           ;       else
 02B7           ;       {
 02B7                   .dbline 417
 02B7           ;               PRT0GS |= 0b00000001;   // Just connect pin 0;
 02B7 430201            or REG[0x2],1
 02BA                   .dbline 418
 02BA           ;               PRT2DR |= 0b00000001;   // Turn off the LED (active low).
 02BA 430801            or REG[0x8],1
 02BD                   .dbline 419
 02BD           ;       }
 02BD           L36:
 02BD                   .dbline -2
 02BD           L11:
 02BD 20                pop X
 02BE                   .dbline 0 ; func end
 02BE 7F                ret
 02BF                   .dbsym l mode -5 I
 02BF                   .dbend
 02BF                   .dbfunc e commandReady _commandReady fI
 02BF           ;   runningTotal -> X+3
 02BF           ;              i -> X+1
 02BF           ;       tempByte -> X+0
 02BF           _commandReady::
 02BF                   .dbline -1
 02BF 10                push X
 02C0 4F                mov X,SP
 02C1 3805              add SP,5
 02C3                   .dbline 426
 02C3           ; }
 02C3           ; 
 02C3           ; // This function checks the current hardware configuration state. Once it finds this state, it
 02C3           ; // uses the receivers that are in that configuration in the way they are intended to grab the
 02C3           ; // transmission information that we require (or just let commands pass through if we don't care).
 02C3           ; int commandReady(void)
 02C3           ; {
 02C3                   .dbline 427
 02C3           ;       int i = 0;                      // This integer is used for looping through the remaining bytes of commands.
 02C3 560200            mov [X+2],0
 02C6 560100            mov [X+1],0
 02C9                   .dbline 428
 02C9           ;       char tempByte = 0;      // This byte is used to store each byte for comparison as it comes in.
 02C9 560000            mov [X+0],0
 02CC                   .dbline 430
 02CC           ;       
 02CC           ;       int runningTotal = 0;   // This is used to check for a checksum in the case of a servo transmit.
 02CC 560400            mov [X+4],0
 02CF 560300            mov [X+3],0
 02D2                   .dbline 434
 02D2           ;       
 02D2           ;       // This conditional checks which configuration is loaded and uses the proper devices to
 02D2           ;       // read a transmission and store the important information from that transmission.
 02D2           ;       if(STATE == WAIT)
 02D2 62D000            mov REG[0xd0],>_STATE
 02D5 3C0000            cmp [_STATE],0
 02D8 B0D4              jnz L38
 02DA 3C0101            cmp [_STATE+1],1
 02DD B0CF              jnz L38
 02DF           X14:
 02DF                   .dbline 435
 02DF           ;       {       
 02DF                   .dbline 438
 02DF           ;               // In wait mode, the only thing that progresses things forward is a master node transmission.
 02DF           ;               // With this being the case, we use a blocking operation to sit and wait for a byte.
 02DF           ;               tempByte = WAIT_RECV_cGetChar();
 02DF 10                push X
 02E0 7C0000            xcall _WAIT_RECV_cGetChar
 02E3 62D000            mov REG[0xd0],>__r0
 02E6 20                pop X
 02E7 5400              mov [X+0],A
 02E9                   .dbline 441
 02E9           ;               
 02E9           ;               // If a transmission has started for either a controller or a servo...
 02E9           ;               if(tempByte == START_TRANSMIT)
 02E9 3D00FC            cmp [X+0],-4
 02EC B047              jnz L40
 02EE                   .dbline 442
 02EE           ;               {
 02EE 800B              xjmp L43
 02F0           L42:
 02F0                   .dbline 445
 02F0           ;                       // While we keep reading start bytes, sit and spin.
 02F0           ;                       while(tempByte == START_TRANSMIT)
 02F0           ;                       {
 02F0                   .dbline 446
 02F0           ;                               tempByte = WAIT_RECV_cGetChar();
 02F0 10                push X
 02F1 7C0000            xcall _WAIT_RECV_cGetChar
 02F4 62D000            mov REG[0xd0],>__r0
 02F7 20                pop X
 02F8 5400              mov [X+0],A
 02FA                   .dbline 447
 02FA           ;                       }
 02FA           L43:
 02FA                   .dbline 444
 02FA 3D00FC            cmp [X+0],-4
 02FD AFF2              jz L42
 02FF                   .dbline 450
 02FF           ;                       
 02FF           ;                       // The tempByte variable contains the source ID. If the source is good, store all bytes.
 02FF           ;                       if(tempByte == MASTER_ID)
 02FF 3D0000            cmp [X+0],0
 0302 B55E              jnz L39
 0304                   .dbline 451
 0304           ;                       {
 0304                   .dbline 452
 0304           ;                               COMMAND_SOURCE = tempByte;
 0304 5200              mov A,[X+0]
 0306 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0309 5300              mov [_COMMAND_SOURCE],A
 030B                   .dbline 453
 030B           ;                               COMMAND_DESTINATION = WAIT_RECV_cGetChar();
 030B 10                push X
 030C 7C0000            xcall _WAIT_RECV_cGetChar
 030F 20                pop X
 0310 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0313 5300              mov [_COMMAND_DESTINATION],A
 0315                   .dbline 454
 0315           ;                               COMMAND_TYPE = WAIT_RECV_cGetChar();
 0315 10                push X
 0316 7C0000            xcall _WAIT_RECV_cGetChar
 0319 20                pop X
 031A 62D000            mov REG[0xd0],>_COMMAND_TYPE
 031D 5300              mov [_COMMAND_TYPE],A
 031F                   .dbline 455
 031F           ;                               COMMAND_PARAM = WAIT_RECV_cGetChar();
 031F 10                push X
 0320 7C0000            xcall _WAIT_RECV_cGetChar
 0323 20                pop X
 0324 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0327 5300              mov [_COMMAND_PARAM],A
 0329                   .dbline 457
 0329           ;                               
 0329           ;                               return 1;
 0329 62D000            mov REG[0xd0],>__r0
 032C 550001            mov [__r1],1
 032F 550000            mov [__r0],0
 0332 8537              xjmp L37
 0334           L40:
 0334                   .dbline 460
 0334           ;                       }
 0334           ;               }
 0334           ;               else if(tempByte == SERVO_START)
 0334 3D00FF            cmp [X+0],-1
 0337 B529              jnz L39
 0339                   .dbline 461
 0339           ;               {
 0339 800B              xjmp L50
 033B           L49:
 033B                   .dbline 464
 033B           ;                       // While we keep reading start bytes, sit and spin.
 033B           ;                       while(tempByte == SERVO_START)
 033B           ;                       {
 033B                   .dbline 465
 033B           ;                               tempByte = WAIT_RECV_cGetChar();
 033B 10                push X
 033C 7C0000            xcall _WAIT_RECV_cGetChar
 033F 62D000            mov REG[0xd0],>__r0
 0342 20                pop X
 0343 5400              mov [X+0],A
 0345                   .dbline 466
 0345           ;                       }
 0345           L50:
 0345                   .dbline 463
 0345 3D00FF            cmp [X+0],-1
 0348 AFF2              jz L49
 034A                   .dbline 469
 034A           ;                       
 034A           ;                       // We assume (and hopefully rightly so) that this is a command from master.
 034A           ;                       COMMAND_SOURCE = MASTER_ID;
 034A 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 034D 550000            mov [_COMMAND_SOURCE],0
 0350                   .dbline 471
 0350           ;                       // The first parameter after the servo start is the destination.
 0350           ;                       COMMAND_DESTINATION = tempByte;
 0350 5200              mov A,[X+0]
 0352 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0355 5300              mov [_COMMAND_DESTINATION],A
 0357                   .dbline 476
 0357           ;                       // The second parameter after the servo start is the command length.
 0357           ;                       // We don't need it to wait for the transmission to go through since the
 0357           ;                       // transmission goes through the chip with a delay of approximately 100 ns
 0357           ;                       // (it is already in and out by the time you read this byte).
 0357           ;                       tempByte = WAIT_RECV_cGetChar();
 0357 10                push X
 0358 7C0000            xcall _WAIT_RECV_cGetChar
 035B 62D000            mov REG[0xd0],>__r0
 035E 20                pop X
 035F 5400              mov [X+0],A
 0361                   .dbline 479
 0361           ;                       // Now we store the command type. Depending on what the status return level
 0361           ;                       // is, we have special duties.
 0361           ;                       COMMAND_TYPE = WAIT_RECV_cGetChar();
 0361 10                push X
 0362 7C0000            xcall _WAIT_RECV_cGetChar
 0365 20                pop X
 0366 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0369 5300              mov [_COMMAND_TYPE],A
 036B                   .dbline 483
 036B           ;                       
 036B           ;                       // This basically clears the rest of the command from the buffer
 036B           ;                       // and serves the dual purpose of allowing everybody time to hear it.
 036B           ;                       for(i = 0; i < (tempByte - 1); i++)
 036B 560200            mov [X+2],0
 036E 560100            mov [X+1],0
 0371 800E              xjmp L55
 0373           L52:
 0373                   .dbline 484
 0373           ;                       {
 0373                   .dbline 485
 0373           ;                               WAIT_RECV_cGetChar();
 0373 10                push X
 0374 7C0000            xcall _WAIT_RECV_cGetChar
 0377 62D000            mov REG[0xd0],>__r0
 037A 20                pop X
 037B                   .dbline 486
 037B           ;                       }
 037B           L53:
 037B                   .dbline 483
 037B 7702              inc [X+2]
 037D 0F0100            adc [X+1],0
 0380           L55:
 0380                   .dbline 483
 0380 62D000            mov REG[0xd0],>__r0
 0383 5200              mov A,[X+0]
 0385 5300              mov [__r1],A
 0387 550000            mov [__r0],0
 038A 160001            sub [__r1],1
 038D 1E0000            sbb [__r0],0
 0390 5202              mov A,[X+2]
 0392 1200              sub A,[__r1]
 0394 5100              mov A,[__r0]
 0396 3180              xor A,-128
 0398 5300              mov [__rX],A
 039A 5201              mov A,[X+1]
 039C 3180              xor A,-128
 039E 1A00              sbb A,[__rX]
 03A0 CFD2              jc L52
 03A2           X15:
 03A2                   .dbline 488
 03A2           ;                               
 03A2           ;                       return 1;
 03A2 62D000            mov REG[0xd0],>__r0
 03A5 550001            mov [__r1],1
 03A8 550000            mov [__r0],0
 03AB 84BE              xjmp L37
 03AD           L38:
 03AD                   .dbline 491
 03AD           ;               }
 03AD           ;       }
 03AD           ;       else if(STATE == HELLO_MODE)
 03AD 62D000            mov REG[0xd0],>_STATE
 03B0 3C0000            cmp [_STATE],0
 03B3 B0E2              jnz L56
 03B5 3C0107            cmp [_STATE+1],7
 03B8 B0DD              jnz L56
 03BA           X16:
 03BA                   .dbline 492
 03BA           ;       {
 03BA                   .dbline 495
 03BA           ;               // Check all of the ports for a start byte. Only one port will produce one.
 03BA           ;               // Only non-blocking commands are used to avoid getting stuck listening downstream.
 03BA           ;               if(HELLO_1_cReadChar() == START_TRANSMIT)
 03BA 10                push X
 03BB 7C0000            xcall _HELLO_1_cReadChar
 03BE 62D000            mov REG[0xd0],>__r0
 03C1 20                pop X
 03C2 39FC              cmp A,-4
 03C4 B02C              jnz L58
 03C6                   .dbline 496
 03C6           ;               {
 03C6 801B              xjmp L61
 03C8           L60:
 03C8                   .dbline 498
 03C8           ;                       while(!TIMEOUT)
 03C8           ;                       {
 03C8                   .dbline 499
 03C8           ;                               if(HELLO_1_cReadChar() == END_TRANSMIT)
 03C8 10                push X
 03C9 7C0000            xcall _HELLO_1_cReadChar
 03CC 20                pop X
 03CD 39FD              cmp A,-3
 03CF B012              jnz L63
 03D1                   .dbline 500
 03D1           ;                               {
 03D1                   .dbline 501
 03D1           ;                                       CHILD = PORT_1;
 03D1 62D000            mov REG[0xd0],>_CHILD
 03D4 550031            mov [_CHILD],49
 03D7                   .dbline 503
 03D7           ;                               
 03D7           ;                                       return 1;
 03D7 62D000            mov REG[0xd0],>__r0
 03DA 550001            mov [__r1],1
 03DD 550000            mov [__r0],0
 03E0 8489              xjmp L37
 03E2           L63:
 03E2                   .dbline 505
 03E2           ;                               }
 03E2           ;                       }
 03E2           L61:
 03E2                   .dbline 497
 03E2 62D000            mov REG[0xd0],>_TIMEOUT
 03E5 3C0000            cmp [_TIMEOUT],0
 03E8 B006              jnz X17
 03EA 3C0100            cmp [_TIMEOUT+1],0
 03ED AFDA              jz L60
 03EF           X17:
 03EF                   .dbline 506
 03EF           ;               }
 03EF 8471              xjmp L57
 03F1           L58:
 03F1                   .dbline 507
 03F1           ;               else if(HELLO_2_cReadChar() == START_TRANSMIT)
 03F1 10                push X
 03F2 7C0000            xcall _HELLO_2_cReadChar
 03F5 62D000            mov REG[0xd0],>__r0
 03F8 20                pop X
 03F9 39FC              cmp A,-4
 03FB B02C              jnz L65
 03FD                   .dbline 508
 03FD           ;               {
 03FD 801B              xjmp L68
 03FF           L67:
 03FF                   .dbline 510
 03FF           ;                       while(!TIMEOUT)
 03FF           ;                       {
 03FF                   .dbline 511
 03FF           ;                               if(HELLO_2_cReadChar() == END_TRANSMIT)
 03FF 10                push X
 0400 7C0000            xcall _HELLO_2_cReadChar
 0403 20                pop X
 0404 39FD              cmp A,-3
 0406 B012              jnz L70
 0408                   .dbline 512
 0408           ;                               {
 0408                   .dbline 513
 0408           ;                                       CHILD = PORT_2;
 0408 62D000            mov REG[0xd0],>_CHILD
 040B 550032            mov [_CHILD],50
 040E                   .dbline 515
 040E           ;                               
 040E           ;                                       return 1;
 040E 62D000            mov REG[0xd0],>__r0
 0411 550001            mov [__r1],1
 0414 550000            mov [__r0],0
 0417 8452              xjmp L37
 0419           L70:
 0419                   .dbline 517
 0419           ;                               }
 0419           ;                       }
 0419           L68:
 0419                   .dbline 509
 0419 62D000            mov REG[0xd0],>_TIMEOUT
 041C 3C0000            cmp [_TIMEOUT],0
 041F B006              jnz X18
 0421 3C0100            cmp [_TIMEOUT+1],0
 0424 AFDA              jz L67
 0426           X18:
 0426                   .dbline 518
 0426           ;               }
 0426 843A              xjmp L57
 0428           L65:
 0428                   .dbline 519
 0428           ;               else if(HELLO_3_cReadChar() == START_TRANSMIT)
 0428 10                push X
 0429 7C0000            xcall _HELLO_3_cReadChar
 042C 62D000            mov REG[0xd0],>__r0
 042F 20                pop X
 0430 39FC              cmp A,-4
 0432 B02C              jnz L72
 0434                   .dbline 520
 0434           ;               {
 0434 801B              xjmp L75
 0436           L74:
 0436                   .dbline 522
 0436           ;                       while(!TIMEOUT)
 0436           ;                       {
 0436                   .dbline 523
 0436           ;                               if(HELLO_3_cReadChar() == END_TRANSMIT)
 0436 10                push X
 0437 7C0000            xcall _HELLO_3_cReadChar
 043A 20                pop X
 043B 39FD              cmp A,-3
 043D B012              jnz L77
 043F                   .dbline 524
 043F           ;                               {
 043F                   .dbline 525
 043F           ;                                       CHILD = PORT_3;
 043F 62D000            mov REG[0xd0],>_CHILD
 0442 550033            mov [_CHILD],51
 0445                   .dbline 527
 0445           ;                               
 0445           ;                                       return 1;
 0445 62D000            mov REG[0xd0],>__r0
 0448 550001            mov [__r1],1
 044B 550000            mov [__r0],0
 044E 841B              xjmp L37
 0450           L77:
 0450                   .dbline 529
 0450           ;                               }
 0450           ;                       }
 0450           L75:
 0450                   .dbline 521
 0450 62D000            mov REG[0xd0],>_TIMEOUT
 0453 3C0000            cmp [_TIMEOUT],0
 0456 B006              jnz X19
 0458 3C0100            cmp [_TIMEOUT+1],0
 045B AFDA              jz L74
 045D           X19:
 045D                   .dbline 530
 045D           ;               }
 045D 8403              xjmp L57
 045F           L72:
 045F                   .dbline 531
 045F           ;               else if(HELLO_4_cReadChar() == START_TRANSMIT)
 045F 10                push X
 0460 7C0000            xcall _HELLO_4_cReadChar
 0463 62D000            mov REG[0xd0],>__r0
 0466 20                pop X
 0467 39FC              cmp A,-4
 0469 B3F7              jnz L57
 046B                   .dbline 532
 046B           ;               {
 046B 801B              xjmp L82
 046D           L81:
 046D                   .dbline 534
 046D           ;                       while(!TIMEOUT)
 046D           ;                       {
 046D                   .dbline 535
 046D           ;                               if(HELLO_4_cReadChar() == END_TRANSMIT)
 046D 10                push X
 046E 7C0000            xcall _HELLO_4_cReadChar
 0471 20                pop X
 0472 39FD              cmp A,-3
 0474 B012              jnz L84
 0476                   .dbline 536
 0476           ;                               {
 0476                   .dbline 537
 0476           ;                                       CHILD = PORT_4;
 0476 62D000            mov REG[0xd0],>_CHILD
 0479 550034            mov [_CHILD],52
 047C                   .dbline 539
 047C           ;                               
 047C           ;                                       return 1;
 047C 62D000            mov REG[0xd0],>__r0
 047F 550001            mov [__r1],1
 0482 550000            mov [__r0],0
 0485 83E4              xjmp L37
 0487           L84:
 0487                   .dbline 541
 0487           ;                               }
 0487           ;                       }
 0487           L82:
 0487                   .dbline 533
 0487 62D000            mov REG[0xd0],>_TIMEOUT
 048A 3C0000            cmp [_TIMEOUT],0
 048D B006              jnz X20
 048F 3C0100            cmp [_TIMEOUT+1],0
 0492 AFDA              jz L81
 0494           X20:
 0494                   .dbline 542
 0494           ;               }
 0494                   .dbline 543
 0494           ;       }
 0494 83CC              xjmp L57
 0496           L56:
 0496                   .dbline 544
 0496           ;       else if(STATE == RESPONSE_1)
 0496 62D000            mov REG[0xd0],>_STATE
 0499 3C0000            cmp [_STATE],0
 049C B0D2              jnz L86
 049E 3C0103            cmp [_STATE+1],3
 04A1 B0CD              jnz L86
 04A3           X21:
 04A3                   .dbline 545
 04A3           ;       {
 04A3                   .dbline 546
 04A3           ;               if(tempByte = CHILD_1_cReadChar())      // If we have a nonzero byte...
 04A3 10                push X
 04A4 7C0000            xcall _CHILD_1_cReadChar
 04A7 62D000            mov REG[0xd0],>__r0
 04AA 20                pop X
 04AB 5400              mov [X+0],A
 04AD 3900              cmp A,0
 04AF A3B1              jz L87
 04B1                   .dbline 547
 04B1           ;               {
 04B1                   .dbline 548
 04B1           ;                       if(tempByte == SERVO_START)             // We have a servo response coming.
 04B1 3D00FF            cmp [X+0],-1
 04B4 B090              jnz L90
 04B6                   .dbline 549
 04B6           ;                       {
 04B6 807F              xjmp L93
 04B8           L92:
 04B8                   .dbline 552
 04B8           ;                               // While we have not timed out, try to let all of the bytes through.
 04B8           ;                               while(!TIMEOUT)
 04B8           ;                               {
 04B8                   .dbline 554
 04B8           ;                                       // Eat the remaining servo start bytes.
 04B8           ;                                       if(tempByte = CHILD_1_cReadChar())
 04B8 10                push X
 04B9 7C0000            xcall _CHILD_1_cReadChar
 04BC 62D000            mov REG[0xd0],>__r0
 04BF 20                pop X
 04C0 5400              mov [X+0],A
 04C2 3900              cmp A,0
 04C4 A071              jz L95
 04C6                   .dbline 555
 04C6           ;                                       {
 04C6                   .dbline 558
 04C6           ;                                               // Once we get past the start bytes, we can start adding the
 04C6           ;                                               // bytes to our running total and searching for a checksum.
 04C6           ;                                               if(tempByte != SERVO_START)
 04C6 3D00FF            cmp [X+0],-1
 04C9 A06C              jz L97
 04CB                   .dbline 559
 04CB           ;                                               {
 04CB                   .dbline 561
 04CB           ;                                                       // Add to the running total.
 04CB           ;                                                       runningTotal += tempByte;
 04CB 5200              mov A,[X+0]
 04CD 0504              add [X+4],A
 04CF 0F0300            adc [X+3],0
 04D2 8056              xjmp L100
 04D4           L99:
 04D4                   .dbline 565
 04D4           ;                                                       
 04D4           ;                                                       // Either find a checksum or time out. Either way we're not stuck.
 04D4           ;                                                       while(!TIMEOUT)
 04D4           ;                                                       {
 04D4                   .dbline 567
 04D4           ;                                                               // If a nonzero byte has arrived...
 04D4           ;                                                               if(tempByte = CHILD_1_cReadChar())
 04D4 10                push X
 04D5 7C0000            xcall _CHILD_1_cReadChar
 04D8 62D000            mov REG[0xd0],>__r0
 04DB 20                pop X
 04DC 5400              mov [X+0],A
 04DE 3900              cmp A,0
 04E0 A048              jz L102
 04E2                   .dbline 568
 04E2           ;                                                               {
 04E2                   .dbline 570
 04E2           ;                                                                       // Check to see if it is a checksum.
 04E2           ;                                                                       if((runningTotal%256) == (255-tempByte))
 04E2 5200              mov A,[X+0]
 04E4 5300              mov [__r1],A
 04E6 550000            mov [__r0],0
 04E9 50FF              mov A,-1
 04EB 1200              sub A,[__r1]
 04ED 5300              mov [__r1],A
 04EF 5000              mov A,0
 04F1 1A00              sbb A,[__r0]
 04F3 5300              mov [__r0],A
 04F5 5001              mov A,1
 04F7 08                push A
 04F8 5000              mov A,0
 04FA 08                push A
 04FB 5203              mov A,[X+3]
 04FD 08                push A
 04FE 5204              mov A,[X+4]
 0500 08                push A
 0501 7C0000            xcall __divmod_16X16_16
 0504 38FE              add SP,-2
 0506 18                pop A
 0507 5300              mov [__r3],A
 0509 18                pop A
 050A 3A00              cmp A,[__r0]
 050C B012              jnz L104
 050E 5100              mov A,[__r3]
 0510 3A00              cmp A,[__r1]
 0512 B00C              jnz L104
 0514           X22:
 0514                   .dbline 571
 0514           ;                                                                       {
 0514                   .dbline 572
 0514           ;                                                                               return 1;
 0514 62D000            mov REG[0xd0],>__r0
 0517 550001            mov [__r1],1
 051A 550000            mov [__r0],0
 051D 834C              xjmp L37
 051F           L104:
 051F                   .dbline 575
 051F           ;                                                                       }
 051F           ;                                                                       else
 051F           ;                                                                       {
 051F                   .dbline 576
 051F           ;                                                                               runningTotal += tempByte;
 051F 62D000            mov REG[0xd0],>__r0
 0522 5200              mov A,[X+0]
 0524 0504              add [X+4],A
 0526 0F0300            adc [X+3],0
 0529                   .dbline 577
 0529           ;                                                                       }
 0529                   .dbline 578
 0529           ;                                                               }
 0529           L102:
 0529                   .dbline 579
 0529           ;                                                       }
 0529           L100:
 0529                   .dbline 564
 0529 62D000            mov REG[0xd0],>_TIMEOUT
 052C 3C0000            cmp [_TIMEOUT],0
 052F B006              jnz X23
 0531 3C0100            cmp [_TIMEOUT+1],0
 0534 AF9F              jz L99
 0536           X23:
 0536                   .dbline 580
 0536           ;                                               }
 0536           L97:
 0536                   .dbline 581
 0536           ;                                       }
 0536           L95:
 0536                   .dbline 582
 0536           ;                               }
 0536           L93:
 0536                   .dbline 551
 0536 62D000            mov REG[0xd0],>_TIMEOUT
 0539 3C0000            cmp [_TIMEOUT],0
 053C B006              jnz X24
 053E 3C0100            cmp [_TIMEOUT+1],0
 0541 AF76              jz L92
 0543           X24:
 0543                   .dbline 583
 0543           ;                       }
 0543 831D              xjmp L87
 0545           L90:
 0545                   .dbline 584
 0545           ;                       else if(tempByte == START_TRANSMIT)     // We have a controller response coming.
 0545 3D00FC            cmp [X+0],-4
 0548 B318              jnz L87
 054A                   .dbline 585
 054A           ;                       {
 054A 8015              xjmp L109
 054C           L108:
 054C                   .dbline 588
 054C           ;                               // We simply wait for the end transmit indicator.
 054C           ;                               while(!TIMEOUT)
 054C           ;                               {
 054C                   .dbline 589
 054C           ;                                       if(CHILD_1_cReadChar() == END_TRANSMIT)
 054C 10                push X
 054D 7C0000            xcall _CHILD_1_cReadChar
 0550 62D000            mov REG[0xd0],>__r0
 0553 20                pop X
 0554 39FD              cmp A,-3
 0556 B009              jnz L111
 0558                   .dbline 590
 0558           ;                                       {
 0558                   .dbline 591
 0558           ;                                               return 1;
 0558 550001            mov [__r1],1
 055B 550000            mov [__r0],0
 055E 830B              xjmp L37
 0560           L111:
 0560                   .dbline 593
 0560           ;                                       }
 0560           ;                               }
 0560           L109:
 0560                   .dbline 587
 0560 62D000            mov REG[0xd0],>_TIMEOUT
 0563 3C0000            cmp [_TIMEOUT],0
 0566 B006              jnz X25
 0568 3C0100            cmp [_TIMEOUT+1],0
 056B AFE0              jz L108
 056D           X25:
 056D                   .dbline 594
 056D           ;                       }
 056D                   .dbline 595
 056D           ;               }
 056D                   .dbline 596
 056D           ;       }
 056D 82F3              xjmp L87
 056F           L86:
 056F                   .dbline 597
 056F           ;       else if(STATE == RESPONSE_2)
 056F 62D000            mov REG[0xd0],>_STATE
 0572 3C0000            cmp [_STATE],0
 0575 B0D2              jnz L113
 0577 3C0104            cmp [_STATE+1],4
 057A B0CD              jnz L113
 057C           X26:
 057C                   .dbline 598
 057C           ;       {
 057C                   .dbline 599
 057C           ;               if(tempByte = CHILD_2_cReadChar())
 057C 10                push X
 057D 7C0000            xcall _CHILD_2_cReadChar
 0580 62D000            mov REG[0xd0],>__r0
 0583 20                pop X
 0584 5400              mov [X+0],A
 0586 3900              cmp A,0
 0588 A2D8              jz L114
 058A                   .dbline 600
 058A           ;               {
 058A                   .dbline 601
 058A           ;                       if(tempByte == SERVO_START)             // We have a servo response coming.
 058A 3D00FF            cmp [X+0],-1
 058D B090              jnz L117
 058F                   .dbline 602
 058F           ;                       {
 058F 807F              xjmp L120
 0591           L119:
 0591                   .dbline 605
 0591           ;                               // While we have not timed out, try to let all of the bytes through.
 0591           ;                               while(!TIMEOUT)
 0591           ;                               {
 0591                   .dbline 607
 0591           ;                                       // Eat the remaining servo start bytes.
 0591           ;                                       if(tempByte = CHILD_2_cReadChar())
 0591 10                push X
 0592 7C0000            xcall _CHILD_2_cReadChar
 0595 62D000            mov REG[0xd0],>__r0
 0598 20                pop X
 0599 5400              mov [X+0],A
 059B 3900              cmp A,0
 059D A071              jz L122
 059F                   .dbline 608
 059F           ;                                       {
 059F                   .dbline 611
 059F           ;                                               // Once we get past the start bytes, we can start adding the
 059F           ;                                               // bytes to our running total and searching for a checksum.
 059F           ;                                               if(tempByte != SERVO_START)
 059F 3D00FF            cmp [X+0],-1
 05A2 A06C              jz L124
 05A4                   .dbline 612
 05A4           ;                                               {
 05A4                   .dbline 614
 05A4           ;                                                       // Add to the running total.
 05A4           ;                                                       runningTotal += tempByte;
 05A4 5200              mov A,[X+0]
 05A6 0504              add [X+4],A
 05A8 0F0300            adc [X+3],0
 05AB 8056              xjmp L127
 05AD           L126:
 05AD                   .dbline 618
 05AD           ;                                                       
 05AD           ;                                                       // Either find a checksum or time out. Either way we're not stuck.
 05AD           ;                                                       while(!TIMEOUT)
 05AD           ;                                                       {
 05AD                   .dbline 620
 05AD           ;                                                               // If a nonzero byte has arrived...
 05AD           ;                                                               if(tempByte = CHILD_2_cReadChar())
 05AD 10                push X
 05AE 7C0000            xcall _CHILD_2_cReadChar
 05B1 62D000            mov REG[0xd0],>__r0
 05B4 20                pop X
 05B5 5400              mov [X+0],A
 05B7 3900              cmp A,0
 05B9 A048              jz L129
 05BB                   .dbline 621
 05BB           ;                                                               {
 05BB                   .dbline 623
 05BB           ;                                                                       // Check to see if it is a checksum.
 05BB           ;                                                                       if((runningTotal%256) == (255-tempByte))
 05BB 5200              mov A,[X+0]
 05BD 5300              mov [__r1],A
 05BF 550000            mov [__r0],0
 05C2 50FF              mov A,-1
 05C4 1200              sub A,[__r1]
 05C6 5300              mov [__r1],A
 05C8 5000              mov A,0
 05CA 1A00              sbb A,[__r0]
 05CC 5300              mov [__r0],A
 05CE 5001              mov A,1
 05D0 08                push A
 05D1 5000              mov A,0
 05D3 08                push A
 05D4 5203              mov A,[X+3]
 05D6 08                push A
 05D7 5204              mov A,[X+4]
 05D9 08                push A
 05DA 7C0000            xcall __divmod_16X16_16
 05DD 38FE              add SP,-2
 05DF 18                pop A
 05E0 5300              mov [__r3],A
 05E2 18                pop A
 05E3 3A00              cmp A,[__r0]
 05E5 B012              jnz L131
 05E7 5100              mov A,[__r3]
 05E9 3A00              cmp A,[__r1]
 05EB B00C              jnz L131
 05ED           X27:
 05ED                   .dbline 624
 05ED           ;                                                                       {
 05ED                   .dbline 625
 05ED           ;                                                                               return 1;
 05ED 62D000            mov REG[0xd0],>__r0
 05F0 550001            mov [__r1],1
 05F3 550000            mov [__r0],0
 05F6 8273              xjmp L37
 05F8           L131:
 05F8                   .dbline 628
 05F8           ;                                                                       }
 05F8           ;                                                                       else
 05F8           ;                                                                       {
 05F8                   .dbline 629
 05F8           ;                                                                               runningTotal += tempByte;
 05F8 62D000            mov REG[0xd0],>__r0
 05FB 5200              mov A,[X+0]
 05FD 0504              add [X+4],A
 05FF 0F0300            adc [X+3],0
 0602                   .dbline 630
 0602           ;                                                                       }
 0602                   .dbline 631
 0602           ;                                                               }
 0602           L129:
 0602                   .dbline 632
 0602           ;                                                       }
 0602           L127:
 0602                   .dbline 617
 0602 62D000            mov REG[0xd0],>_TIMEOUT
 0605 3C0000            cmp [_TIMEOUT],0
 0608 B006              jnz X28
 060A 3C0100            cmp [_TIMEOUT+1],0
 060D AF9F              jz L126
 060F           X28:
 060F                   .dbline 633
 060F           ;                                               }
 060F           L124:
 060F                   .dbline 634
 060F           ;                                       }
 060F           L122:
 060F                   .dbline 635
 060F           ;                               }
 060F           L120:
 060F                   .dbline 604
 060F 62D000            mov REG[0xd0],>_TIMEOUT
 0612 3C0000            cmp [_TIMEOUT],0
 0615 B006              jnz X29
 0617 3C0100            cmp [_TIMEOUT+1],0
 061A AF76              jz L119
 061C           X29:
 061C                   .dbline 636
 061C           ;                       }
 061C 8244              xjmp L114
 061E           L117:
 061E                   .dbline 637
 061E           ;                       else if(tempByte == START_TRANSMIT)     // We have a controller response coming.
 061E 3D00FC            cmp [X+0],-4
 0621 B23F              jnz L114
 0623                   .dbline 638
 0623           ;                       {
 0623 8015              xjmp L136
 0625           L135:
 0625                   .dbline 641
 0625           ;                               // We simply wait for the end transmit indicator.
 0625           ;                               while(!TIMEOUT)
 0625           ;                               {
 0625                   .dbline 642
 0625           ;                                       if(CHILD_2_cReadChar() == END_TRANSMIT)
 0625 10                push X
 0626 7C0000            xcall _CHILD_2_cReadChar
 0629 62D000            mov REG[0xd0],>__r0
 062C 20                pop X
 062D 39FD              cmp A,-3
 062F B009              jnz L138
 0631                   .dbline 643
 0631           ;                                       {
 0631                   .dbline 644
 0631           ;                                               return 1;
 0631 550001            mov [__r1],1
 0634 550000            mov [__r0],0
 0637 8232              xjmp L37
 0639           L138:
 0639                   .dbline 646
 0639           ;                                       }
 0639           ;                               }
 0639           L136:
 0639                   .dbline 640
 0639 62D000            mov REG[0xd0],>_TIMEOUT
 063C 3C0000            cmp [_TIMEOUT],0
 063F B006              jnz X30
 0641 3C0100            cmp [_TIMEOUT+1],0
 0644 AFE0              jz L135
 0646           X30:
 0646                   .dbline 647
 0646           ;                       }
 0646                   .dbline 648
 0646           ;               }
 0646                   .dbline 649
 0646           ;       }
 0646 821A              xjmp L114
 0648           L113:
 0648                   .dbline 650
 0648           ;       else if(STATE == RESPONSE_3)
 0648 62D000            mov REG[0xd0],>_STATE
 064B 3C0000            cmp [_STATE],0
 064E B0D2              jnz L140
 0650 3C0105            cmp [_STATE+1],5
 0653 B0CD              jnz L140
 0655           X31:
 0655                   .dbline 651
 0655           ;       {
 0655                   .dbline 652
 0655           ;               if(tempByte = CHILD_3_cReadChar())
 0655 10                push X
 0656 7C0000            xcall _CHILD_3_cReadChar
 0659 62D000            mov REG[0xd0],>__r0
 065C 20                pop X
 065D 5400              mov [X+0],A
 065F 3900              cmp A,0
 0661 A1FF              jz L141
 0663                   .dbline 653
 0663           ;               {
 0663                   .dbline 654
 0663           ;                       if(tempByte == SERVO_START)             // We have a servo response coming.
 0663 3D00FF            cmp [X+0],-1
 0666 B090              jnz L144
 0668                   .dbline 655
 0668           ;                       {
 0668 807F              xjmp L147
 066A           L146:
 066A                   .dbline 658
 066A           ;                               // While we have not timed out, try to let all of the bytes through.
 066A           ;                               while(!TIMEOUT)
 066A           ;                               {
 066A                   .dbline 660
 066A           ;                                       // Eat the remaining servo start bytes.
 066A           ;                                       if(tempByte = CHILD_3_cReadChar())
 066A 10                push X
 066B 7C0000            xcall _CHILD_3_cReadChar
 066E 62D000            mov REG[0xd0],>__r0
 0671 20                pop X
 0672 5400              mov [X+0],A
 0674 3900              cmp A,0
 0676 A071              jz L149
 0678                   .dbline 661
 0678           ;                                       {
 0678                   .dbline 664
 0678           ;                                               // Once we get past the start bytes, we can start adding the
 0678           ;                                               // bytes to our running total and searching for a checksum.
 0678           ;                                               if(tempByte != SERVO_START)
 0678 3D00FF            cmp [X+0],-1
 067B A06C              jz L151
 067D                   .dbline 665
 067D           ;                                               {
 067D                   .dbline 667
 067D           ;                                                       // Add to the running total.
 067D           ;                                                       runningTotal += tempByte;
 067D 5200              mov A,[X+0]
 067F 0504              add [X+4],A
 0681 0F0300            adc [X+3],0
 0684 8056              xjmp L154
 0686           L153:
 0686                   .dbline 671
 0686           ;                                                       
 0686           ;                                                       // Either find a checksum or time out. Either way we're not stuck.
 0686           ;                                                       while(!TIMEOUT)
 0686           ;                                                       {
 0686                   .dbline 673
 0686           ;                                                               // If a nonzero byte has arrived...
 0686           ;                                                               if(tempByte = CHILD_3_cReadChar())
 0686 10                push X
 0687 7C0000            xcall _CHILD_3_cReadChar
 068A 62D000            mov REG[0xd0],>__r0
 068D 20                pop X
 068E 5400              mov [X+0],A
 0690 3900              cmp A,0
 0692 A048              jz L156
 0694                   .dbline 674
 0694           ;                                                               {
 0694                   .dbline 676
 0694           ;                                                                       // Check to see if it is a checksum.
 0694           ;                                                                       if((runningTotal%256) == (255-tempByte))
 0694 5200              mov A,[X+0]
 0696 5300              mov [__r1],A
 0698 550000            mov [__r0],0
 069B 50FF              mov A,-1
 069D 1200              sub A,[__r1]
 069F 5300              mov [__r1],A
 06A1 5000              mov A,0
 06A3 1A00              sbb A,[__r0]
 06A5 5300              mov [__r0],A
 06A7 5001              mov A,1
 06A9 08                push A
 06AA 5000              mov A,0
 06AC 08                push A
 06AD 5203              mov A,[X+3]
 06AF 08                push A
 06B0 5204              mov A,[X+4]
 06B2 08                push A
 06B3 7C0000            xcall __divmod_16X16_16
 06B6 38FE              add SP,-2
 06B8 18                pop A
 06B9 5300              mov [__r3],A
 06BB 18                pop A
 06BC 3A00              cmp A,[__r0]
 06BE B012              jnz L158
 06C0 5100              mov A,[__r3]
 06C2 3A00              cmp A,[__r1]
 06C4 B00C              jnz L158
 06C6           X32:
 06C6                   .dbline 677
 06C6           ;                                                                       {
 06C6                   .dbline 678
 06C6           ;                                                                               return 1;
 06C6 62D000            mov REG[0xd0],>__r0
 06C9 550001            mov [__r1],1
 06CC 550000            mov [__r0],0
 06CF 819A              xjmp L37
 06D1           L158:
 06D1                   .dbline 681
 06D1           ;                                                                       }
 06D1           ;                                                                       else
 06D1           ;                                                                       {
 06D1                   .dbline 682
 06D1           ;                                                                               runningTotal += tempByte;
 06D1 62D000            mov REG[0xd0],>__r0
 06D4 5200              mov A,[X+0]
 06D6 0504              add [X+4],A
 06D8 0F0300            adc [X+3],0
 06DB                   .dbline 683
 06DB           ;                                                                       }
 06DB                   .dbline 684
 06DB           ;                                                               }
 06DB           L156:
 06DB                   .dbline 685
 06DB           ;                                                       }
 06DB           L154:
 06DB                   .dbline 670
 06DB 62D000            mov REG[0xd0],>_TIMEOUT
 06DE 3C0000            cmp [_TIMEOUT],0
 06E1 B006              jnz X33
 06E3 3C0100            cmp [_TIMEOUT+1],0
 06E6 AF9F              jz L153
 06E8           X33:
 06E8                   .dbline 686
 06E8           ;                                               }
 06E8           L151:
 06E8                   .dbline 687
 06E8           ;                                       }
 06E8           L149:
 06E8                   .dbline 688
 06E8           ;                               }
 06E8           L147:
 06E8                   .dbline 657
 06E8 62D000            mov REG[0xd0],>_TIMEOUT
 06EB 3C0000            cmp [_TIMEOUT],0
 06EE B006              jnz X34
 06F0 3C0100            cmp [_TIMEOUT+1],0
 06F3 AF76              jz L146
 06F5           X34:
 06F5                   .dbline 689
 06F5           ;                       }
 06F5 816B              xjmp L141
 06F7           L144:
 06F7                   .dbline 690
 06F7           ;                       else if(tempByte == START_TRANSMIT)     // We have a controller response coming.
 06F7 3D00FC            cmp [X+0],-4
 06FA B166              jnz L141
 06FC                   .dbline 691
 06FC           ;                       {
 06FC 8015              xjmp L163
 06FE           L162:
 06FE                   .dbline 694
 06FE           ;                               // We simply wait for the end transmit indicator.
 06FE           ;                               while(!TIMEOUT)
 06FE           ;                               {
 06FE                   .dbline 695
 06FE           ;                                       if(CHILD_3_cReadChar() == END_TRANSMIT)
 06FE 10                push X
 06FF 7C0000            xcall _CHILD_3_cReadChar
 0702 62D000            mov REG[0xd0],>__r0
 0705 20                pop X
 0706 39FD              cmp A,-3
 0708 B009              jnz L165
 070A                   .dbline 696
 070A           ;                                       {
 070A                   .dbline 697
 070A           ;                                               return 1;
 070A 550001            mov [__r1],1
 070D 550000            mov [__r0],0
 0710 8159              xjmp L37
 0712           L165:
 0712                   .dbline 699
 0712           ;                                       }
 0712           ;                               }
 0712           L163:
 0712                   .dbline 693
 0712 62D000            mov REG[0xd0],>_TIMEOUT
 0715 3C0000            cmp [_TIMEOUT],0
 0718 B006              jnz X35
 071A 3C0100            cmp [_TIMEOUT+1],0
 071D AFE0              jz L162
 071F           X35:
 071F                   .dbline 700
 071F           ;                       }
 071F                   .dbline 701
 071F           ;               }
 071F                   .dbline 702
 071F           ;       }
 071F 8141              xjmp L141
 0721           L140:
 0721                   .dbline 703
 0721           ;       else if(STATE == RESPONSE_4)
 0721 62D000            mov REG[0xd0],>_STATE
 0724 3C0000            cmp [_STATE],0
 0727 B0D2              jnz L167
 0729 3C0106            cmp [_STATE+1],6
 072C B0CD              jnz L167
 072E           X36:
 072E                   .dbline 704
 072E           ;       {
 072E                   .dbline 705
 072E           ;               if(tempByte = CHILD_4_cReadChar())
 072E 10                push X
 072F 7C0000            xcall _CHILD_4_cReadChar
 0732 62D000            mov REG[0xd0],>__r0
 0735 20                pop X
 0736 5400              mov [X+0],A
 0738 3900              cmp A,0
 073A A126              jz L168
 073C                   .dbline 706
 073C           ;               {
 073C                   .dbline 707
 073C           ;                       if(tempByte == SERVO_START)             // We have a servo response coming.
 073C 3D00FF            cmp [X+0],-1
 073F B090              jnz L171
 0741                   .dbline 708
 0741           ;                       {
 0741 807F              xjmp L174
 0743           L173:
 0743                   .dbline 711
 0743           ;                               // While we have not timed out, try to let all of the bytes through.
 0743           ;                               while(!TIMEOUT)
 0743           ;                               {
 0743                   .dbline 713
 0743           ;                                       // Eat the remaining servo start bytes.
 0743           ;                                       if(tempByte = CHILD_4_cReadChar())
 0743 10                push X
 0744 7C0000            xcall _CHILD_4_cReadChar
 0747 62D000            mov REG[0xd0],>__r0
 074A 20                pop X
 074B 5400              mov [X+0],A
 074D 3900              cmp A,0
 074F A071              jz L176
 0751                   .dbline 714
 0751           ;                                       {
 0751                   .dbline 717
 0751           ;                                               // Once we get past the start bytes, we can start adding the
 0751           ;                                               // bytes to our running total and searching for a checksum.
 0751           ;                                               if(tempByte != SERVO_START)
 0751 3D00FF            cmp [X+0],-1
 0754 A06C              jz L178
 0756                   .dbline 718
 0756           ;                                               {
 0756                   .dbline 720
 0756           ;                                                       // Add to the running total.
 0756           ;                                                       runningTotal += tempByte;
 0756 5200              mov A,[X+0]
 0758 0504              add [X+4],A
 075A 0F0300            adc [X+3],0
 075D 8056              xjmp L181
 075F           L180:
 075F                   .dbline 724
 075F           ;                                                       
 075F           ;                                                       // Either find a checksum or time out. Either way we're not stuck.
 075F           ;                                                       while(!TIMEOUT)
 075F           ;                                                       {
 075F                   .dbline 726
 075F           ;                                                               // If a nonzero byte has arrived...
 075F           ;                                                               if(tempByte = CHILD_4_cReadChar())
 075F 10                push X
 0760 7C0000            xcall _CHILD_4_cReadChar
 0763 62D000            mov REG[0xd0],>__r0
 0766 20                pop X
 0767 5400              mov [X+0],A
 0769 3900              cmp A,0
 076B A048              jz L183
 076D                   .dbline 727
 076D           ;                                                               {
 076D                   .dbline 729
 076D           ;                                                                       // Check to see if it is a checksum.
 076D           ;                                                                       if((runningTotal%256) == (255-tempByte))
 076D 5200              mov A,[X+0]
 076F 5300              mov [__r1],A
 0771 550000            mov [__r0],0
 0774 50FF              mov A,-1
 0776 1200              sub A,[__r1]
 0778 5300              mov [__r1],A
 077A 5000              mov A,0
 077C 1A00              sbb A,[__r0]
 077E 5300              mov [__r0],A
 0780 5001              mov A,1
 0782 08                push A
 0783 5000              mov A,0
 0785 08                push A
 0786 5203              mov A,[X+3]
 0788 08                push A
 0789 5204              mov A,[X+4]
 078B 08                push A
 078C 7C0000            xcall __divmod_16X16_16
 078F 38FE              add SP,-2
 0791 18                pop A
 0792 5300              mov [__r3],A
 0794 18                pop A
 0795 3A00              cmp A,[__r0]
 0797 B012              jnz L185
 0799 5100              mov A,[__r3]
 079B 3A00              cmp A,[__r1]
 079D B00C              jnz L185
 079F           X37:
 079F                   .dbline 730
 079F           ;                                                                       {
 079F                   .dbline 731
 079F           ;                                                                               return 1;
 079F 62D000            mov REG[0xd0],>__r0
 07A2 550001            mov [__r1],1
 07A5 550000            mov [__r0],0
 07A8 80C1              xjmp L37
 07AA           L185:
 07AA                   .dbline 734
 07AA           ;                                                                       }
 07AA           ;                                                                       else
 07AA           ;                                                                       {
 07AA                   .dbline 735
 07AA           ;                                                                               runningTotal += tempByte;
 07AA 62D000            mov REG[0xd0],>__r0
 07AD 5200              mov A,[X+0]
 07AF 0504              add [X+4],A
 07B1 0F0300            adc [X+3],0
 07B4                   .dbline 736
 07B4           ;                                                                       }
 07B4                   .dbline 737
 07B4           ;                                                               }
 07B4           L183:
 07B4                   .dbline 738
 07B4           ;                                                       }
 07B4           L181:
 07B4                   .dbline 723
 07B4 62D000            mov REG[0xd0],>_TIMEOUT
 07B7 3C0000            cmp [_TIMEOUT],0
 07BA B006              jnz X38
 07BC 3C0100            cmp [_TIMEOUT+1],0
 07BF AF9F              jz L180
 07C1           X38:
 07C1                   .dbline 739
 07C1           ;                                               }
 07C1           L178:
 07C1                   .dbline 740
 07C1           ;                                       }
 07C1           L176:
 07C1                   .dbline 741
 07C1           ;                               }
 07C1           L174:
 07C1                   .dbline 710
 07C1 62D000            mov REG[0xd0],>_TIMEOUT
 07C4 3C0000            cmp [_TIMEOUT],0
 07C7 B006              jnz X39
 07C9 3C0100            cmp [_TIMEOUT+1],0
 07CC AF76              jz L173
 07CE           X39:
 07CE                   .dbline 742
 07CE           ;                       }
 07CE 8092              xjmp L168
 07D0           L171:
 07D0                   .dbline 743
 07D0           ;                       else if(tempByte == START_TRANSMIT)     // We have a controller response coming.
 07D0 3D00FC            cmp [X+0],-4
 07D3 B08D              jnz L168
 07D5                   .dbline 744
 07D5           ;                       {
 07D5 8015              xjmp L190
 07D7           L189:
 07D7                   .dbline 747
 07D7           ;                               // We simply wait for the end transmit indicator.
 07D7           ;                               while(!TIMEOUT)
 07D7           ;                               {
 07D7                   .dbline 748
 07D7           ;                                       if(CHILD_4_cReadChar() == END_TRANSMIT)
 07D7 10                push X
 07D8 7C0000            xcall _CHILD_4_cReadChar
 07DB 62D000            mov REG[0xd0],>__r0
 07DE 20                pop X
 07DF 39FD              cmp A,-3
 07E1 B009              jnz L192
 07E3                   .dbline 749
 07E3           ;                                       {
 07E3                   .dbline 750
 07E3           ;                                               return 1;
 07E3 550001            mov [__r1],1
 07E6 550000            mov [__r0],0
 07E9 8080              xjmp L37
 07EB           L192:
 07EB                   .dbline 752
 07EB           ;                                       }
 07EB           ;                               }
 07EB           L190:
 07EB                   .dbline 746
 07EB 62D000            mov REG[0xd0],>_TIMEOUT
 07EE 3C0000            cmp [_TIMEOUT],0
 07F1 B006              jnz X40
 07F3 3C0100            cmp [_TIMEOUT+1],0
 07F6 AFE0              jz L189
 07F8           X40:
 07F8                   .dbline 753
 07F8           ;                       }
 07F8                   .dbline 754
 07F8           ;               }
 07F8                   .dbline 755
 07F8           ;       }
 07F8 8068              xjmp L168
 07FA           L167:
 07FA                   .dbline 756
 07FA           ;       else if(STATE == INITIALIZE)
 07FA 62D000            mov REG[0xd0],>_STATE
 07FD 3C0000            cmp [_STATE],0
 0800 B060              jnz L194
 0802 3C0108            cmp [_STATE+1],8
 0805 B05B              jnz L194
 0807           X41:
 0807                   .dbline 757
 0807           ;       {
 0807                   .dbline 758
 0807           ;               if(INIT_RX_cReadChar() == SERVO_START)
 0807 10                push X
 0808 7C0000            xcall _INIT_RX_cReadChar
 080B 62D000            mov REG[0xd0],>__r0
 080E 20                pop X
 080F 39FF              cmp A,-1
 0811 B04F              jnz L196
 0813                   .dbline 759
 0813           ;               {
 0813 8040              xjmp L199
 0815           L198:
 0815                   .dbline 761
 0815           ;                       while(!TIMEOUT)
 0815           ;                       {
 0815                   .dbline 763
 0815           ;                               // We officially have a transmission.
 0815           ;                               if(INIT_RX_cReadChar() == SERVO_START)
 0815 10                push X
 0816 7C0000            xcall _INIT_RX_cReadChar
 0819 62D000            mov REG[0xd0],>__r0
 081C 20                pop X
 081D 39FF              cmp A,-1
 081F B034              jnz L201
 0821                   .dbline 764
 0821           ;                               {
 0821                   .dbline 767
 0821           ;                                       // If we definitely have a transmission starting, grab all bytes from the rx buffer
 0821           ;                                       // and store them in the proper variables for actions to be taken later.
 0821           ;                                       COMMAND_SOURCE = INIT_RX_cGetChar();
 0821 10                push X
 0822 7C0000            xcall _INIT_RX_cGetChar
 0825 20                pop X
 0826 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0829 5300              mov [_COMMAND_SOURCE],A
 082B                   .dbline 768
 082B           ;                                       COMMAND_LENGTH = INIT_RX_cGetChar();
 082B 10                push X
 082C 7C0000            xcall _INIT_RX_cGetChar
 082F 20                pop X
 0830 62D000            mov REG[0xd0],>_COMMAND_LENGTH
 0833 5300              mov [_COMMAND_LENGTH],A
 0835                   .dbline 769
 0835           ;                                       COMMAND_ERROR = INIT_RX_cGetChar();
 0835 10                push X
 0836 7C0000            xcall _INIT_RX_cGetChar
 0839 20                pop X
 083A 62D000            mov REG[0xd0],>_COMMAND_ERROR
 083D 5300              mov [_COMMAND_ERROR],A
 083F                   .dbline 770
 083F           ;                                       COMMAND_PARAM = INIT_RX_cGetChar();
 083F 10                push X
 0840 7C0000            xcall _INIT_RX_cGetChar
 0843 20                pop X
 0844 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0847 5300              mov [_COMMAND_PARAM],A
 0849                   .dbline 772
 0849           ;                                       
 0849           ;                                       return 1;
 0849 62D000            mov REG[0xd0],>__r0
 084C 550001            mov [__r1],1
 084F 550000            mov [__r0],0
 0852 8017              xjmp L37
 0854           L201:
 0854                   .dbline 774
 0854           ;                               }
 0854           ;                       }
 0854           L199:
 0854                   .dbline 760
 0854 62D000            mov REG[0xd0],>_TIMEOUT
 0857 3C0000            cmp [_TIMEOUT],0
 085A B006              jnz X42
 085C 3C0100            cmp [_TIMEOUT+1],0
 085F AFB5              jz L198
 0861           X42:
 0861                   .dbline 775
 0861           ;               }
 0861           L196:
 0861                   .dbline 776
 0861           ;       }
 0861           L194:
 0861           L168:
 0861           L141:
 0861           L114:
 0861           L87:
 0861           L57:
 0861           L39:
 0861                   .dbline 778
 0861           ;       
 0861           ;       return 0;
 0861 62D000            mov REG[0xd0],>__r0
 0864 550000            mov [__r1],0
 0867 550000            mov [__r0],0
 086A                   .dbline -2
 086A           L37:
 086A 38FB              add SP,-5
 086C 20                pop X
 086D                   .dbline 0 ; func end
 086D 7F                ret
 086E                   .dbsym l runningTotal 3 I
 086E                   .dbsym l i 1 I
 086E                   .dbsym l tempByte 0 c
 086E                   .dbend
 086E                   .dbfunc e takeAction _takeAction fV
 086E           ;              j -> X+7
 086E           ;              i -> X+5
 086E           ;   runningTotal -> X+3
 086E           ;       tempByte -> X+2
 086E           ;              i -> X+0
 086E           _takeAction::
 086E                   .dbline -1
 086E 10                push X
 086F 4F                mov X,SP
 0870 3809              add SP,9
 0872                   .dbline 784
 0872           ; }
 0872           ; 
 0872           ; // This function interprets what has been read by the command ready function
 0872           ; // and performs the appropriate action.
 0872           ; void takeAction(void)
 0872           ; {
 0872                   .dbline 785
 0872           ;       int i = 0;                                                      // An index variable for looping.
 0872 560100            mov [X+1],0
 0875 560000            mov [X+0],0
 0878                   .dbline 786
 0878           ;       char tempByte = 0;                                      // A temporary byte storage variable.
 0878 560200            mov [X+2],0
 087B                   .dbline 787
 087B           ;       int runningTotal = 0;                           // A running total of bytes to check against a checksum.
 087B 560400            mov [X+4],0
 087E 560300            mov [X+3],0
 0881                   .dbline 789
 0881           ;       
 0881           ;       if(COMMAND_TYPE == CLEAR)                       // The master wants to clear the arm.
 0881 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0884 3C00CC            cmp [_COMMAND_TYPE],-52
 0887 B018              jnz L204
 0889                   .dbline 790
 0889           ;       {
 0889                   .dbline 791
 0889           ;               ID = DEFAULT_ID;
 0889 62D000            mov REG[0xd0],>_ID
 088C 5500FB            mov [_ID],-5
 088F                   .dbline 792
 088F           ;               CONFIGURED = 0;
 088F 62D000            mov REG[0xd0],>_CONFIGURED
 0892 550100            mov [_CONFIGURED+1],0
 0895 550000            mov [_CONFIGURED],0
 0898                   .dbline 793
 0898           ;               CHILD = 0;
 0898 62D000            mov REG[0xd0],>_CHILD
 089B 550000            mov [_CHILD],0
 089E                   .dbline 794
 089E           ;       }
 089E 819E              xjmp L205
 08A0           L204:
 08A0                   .dbline 795
 08A0           ;       else if(COMMAND_TYPE == HELLO_BYTE)             // The master is probing for new modules.
 08A0 62D000            mov REG[0xd0],>_COMMAND_TYPE
 08A3 3C00C8            cmp [_COMMAND_TYPE],-56
 08A6 B03B              jnz L206
 08A8                   .dbline 796
 08A8           ;       {
 08A8                   .dbline 797
 08A8           ;               if(!CONFIGURED)
 08A8 62D000            mov REG[0xd0],>_CONFIGURED
 08AB 3C0000            cmp [_CONFIGURED],0
 08AE B00B              jnz L208
 08B0 3C0100            cmp [_CONFIGURED+1],0
 08B3 B006              jnz L208
 08B5           X43:
 08B5                   .dbline 798
 08B5           ;               {
 08B5                   .dbline 800
 08B5           ;                       // Announce this module's presence if not configured.
 08B5           ;                       sayHello();
 08B5 7C0050            xcall _sayHello
 08B8                   .dbline 801
 08B8           ;               }
 08B8 8184              xjmp L207
 08BA           L208:
 08BA                   .dbline 802
 08BA           ;               else if(!CHILD)
 08BA 62D000            mov REG[0xd0],>_CHILD
 08BD 3C0000            cmp [_CHILD],0
 08C0 B015              jnz L210
 08C2                   .dbline 803
 08C2           ;               {
 08C2                   .dbline 805
 08C2           ;                       // Listen for children if we have none.
 08C2           ;                       if(childListen())
 08C2 9382              xcall _childListen
 08C4 62D000            mov REG[0xd0],>__r0
 08C7 3C0000            cmp [__r0],0
 08CA B006              jnz X44
 08CC 3C0000            cmp [__r1],0
 08CF A16D              jz L207
 08D1           X44:
 08D1                   .dbline 806
 08D1           ;                       {
 08D1                   .dbline 808
 08D1           ;                               // If a child was heard saying hello, forward the command with the port number added.
 08D1           ;                               sayHello();
 08D1 7C0050            xcall _sayHello
 08D4                   .dbline 809
 08D4           ;                       }
 08D4                   .dbline 810
 08D4           ;               }
 08D4 8168              xjmp L207
 08D6           L210:
 08D6                   .dbline 811
 08D6           ;               else if(CHILD)
 08D6 62D000            mov REG[0xd0],>_CHILD
 08D9 3C0000            cmp [_CHILD],0
 08DC A160              jz L207
 08DE                   .dbline 812
 08DE           ;               {
 08DE                   .dbline 814
 08DE           ;                       // If you have a child established, listen to that child.
 08DE           ;                       childResponse();
 08DE 93BE              xcall _childResponse
 08E0                   .dbline 815
 08E0           ;               }
 08E0                   .dbline 816
 08E0           ;       }
 08E0 815C              xjmp L207
 08E2           L206:
 08E2                   .dbline 817
 08E2           ;       else if(COMMAND_TYPE == PING)           // The master is trying to find a module that is configured.
 08E2 62D000            mov REG[0xd0],>_COMMAND_TYPE
 08E5 3C00CB            cmp [_COMMAND_TYPE],-53
 08E8 B021              jnz L216
 08EA                   .dbline 818
 08EA           ;       {
 08EA                   .dbline 820
 08EA           ;               // If this is to me, act accordingly.
 08EA           ;               if(COMMAND_DESTINATION == ID)
 08EA 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 08ED 5100              mov A,[_COMMAND_DESTINATION]
 08EF 62D000            mov REG[0xd0],>_ID
 08F2 3A00              cmp A,[_ID]
 08F4 B005              jnz L218
 08F6                   .dbline 821
 08F6           ;               {
 08F6                   .dbline 823
 08F6           ;                       // Ping back to the master.
 08F6           ;                       pingResponse();
 08F6 9149              xcall _pingResponse
 08F8                   .dbline 824
 08F8           ;               }
 08F8 8144              xjmp L217
 08FA           L218:
 08FA                   .dbline 825
 08FA           ;               else if(COMMAND_DESTINATION > ID)
 08FA 62D000            mov REG[0xd0],>_ID
 08FD 5100              mov A,[_ID]
 08FF 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0902 3A00              cmp A,[_COMMAND_DESTINATION]
 0904 D138              jnc L217
 0906           X45:
 0906                   .dbline 826
 0906           ;               {
 0906                   .dbline 828
 0906           ;                       // If you have a child established, listen to that child.
 0906           ;                       childResponse();
 0906 9396              xcall _childResponse
 0908                   .dbline 829
 0908           ;               }
 0908                   .dbline 830
 0908           ;       }
 0908 8134              xjmp L217
 090A           L216:
 090A                   .dbline 831
 090A           ;       else if(COMMAND_TYPE == ID_ASSIGNMENT)  // The master is assigning an ID to someone.
 090A 62D000            mov REG[0xd0],>_COMMAND_TYPE
 090D 3C00C9            cmp [_COMMAND_TYPE],-55
 0910 B111              jnz L222
 0912                   .dbline 832
 0912           ;       {
 0912                   .dbline 834
 0912           ;               // If this is meant for me, change my ID.
 0912           ;               if(COMMAND_DESTINATION == ID)
 0912 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0915 5100              mov A,[_COMMAND_DESTINATION]
 0917 62D000            mov REG[0xd0],>_ID
 091A 3A00              cmp A,[_ID]
 091C B0F5              jnz L224
 091E                   .dbline 835
 091E           ;               {
 091E                   .dbline 836
 091E           ;                       if((COMMAND_PARAM > MASTER_ID) && (COMMAND_PARAM < DEFAULT_ID))
 091E 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0921 5000              mov A,0
 0923 3A00              cmp A,[_COMMAND_PARAM]
 0925 D117              jnc L223
 0927           X46:
 0927 62D000            mov REG[0xd0],>_COMMAND_PARAM
 092A 3C00FB            cmp [_COMMAND_PARAM],-5
 092D D10F              jnc L223
 092F           X47:
 092F                   .dbline 837
 092F           ;                       {
 092F                   .dbline 839
 092F           ;                               // Assign this module the ID that has been passed by the master.
 092F           ;                               ID = COMMAND_PARAM;
 092F 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0932 5100              mov A,[_COMMAND_PARAM]
 0934 62D000            mov REG[0xd0],>_ID
 0937 5300              mov [_ID],A
 0939                   .dbline 842
 0939           ;                               
 0939           ;                               // This module is now configured.
 0939           ;                               CONFIGURED = 1;
 0939 62D000            mov REG[0xd0],>_CONFIGURED
 093C 550101            mov [_CONFIGURED+1],1
 093F 550000            mov [_CONFIGURED],0
 0942                   .dbline 845
 0942           ;                               
 0942           ;                               // If the servo ID doesn't match what we want, change it to match.
 0942           ;                               if(ID != SERVO_ID)
 0942 62D000            mov REG[0xd0],>_ID
 0945 5100              mov A,[_ID]
 0947 62D000            mov REG[0xd0],>_SERVO_ID
 094A 3A00              cmp A,[_SERVO_ID]
 094C A0A8              jz L228
 094E                   .dbline 846
 094E           ;                               {
 094E                   .dbline 853
 094E           ;                                       // These are our index variables for communication attempt timeouts.
 094E           ;                                       int i;
 094E           ;                                       int j;
 094E           ;                                       
 094E           ;                                       //while(ID != SERVO_ID)
 094E           ;                                       
 094E           ;                                       for(j = 0; j < SERVO_COMM_LOOPS; j++)
 094E 560800            mov [X+8],0
 0951 560700            mov [X+7],0
 0954           L230:
 0954                   .dbline 854
 0954           ;                                       {       
 0954                   .dbline 856
 0954           ;                                               // Send a request to change the servo ID to match the controller ID.
 0954           ;                                               servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, ID_ADDRESS, ID);
 0954 62D000            mov REG[0xd0],>_ID
 0957 5100              mov A,[_ID]
 0959 08                push A
 095A 5003              mov A,3
 095C 08                push A
 095D 08                push A
 095E 5004              mov A,4
 0960 08                push A
 0961 62D000            mov REG[0xd0],>_SERVO_ID
 0964 5100              mov A,[_SERVO_ID]
 0966 08                push A
 0967 96AE              xcall _servoInstruction
 0969 38FB              add SP,-5
 096B                   .dbline 859
 096B           ;                                       
 096B           ;                                               // Try to read the servo's ID several times.
 096B           ;                                               for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 096B 560600            mov [X+6],0
 096E 560500            mov [X+5],0
 0971           L234:
 0971                   .dbline 860
 0971           ;                                               {
 0971                   .dbline 862
 0971           ;                                                       // Send a request for the servo ID, which is presumably now equal to ID.
 0971           ;                                                       servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
 0971 5000              mov A,0
 0973 08                push A
 0974 08                push A
 0975 5001              mov A,1
 0977 08                push A
 0978 5002              mov A,2
 097A 08                push A
 097B 50FE              mov A,-2
 097D 08                push A
 097E 9697              xcall _servoInstruction
 0980 38FB              add SP,-5
 0982 8043              xjmp L239
 0984           L238:
 0984                   .dbline 866
 0984           ;                                                       
 0984           ;                                                       // Wait for either a timeout or an indication that we want to exit the loop.
 0984           ;                                                       while(!TIMEOUT)
 0984           ;                                                       {
 0984                   .dbline 868
 0984           ;                                                               // If we have a command to interpret, read it.
 0984           ;                                                               if(commandReady())
 0984 9939              xcall _commandReady
 0986 62D000            mov REG[0xd0],>__r0
 0989 3C0000            cmp [__r0],0
 098C B006              jnz X48
 098E 3C0000            cmp [__r1],0
 0991 A034              jz L241
 0993           X48:
 0993                   .dbline 869
 0993           ;                                                               {
 0993                   .dbline 870
 0993           ;                                                                       if(!COMMAND_ERROR)
 0993 62D000            mov REG[0xd0],>_COMMAND_ERROR
 0996 3C0000            cmp [_COMMAND_ERROR],0
 0999 B02C              jnz L243
 099B                   .dbline 871
 099B           ;                                                                       {
 099B                   .dbline 873
 099B           ;                                                                               // If we have a valid servo ID, exit the loop.
 099B           ;                                                                               if(COMMAND_SOURCE == ID)
 099B 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 099E 5100              mov A,[_COMMAND_SOURCE]
 09A0 62D000            mov REG[0xd0],>_ID
 09A3 3A00              cmp A,[_ID]
 09A5 B020              jnz L245
 09A7                   .dbline 874
 09A7           ;                                                                               {
 09A7                   .dbline 876
 09A7           ;                                                                                       // Set the timeout flag to exit the while loop.
 09A7           ;                                                                                       TIMEOUT = 1;
 09A7 62D000            mov REG[0xd0],>_TIMEOUT
 09AA 550101            mov [_TIMEOUT+1],1
 09AD 550000            mov [_TIMEOUT],0
 09B0                   .dbline 878
 09B0           ;                                                                                       // Set i such that the for loop is exited.
 09B0           ;                                                                                       i = SERVO_COMM_ATTEMPTS;
 09B0 56060A            mov [X+6],10
 09B3 560500            mov [X+5],0
 09B6                   .dbline 880
 09B6           ;                                                                                       // Set j such that we exit the outer loop as well.
 09B6           ;                                                                                       j = SERVO_COMM_LOOPS;
 09B6 560803            mov [X+8],3
 09B9 560700            mov [X+7],0
 09BC                   .dbline 882
 09BC           ;                                                                                       // Store the ID value.
 09BC           ;                                                                                       SERVO_ID = ID;
 09BC 62D000            mov REG[0xd0],>_ID
 09BF 5100              mov A,[_ID]
 09C1 62D000            mov REG[0xd0],>_SERVO_ID
 09C4 5300              mov [_SERVO_ID],A
 09C6                   .dbline 883
 09C6           ;                                                                               }
 09C6           L245:
 09C6                   .dbline 884
 09C6           ;                                                                       }
 09C6           L243:
 09C6                   .dbline 885
 09C6           ;                                                               }
 09C6           L241:
 09C6                   .dbline 886
 09C6           ;                                                       }
 09C6           L239:
 09C6                   .dbline 865
 09C6 62D000            mov REG[0xd0],>_TIMEOUT
 09C9 3C0000            cmp [_TIMEOUT],0
 09CC B006              jnz X49
 09CE 3C0100            cmp [_TIMEOUT+1],0
 09D1 AFB2              jz L238
 09D3           X49:
 09D3                   .dbline 887
 09D3           ;                                               }
 09D3           L235:
 09D3                   .dbline 859
 09D3 7706              inc [X+6]
 09D5 0F0500            adc [X+5],0
 09D8                   .dbline 859
 09D8 5206              mov A,[X+6]
 09DA 110A              sub A,10
 09DC 5205              mov A,[X+5]
 09DE 3180              xor A,-128
 09E0 1980              sbb A,(0 ^ 0x80)
 09E2 CF8E              jc L234
 09E4           X50:
 09E4                   .dbline 888
 09E4           ;                                       }       
 09E4           L231:
 09E4                   .dbline 853
 09E4 7708              inc [X+8]
 09E6 0F0700            adc [X+7],0
 09E9                   .dbline 853
 09E9 5208              mov A,[X+8]
 09EB 1103              sub A,3
 09ED 5207              mov A,[X+7]
 09EF 3180              xor A,-128
 09F1 1980              sbb A,(0 ^ 0x80)
 09F3 CF60              jc L230
 09F5           X51:
 09F5                   .dbline 889
 09F5           ;                               }
 09F5           L228:
 09F5                   .dbline 891
 09F5           ;                               
 09F5           ;                               if(ID != SERVO_ID)
 09F5 62D000            mov REG[0xd0],>_ID
 09F8 5100              mov A,[_ID]
 09FA 62D000            mov REG[0xd0],>_SERVO_ID
 09FD 3A00              cmp A,[_SERVO_ID]
 09FF A00E              jz L247
 0A01                   .dbline 892
 0A01           ;                               {
 0A01                   .dbline 894
 0A01           ;                                       // Toggle back to normal wait mode.
 0A01           ;                                       configToggle(WAIT);
 0A01 5000              mov A,0
 0A03 08                push A
 0A04 5001              mov A,1
 0A06 08                push A
 0A07 7C00B5            xcall _configToggle
 0A0A 38FE              add SP,-2
 0A0C                   .dbline 895
 0A0C           ;                               }
 0A0C 8030              xjmp L223
 0A0E           L247:
 0A0E                   .dbline 897
 0A0E           ;                               else
 0A0E           ;                               {
 0A0E                   .dbline 899
 0A0E           ;                                       // Let the master node know that you got the ID assignment.
 0A0E           ;                                       assignedID();
 0A0E 9197              xcall _assignedID
 0A10                   .dbline 900
 0A10           ;                               }
 0A10                   .dbline 901
 0A10           ;                       }
 0A10                   .dbline 902
 0A10           ;               }
 0A10 802C              xjmp L223
 0A12           L224:
 0A12                   .dbline 903
 0A12           ;               else if(COMMAND_DESTINATION > ID)
 0A12 62D000            mov REG[0xd0],>_ID
 0A15 5100              mov A,[_ID]
 0A17 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0A1A 3A00              cmp A,[_COMMAND_DESTINATION]
 0A1C D020              jnc L223
 0A1E           X52:
 0A1E                   .dbline 904
 0A1E           ;               {
 0A1E                   .dbline 906
 0A1E           ;                       // Switch to listen to your child.
 0A1E           ;                       childResponse();
 0A1E 927E              xcall _childResponse
 0A20                   .dbline 907
 0A20           ;               }
 0A20                   .dbline 908
 0A20           ;       }
 0A20 801C              xjmp L223
 0A22           L222:
 0A22                   .dbline 909
 0A22           ;       else if((COMMAND_TYPE == PING_SERVO) || (COMMAND_TYPE == READ_SERVO))
 0A22 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0A25 3C0001            cmp [_COMMAND_TYPE],1
 0A28 A006              jz L253
 0A2A 3C0002            cmp [_COMMAND_TYPE],2
 0A2D B00F              jnz L251
 0A2F           L253:
 0A2F                   .dbline 910
 0A2F           ;       {
 0A2F                   .dbline 911
 0A2F           ;               if(COMMAND_DESTINATION > ID)
 0A2F 62D000            mov REG[0xd0],>_ID
 0A32 5100              mov A,[_ID]
 0A34 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0A37 3A00              cmp A,[_COMMAND_DESTINATION]
 0A39 D003              jnc L254
 0A3B           X53:
 0A3B                   .dbline 912
 0A3B           ;               {
 0A3B                   .dbline 914
 0A3B           ;                       // Allow the child response through.
 0A3B           ;                       childResponse();
 0A3B 9261              xcall _childResponse
 0A3D                   .dbline 915
 0A3D           ;               }
 0A3D           L254:
 0A3D                   .dbline 916
 0A3D           ;       }
 0A3D           L251:
 0A3D           L223:
 0A3D           L217:
 0A3D           L207:
 0A3D           L205:
 0A3D                   .dbline -2
 0A3D           L203:
 0A3D 38F7              add SP,-9
 0A3F 20                pop X
 0A40                   .dbline 0 ; func end
 0A40 7F                ret
 0A41                   .dbsym l j 7 I
 0A41                   .dbsym l i 5 I
 0A41                   .dbsym l runningTotal 3 I
 0A41                   .dbsym l tempByte 2 c
 0A41                   .dbsym l i 0 I
 0A41                   .dbend
 0A41                   .dbfunc e pingResponse _pingResponse fV
 0A41           _pingResponse::
 0A41                   .dbline -1
 0A41                   .dbline 921
 0A41           ; }
 0A41           ; 
 0A41           ; // This function sends out a ping response for everyone to hear.
 0A41           ; void pingResponse(void)
 0A41           ; {
 0A41                   .dbline 922
 0A41           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 0A41 5000              mov A,0
 0A43 08                push A
 0A44 5002              mov A,2
 0A46 08                push A
 0A47 7C00B5            xcall _configToggle
 0A4A 38FE              add SP,-2
 0A4C                   .dbline 925
 0A4C           ;       
 0A4C           ;       // Transmit a ping to everyone.
 0A4C           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 0A4C 10                push X
 0A4D 50FC              mov A,-4
 0A4F 7C0000            xcall _TX_014_PutChar
 0A52 20                pop X
 0A53                   .dbline 926
 0A53           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 0A53 10                push X
 0A54 50FC              mov A,-4
 0A56 7C0000            xcall _TX_23_PutChar
 0A59 20                pop X
 0A5A                   .dbline 927
 0A5A           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 0A5A 10                push X
 0A5B 50FC              mov A,-4
 0A5D 7C0000            xcall _TX_014_PutChar
 0A60 20                pop X
 0A61                   .dbline 928
 0A61           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 0A61 10                push X
 0A62 50FC              mov A,-4
 0A64 7C0000            xcall _TX_23_PutChar
 0A67 20                pop X
 0A68                   .dbline 929
 0A68           ;       TX_014_PutChar(ID);                             // My ID
 0A68 10                push X
 0A69 62D000            mov REG[0xd0],>_ID
 0A6C 5100              mov A,[_ID]
 0A6E 7C0000            xcall _TX_014_PutChar
 0A71 20                pop X
 0A72                   .dbline 930
 0A72           ;       TX_23_PutChar(ID);                              // My ID
 0A72 10                push X
 0A73 62D000            mov REG[0xd0],>_ID
 0A76 5100              mov A,[_ID]
 0A78 7C0000            xcall _TX_23_PutChar
 0A7B 20                pop X
 0A7C                   .dbline 931
 0A7C           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 0A7C 10                push X
 0A7D 5000              mov A,0
 0A7F 7C0000            xcall _TX_014_PutChar
 0A82 20                pop X
 0A83                   .dbline 932
 0A83           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 0A83 10                push X
 0A84 5000              mov A,0
 0A86 7C0000            xcall _TX_23_PutChar
 0A89 20                pop X
 0A8A                   .dbline 933
 0A8A           ;       TX_014_PutChar(PING);                   // This is a ping response
 0A8A 10                push X
 0A8B 50CB              mov A,-53
 0A8D 7C0000            xcall _TX_014_PutChar
 0A90 20                pop X
 0A91                   .dbline 934
 0A91           ;       TX_23_PutChar(PING);                    // This is a ping response
 0A91 10                push X
 0A92 50CB              mov A,-53
 0A94 7C0000            xcall _TX_23_PutChar
 0A97 20                pop X
 0A98                   .dbline 935
 0A98           ;       TX_014_PutChar(TYPE);                   // This is the module type
 0A98 10                push X
 0A99 5031              mov A,49
 0A9B 7C0000            xcall _TX_014_PutChar
 0A9E 20                pop X
 0A9F                   .dbline 936
 0A9F           ;       TX_23_PutChar(TYPE);                    // This is the module type
 0A9F 10                push X
 0AA0 5031              mov A,49
 0AA2 7C0000            xcall _TX_23_PutChar
 0AA5 20                pop X
 0AA6                   .dbline 937
 0AA6           ;       TX_014_PutChar(CHILD);                  // This is the child-connected port
 0AA6 10                push X
 0AA7 62D000            mov REG[0xd0],>_CHILD
 0AAA 5100              mov A,[_CHILD]
 0AAC 7C0000            xcall _TX_014_PutChar
 0AAF 20                pop X
 0AB0                   .dbline 938
 0AB0           ;       TX_23_PutChar(CHILD);                   // This is the child-connected port
 0AB0 10                push X
 0AB1 62D000            mov REG[0xd0],>_CHILD
 0AB4 5100              mov A,[_CHILD]
 0AB6 7C0000            xcall _TX_23_PutChar
 0AB9 20                pop X
 0ABA                   .dbline 939
 0ABA           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0ABA 10                push X
 0ABB 50FD              mov A,-3
 0ABD 7C0000            xcall _TX_014_PutChar
 0AC0 20                pop X
 0AC1                   .dbline 940
 0AC1           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0AC1 10                push X
 0AC2 50FD              mov A,-3
 0AC4 7C0000            xcall _TX_23_PutChar
 0AC7 20                pop X
 0AC8                   .dbline 941
 0AC8           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0AC8 10                push X
 0AC9 50FD              mov A,-3
 0ACB 7C0000            xcall _TX_014_PutChar
 0ACE 20                pop X
 0ACF                   .dbline 942
 0ACF           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0ACF 10                push X
 0AD0 50FD              mov A,-3
 0AD2 7C0000            xcall _TX_23_PutChar
 0AD5 20                pop X
 0AD6           L257:
 0AD6                   .dbline 945
 0AD6           ;       
 0AD6           ;       // Wait for the transmission to finish.
 0AD6           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0AD6           L258:
 0AD6                   .dbline 945
 0AD6 10                push X
 0AD7 7C0000            xcall _TX_014_bReadTxStatus
 0ADA 62D000            mov REG[0xd0],>__r0
 0ADD 20                pop X
 0ADE 5300              mov [__r0],A
 0AE0 470020            tst [__r0],32
 0AE3 AFF2              jz L257
 0AE5           L260:
 0AE5                   .dbline 946
 0AE5           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 0AE5           L261:
 0AE5                   .dbline 946
 0AE5 10                push X
 0AE6 7C0000            xcall _TX_23_bReadTxStatus
 0AE9 62D000            mov REG[0xd0],>__r0
 0AEC 20                pop X
 0AED 5300              mov [__r0],A
 0AEF 470020            tst [__r0],32
 0AF2 AFF2              jz L260
 0AF4                   .dbline 949
 0AF4           ;       
 0AF4           ;       // Make completely sure we're done.
 0AF4           ;       xmitWait();
 0AF4 95FF              xcall _xmitWait
 0AF6                   .dbline 951
 0AF6           ;       
 0AF6           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0AF6 5000              mov A,0
 0AF8 08                push A
 0AF9 5001              mov A,1
 0AFB 08                push A
 0AFC 7C00B5            xcall _configToggle
 0AFF 38FE              add SP,-2
 0B01                   .dbline -2
 0B01           L256:
 0B01                   .dbline 0 ; func end
 0B01 7F                ret
 0B02                   .dbend
 0B02                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0B02           _unloadAllConfigs::
 0B02                   .dbline -1
 0B02                   .dbline 957
 0B02           ; }
 0B02           ; 
 0B02           ; // This function blindly unloads all user configurations. This will be called once,
 0B02           ; // when the system initially has no known state.
 0B02           ; void unloadAllConfigs(void)
 0B02           ; {
 0B02                   .dbline 958
 0B02           ;       UnloadConfig_waiting();
 0B02 7C0000            xcall _UnloadConfig_waiting
 0B05                   .dbline 959
 0B05           ;       UnloadConfig_hello();
 0B05 7C0000            xcall _UnloadConfig_hello
 0B08                   .dbline 960
 0B08           ;       UnloadConfig_my_response();
 0B08 7C0000            xcall _UnloadConfig_my_response
 0B0B                   .dbline 961
 0B0B           ;       UnloadConfig_response1();
 0B0B 7C0000            xcall _UnloadConfig_response1
 0B0E                   .dbline 962
 0B0E           ;       UnloadConfig_response2();
 0B0E 7C0000            xcall _UnloadConfig_response2
 0B11                   .dbline 963
 0B11           ;       UnloadConfig_response3();
 0B11 7C0000            xcall _UnloadConfig_response3
 0B14                   .dbline 964
 0B14           ;       UnloadConfig_response4();
 0B14 7C0000            xcall _UnloadConfig_response4
 0B17                   .dbline 965
 0B17           ;       UnloadConfig_initial();
 0B17 7C0000            xcall _UnloadConfig_initial
 0B1A                   .dbline 966
 0B1A           ;       UnloadConfig_servo_transmit();
 0B1A 7C0000            xcall _UnloadConfig_servo_transmit
 0B1D                   .dbline -2
 0B1D           L263:
 0B1D                   .dbline 0 ; func end
 0B1D 7F                ret
 0B1E                   .dbend
 0B1E                   .dbfunc e unloadConfig _unloadConfig fV
 0B1E           ;     config_num -> X-5
 0B1E           _unloadConfig::
 0B1E                   .dbline -1
 0B1E 10                push X
 0B1F 4F                mov X,SP
 0B20                   .dbline 972
 0B20           ; }
 0B20           ; 
 0B20           ; // This function unloads the configuration corresponding to the config number passed to it.
 0B20           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0B20           ; void unloadConfig(int config_num)
 0B20           ; {
 0B20                   .dbline 973
 0B20           ;       if(config_num == WAIT)
 0B20 3DFB00            cmp [X-5],0
 0B23 B00B              jnz L265
 0B25 3DFC01            cmp [X-4],1
 0B28 B006              jnz L265
 0B2A           X54:
 0B2A                   .dbline 974
 0B2A           ;       {
 0B2A                   .dbline 975
 0B2A           ;               UnloadConfig_waiting();
 0B2A 7C0000            xcall _UnloadConfig_waiting
 0B2D                   .dbline 976
 0B2D           ;       }
 0B2D 8077              xjmp L266
 0B2F           L265:
 0B2F                   .dbline 977
 0B2F           ;       else if(config_num == HELLO_MODE)
 0B2F 3DFB00            cmp [X-5],0
 0B32 B00B              jnz L267
 0B34 3DFC07            cmp [X-4],7
 0B37 B006              jnz L267
 0B39           X55:
 0B39                   .dbline 978
 0B39           ;       {
 0B39                   .dbline 979
 0B39           ;               UnloadConfig_hello();
 0B39 7C0000            xcall _UnloadConfig_hello
 0B3C                   .dbline 980
 0B3C           ;       }
 0B3C 8068              xjmp L268
 0B3E           L267:
 0B3E                   .dbline 981
 0B3E           ;       else if(config_num == MY_RESPONSE)
 0B3E 3DFB00            cmp [X-5],0
 0B41 B00B              jnz L269
 0B43 3DFC02            cmp [X-4],2
 0B46 B006              jnz L269
 0B48           X56:
 0B48                   .dbline 982
 0B48           ;       {
 0B48                   .dbline 983
 0B48           ;               UnloadConfig_my_response();
 0B48 7C0000            xcall _UnloadConfig_my_response
 0B4B                   .dbline 984
 0B4B           ;       }
 0B4B 8059              xjmp L270
 0B4D           L269:
 0B4D                   .dbline 985
 0B4D           ;       else if(config_num == RESPONSE_1)
 0B4D 3DFB00            cmp [X-5],0
 0B50 B00B              jnz L271
 0B52 3DFC03            cmp [X-4],3
 0B55 B006              jnz L271
 0B57           X57:
 0B57                   .dbline 986
 0B57           ;       {
 0B57                   .dbline 987
 0B57           ;               UnloadConfig_response1();
 0B57 7C0000            xcall _UnloadConfig_response1
 0B5A                   .dbline 988
 0B5A           ;       }
 0B5A 804A              xjmp L272
 0B5C           L271:
 0B5C                   .dbline 989
 0B5C           ;       else if(config_num == RESPONSE_2)
 0B5C 3DFB00            cmp [X-5],0
 0B5F B00B              jnz L273
 0B61 3DFC04            cmp [X-4],4
 0B64 B006              jnz L273
 0B66           X58:
 0B66                   .dbline 990
 0B66           ;       {
 0B66                   .dbline 991
 0B66           ;               UnloadConfig_response2();
 0B66 7C0000            xcall _UnloadConfig_response2
 0B69                   .dbline 992
 0B69           ;       }
 0B69 803B              xjmp L274
 0B6B           L273:
 0B6B                   .dbline 993
 0B6B           ;       else if(config_num == RESPONSE_3)
 0B6B 3DFB00            cmp [X-5],0
 0B6E B00B              jnz L275
 0B70 3DFC05            cmp [X-4],5
 0B73 B006              jnz L275
 0B75           X59:
 0B75                   .dbline 994
 0B75           ;       {
 0B75                   .dbline 995
 0B75           ;               UnloadConfig_response3();
 0B75 7C0000            xcall _UnloadConfig_response3
 0B78                   .dbline 996
 0B78           ;       }
 0B78 802C              xjmp L276
 0B7A           L275:
 0B7A                   .dbline 997
 0B7A           ;       else if(config_num == RESPONSE_4)
 0B7A 3DFB00            cmp [X-5],0
 0B7D B00B              jnz L277
 0B7F 3DFC06            cmp [X-4],6
 0B82 B006              jnz L277
 0B84           X60:
 0B84                   .dbline 998
 0B84           ;       {
 0B84                   .dbline 999
 0B84           ;               UnloadConfig_response4();
 0B84 7C0000            xcall _UnloadConfig_response4
 0B87                   .dbline 1000
 0B87           ;       }
 0B87 801D              xjmp L278
 0B89           L277:
 0B89                   .dbline 1001
 0B89           ;       else if(config_num == INITIALIZE)
 0B89 3DFB00            cmp [X-5],0
 0B8C B00B              jnz L279
 0B8E 3DFC08            cmp [X-4],8
 0B91 B006              jnz L279
 0B93           X61:
 0B93                   .dbline 1002
 0B93           ;       {
 0B93                   .dbline 1003
 0B93           ;               UnloadConfig_initial();
 0B93 7C0000            xcall _UnloadConfig_initial
 0B96                   .dbline 1004
 0B96           ;       }
 0B96 800E              xjmp L280
 0B98           L279:
 0B98                   .dbline 1005
 0B98           ;       else if(config_num == SERVO_COMM)
 0B98 3DFB00            cmp [X-5],0
 0B9B B009              jnz L281
 0B9D 3DFC09            cmp [X-4],9
 0BA0 B004              jnz L281
 0BA2           X62:
 0BA2                   .dbline 1006
 0BA2           ;       {
 0BA2                   .dbline 1007
 0BA2           ;               UnloadConfig_servo_transmit();
 0BA2 7C0000            xcall _UnloadConfig_servo_transmit
 0BA5                   .dbline 1008
 0BA5           ;       }
 0BA5           L281:
 0BA5           L280:
 0BA5           L278:
 0BA5           L276:
 0BA5           L274:
 0BA5           L272:
 0BA5           L270:
 0BA5           L268:
 0BA5           L266:
 0BA5                   .dbline -2
 0BA5           L264:
 0BA5 20                pop X
 0BA6                   .dbline 0 ; func end
 0BA6 7F                ret
 0BA7                   .dbsym l config_num -5 I
 0BA7                   .dbend
 0BA7                   .dbfunc e assignedID _assignedID fV
 0BA7           _assignedID::
 0BA7                   .dbline -1
 0BA7                   .dbline 1013
 0BA7           ; }
 0BA7           ; 
 0BA7           ; // This function responds that an ID has been assigned to it.
 0BA7           ; void assignedID(void)
 0BA7           ; {
 0BA7                   .dbline 1014
 0BA7           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 0BA7 5000              mov A,0
 0BA9 08                push A
 0BAA 5002              mov A,2
 0BAC 08                push A
 0BAD 7C00B5            xcall _configToggle
 0BB0 38FE              add SP,-2
 0BB2                   .dbline 1017
 0BB2           ;       
 0BB2           ;       // Transmit a ping to everyone.
 0BB2           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 0BB2 10                push X
 0BB3 50FC              mov A,-4
 0BB5 7C0000            xcall _TX_014_PutChar
 0BB8 20                pop X
 0BB9                   .dbline 1018
 0BB9           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 0BB9 10                push X
 0BBA 50FC              mov A,-4
 0BBC 7C0000            xcall _TX_23_PutChar
 0BBF 20                pop X
 0BC0                   .dbline 1019
 0BC0           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 0BC0 10                push X
 0BC1 50FC              mov A,-4
 0BC3 7C0000            xcall _TX_014_PutChar
 0BC6 20                pop X
 0BC7                   .dbline 1020
 0BC7           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 0BC7 10                push X
 0BC8 50FC              mov A,-4
 0BCA 7C0000            xcall _TX_23_PutChar
 0BCD 20                pop X
 0BCE                   .dbline 1021
 0BCE           ;       TX_014_PutChar(ID);                             // My ID
 0BCE 10                push X
 0BCF 62D000            mov REG[0xd0],>_ID
 0BD2 5100              mov A,[_ID]
 0BD4 7C0000            xcall _TX_014_PutChar
 0BD7 20                pop X
 0BD8                   .dbline 1022
 0BD8           ;       TX_23_PutChar(ID);                              // My ID
 0BD8 10                push X
 0BD9 62D000            mov REG[0xd0],>_ID
 0BDC 5100              mov A,[_ID]
 0BDE 7C0000            xcall _TX_23_PutChar
 0BE1 20                pop X
 0BE2                   .dbline 1023
 0BE2           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 0BE2 10                push X
 0BE3 5000              mov A,0
 0BE5 7C0000            xcall _TX_014_PutChar
 0BE8 20                pop X
 0BE9                   .dbline 1024
 0BE9           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 0BE9 10                push X
 0BEA 5000              mov A,0
 0BEC 7C0000            xcall _TX_23_PutChar
 0BEF 20                pop X
 0BF0                   .dbline 1025
 0BF0           ;       TX_014_PutChar(ID_ASSIGN_OK);   // This is an assignment ack response
 0BF0 10                push X
 0BF1 50CA              mov A,-54
 0BF3 7C0000            xcall _TX_014_PutChar
 0BF6 20                pop X
 0BF7                   .dbline 1026
 0BF7           ;       TX_23_PutChar(ID_ASSIGN_OK);    // This is an assignment ack response
 0BF7 10                push X
 0BF8 50CA              mov A,-54
 0BFA 7C0000            xcall _TX_23_PutChar
 0BFD 20                pop X
 0BFE                   .dbline 1027
 0BFE           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0BFE 10                push X
 0BFF 50FD              mov A,-3
 0C01 7C0000            xcall _TX_014_PutChar
 0C04 20                pop X
 0C05                   .dbline 1028
 0C05           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0C05 10                push X
 0C06 50FD              mov A,-3
 0C08 7C0000            xcall _TX_23_PutChar
 0C0B 20                pop X
 0C0C                   .dbline 1029
 0C0C           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0C0C 10                push X
 0C0D 50FD              mov A,-3
 0C0F 7C0000            xcall _TX_014_PutChar
 0C12 20                pop X
 0C13                   .dbline 1030
 0C13           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0C13 10                push X
 0C14 50FD              mov A,-3
 0C16 7C0000            xcall _TX_23_PutChar
 0C19 20                pop X
 0C1A           L284:
 0C1A                   .dbline 1033
 0C1A           ;       
 0C1A           ;       // Wait for the transmission to finish.
 0C1A           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0C1A           L285:
 0C1A                   .dbline 1033
 0C1A 10                push X
 0C1B 7C0000            xcall _TX_014_bReadTxStatus
 0C1E 62D000            mov REG[0xd0],>__r0
 0C21 20                pop X
 0C22 5300              mov [__r0],A
 0C24 470020            tst [__r0],32
 0C27 AFF2              jz L284
 0C29           L287:
 0C29                   .dbline 1034
 0C29           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 0C29           L288:
 0C29                   .dbline 1034
 0C29 10                push X
 0C2A 7C0000            xcall _TX_23_bReadTxStatus
 0C2D 62D000            mov REG[0xd0],>__r0
 0C30 20                pop X
 0C31 5300              mov [__r0],A
 0C33 470020            tst [__r0],32
 0C36 AFF2              jz L287
 0C38                   .dbline 1037
 0C38           ;       
 0C38           ;       // Make completely sure we're done.
 0C38           ;       xmitWait();
 0C38 94BB              xcall _xmitWait
 0C3A                   .dbline 1039
 0C3A           ;       
 0C3A           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0C3A 5000              mov A,0
 0C3C 08                push A
 0C3D 5001              mov A,1
 0C3F 08                push A
 0C40 7C00B5            xcall _configToggle
 0C43 38FE              add SP,-2
 0C45                   .dbline -2
 0C45           L283:
 0C45                   .dbline 0 ; func end
 0C45 7F                ret
 0C46                   .dbend
 0C46                   .dbfunc e childListen _childListen fI
 0C46           _childListen::
 0C46                   .dbline -1
 0C46                   .dbline 1044
 0C46           ; }
 0C46           ; 
 0C46           ; // This function listens for children and registers the port that they talk to.
 0C46           ; int childListen(void)
 0C46           ; {
 0C46                   .dbline 1045
 0C46           ;       configToggle(HELLO_MODE);       // Switch to listen for hellos on every port.
 0C46 5000              mov A,0
 0C48 08                push A
 0C49 5007              mov A,7
 0C4B 08                push A
 0C4C 7C00B5            xcall _configToggle
 0C4F 38FE              add SP,-2
 0C51 801C              xjmp L292
 0C53           L291:
 0C53                   .dbline 1049
 0C53           ;       
 0C53           ;       // Wait to either hear a child or time out.
 0C53           ;       while(!TIMEOUT)
 0C53           ;       {               
 0C53                   .dbline 1050
 0C53           ;               if(commandReady())
 0C53 7C02BF            xcall _commandReady
 0C56 62D000            mov REG[0xd0],>__r0
 0C59 3C0000            cmp [__r0],0
 0C5C B006              jnz X63
 0C5E 3C0000            cmp [__r1],0
 0C61 A00C              jz L294
 0C63           X63:
 0C63                   .dbline 1051
 0C63           ;               {
 0C63                   .dbline 1052
 0C63           ;                       return 1;
 0C63 62D000            mov REG[0xd0],>__r0
 0C66 550001            mov [__r1],1
 0C69 550000            mov [__r0],0
 0C6C 8030              xjmp L290
 0C6E           L294:
 0C6E                   .dbline 1054
 0C6E           ;               }
 0C6E           ;       }
 0C6E           L292:
 0C6E                   .dbline 1048
 0C6E 62D000            mov REG[0xd0],>_TIMEOUT
 0C71 3C0000            cmp [_TIMEOUT],0
 0C74 B006              jnz X64
 0C76 3C0100            cmp [_TIMEOUT+1],0
 0C79 AFD9              jz L291
 0C7B           X64:
 0C7B                   .dbline 1056
 0C7B           ;       
 0C7B           ;       HELLO_TIMEOUT_Stop();           // Stop the timer.
 0C7B 10                push X
 0C7C 7C0000            xcall _HELLO_TIMEOUT_Stop
 0C7F 20                pop X
 0C80                   .dbline 1057
 0C80           ;       TIMEOUT = 0;                            // Clear the timeout flag.
 0C80 62D000            mov REG[0xd0],>_TIMEOUT
 0C83 550100            mov [_TIMEOUT+1],0
 0C86 550000            mov [_TIMEOUT],0
 0C89                   .dbline 1059
 0C89           ;       
 0C89           ;       configToggle(WAIT);                     // Switch back to wait for a master response.
 0C89 5000              mov A,0
 0C8B 08                push A
 0C8C 5001              mov A,1
 0C8E 08                push A
 0C8F 7C00B5            xcall _configToggle
 0C92 38FE              add SP,-2
 0C94                   .dbline 1061
 0C94           ;       
 0C94           ;       return 0;                                       // Return the result of our listening session.
 0C94 62D000            mov REG[0xd0],>__r0
 0C97 550000            mov [__r1],0
 0C9A 550000            mov [__r0],0
 0C9D                   .dbline -2
 0C9D           L290:
 0C9D                   .dbline 0 ; func end
 0C9D 7F                ret
 0C9E                   .dbend
 0C9E                   .dbfunc e childResponse _childResponse fI
 0C9E           ; child_responded -> X+0
 0C9E           _childResponse::
 0C9E                   .dbline -1
 0C9E 10                push X
 0C9F 4F                mov X,SP
 0CA0 3802              add SP,2
 0CA2                   .dbline 1066
 0CA2           ; }
 0CA2           ; 
 0CA2           ; // This function waits for a known child's response.
 0CA2           ; int childResponse(void)
 0CA2           ; {
 0CA2                   .dbline 1067
 0CA2           ;       int child_responded = 0;
 0CA2 560100            mov [X+1],0
 0CA5 560000            mov [X+0],0
 0CA8                   .dbline 1070
 0CA8           ;       
 0CA8           ;       // Switch to the right port.
 0CA8           ;       if(CHILD == PORT_1)
 0CA8 62D000            mov REG[0xd0],>_CHILD
 0CAB 3C0031            cmp [_CHILD],49
 0CAE B00E              jnz L297
 0CB0                   .dbline 1071
 0CB0           ;       {
 0CB0                   .dbline 1072
 0CB0           ;               configToggle(RESPONSE_1);
 0CB0 5000              mov A,0
 0CB2 08                push A
 0CB3 5003              mov A,3
 0CB5 08                push A
 0CB6 7C00B5            xcall _configToggle
 0CB9 38FE              add SP,-2
 0CBB                   .dbline 1073
 0CBB           ;       }
 0CBB 8056              xjmp L306
 0CBD           L297:
 0CBD                   .dbline 1074
 0CBD           ;       else if(CHILD == PORT_2)
 0CBD 62D000            mov REG[0xd0],>_CHILD
 0CC0 3C0032            cmp [_CHILD],50
 0CC3 B00E              jnz L299
 0CC5                   .dbline 1075
 0CC5           ;       {
 0CC5                   .dbline 1076
 0CC5           ;               configToggle(RESPONSE_2);
 0CC5 5000              mov A,0
 0CC7 08                push A
 0CC8 5004              mov A,4
 0CCA 08                push A
 0CCB 7C00B5            xcall _configToggle
 0CCE 38FE              add SP,-2
 0CD0                   .dbline 1077
 0CD0           ;       }
 0CD0 8041              xjmp L306
 0CD2           L299:
 0CD2                   .dbline 1078
 0CD2           ;       else if(CHILD == PORT_3)
 0CD2 62D000            mov REG[0xd0],>_CHILD
 0CD5 3C0033            cmp [_CHILD],51
 0CD8 B00E              jnz L301
 0CDA                   .dbline 1079
 0CDA           ;       {
 0CDA                   .dbline 1080
 0CDA           ;               configToggle(RESPONSE_3);
 0CDA 5000              mov A,0
 0CDC 08                push A
 0CDD 5005              mov A,5
 0CDF 08                push A
 0CE0 7C00B5            xcall _configToggle
 0CE3 38FE              add SP,-2
 0CE5                   .dbline 1081
 0CE5           ;       }
 0CE5 802C              xjmp L306
 0CE7           L301:
 0CE7                   .dbline 1082
 0CE7           ;       else if(CHILD == PORT_4)
 0CE7 62D000            mov REG[0xd0],>_CHILD
 0CEA 3C0034            cmp [_CHILD],52
 0CED B024              jnz L306
 0CEF                   .dbline 1083
 0CEF           ;       {
 0CEF                   .dbline 1084
 0CEF           ;               configToggle(RESPONSE_4);
 0CEF 5000              mov A,0
 0CF1 08                push A
 0CF2 5006              mov A,6
 0CF4 08                push A
 0CF5 7C00B5            xcall _configToggle
 0CF8 38FE              add SP,-2
 0CFA                   .dbline 1085
 0CFA           ;       }
 0CFA 8017              xjmp L306
 0CFC           L305:
 0CFC                   .dbline 1089
 0CFC           ;       
 0CFC           ;       // Wait for a response or a timeout.
 0CFC           ;       while((!child_responded) && (!TIMEOUT))
 0CFC           ;       {
 0CFC                   .dbline 1090
 0CFC           ;               if(commandReady())
 0CFC 7C02BF            xcall _commandReady
 0CFF 62D000            mov REG[0xd0],>__r0
 0D02 3C0000            cmp [__r0],0
 0D05 B006              jnz X65
 0D07 3C0000            cmp [__r1],0
 0D0A A007              jz L308
 0D0C           X65:
 0D0C                   .dbline 1091
 0D0C           ;               {
 0D0C                   .dbline 1092
 0D0C           ;                       child_responded = 1;
 0D0C 560101            mov [X+1],1
 0D0F 560000            mov [X+0],0
 0D12                   .dbline 1093
 0D12           ;               }
 0D12           L308:
 0D12                   .dbline 1094
 0D12           ;       }
 0D12           L306:
 0D12                   .dbline 1088
 0D12 3D0000            cmp [X+0],0
 0D15 B013              jnz L310
 0D17 3D0100            cmp [X+1],0
 0D1A B00E              jnz L310
 0D1C           X66:
 0D1C 62D000            mov REG[0xd0],>_TIMEOUT
 0D1F 3C0000            cmp [_TIMEOUT],0
 0D22 B006              jnz X67
 0D24 3C0100            cmp [_TIMEOUT+1],0
 0D27 AFD4              jz L305
 0D29           X67:
 0D29           L310:
 0D29                   .dbline 1097
 0D29           ;       
 0D29           ;       // Stop the right timer.
 0D29           ;       if(CHILD == PORT_1)
 0D29 62D000            mov REG[0xd0],>_CHILD
 0D2C 3C0031            cmp [_CHILD],49
 0D2F B008              jnz L311
 0D31                   .dbline 1098
 0D31           ;       {
 0D31                   .dbline 1099
 0D31           ;               CHILD_1_TIMEOUT_Stop();
 0D31 10                push X
 0D32 7C0000            xcall _CHILD_1_TIMEOUT_Stop
 0D35 20                pop X
 0D36                   .dbline 1100
 0D36           ;       }
 0D36 802C              xjmp L312
 0D38           L311:
 0D38                   .dbline 1101
 0D38           ;       else if(CHILD == PORT_2)
 0D38 62D000            mov REG[0xd0],>_CHILD
 0D3B 3C0032            cmp [_CHILD],50
 0D3E B008              jnz L313
 0D40                   .dbline 1102
 0D40           ;       {
 0D40                   .dbline 1103
 0D40           ;               CHILD_2_TIMEOUT_Stop();
 0D40 10                push X
 0D41 7C0000            xcall _CHILD_2_TIMEOUT_Stop
 0D44 20                pop X
 0D45                   .dbline 1104
 0D45           ;       }
 0D45 801D              xjmp L314
 0D47           L313:
 0D47                   .dbline 1105
 0D47           ;       else if(CHILD == PORT_3)
 0D47 62D000            mov REG[0xd0],>_CHILD
 0D4A 3C0033            cmp [_CHILD],51
 0D4D B008              jnz L315
 0D4F                   .dbline 1106
 0D4F           ;       {
 0D4F                   .dbline 1107
 0D4F           ;               CHILD_3_TIMEOUT_Stop();
 0D4F 10                push X
 0D50 7C0000            xcall _CHILD_3_TIMEOUT_Stop
 0D53 20                pop X
 0D54                   .dbline 1108
 0D54           ;       }
 0D54 800E              xjmp L316
 0D56           L315:
 0D56                   .dbline 1109
 0D56           ;       else if(CHILD == PORT_4)
 0D56 62D000            mov REG[0xd0],>_CHILD
 0D59 3C0034            cmp [_CHILD],52
 0D5C B006              jnz L317
 0D5E                   .dbline 1110
 0D5E           ;       {
 0D5E                   .dbline 1111
 0D5E           ;               CHILD_4_TIMEOUT_Stop();
 0D5E 10                push X
 0D5F 7C0000            xcall _CHILD_4_TIMEOUT_Stop
 0D62 20                pop X
 0D63                   .dbline 1112
 0D63           ;       }
 0D63           L317:
 0D63           L316:
 0D63           L314:
 0D63           L312:
 0D63                   .dbline 1114
 0D63           ;       
 0D63           ;       TIMEOUT = 0;                                    // Reset the timeout flag.
 0D63 62D000            mov REG[0xd0],>_TIMEOUT
 0D66 550100            mov [_TIMEOUT+1],0
 0D69 550000            mov [_TIMEOUT],0
 0D6C                   .dbline 1116
 0D6C           ;       
 0D6C           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0D6C 5000              mov A,0
 0D6E 08                push A
 0D6F 5001              mov A,1
 0D71 08                push A
 0D72 7C00B5            xcall _configToggle
 0D75 38FE              add SP,-2
 0D77                   .dbline 1118
 0D77           ;       
 0D77           ;       return child_responded;
 0D77 62D000            mov REG[0xd0],>__r0
 0D7A 5201              mov A,[X+1]
 0D7C 5300              mov [__r1],A
 0D7E 5200              mov A,[X+0]
 0D80 5300              mov [__r0],A
 0D82                   .dbline -2
 0D82           L296:
 0D82 38FE              add SP,-2
 0D84 20                pop X
 0D85                   .dbline 0 ; func end
 0D85 7F                ret
 0D86                   .dbsym l child_responded 0 I
 0D86                   .dbend
 0D86                   .dbfunc e servoFinder _servoFinder fV
 0D86           ;     flashWrite -> X+5
 0D86           ; status_return_level -> X+4
 0D86           ;              j -> X+2
 0D86           ;              i -> X+0
 0D86           _servoFinder::
 0D86                   .dbline -1
 0D86 10                push X
 0D87 4F                mov X,SP
 0D88 3807              add SP,7
 0D8A                   .dbline 1125
 0D8A           ; }
 0D8A           ; 
 0D8A           ; // This function is used to find the servo that is directly connected to this module's controller.
 0D8A           ; // After the servo ID is found, the status return level is changed so that packets are only
 0D8A           ; // returned for the desired status return level defined at the top of this file.
 0D8A           ; void servoFinder(void)
 0D8A           ; {                             
 0D8A                   .dbline 1127
 0D8A           ;       // Index variables for incrementing and checking against the maximum servo comm attempts.
 0D8A           ;       int i = 0;
 0D8A 560100            mov [X+1],0
 0D8D 560000            mov [X+0],0
 0D90                   .dbline 1128
 0D90           ;       int j = 0;
 0D90 560300            mov [X+3],0
 0D93 560200            mov [X+2],0
 0D96                   .dbline 1131
 0D96           ;       
 0D96           ;       // Integer used as a flag so that EEPROM writes aren't done more than once.
 0D96           ;       int flashWrite = 0;
 0D96 560600            mov [X+6],0
 0D99 560500            mov [X+5],0
 0D9C                   .dbline 1134
 0D9C           ;       
 0D9C           ;       // Create a status return level variable and set it to an out of range value initially.
 0D9C           ;       char status_return_level = 3;
 0D9C 560403            mov [X+4],3
 0D9F                   .dbline 1137
 0D9F           ;       
 0D9F           ;       // Start with a servo ID of 255 (out of valid range).
 0D9F           ;       SERVO_ID = SERVO_START;
 0D9F 62D000            mov REG[0xd0],>_SERVO_ID
 0DA2 5500FF            mov [_SERVO_ID],-1
 0DA5                   .dbline 1146
 0DA5           ; 
 0DA5           ;       // This for loop will loop SERVO_COMM_LOOPS number of times and ping the servo SERVO_COMM_ATTEMPTS
 0DA5           ;       // number of times in each loop (unless stopped short due to early success). If this fails for the
 0DA5           ;       // first round of pings, a broadcast reset will be performed to reset the servo. This is done
 0DA5           ;       // because we assume that the baud rate is matching up, but the servo's return delay time is too
 0DA5           ;       // fast for the controller to switch into receive mode to read the response. The default return
 0DA5           ;       // delay time is 500 microseconds. If we loop for SERVO_COMM_LOOPS number of times and still don't
 0DA5           ;       // see anything, we assume that there is something is too wrong for us to fix.
 0DA5           ;       for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0DA5 560300            mov [X+3],0
 0DA8 560200            mov [X+2],0
 0DAB           L320:
 0DAB                   .dbline 1147
 0DAB           ;       {       
 0DAB                   .dbline 1149
 0DAB           ;               // Ping SERVO_COMM_ATTEMPTS times to try and extract the servo ID.
 0DAB           ;               for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0DAB 560100            mov [X+1],0
 0DAE 560000            mov [X+0],0
 0DB1           L324:
 0DB1                   .dbline 1150
 0DB1           ;               {
 0DB1                   .dbline 1152
 0DB1           ;                       // Send a ping out for any servo connected to me (will only be one).
 0DB1           ;                       servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
 0DB1 5000              mov A,0
 0DB3 08                push A
 0DB4 08                push A
 0DB5 5001              mov A,1
 0DB7 08                push A
 0DB8 5002              mov A,2
 0DBA 08                push A
 0DBB 50FE              mov A,-2
 0DBD 08                push A
 0DBE 9257              xcall _servoInstruction
 0DC0 38FB              add SP,-5
 0DC2 804C              xjmp L329
 0DC4           L328:
 0DC4                   .dbline 1156
 0DC4           ;                       
 0DC4           ;                       // Wait for either a timeout or a valid servo ID (which will trigger a timeout).
 0DC4           ;                       while(!TIMEOUT)
 0DC4           ;                       {       
 0DC4                   .dbline 1157
 0DC4           ;                               if(commandReady())
 0DC4 7C02BF            xcall _commandReady
 0DC7 62D000            mov REG[0xd0],>__r0
 0DCA 3C0000            cmp [__r0],0
 0DCD B006              jnz X68
 0DCF 3C0000            cmp [__r1],0
 0DD2 A03C              jz L331
 0DD4           X68:
 0DD4                   .dbline 1158
 0DD4           ;                               {
 0DD4                   .dbline 1160
 0DD4           ;                                       // If we read a source ID within the range, exit the loop.
 0DD4           ;                                       if((COMMAND_SOURCE >= SERVO_ID_MIN) && (COMMAND_SOURCE <= SERVO_ID_MAX))
 0DD4 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0DD7 3C0000            cmp [_COMMAND_SOURCE],0
 0DDA C02B              jc L333
 0DDC           X69:
 0DDC 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0DDF 50FD              mov A,-3
 0DE1 3A00              cmp A,[_COMMAND_SOURCE]
 0DE3 C022              jc L333
 0DE5           X70:
 0DE5                   .dbline 1161
 0DE5           ;                                       {       
 0DE5                   .dbline 1163
 0DE5           ;                                               // Exit this while loop by setting the timeout flag.
 0DE5           ;                                               TIMEOUT = 1;
 0DE5 62D000            mov REG[0xd0],>_TIMEOUT
 0DE8 550101            mov [_TIMEOUT+1],1
 0DEB 550000            mov [_TIMEOUT],0
 0DEE                   .dbline 1165
 0DEE           ;                                               // Set the servo ID variable to where the ping came from.
 0DEE           ;                                               SERVO_ID = COMMAND_SOURCE;
 0DEE 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0DF1 5100              mov A,[_COMMAND_SOURCE]
 0DF3 62D000            mov REG[0xd0],>_SERVO_ID
 0DF6 5300              mov [_SERVO_ID],A
 0DF8                   .dbline 1167
 0DF8           ;                                               // Set the index variable such that the for loop exits.
 0DF8           ;                                               i = SERVO_COMM_ATTEMPTS;
 0DF8 56010A            mov [X+1],10
 0DFB 560000            mov [X+0],0
 0DFE                   .dbline 1169
 0DFE           ;                                               // Set the outer index variable to 2 to not attempt again for no reason.
 0DFE           ;                                               j = SERVO_COMM_LOOPS;
 0DFE 560303            mov [X+3],3
 0E01 560200            mov [X+2],0
 0E04                   .dbline 1170
 0E04           ;                                       }
 0E04 800A              xjmp L334
 0E06           L333:
 0E06                   .dbline 1172
 0E06           ;                                       else
 0E06           ;                                       {
 0E06                   .dbline 1174
 0E06           ;                                               // Exit this while loop and try to ping again.
 0E06           ;                                               TIMEOUT = 1;
 0E06 62D000            mov REG[0xd0],>_TIMEOUT
 0E09 550101            mov [_TIMEOUT+1],1
 0E0C 550000            mov [_TIMEOUT],0
 0E0F                   .dbline 1175
 0E0F           ;                                       }
 0E0F           L334:
 0E0F                   .dbline 1176
 0E0F           ;                               }
 0E0F           L331:
 0E0F                   .dbline 1177
 0E0F           ;                       }
 0E0F           L329:
 0E0F                   .dbline 1155
 0E0F 62D000            mov REG[0xd0],>_TIMEOUT
 0E12 3C0000            cmp [_TIMEOUT],0
 0E15 B006              jnz X71
 0E17 3C0100            cmp [_TIMEOUT+1],0
 0E1A AFA9              jz L328
 0E1C           X71:
 0E1C                   .dbline 1178
 0E1C           ;               }
 0E1C           L325:
 0E1C                   .dbline 1149
 0E1C 7701              inc [X+1]
 0E1E 0F0000            adc [X+0],0
 0E21                   .dbline 1149
 0E21 5201              mov A,[X+1]
 0E23 110A              sub A,10
 0E25 5200              mov A,[X+0]
 0E27 3180              xor A,-128
 0E29 1980              sbb A,(0 ^ 0x80)
 0E2B CF85              jc L324
 0E2D           X72:
 0E2D                   .dbline 1182
 0E2D           ;               
 0E2D           ;               // If we didn't get a response and haven't written to the flash of the
 0E2D           ;               // servo (first time through), send out a broadcast reset.
 0E2D           ;               if((SERVO_ID == SERVO_START) && (!flashWrite))
 0E2D 62D000            mov REG[0xd0],>_SERVO_ID
 0E30 3C00FF            cmp [_SERVO_ID],-1
 0E33 B022              jnz L335
 0E35 3D0500            cmp [X+5],0
 0E38 B01D              jnz L335
 0E3A 3D0600            cmp [X+6],0
 0E3D B018              jnz L335
 0E3F           X73:
 0E3F                   .dbline 1183
 0E3F           ;               {
 0E3F                   .dbline 1185
 0E3F           ;                       // Set the flash write flag so that we only do this once per power cycle.
 0E3F           ;                       flashWrite = 1;
 0E3F 560601            mov [X+6],1
 0E42 560500            mov [X+5],0
 0E45                   .dbline 1189
 0E45           ;                       
 0E45           ;                       // Send out a broadcast reset so that we know that the response time interval
 0E45           ;                       // is large enough (default delay time for a servo is 500 microseconds).
 0E45           ;                       servoInstruction(BROADCAST, RESET_LENGTH, RESET_SERVO, 0, 0);
 0E45 5000              mov A,0
 0E47 08                push A
 0E48 08                push A
 0E49 5006              mov A,6
 0E4B 08                push A
 0E4C 5002              mov A,2
 0E4E 08                push A
 0E4F 50FE              mov A,-2
 0E51 08                push A
 0E52 91C3              xcall _servoInstruction
 0E54 38FB              add SP,-5
 0E56                   .dbline 1190
 0E56           ;               }
 0E56           L335:
 0E56                   .dbline 1191
 0E56           ;       }
 0E56           L321:
 0E56                   .dbline 1146
 0E56 7703              inc [X+3]
 0E58 0F0200            adc [X+2],0
 0E5B                   .dbline 1146
 0E5B 5203              mov A,[X+3]
 0E5D 1103              sub A,3
 0E5F 5202              mov A,[X+2]
 0E61 3180              xor A,-128
 0E63 1980              sbb A,(0 ^ 0x80)
 0E65 CF45              jc L320
 0E67           X74:
 0E67                   .dbline 1194
 0E67           ; 
 0E67           ;       // Reset flash write flag.
 0E67           ;       flashWrite = 0;
 0E67 560600            mov [X+6],0
 0E6A 560500            mov [X+5],0
 0E6D                   .dbline 1198
 0E6D           ;       
 0E6D           ;       // If we have a valid servo ID, set the status return level. If we don't, just skip this
 0E6D           ;       // because all hope is lost.
 0E6D           ;       if(SERVO_ID < BROADCAST)
 0E6D 62D000            mov REG[0xd0],>_SERVO_ID
 0E70 3C00FE            cmp [_SERVO_ID],-2
 0E73 D19B              jnc L372
 0E75           X75:
 0E75                   .dbline 1199
 0E75           ;       {
 0E75                   .dbline 1204
 0E75           ;               // This for loop will loop SERVO_COMM_LOOPS number of times and poll for the servo's status
 0E75           ;               // return level SERVO_COMM_ATTEMPTS number of times in each loop (unless stopped short due
 0E75           ;               // to early success). If this fails for the first iteration, or we read a status return level
 0E75           ;               // other than what we want, we will attempt to write the desired status return level onto the servo.
 0E75           ;               for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0E75 560300            mov [X+3],0
 0E78 560200            mov [X+2],0
 0E7B           L339:
 0E7B                   .dbline 1205
 0E7B           ;               {
 0E7B                   .dbline 1207
 0E7B           ;                       // Attempt to read the status return level for the defined number of attempts.
 0E7B           ;                       for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0E7B 560100            mov [X+1],0
 0E7E 560000            mov [X+0],0
 0E81           L343:
 0E81                   .dbline 1208
 0E81           ;                       {
 0E81                   .dbline 1210
 0E81           ;                               // Send a request for the servo's status return level.
 0E81           ;                               servoInstruction(SERVO_ID, READ_LENGTH, READ_SERVO, STATUS_RET_ADDRESS, 1);
 0E81 5001              mov A,1
 0E83 08                push A
 0E84 5010              mov A,16
 0E86 08                push A
 0E87 5002              mov A,2
 0E89 08                push A
 0E8A 5004              mov A,4
 0E8C 08                push A
 0E8D 62D000            mov REG[0xd0],>_SERVO_ID
 0E90 5100              mov A,[_SERVO_ID]
 0E92 08                push A
 0E93 9182              xcall _servoInstruction
 0E95 38FB              add SP,-5
 0E97 8048              xjmp L348
 0E99           L347:
 0E99                   .dbline 1214
 0E99           ;                               
 0E99           ;                               // Wait for either a timeout or an indication that we want to exit the loop.
 0E99           ;                               while(!TIMEOUT)
 0E99           ;                               {
 0E99                   .dbline 1216
 0E99           ;                                       // If a valid command is ready, interpret it.
 0E99           ;                                       if(commandReady())
 0E99 7C02BF            xcall _commandReady
 0E9C 62D000            mov REG[0xd0],>__r0
 0E9F 3C0000            cmp [__r0],0
 0EA2 B006              jnz X76
 0EA4 3C0000            cmp [__r1],0
 0EA7 A038              jz L350
 0EA9           X76:
 0EA9                   .dbline 1217
 0EA9           ;                                       {
 0EA9                   .dbline 1218
 0EA9           ;                                               if(!COMMAND_ERROR)
 0EA9 62D000            mov REG[0xd0],>_COMMAND_ERROR
 0EAC 3C0000            cmp [_COMMAND_ERROR],0
 0EAF B030              jnz L352
 0EB1                   .dbline 1219
 0EB1           ;                                               {
 0EB1                   .dbline 1221
 0EB1           ;                                                       // If the return level is equal to what is desired, store it.
 0EB1           ;                                                       if(COMMAND_PARAM == STATUS_RET_LEVEL)
 0EB1 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0EB4 3C0001            cmp [_COMMAND_PARAM],1
 0EB7 B01F              jnz L354
 0EB9                   .dbline 1222
 0EB9           ;                                                       {
 0EB9                   .dbline 1224
 0EB9           ;                                                               // Set the timeout flag to exit the loop.
 0EB9           ;                                                               TIMEOUT = 1;
 0EB9 62D000            mov REG[0xd0],>_TIMEOUT
 0EBC 550101            mov [_TIMEOUT+1],1
 0EBF 550000            mov [_TIMEOUT],0
 0EC2                   .dbline 1226
 0EC2           ;                                                               // Store the status return level.
 0EC2           ;                                                               status_return_level = COMMAND_PARAM;
 0EC2 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0EC5 5100              mov A,[_COMMAND_PARAM]
 0EC7 5404              mov [X+4],A
 0EC9                   .dbline 1228
 0EC9           ;                                                               // Set i so that we exit the for loop.
 0EC9           ;                                                               i = SERVO_COMM_ATTEMPTS;
 0EC9 56010A            mov [X+1],10
 0ECC 560000            mov [X+0],0
 0ECF                   .dbline 1230
 0ECF           ;                                                               // Set the outer loop's variable so that we don't loop again.
 0ECF           ;                                                               j = SERVO_COMM_LOOPS;
 0ECF 560303            mov [X+3],3
 0ED2 560200            mov [X+2],0
 0ED5                   .dbline 1231
 0ED5           ;                                                       }
 0ED5 800A              xjmp L355
 0ED7           L354:
 0ED7                   .dbline 1233
 0ED7           ;                                                       else
 0ED7           ;                                                       {       
 0ED7                   .dbline 1235
 0ED7           ;                                                               // Set the timeout flag to exit the loop.
 0ED7           ;                                                               TIMEOUT = 1;
 0ED7 62D000            mov REG[0xd0],>_TIMEOUT
 0EDA 550101            mov [_TIMEOUT+1],1
 0EDD 550000            mov [_TIMEOUT],0
 0EE0                   .dbline 1236
 0EE0           ;                                                       }
 0EE0           L355:
 0EE0                   .dbline 1237
 0EE0           ;                                               }
 0EE0           L352:
 0EE0                   .dbline 1238
 0EE0           ;                                       }
 0EE0           L350:
 0EE0                   .dbline 1239
 0EE0           ;                               }
 0EE0           L348:
 0EE0                   .dbline 1213
 0EE0 62D000            mov REG[0xd0],>_TIMEOUT
 0EE3 3C0000            cmp [_TIMEOUT],0
 0EE6 B006              jnz X77
 0EE8 3C0100            cmp [_TIMEOUT+1],0
 0EEB AFAD              jz L347
 0EED           X77:
 0EED                   .dbline 1240
 0EED           ;                       }
 0EED           L344:
 0EED                   .dbline 1207
 0EED 7701              inc [X+1]
 0EEF 0F0000            adc [X+0],0
 0EF2                   .dbline 1207
 0EF2 5201              mov A,[X+1]
 0EF4 110A              sub A,10
 0EF6 5200              mov A,[X+0]
 0EF8 3180              xor A,-128
 0EFA 1980              sbb A,(0 ^ 0x80)
 0EFC CF84              jc L343
 0EFE           X78:
 0EFE                   .dbline 1244
 0EFE           ;               
 0EFE           ;                       // If we didn't get a good response and haven't written to the flash of the servo,
 0EFE           ;                       // force a change in the status return level with an EEPROM write.
 0EFE           ;                       if((status_return_level != STATUS_RET_LEVEL) && (!flashWrite))
 0EFE 3D0401            cmp [X+4],1
 0F01 A027              jz L356
 0F03 3D0500            cmp [X+5],0
 0F06 B022              jnz L356
 0F08 3D0600            cmp [X+6],0
 0F0B B01D              jnz L356
 0F0D           X79:
 0F0D                   .dbline 1245
 0F0D           ;                       {       
 0F0D                   .dbline 1246
 0F0D           ;                               flashWrite = 1;
 0F0D 560601            mov [X+6],1
 0F10 560500            mov [X+5],0
 0F13                   .dbline 1249
 0F13           ;                               
 0F13           ;                               // Try to force the return status to what we want.
 0F13           ;                               servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, STATUS_RET_ADDRESS, STATUS_RET_LEVEL);
 0F13 5001              mov A,1
 0F15 08                push A
 0F16 5010              mov A,16
 0F18 08                push A
 0F19 5003              mov A,3
 0F1B 08                push A
 0F1C 5004              mov A,4
 0F1E 08                push A
 0F1F 62D000            mov REG[0xd0],>_SERVO_ID
 0F22 5100              mov A,[_SERVO_ID]
 0F24 08                push A
 0F25 90F0              xcall _servoInstruction
 0F27 38FB              add SP,-5
 0F29                   .dbline 1250
 0F29           ;                       }
 0F29           L356:
 0F29                   .dbline 1251
 0F29           ;               }
 0F29           L340:
 0F29                   .dbline 1204
 0F29 7703              inc [X+3]
 0F2B 0F0200            adc [X+2],0
 0F2E                   .dbline 1204
 0F2E 5203              mov A,[X+3]
 0F30 1103              sub A,3
 0F32 5202              mov A,[X+2]
 0F34 3180              xor A,-128
 0F36 1980              sbb A,(0 ^ 0x80)
 0F38 CF42              jc L339
 0F3A           X80:
 0F3A                   .dbline 1253
 0F3A           ;               
 0F3A           ;               if(status_return_level != STATUS_RET_LEVEL)
 0F3A 3D0401            cmp [X+4],1
 0F3D A0D3              jz L338
 0F3F                   .dbline 1254
 0F3F           ;               {
 0F3F 8095              xjmp L361
 0F41           L360:
 0F41                   .dbline 1258
 0F41           ;                       // Break this module on purpose because it won't function like we want it to anyway.
 0F41           ;                       // The LED on the module will blink slowly (on for 2 seconds, off for 2 seconds).
 0F41           ;                       while(1)
 0F41           ;                       {
 0F41                   .dbline 1259
 0F41           ;                               PRT2DR &= 0b11111110;
 0F41 4108FE            and REG[0x8],-2
 0F44                   .dbline 1260
 0F44           ;                               for(i = 0; i < 40000; i++)
 0F44 560100            mov [X+1],0
 0F47 560000            mov [X+0],0
 0F4A 8008              xjmp L366
 0F4C           L363:
 0F4C                   .dbline 1261
 0F4C           ;                               {
 0F4C                   .dbline 1262
 0F4C           ;                                       xmitWait();
 0F4C 91A7              xcall _xmitWait
 0F4E                   .dbline 1263
 0F4E           ;                               }
 0F4E           L364:
 0F4E                   .dbline 1260
 0F4E 7701              inc [X+1]
 0F50 0F0000            adc [X+0],0
 0F53           L366:
 0F53                   .dbline 1260
 0F53 62D000            mov REG[0xd0],>__r0
 0F56 5201              mov A,[X+1]
 0F58 5300              mov [__r3],A
 0F5A 5200              mov A,[X+0]
 0F5C 5300              mov [__r2],A
 0F5E 470080            tst [__r2],-128
 0F61 A009              jz X81
 0F63 5500FF            mov [__r1],-1
 0F66 5500FF            mov [__r0],-1
 0F69 800A              jmp X82
 0F6B           X81:
 0F6B 62D000            mov REG[0xd0],>__r0
 0F6E 550000            mov [__r1],0
 0F71 550000            mov [__r0],0
 0F74           X82:
 0F74 62D000            mov REG[0xd0],>__r0
 0F77 5100              mov A,[__r3]
 0F79 1140              sub A,64
 0F7B 5100              mov A,[__r2]
 0F7D 199C              sbb A,-100
 0F7F 5100              mov A,[__r1]
 0F81 1900              sbb A,0
 0F83 5100              mov A,[__r0]
 0F85 3180              xor A,-128
 0F87 1980              sbb A,(0 ^ 0x80)
 0F89 CFC2              jc L363
 0F8B           X83:
 0F8B                   .dbline 1264
 0F8B           ;                               PRT2DR |= 0b00000001;
 0F8B 430801            or REG[0x8],1
 0F8E                   .dbline 1265
 0F8E           ;                               for(i = 0; i < 40000; i++)
 0F8E 560100            mov [X+1],0
 0F91 560000            mov [X+0],0
 0F94 8008              xjmp L370
 0F96           L367:
 0F96                   .dbline 1266
 0F96           ;                               {
 0F96                   .dbline 1267
 0F96           ;                                       xmitWait();
 0F96 915D              xcall _xmitWait
 0F98                   .dbline 1268
 0F98           ;                               }
 0F98           L368:
 0F98                   .dbline 1265
 0F98 7701              inc [X+1]
 0F9A 0F0000            adc [X+0],0
 0F9D           L370:
 0F9D                   .dbline 1265
 0F9D 62D000            mov REG[0xd0],>__r0
 0FA0 5201              mov A,[X+1]
 0FA2 5300              mov [__r3],A
 0FA4 5200              mov A,[X+0]
 0FA6 5300              mov [__r2],A
 0FA8 470080            tst [__r2],-128
 0FAB A009              jz X84
 0FAD 5500FF            mov [__r1],-1
 0FB0 5500FF            mov [__r0],-1
 0FB3 800A              jmp X85
 0FB5           X84:
 0FB5 62D000            mov REG[0xd0],>__r0
 0FB8 550000            mov [__r1],0
 0FBB 550000            mov [__r0],0
 0FBE           X85:
 0FBE 62D000            mov REG[0xd0],>__r0
 0FC1 5100              mov A,[__r3]
 0FC3 1140              sub A,64
 0FC5 5100              mov A,[__r2]
 0FC7 199C              sbb A,-100
 0FC9 5100              mov A,[__r1]
 0FCB 1900              sbb A,0
 0FCD 5100              mov A,[__r0]
 0FCF 3180              xor A,-128
 0FD1 1980              sbb A,(0 ^ 0x80)
 0FD3 CFC2              jc L367
 0FD5           X86:
 0FD5                   .dbline 1269
 0FD5           ;                       }
 0FD5           L361:
 0FD5                   .dbline 1257
 0FD5 8F6B              xjmp L360
 0FD7           L371:
 0FD7                   .dbline 1277
 0FD7           ;               }
 0FD7           ;       }
 0FD7           ;       else
 0FD7           ;       {
 0FD7           ;               // Purposely break the module since it was unable to assign an ID correctly.
 0FD7           ;               // The LED on the module will blink at a moderate speed (0.5 seconds on, 0.5 seconds off).
 0FD7           ;               while(1)
 0FD7           ;               {
 0FD7                   .dbline 1278
 0FD7           ;                       PRT2DR &= 0b11111110;
 0FD7 4108FE            and REG[0x8],-2
 0FDA                   .dbline 1279
 0FDA           ;                       for(i = 0; i < 10000; i++)
 0FDA 560100            mov [X+1],0
 0FDD 560000            mov [X+0],0
 0FE0           L374:
 0FE0                   .dbline 1280
 0FE0           ;                       {
 0FE0                   .dbline 1281
 0FE0           ;                               xmitWait();
 0FE0 9113              xcall _xmitWait
 0FE2                   .dbline 1282
 0FE2           ;                       }
 0FE2           L375:
 0FE2                   .dbline 1279
 0FE2 7701              inc [X+1]
 0FE4 0F0000            adc [X+0],0
 0FE7                   .dbline 1279
 0FE7 5201              mov A,[X+1]
 0FE9 1110              sub A,16
 0FEB 5200              mov A,[X+0]
 0FED 3180              xor A,-128
 0FEF 19A7              sbb A,(39 ^ 0x80)
 0FF1 CFEE              jc L374
 0FF3           X87:
 0FF3                   .dbline 1283
 0FF3           ;                       PRT2DR |= 0b00000001;
 0FF3 430801            or REG[0x8],1
 0FF6                   .dbline 1284
 0FF6           ;                       for(i = 0; i < 10000; i++)
 0FF6 560100            mov [X+1],0
 0FF9 560000            mov [X+0],0
 0FFC           L378:
 0FFC                   .dbline 1285
 0FFC           ;                       {
 0FFC                   .dbline 1286
 0FFC           ;                               xmitWait();
 0FFC 90F7              xcall _xmitWait
 0FFE                   .dbline 1287
 0FFE           ;                       }
 0FFE           L379:
 0FFE                   .dbline 1284
 0FFE 7701              inc [X+1]
 1000 0F0000            adc [X+0],0
 1003                   .dbline 1284
 1003 5201              mov A,[X+1]
 1005 1110              sub A,16
 1007 5200              mov A,[X+0]
 1009 3180              xor A,-128
 100B 19A7              sbb A,(39 ^ 0x80)
 100D CFEE              jc L378
 100F           X88:
 100F                   .dbline 1288
 100F           ;               }
 100F           L372:
 100F                   .dbline 1276
 100F 8FC7              xjmp L371
 1011           L338:
 1011                   .dbline 1292
 1011           ;       }
 1011           ;       
 1011           ;       // Wait for the other controllers to find their servos.
 1011           ;       servoConfigWait();
 1011 9155              xcall _servoConfigWait
 1013                   .dbline -2
 1013           L319:
 1013 38F9              add SP,-7
 1015 20                pop X
 1016                   .dbline 0 ; func end
 1016 7F                ret
 1017                   .dbsym l flashWrite 5 I
 1017                   .dbsym l status_return_level 4 c
 1017                   .dbsym l j 2 I
 1017                   .dbsym l i 0 I
 1017                   .dbend
 1017                   .dbfunc e servoInstruction _servoInstruction fV
 1017           ;       checksum -> X+0
 1017           ;          value -> X-8
 1017           ;        address -> X-7
 1017           ;    instruction -> X-6
 1017           ;         length -> X-5
 1017           ;             id -> X-4
 1017           _servoInstruction::
 1017                   .dbline -1
 1017 10                push X
 1018 4F                mov X,SP
 1019 3801              add SP,1
 101B                   .dbline 1298
 101B           ; }
 101B           ; 
 101B           ; // This function receives a destination, command length, instruction type, address, and value.
 101B           ; // With these parameters, the function sends a packet to the communication bus.
 101B           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 101B           ; {
 101B                   .dbline 1302
 101B           ;       char checksum;
 101B           ;       
 101B           ;       // Toggle into transmit mode.
 101B           ;       configToggle(SERVO_COMM);
 101B 5000              mov A,0
 101D 08                push A
 101E 5009              mov A,9
 1020 08                push A
 1021 7C00B5            xcall _configToggle
 1024 38FE              add SP,-2
 1026                   .dbline 1305
 1026           ;       
 1026           ;       // Calculate the checksum value for our servo communication.
 1026           ;       checksum = 255-((id + length + instruction + address + value)%256);
 1026 62D000            mov REG[0xd0],>__r0
 1029 52FB              mov A,[X-5]
 102B 5300              mov [__r1],A
 102D 550000            mov [__r0],0
 1030 52FC              mov A,[X-4]
 1032 0200              add A,[__r1]
 1034 5300              mov [__r1],A
 1036 5000              mov A,0
 1038 0A00              adc A,[__r0]
 103A 5300              mov [__r0],A
 103C 52FA              mov A,[X-6]
 103E 0400              add [__r1],A
 1040 0E0000            adc [__r0],0
 1043 52F9              mov A,[X-7]
 1045 0400              add [__r1],A
 1047 0E0000            adc [__r0],0
 104A 52F8              mov A,[X-8]
 104C 0400              add [__r1],A
 104E 0E0000            adc [__r0],0
 1051 5001              mov A,1
 1053 08                push A
 1054 5000              mov A,0
 1056 08                push A
 1057 5100              mov A,[__r0]
 1059 08                push A
 105A 5100              mov A,[__r1]
 105C 08                push A
 105D 7C0000            xcall __divmod_16X16_16
 1060 38FE              add SP,-2
 1062 18                pop A
 1063 5300              mov [__r1],A
 1065 18                pop A
 1066 50FF              mov A,-1
 1068 1200              sub A,[__r1]
 106A 5400              mov [X+0],A
 106C                   .dbline 1308
 106C           ;       
 106C           ;       // Talk to the servo.
 106C           ;       if(instruction == PING_SERVO)
 106C 3DFA01            cmp [X-6],1
 106F B02D              jnz L383
 1071                   .dbline 1309
 1071           ;       {
 1071                   .dbline 1310
 1071           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte one
 1071 10                push X
 1072 50FF              mov A,-1
 1074 7C0000            xcall _SERVO_TX_PutChar
 1077 20                pop X
 1078                   .dbline 1311
 1078           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte two
 1078 10                push X
 1079 50FF              mov A,-1
 107B 7C0000            xcall _SERVO_TX_PutChar
 107E 20                pop X
 107F                   .dbline 1312
 107F           ;               SERVO_TX_PutChar(id);                   // Servo ID
 107F 10                push X
 1080 52FC              mov A,[X-4]
 1082 7C0000            xcall _SERVO_TX_PutChar
 1085 20                pop X
 1086                   .dbline 1313
 1086           ;               SERVO_TX_PutChar(length);               // The instruction length.
 1086 10                push X
 1087 52FB              mov A,[X-5]
 1089 7C0000            xcall _SERVO_TX_PutChar
 108C 20                pop X
 108D                   .dbline 1314
 108D           ;               SERVO_TX_PutChar(instruction);  // The instruction to carry out.
 108D 10                push X
 108E 52FA              mov A,[X-6]
 1090 7C0000            xcall _SERVO_TX_PutChar
 1093 20                pop X
 1094                   .dbline 1315
 1094           ;               SERVO_TX_PutChar(checksum);             // This is the checksum.
 1094 10                push X
 1095 5200              mov A,[X+0]
 1097 7C0000            xcall _SERVO_TX_PutChar
 109A 20                pop X
 109B                   .dbline 1316
 109B           ;       }
 109B 8039              xjmp L386
 109D           L383:
 109D                   .dbline 1318
 109D           ;       else
 109D           ;       {
 109D                   .dbline 1319
 109D           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte one
 109D 10                push X
 109E 50FF              mov A,-1
 10A0 7C0000            xcall _SERVO_TX_PutChar
 10A3 20                pop X
 10A4                   .dbline 1320
 10A4           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte two
 10A4 10                push X
 10A5 50FF              mov A,-1
 10A7 7C0000            xcall _SERVO_TX_PutChar
 10AA 20                pop X
 10AB                   .dbline 1321
 10AB           ;               SERVO_TX_PutChar(id);                   // Servo ID
 10AB 10                push X
 10AC 52FC              mov A,[X-4]
 10AE 7C0000            xcall _SERVO_TX_PutChar
 10B1 20                pop X
 10B2                   .dbline 1322
 10B2           ;               SERVO_TX_PutChar(length);               // The instruction length.
 10B2 10                push X
 10B3 52FB              mov A,[X-5]
 10B5 7C0000            xcall _SERVO_TX_PutChar
 10B8 20                pop X
 10B9                   .dbline 1323
 10B9           ;               SERVO_TX_PutChar(instruction);  // The instruction to carry out.
 10B9 10                push X
 10BA 52FA              mov A,[X-6]
 10BC 7C0000            xcall _SERVO_TX_PutChar
 10BF 20                pop X
 10C0                   .dbline 1324
 10C0           ;               SERVO_TX_PutChar(address);              // The address to read/write from/to.
 10C0 10                push X
 10C1 52F9              mov A,[X-7]
 10C3 7C0000            xcall _SERVO_TX_PutChar
 10C6 20                pop X
 10C7                   .dbline 1325
 10C7           ;               SERVO_TX_PutChar(value);                // The value to write or number of bytes to read.
 10C7 10                push X
 10C8 52F8              mov A,[X-8]
 10CA 7C0000            xcall _SERVO_TX_PutChar
 10CD 20                pop X
 10CE                   .dbline 1326
 10CE           ;               SERVO_TX_PutChar(checksum);             // This is the checksum.
 10CE 10                push X
 10CF 5200              mov A,[X+0]
 10D1 7C0000            xcall _SERVO_TX_PutChar
 10D4 20                pop X
 10D5                   .dbline 1327
 10D5           ;       }
 10D5           L385:
 10D5                   .dbline 1330
 10D5           ;       
 10D5           ;       // Wait for the transmission to finish.
 10D5           ;       while(!(SERVO_TX_bReadTxStatus() & SERVO_TX_TX_COMPLETE));
 10D5           L386:
 10D5                   .dbline 1330
 10D5 10                push X
 10D6 7C0000            xcall _SERVO_TX_bReadTxStatus
 10D9 62D000            mov REG[0xd0],>__r0
 10DC 20                pop X
 10DD 5300              mov [__r0],A
 10DF 470020            tst [__r0],32
 10E2 AFF2              jz L385
 10E4                   .dbline 1333
 10E4           ;       
 10E4           ;       // Make completely sure we're done.
 10E4           ;       xmitWait();
 10E4 900F              xcall _xmitWait
 10E6                   .dbline 1336
 10E6           ;       
 10E6           ;       // Switch back to wait for a servo response.
 10E6           ;       configToggle(INITIALIZE);
 10E6 5000              mov A,0
 10E8 08                push A
 10E9 5008              mov A,8
 10EB 08                push A
 10EC 7C00B5            xcall _configToggle
 10EF 38FE              add SP,-2
 10F1                   .dbline -2
 10F1           L382:
 10F1 38FF              add SP,-1
 10F3 20                pop X
 10F4                   .dbline 0 ; func end
 10F4 7F                ret
 10F5                   .dbsym l checksum 0 c
 10F5                   .dbsym l value -8 c
 10F5                   .dbsym l address -7 c
 10F5                   .dbsym l instruction -6 c
 10F5                   .dbsym l length -5 c
 10F5                   .dbsym l id -4 c
 10F5                   .dbend
 10F5                   .dbfunc e xmitWait _xmitWait fV
 10F5           ;              i -> X+0
 10F5           _xmitWait::
 10F5                   .dbline -1
 10F5 10                push X
 10F6 4F                mov X,SP
 10F7 3802              add SP,2
 10F9                   .dbline 1342
 10F9           ; }
 10F9           ; 
 10F9           ; // This function is used in various ways to create a period of nothingness. Mostly,
 10F9           ; // it is used to allow the controller enough time to transmit bytes (as its name suggests).
 10F9           ; void xmitWait(void)
 10F9           ; {
 10F9                   .dbline 1345
 10F9           ;       int i;
 10F9           ;       
 10F9           ;       for(i = 0; i < 25; i++)
 10F9 560100            mov [X+1],0
 10FC 560000            mov [X+0],0
 10FF           L389:
 10FF                   .dbline 1346
 10FF           ;       {
 10FF                   .dbline 1348
 10FF           ;               // Does nothing and wastes approximately 50 microseconds.
 10FF           ;       }
 10FF           L390:
 10FF                   .dbline 1345
 10FF 7701              inc [X+1]
 1101 0F0000            adc [X+0],0
 1104                   .dbline 1345
 1104 5201              mov A,[X+1]
 1106 1119              sub A,25
 1108 5200              mov A,[X+0]
 110A 3180              xor A,-128
 110C 1980              sbb A,(0 ^ 0x80)
 110E CFF0              jc L389
 1110           X89:
 1110                   .dbline -2
 1110           L388:
 1110 38FE              add SP,-2
 1112 20                pop X
 1113                   .dbline 0 ; func end
 1113 7F                ret
 1114                   .dbsym l i 0 I
 1114                   .dbend
 1114                   .dbfunc e servoBootWait _servoBootWait fV
 1114           ;              i -> X+0
 1114           _servoBootWait::
 1114                   .dbline -1
 1114 10                push X
 1115 4F                mov X,SP
 1116 3802              add SP,2
 1118                   .dbline 1356
 1118           ; }
 1118           ; 
 1118           ; // This function wastes time while the servo that is attached to this controller boots up.
 1118           ; // Once that happens, communications should happen quickly and reliably. The estimated boot
 1118           ; // time in testing was approximately 120 ms. This means that the define SERVO_BOOT_TIMEOUTS
 1118           ; // at the top must be a minimum of 60 since timeout periods are in 2 ms intervals.
 1118           ; void servoBootWait(void)
 1118           ; {
 1118                   .dbline 1357
 1118           ;       int i = 0;                                      // Index integer used for looping.
 1118 560100            mov [X+1],0
 111B 560000            mov [X+0],0
 111E                   .dbline 1359
 111E           ; 
 111E           ;       configToggle(INITIALIZE);       // Switch to initialize mode to do this timeout routine.
 111E 5000              mov A,0
 1120 08                push A
 1121 5008              mov A,8
 1123 08                push A
 1124 7C00B5            xcall _configToggle
 1127 38FE              add SP,-2
 1129                   .dbline 1362
 1129           ;       
 1129           ;       // Loop and wait for enough timeouts to happen before we talk to the servo.
 1129           ;       for(i = 0; i < SERVO_BOOT_TIMEOUTS; i++)
 1129 560100            mov [X+1],0
 112C 560000            mov [X+0],0
 112F                   .dbline 1363
 112F           ;       {
 112F           L398:
 112F                   .dbline 1364
 112F           ;               while(!TIMEOUT) { }             // Do nothing while we wait for one timeout period.
 112F                   .dbline 1364
 112F           L399:
 112F                   .dbline 1364
 112F 62D000            mov REG[0xd0],>_TIMEOUT
 1132 3C0000            cmp [_TIMEOUT],0
 1135 B006              jnz X90
 1137 3C0100            cmp [_TIMEOUT+1],0
 113A AFF4              jz L398
 113C           X90:
 113C                   .dbline 1365
 113C           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 113C 62D000            mov REG[0xd0],>_TIMEOUT
 113F 550100            mov [_TIMEOUT+1],0
 1142 550000            mov [_TIMEOUT],0
 1145                   .dbline 1366
 1145           ;       }
 1145           L395:
 1145                   .dbline 1362
 1145 7701              inc [X+1]
 1147 0F0000            adc [X+0],0
 114A                   .dbline 1362
 114A 5201              mov A,[X+1]
 114C 1164              sub A,100
 114E 5200              mov A,[X+0]
 1150 3180              xor A,-128
 1152 1980              sbb A,(0 ^ 0x80)
 1154 CFDA              jc L399
 1156           X91:
 1156                   .dbline 1368
 1156           ;       
 1156           ;       INIT_TIMEOUT_Stop();            // Stop the timeout timer.
 1156 10                push X
 1157 7C0000            xcall _INIT_TIMEOUT_Stop
 115A 20                pop X
 115B                   .dbline 1369
 115B           ;       TIMEOUT = 0;                            // Clear the timeout flag.
 115B 62D000            mov REG[0xd0],>_TIMEOUT
 115E 550100            mov [_TIMEOUT+1],0
 1161 550000            mov [_TIMEOUT],0
 1164                   .dbline -2
 1164           L393:
 1164 38FE              add SP,-2
 1166 20                pop X
 1167                   .dbline 0 ; func end
 1167 7F                ret
 1168                   .dbsym l i 0 I
 1168                   .dbend
 1168                   .dbfunc e servoConfigWait _servoConfigWait fV
 1168           ;              i -> X+0
 1168           _servoConfigWait::
 1168                   .dbline -1
 1168 10                push X
 1169 4F                mov X,SP
 116A 3802              add SP,2
 116C                   .dbline 1375
 116C           ; }
 116C           ; 
 116C           ; // Sits and spins for the amount of time it takes for a worst case scenario for setup time
 116C           ; // to take place. This allows all other modules to initialize.
 116C           ; void servoConfigWait(void)
 116C           ; {
 116C                   .dbline 1376
 116C           ;       int i = 0;                                      // Index integer for looping purposes.
 116C 560100            mov [X+1],0
 116F 560000            mov [X+0],0
 1172                   .dbline 1378
 1172           ;       
 1172           ;       configToggle(INITIALIZE);       // Switch to initialize mode to do this timeout routine.
 1172 5000              mov A,0
 1174 08                push A
 1175 5008              mov A,8
 1177 08                push A
 1178 7C00B5            xcall _configToggle
 117B 38FE              add SP,-2
 117D                   .dbline 1383
 117D           ;       
 117D           ;       // For SERVO_COMM_ATTEMPTS*SERVO_COMM_LOOPS cycles, let the other controllers find
 117D           ;       // their servos. The reason we loop this many times is to allow for a possible worst
 117D           ;       // case scenario of setup time to complete.
 117D           ;       for(i = 0; i < (SERVO_COMM_ATTEMPTS*SERVO_COMM_LOOPS); i++)
 117D 560100            mov [X+1],0
 1180 560000            mov [X+0],0
 1183                   .dbline 1384
 1183           ;       {
 1183           L406:
 1183                   .dbline 1385
 1183           ;               while(!TIMEOUT) { }             // Do nothing while we wait for one timeout period.
 1183                   .dbline 1385
 1183           L407:
 1183                   .dbline 1385
 1183 62D000            mov REG[0xd0],>_TIMEOUT
 1186 3C0000            cmp [_TIMEOUT],0
 1189 B006              jnz X92
 118B 3C0100            cmp [_TIMEOUT+1],0
 118E AFF4              jz L406
 1190           X92:
 1190                   .dbline 1386
 1190           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 1190 62D000            mov REG[0xd0],>_TIMEOUT
 1193 550100            mov [_TIMEOUT+1],0
 1196 550000            mov [_TIMEOUT],0
 1199                   .dbline 1387
 1199           ;       }
 1199           L403:
 1199                   .dbline 1383
 1199 7701              inc [X+1]
 119B 0F0000            adc [X+0],0
 119E                   .dbline 1383
 119E 5201              mov A,[X+1]
 11A0 111E              sub A,30
 11A2 5200              mov A,[X+0]
 11A4 3180              xor A,-128
 11A6 1980              sbb A,(0 ^ 0x80)
 11A8 CFDA              jc L407
 11AA           X93:
 11AA                   .dbline 1389
 11AA           ;       
 11AA           ;       INIT_TIMEOUT_Stop();            // Stop the timer.
 11AA 10                push X
 11AB 7C0000            xcall _INIT_TIMEOUT_Stop
 11AE 20                pop X
 11AF                   .dbline 1390
 11AF           ;       TIMEOUT = 0;                            // Reset the timeout flag.
 11AF 62D000            mov REG[0xd0],>_TIMEOUT
 11B2 550100            mov [_TIMEOUT+1],0
 11B5 550000            mov [_TIMEOUT],0
 11B8                   .dbline 1392
 11B8           ; 
 11B8           ;       configToggle(WAIT);                     // Switch to wait for the master node to speak to you.
 11B8 5000              mov A,0
 11BA 08                push A
 11BB 5001              mov A,1
 11BD 08                push A
 11BE 7C00B5            xcall _configToggle
 11C1 38FE              add SP,-2
 11C3                   .dbline -2
 11C3           L401:
 11C3 38FE              add SP,-2
 11C5 20                pop X
 11C6                   .dbline 0 ; func end
 11C6 7F                ret
 11C7                   .dbsym l i 0 I
 11C7                   .dbend
 11C7                   .dbfunc e TX_01234_TIMEOUT_ISR _TX_01234_TIMEOUT_ISR fV
 11C7           _TX_01234_TIMEOUT_ISR::
 11C7                   .dbline -1
 11C7 71C0              or F,-64
 11C9 08                push A
 11CA 5DD0              mov A,REG[0xd0]
 11CC 08                push A
 11CD                   .dbline 1400
 11CD           ; }
 11CD           ; 
 11CD           ; // This timeout ISR is for waiting before a transmission is made from this module.
 11CD           ; // This is to give all the other modules a chance to set up and clear their buffers.
 11CD           ; // It is currently set so that there is 1 ms of down time between the last transmission
 11CD           ; // and this module's transmission.
 11CD           ; void TX_01234_TIMEOUT_ISR(void)
 11CD           ; {
 11CD                   .dbline 1401
 11CD           ;       TIMEOUT = 1;    // Set the timeout flag.
 11CD 62D000            mov REG[0xd0],>_TIMEOUT
 11D0 550101            mov [_TIMEOUT+1],1
 11D3 550000            mov [_TIMEOUT],0
 11D6                   .dbline 1402
 11D6           ;       M8C_ClearIntFlag(INT_CLR0,TX_01234_TIMEOUT_INT_MASK);
 11D6 62DAFD            mov REG[0xda],-3
 11D9                   .dbline -2
 11D9           L409:
 11D9 18                pop A
 11DA 60D0              mov REG[208],A
 11DC 18                pop A
 11DD                   .dbline 0 ; func end
 11DD 7E                reti
 11DE                   .dbend
 11DE                   .dbfunc e HELLO_TIMEOUT_ISR _HELLO_TIMEOUT_ISR fV
 11DE           _HELLO_TIMEOUT_ISR::
 11DE                   .dbline -1
 11DE 71C0              or F,-64
 11E0 08                push A
 11E1 5DD0              mov A,REG[0xd0]
 11E3 08                push A
 11E4                   .dbline 1407
 11E4           ; }
 11E4           ; 
 11E4           ; // This is the ISR for a hello response timeout.
 11E4           ; void HELLO_TIMEOUT_ISR(void)
 11E4           ; {
 11E4                   .dbline 1408
 11E4           ;       TIMEOUT = 1;    // Set the timeout flag.
 11E4 62D000            mov REG[0xd0],>_TIMEOUT
 11E7 550101            mov [_TIMEOUT+1],1
 11EA 550000            mov [_TIMEOUT],0
 11ED                   .dbline 1409
 11ED           ;       M8C_ClearIntFlag(INT_CLR0,HELLO_TIMEOUT_INT_MASK);
 11ED 62DAFD            mov REG[0xda],-3
 11F0                   .dbline -2
 11F0           L410:
 11F0 18                pop A
 11F1 60D0              mov REG[208],A
 11F3 18                pop A
 11F4                   .dbline 0 ; func end
 11F4 7E                reti
 11F5                   .dbend
 11F5                   .dbfunc e CHILD_1_TIMEOUT_ISR _CHILD_1_TIMEOUT_ISR fV
 11F5           _CHILD_1_TIMEOUT_ISR::
 11F5                   .dbline -1
 11F5 71C0              or F,-64
 11F7 08                push A
 11F8 5DD0              mov A,REG[0xd0]
 11FA 08                push A
 11FB                   .dbline 1414
 11FB           ; }
 11FB           ; 
 11FB           ; // These remaining ISRs are for all the child timeout scenarios.
 11FB           ; void CHILD_1_TIMEOUT_ISR(void)
 11FB           ; {
 11FB                   .dbline 1415
 11FB           ;       TIMEOUT = 1;    // Set the timeout flag.
 11FB 62D000            mov REG[0xd0],>_TIMEOUT
 11FE 550101            mov [_TIMEOUT+1],1
 1201 550000            mov [_TIMEOUT],0
 1204                   .dbline 1416
 1204           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_1_TIMEOUT_INT_MASK);
 1204 62DAFD            mov REG[0xda],-3
 1207                   .dbline -2
 1207           L411:
 1207 18                pop A
 1208 60D0              mov REG[208],A
 120A 18                pop A
 120B                   .dbline 0 ; func end
 120B 7E                reti
 120C                   .dbend
 120C                   .dbfunc e CHILD_2_TIMEOUT_ISR _CHILD_2_TIMEOUT_ISR fV
 120C           _CHILD_2_TIMEOUT_ISR::
 120C                   .dbline -1
 120C 71C0              or F,-64
 120E 08                push A
 120F 5DD0              mov A,REG[0xd0]
 1211 08                push A
 1212                   .dbline 1420
 1212           ; }
 1212           ; 
 1212           ; void CHILD_2_TIMEOUT_ISR(void)
 1212           ; {
 1212                   .dbline 1421
 1212           ;       TIMEOUT = 1;    // Set the timeout flag.
 1212 62D000            mov REG[0xd0],>_TIMEOUT
 1215 550101            mov [_TIMEOUT+1],1
 1218 550000            mov [_TIMEOUT],0
 121B                   .dbline 1422
 121B           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_2_TIMEOUT_INT_MASK);
 121B 62DAFD            mov REG[0xda],-3
 121E                   .dbline -2
 121E           L412:
 121E 18                pop A
 121F 60D0              mov REG[208],A
 1221 18                pop A
 1222                   .dbline 0 ; func end
 1222 7E                reti
 1223                   .dbend
 1223                   .dbfunc e CHILD_3_TIMEOUT_ISR _CHILD_3_TIMEOUT_ISR fV
 1223           _CHILD_3_TIMEOUT_ISR::
 1223                   .dbline -1
 1223 71C0              or F,-64
 1225 08                push A
 1226 5DD0              mov A,REG[0xd0]
 1228 08                push A
 1229                   .dbline 1426
 1229           ; }
 1229           ; 
 1229           ; void CHILD_3_TIMEOUT_ISR(void)
 1229           ; {
 1229                   .dbline 1427
 1229           ;       TIMEOUT = 1;    // Set the timeout flag.
 1229 62D000            mov REG[0xd0],>_TIMEOUT
 122C 550101            mov [_TIMEOUT+1],1
 122F 550000            mov [_TIMEOUT],0
 1232                   .dbline 1428
 1232           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_3_TIMEOUT_INT_MASK);
 1232 62DAFD            mov REG[0xda],-3
 1235                   .dbline -2
 1235           L413:
 1235 18                pop A
 1236 60D0              mov REG[208],A
 1238 18                pop A
 1239                   .dbline 0 ; func end
 1239 7E                reti
 123A                   .dbend
 123A                   .dbfunc e CHILD_4_TIMEOUT_ISR _CHILD_4_TIMEOUT_ISR fV
 123A           _CHILD_4_TIMEOUT_ISR::
 123A                   .dbline -1
 123A 71C0              or F,-64
 123C 08                push A
 123D 5DD0              mov A,REG[0xd0]
 123F 08                push A
 1240                   .dbline 1432
 1240           ; }
 1240           ; 
 1240           ; void CHILD_4_TIMEOUT_ISR(void)
 1240           ; {
 1240                   .dbline 1433
 1240           ;       TIMEOUT = 1;    // Set the timeout flag.
 1240 62D000            mov REG[0xd0],>_TIMEOUT
 1243 550101            mov [_TIMEOUT+1],1
 1246 550000            mov [_TIMEOUT],0
 1249                   .dbline 1434
 1249           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_4_TIMEOUT_INT_MASK);
 1249 62DAFD            mov REG[0xda],-3
 124C                   .dbline -2
 124C           L414:
 124C 18                pop A
 124D 60D0              mov REG[208],A
 124F 18                pop A
 1250                   .dbline 0 ; func end
 1250 7E                reti
 1251                   .dbend
 1251                   .dbfunc e INIT_TIMEOUT_ISR _INIT_TIMEOUT_ISR fV
 1251           _INIT_TIMEOUT_ISR::
 1251                   .dbline -1
 1251 71C0              or F,-64
 1253 08                push A
 1254 5DD0              mov A,REG[0xd0]
 1256 08                push A
 1257                   .dbline 1438
 1257           ; }
 1257           ; 
 1257           ; void INIT_TIMEOUT_ISR(void)
 1257           ; {
 1257                   .dbline 1439
 1257           ;       TIMEOUT = 1;    // Set the timeout flag.
 1257 62D000            mov REG[0xd0],>_TIMEOUT
 125A 550101            mov [_TIMEOUT+1],1
 125D 550000            mov [_TIMEOUT],0
 1260                   .dbline 1440
 1260           ;       M8C_ClearIntFlag(INT_CLR0,INIT_TIMEOUT_INT_MASK);
 1260 62DAFD            mov REG[0xda],-3
 1263                   .dbline -2
 1263           L415:
 1263 18                pop A
 1264 60D0              mov REG[208],A
 1266 18                pop A
 1267                   .dbline 0 ; func end
 1267 7E                reti
 1268                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _SERVO_ID::
 0000 00                .byte 0
 0001                   .dbsym e SERVO_ID _SERVO_ID c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_ERROR::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_ERROR _COMMAND_ERROR c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_LENGTH::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_LENGTH _COMMAND_LENGTH c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_PARAM::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_PARAM _COMMAND_PARAM c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _CONFIGURED::
 0000 0000              .byte 0,0
 0002                   .dbsym e CONFIGURED _CONFIGURED I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _ID::
 0000 00                .byte 0
 0001                   .dbsym e ID _ID c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _CHILD::
 0000 00                .byte 0
 0001                   .dbsym e CHILD _CHILD c
