 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 155
 0000           ; // Author: Jason Tennyson
 0000           ; // Date: 1-25-11
 0000           ; // File: main.c
 0000           ; //
 0000           ; // This is the design for the revolute modules for Jason Tennyson's Thesis.
 0000           ; // This design is made for a PSoC CY8C28433-24PVXI.
 0000           ; //
 0000           ; // Packet Structure
 0000           ; // ----------------
 0000           ; // START BYTE/START BYTE/SOURCE ID BYTE/DESTINATION ID BYTE/COMMAND TYPE/PARAM 1/.../PARAM N/END TRANSMIT
 0000           ; 
 0000           ; #include <m8c.h>              // Part-specific constants and macros.
 0000           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules.
 0000           ; #include "psocdynamic.h"      // Required for dynamically swapping configurations at run time.
 0000           ; 
 0000           ; // These are declarations of all of the timer interrupts that are used for all configurations.
 0000           ; #pragma interrupt_handler WAIT_NC_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler TX_01234_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_1_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_2_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_3_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_4_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler HELLO_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler INIT_TIMEOUT_ISR
 0000           ; 
 0000           ; // These defines are used as parameters of the configToggle function.  Passing one of
 0000           ; // these identifiers to configToggle will put the chip in that device configuration.
 0000           ; #define               WAIT                                            (1)
 0000           ; #define               MY_RESPONSE                                     (2)
 0000           ; #define       RESPONSE_1                                      (3)
 0000           ; #define       RESPONSE_2                                      (4)
 0000           ; #define       RESPONSE_3                                      (5)
 0000           ; #define       RESPONSE_4                                      (6)
 0000           ; #define               HELLO_MODE                                      (7)
 0000           ; #define               INITIALIZE                                      (8)
 0000           ; #define               SERVO_COMM                                      (9)
 0000           ; 
 0000           ; // These defines are used as comparisons to find what port the next module connected to.
 0000           ; #define               PORT_A                                          ('A')
 0000           ; #define               PORT_B                                          ('B')
 0000           ; #define               PORT_C                                          ('C')
 0000           ; #define               PORT_D                                          ('D')
 0000           ; 
 0000           ; // These defines are used as transmission indicators for transmissions between PSoC controllers.
 0000           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0000           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0000           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0000           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0000           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is complete.
 0000           ; #define               PING                                            (203)   // Indicates a ping message to or from the master.
 0000           ; #define               CLEAR_CONFIG                            (204)   // Indicates that the master is asking for a config clear.
 0000           ; #define               CONFIG_CLEARED                          (205)   // Indicates that a module has cleared its own config.
 0000           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0000           ; #define               DEFAULT_ID                                      (251)   // The ID that all modules start with.
 0000           ; #define               BROADCAST                                       (254)   // The broadcast ID for all controllers and servos.
 0000           ; 
 0000           ; // SERVO DEFINES
 0000           ; // These numbers can all be found in the AX-12+ datasheet.
 0000           ; // These defines cover the range of IDs these servos are capable of.
 0000           ; #define               SERVO_ID_MIN                            (0)             // This is the lowest servo ID possible.
 0000           ; #define               SERVO_ID_MAX                            (253)   // This is the highest servo ID possible.
 0000           ; // These defines are servo transmission indicators.
 0000           ; #define               SERVO_START                                     (255)   // This is the start byte for a servo transmission.
 0000           ; // These defines are used to fill in the length parameter for a given command type.  These are the only
 0000           ; // lengths used by this controller for servo configuration purposes.  It is worth noting that any type
 0000           ; // and length of command can be issued from the master after configuration is complete.
 0000           ; #define               READ_LENGTH                                     (4)             // This is the length value for all reads.
 0000           ; #define               WRITE_LENGTH                            (4)             // This is the length value for all writes.
 0000           ; #define               PING_LENGTH                                     (2)             // This is the length value for a ping.
 0000           ; #define               RESET_LENGTH                            (2)             // This is the length value for a reset.
 0000           ; // These defines are used to fill in the servo's EEPROM address parameter for a given command type.
 0000           ; #define               ID_ADDRESS                                      (3)             // This is the address where servo ID is stored.
 0000           ; #define               STATUS_RET_ADDRESS                      (16)    // This is where the status return level is stored.
 0000           ; // These defines are used to fill in the instruction we are using on the servo.
 0000           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0000           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0000           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0000           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0000           ; // These defines cover all of the status return level possibilities.
 0000           ; #define               STATUS_RET_NEVER                        (0)             // Only respond to ping commands.
 0000           ; #define               STATUS_RET_READ                         (1)             // Only respond to read data commands (recommended).
 0000           ; #define               STATUS_RET_ALL                          (2)             // Respond to every command.
 0000           ; 
 0000           ; // This is the number of attempts we make to contact the servo per sweep of attempts before
 0000           ; // writing to its EEPROM in an attempt to alter settings that keep us from communicating.
 0000           ; #define               SERVO_COMM_ATTEMPTS                     (10)
 0000           ; // This is the number of times we do a loop of SERVO_COMM_ATTEMPTS.  We would like this to be at least 2.
 0000           ; // This is because we do an EEPROM write after the first unsuccessful loop of SERVO_COMM_ATTEMPTS.
 0000           ; // If we don't then do at least one more loop, the EEPROM write was done for no reason.
 0000           ; #define               SERVO_COMM_LOOPS                        (2)
 0000           ; // This is the number of timeout periods to wait through while the servo boots up (2 ms per period).
 0000           ; #define               SERVO_BOOT_TIMEOUTS                     (75)
 0000           ; 
 0000           ; // This is the number of iterations we loop waiting for bytes to reset the timeout on a child response.
 0000           ; // This will be the amount of iterations we do after the last byte has been received as well.
 0000           ; #define               RESPONSE_ITERATIONS                     (10)
 0000           ; 
 0000           ; // This is the status return level, which is set to one of the possible status return values above.
 0000           ; // We want the status return level to be return on read commands only so that we don't have garbage
 0000           ; // return packets flying around every time we tell the servo to move.
 0000           ; #define               STATUS_RET_LEVEL                        (STATUS_RET_READ)
 0000           ; 
 0000           ; // This function receives a mode identifier as a parameter and toggles the system configuration.
 0000           ; void configToggle(int mode);
 0000           ; // This function unloads all configurations.  This should only be needed at startup.
 0000           ; void unloadAllConfigs(void);
 0000           ; // This function unloads the configuration corresponding to the number passed to it.
 0000           ; void unloadConfig(int config_num);
 0000           ; // This function is a response to the master sending out a hello message.
 0000           ; void sayHello(void);
 0000           ; // This function looks for commands and returns 1 if a command has been read, 0 if not.
 0000           ; int commandReady(void);
 0000           ; // This function interprets the command that has just been read and performs an action accordingly.
 0000           ; void takeAction(void);
 0000           ; // This function responds to a ping.
 0000           ; void pingResponse(void);
 0000           ; // This function tells the master node that an ID assignment was completed on this module.
 0000           ; void assignedID(void);
 0000           ; // This function sends out an acknowledgement of a configuration reset.
 0000           ; void configCleared(void);
 0000           ; // This function listens for children and registers the port that they talk to.
 0000           ; int childListen(void);
 0000           ; // This function waits for a known child's response to a command to that child from the master.
 0000           ; int childResponse(void);
 0000           ; // This function does everything it can to find the servo attached to this controller.
 0000           ; void servoFinder(void);
 0000           ; // This function carries out the passed servo instruction.
 0000           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0000           ; // This function does a simple for loop to stall and make doubly sure that the transmission finished.
 0000           ; // It is meant to be used as a definite amount of wait time after the transmission complete flag is set.
 0000           ; void xmitWait(void);
 0000           ; // This function is called to do nothing while we wait for the servo to boot up.
 0000           ; void servoBootWait(void);
 0000           ; // This function is used to wait for other controllers to find their servos while not
 0000           ; // driving any pins (which would keep a child from talking to its servo).
 0000           ; void servoConfigWait(void);
 0000           ; 
 0000           ; char CHILD;           // Keeps track of where the child is connected.
 0000           ; char ID;              // Stores the ID that the master gives this module.
 0000           ; 
 0000           ; int CONFIGURED;       // Keeps track of whether or not this module has been configured by the master.
 0000           ; int TIMEOUT;  // This flag is set if a timeout occurs.
 0000           ; int STATE;            // This stores the ID of the currently-loaded configuration.
 0000           ; 
 0000           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0000           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0000           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0000           ; char COMMAND_PARAM;                   // Stores a parameter that accompanies the command (if any).
 0000           ; char COMMAND_LENGTH;          // Stores the length parameter of a servo command.
 0000           ; char COMMAND_ERROR;                   // Stores the error code of a servo command.
 0000           ; 
 0000           ; char SERVO_ID;                                // Stores the ID of the servo inside of this module.
 0000           ; 
 0000           ; void main()
 0000           ; {     
 0000                   .dbline 157
 0000           ;       // Initial value assignment for variables of importance.
 0000           ;       CHILD = 0;                              // There is no child yet.
 0000 62D000            mov REG[0xd0],>_CHILD
 0003 550000            mov [_CHILD],0
 0006                   .dbline 158
 0006           ;       CONFIGURED = 0;                 // This module is not configured yet.
 0006 62D000            mov REG[0xd0],>_CONFIGURED
 0009 550100            mov [_CONFIGURED+1],0
 000C 550000            mov [_CONFIGURED],0
 000F                   .dbline 159
 000F           ;       TIMEOUT = 0;                    // Set the timeout flag low to start.
 000F 62D000            mov REG[0xd0],>_TIMEOUT
 0012 550100            mov [_TIMEOUT+1],0
 0015 550000            mov [_TIMEOUT],0
 0018                   .dbline 160
 0018           ;       COMMAND_PARAM = 0;              // There is no parameter yet.
 0018 62D000            mov REG[0xd0],>_COMMAND_PARAM
 001B 550000            mov [_COMMAND_PARAM],0
 001E                   .dbline 161
 001E           ;       STATE = 0;                              // There is no state yet.
 001E 62D000            mov REG[0xd0],>_STATE
 0021 550100            mov [_STATE+1],0
 0024 550000            mov [_STATE],0
 0027                   .dbline 162
 0027           ;       ID = DEFAULT_ID;                // Set the ID of this controller to the default to start with.
 0027 62D000            mov REG[0xd0],>_ID
 002A 5500FB            mov [_ID],-5
 002D                   .dbline 164
 002D           ; 
 002D           ;       M8C_EnableGInt;                 // Turn on global interrupts for the transmission timeout timer.
 002D 7101                      or  F, 01h
 002F           
 002F                   .dbline 166
 002F           ;       
 002F           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); // Activate GPIO ISR
 002F 43E020            or REG[0xe0],32
 0032                   .dbline 169
 0032           ;       
 0032           ;       // We have to wait for the servo to power up and get ready for communications.
 0032           ;       servoBootWait();
 0032 7C0F60            xcall _servoBootWait
 0035                   .dbline 172
 0035           ;       
 0035           ;       // Find the servo that is inside of this module.
 0035           ;       servoFinder();
 0035 7C0C95            xcall _servoFinder
 0038 8012              xjmp L3
 003A           L2:
 003A                   .dbline 176
 003A           ;       
 003A           ;       // Loop and wait for commands.
 003A           ;       while(1)
 003A           ;       {       
 003A                   .dbline 177
 003A           ;               if(commandReady())
 003A 9282              xcall _commandReady
 003C 62D000            mov REG[0xd0],>__r0
 003F 3C0000            cmp [__r0],0
 0042 B006              jnz X1
 0044 3C0000            cmp [__r1],0
 0047 A003              jz L5
 0049           X1:
 0049                   .dbline 178
 0049           ;               {
 0049                   .dbline 180
 0049           ;                       // If the command is ready, take action.
 0049           ;                       takeAction();
 0049 9655              xcall _takeAction
 004B                   .dbline 181
 004B           ;               }
 004B           L5:
 004B                   .dbline 182
 004B           ;       }
 004B           L3:
 004B                   .dbline 175
 004B 8FEE              xjmp L2
 004D           X0:
 004D                   .dbline -2
 004D           L1:
 004D                   .dbline 0 ; func end
 004D 8FFF              jmp .
 004F                   .dbend
 004F                   .dbfunc e sayHello _sayHello fV
 004F           _sayHello::
 004F                   .dbline -1
 004F                   .dbline 187
 004F           ; }
 004F           ; 
 004F           ; // This function transmits a response to a hello command from the master.
 004F           ; void sayHello(void)
 004F           ; {     
 004F                   .dbline 188
 004F           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 004F 5000              mov A,0
 0051 08                push A
 0052 5002              mov A,2
 0054 08                push A
 0055 905D              xcall _configToggle
 0057 38FE              add SP,-2
 0059                   .dbline 191
 0059           ;       
 0059           ;       // Transmit a hello response to the master node.
 0059           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 0059 10                push X
 005A 50FC              mov A,-4
 005C 7C0000            xcall _TX_014_PutChar
 005F 20                pop X
 0060                   .dbline 192
 0060           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 0060 10                push X
 0061 50FC              mov A,-4
 0063 7C0000            xcall _TX_014_PutChar
 0066 20                pop X
 0067                   .dbline 193
 0067           ;       TX_014_PutChar(ID);                             // My ID (source)
 0067 10                push X
 0068 62D000            mov REG[0xd0],>_ID
 006B 5100              mov A,[_ID]
 006D 7C0000            xcall _TX_014_PutChar
 0070 20                pop X
 0071                   .dbline 194
 0071           ;       TX_014_PutChar(MASTER_ID);              // Master ID (destination)
 0071 10                push X
 0072 5000              mov A,0
 0074 7C0000            xcall _TX_014_PutChar
 0077 20                pop X
 0078                   .dbline 195
 0078           ;       TX_014_PutChar(HELLO_BYTE);             // This is a hello command.
 0078 10                push X
 0079 50C8              mov A,-56
 007B 7C0000            xcall _TX_014_PutChar
 007E 20                pop X
 007F                   .dbline 196
 007F           ;       TX_014_PutChar(CHILD);                  // Sends child port value, default 0.
 007F 10                push X
 0080 62D000            mov REG[0xd0],>_CHILD
 0083 5100              mov A,[_CHILD]
 0085 7C0000            xcall _TX_014_PutChar
 0088 20                pop X
 0089                   .dbline 197
 0089           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission.
 0089 10                push X
 008A 50FD              mov A,-3
 008C 7C0000            xcall _TX_014_PutChar
 008F 20                pop X
 0090                   .dbline 198
 0090           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission.
 0090 10                push X
 0091 50FD              mov A,-3
 0093 7C0000            xcall _TX_014_PutChar
 0096 20                pop X
 0097           L8:
 0097                   .dbline 201
 0097           ;       
 0097           ;       // Wait for the transmission to finish.
 0097           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0097           L9:
 0097                   .dbline 201
 0097 10                push X
 0098 7C0000            xcall _TX_014_bReadTxStatus
 009B 62D000            mov REG[0xd0],>__r0
 009E 20                pop X
 009F 5300              mov [__r0],A
 00A1 470020            tst [__r0],32
 00A4 AFF2              jz L8
 00A6                   .dbline 204
 00A6           ;       
 00A6           ;       // Make completely sure we're done.
 00A6           ;       xmitWait();
 00A6 7C0F41            xcall _xmitWait
 00A9                   .dbline 206
 00A9           ; 
 00A9           ;       configToggle(WAIT);                             // Switch back to wait mode.
 00A9 5000              mov A,0
 00AB 08                push A
 00AC 5001              mov A,1
 00AE 08                push A
 00AF 9003              xcall _configToggle
 00B1 38FE              add SP,-2
 00B3                   .dbline -2
 00B3           L7:
 00B3                   .dbline 0 ; func end
 00B3 7F                ret
 00B4                   .dbend
 00B4                   .dbfunc e configToggle _configToggle fV
 00B4           ;           mode -> X-5
 00B4           _configToggle::
 00B4                   .dbline -1
 00B4 10                push X
 00B5 4F                mov X,SP
 00B6                   .dbline 212
 00B6           ; }
 00B6           ; 
 00B6           ; // This function receives a mode flag and switches the microcontroller to the
 00B6           ; // desired hardware configuration.
 00B6           ; void configToggle(int mode)
 00B6           ; {     
 00B6                   .dbline 215
 00B6           ;       // Set the pins high and disconnect from the global bus.
 00B6           ;       // This keeps false start bits from happening while we swap configs.
 00B6           ;       PRT0DR |= 0b00011111;   // Set pins P00 through P04 high.
 00B6 43001F            or REG[0],31
 00B9                   .dbline 216
 00B9           ;       PRT0GS &= 0b11100000;   // Disconnect pins P00 through P04 from the global bus.
 00B9 4102E0            and REG[0x2],-32
 00BC                   .dbline 220
 00BC           ;       
 00BC           ;       // Unload the configuration of the current state.
 00BC           ;       // If there is no state, blindly wipe all configurations.
 00BC           ;       if(STATE)
 00BC 62D000            mov REG[0xd0],>_STATE
 00BF 3C0000            cmp [_STATE],0
 00C2 B006              jnz X2
 00C4 3C0100            cmp [_STATE+1],0
 00C7 A011              jz L12
 00C9           X2:
 00C9                   .dbline 221
 00C9           ;       {
 00C9                   .dbline 222
 00C9           ;               unloadConfig(STATE);
 00C9 62D000            mov REG[0xd0],>_STATE
 00CC 5100              mov A,[_STATE]
 00CE 08                push A
 00CF 5101              mov A,[_STATE+1]
 00D1 08                push A
 00D2 7C0A2D            xcall _unloadConfig
 00D5 38FE              add SP,-2
 00D7                   .dbline 223
 00D7           ;       }
 00D7 8004              xjmp L13
 00D9           L12:
 00D9                   .dbline 225
 00D9           ;       else
 00D9           ;       {
 00D9                   .dbline 226
 00D9           ;               unloadAllConfigs();
 00D9 7C0A11            xcall _unloadAllConfigs
 00DC                   .dbline 227
 00DC           ;       }
 00DC           L13:
 00DC                   .dbline 231
 00DC           ;       
 00DC           ;       // Go through the list of possible modes until we find the one that was passed in to us.
 00DC           ;       // Then, load that configuration and initialize whatever needs to be initialized.
 00DC           ;       if(mode == WAIT)
 00DC 3DFB00            cmp [X-5],0
 00DF B022              jnz L14
 00E1 3DFC01            cmp [X-4],1
 00E4 B01D              jnz L14
 00E6           X3:
 00E6                   .dbline 232
 00E6           ;       {
 00E6                   .dbline 235
 00E6           ;               // Load the wait receiver configuration.  This is the receiver configuration used after
 00E6           ;               // initialization is complete.  It listens and forwards everything it hears.
 00E6           ;               LoadConfig_waiting();
 00E6 7C0000            xcall _LoadConfig_waiting
 00E9                   .dbline 238
 00E9           ;               
 00E9           ;               // Start the receivers.
 00E9           ;               WAIT_RECV_Start(WAIT_RECV_PARITY_NONE);
 00E9 10                push X
 00EA 5000              mov A,0
 00EC 7C0000            xcall _WAIT_RECV_Start
 00EF 20                pop X
 00F0                   .dbline 239
 00F0           ;               RX8_2_Start(RX8_2_PARITY_NONE);
 00F0 10                push X
 00F1 5000              mov A,0
 00F3 7C0000            xcall _RX8_2_Start
 00F6 20                pop X
 00F7                   .dbline 242
 00F7           ;               
 00F7           ;               // Set the current state.
 00F7           ;               STATE = WAIT;
 00F7 62D000            mov REG[0xd0],>_STATE
 00FA 550101            mov [_STATE+1],1
 00FD 550000            mov [_STATE],0
 0100                   .dbline 243
 0100           ;       }
 0100 81A0              xjmp L15
 0102           L14:
 0102                   .dbline 244
 0102           ;       else if(mode == MY_RESPONSE)
 0102 3DFB00            cmp [X-5],0
 0105 B04C              jnz L16
 0107 3DFC02            cmp [X-4],2
 010A B047              jnz L16
 010C           X4:
 010C                   .dbline 245
 010C           ;       {
 010C                   .dbline 247
 010C           ;               // Load the transmitter configuration.  This is for transmitting messages on all ports.
 010C           ;               LoadConfig_my_response();
 010C 7C0000            xcall _LoadConfig_my_response
 010F                   .dbline 250
 010F           ;               
 010F           ;               // Clear the timeout flag.
 010F           ;               TIMEOUT = 0;
 010F 62D000            mov REG[0xd0],>_TIMEOUT
 0112 550100            mov [_TIMEOUT+1],0
 0115 550000            mov [_TIMEOUT],0
 0118                   .dbline 253
 0118           ;               
 0118           ;               // Start the transmitters.
 0118           ;               TX_014_Start(TX_014_PARITY_NONE);       // Transmits on P00, P01, and P04.
 0118 10                push X
 0119 5000              mov A,0
 011B 7C0000            xcall _TX_014_Start
 011E 20                pop X
 011F                   .dbline 254
 011F           ;               TX_23_Start(TX_23_PARITY_NONE);         // Transmits on P02 and P03.
 011F 10                push X
 0120 5000              mov A,0
 0122 7C0000            xcall _TX_23_Start
 0125                   .dbline 256
 0125           ;               
 0125           ;               TX_01234_TIMEOUT_EnableInt();           // Make sure interrupts are enabled.
 0125 7C0000            xcall _TX_01234_TIMEOUT_EnableInt
 0128                   .dbline 257
 0128           ;               TX_01234_TIMEOUT_Start();                       // Start the timer.
 0128 7C0000            xcall _TX_01234_TIMEOUT_Start
 012B 20                pop X
 012C           L18:
 012C                   .dbline 261
 012C           ;               
 012C           ;               // Do nothing while we wait for one timeout period (1 ms).
 012C           ;               // This is to allow everyone to get in the right configuration before talking.
 012C           ;               while(!TIMEOUT) { }
 012C                   .dbline 261
 012C           L19:
 012C                   .dbline 261
 012C 62D000            mov REG[0xd0],>_TIMEOUT
 012F 3C0000            cmp [_TIMEOUT],0
 0132 B006              jnz X5
 0134 3C0100            cmp [_TIMEOUT+1],0
 0137 AFF4              jz L18
 0139           X5:
 0139                   .dbline 263
 0139           ;               
 0139           ;               TX_01234_TIMEOUT_Stop();                        // Stop the timer.
 0139 10                push X
 013A 7C0000            xcall _TX_01234_TIMEOUT_Stop
 013D 20                pop X
 013E                   .dbline 264
 013E           ;               TIMEOUT = 0;                                            // Reset the timeout flag.
 013E 62D000            mov REG[0xd0],>_TIMEOUT
 0141 550100            mov [_TIMEOUT+1],0
 0144 550000            mov [_TIMEOUT],0
 0147                   .dbline 267
 0147           ;       
 0147           ;               // Set the current state.
 0147           ;               STATE = MY_RESPONSE;
 0147 62D000            mov REG[0xd0],>_STATE
 014A 550102            mov [_STATE+1],2
 014D 550000            mov [_STATE],0
 0150                   .dbline 268
 0150           ;       }
 0150 8150              xjmp L17
 0152           L16:
 0152                   .dbline 269
 0152           ;       else if(mode == RESPONSE_1)
 0152 3DFB00            cmp [X-5],0
 0155 B02A              jnz L21
 0157 3DFC03            cmp [X-4],3
 015A B025              jnz L21
 015C           X6:
 015C                   .dbline 270
 015C           ;       {
 015C                   .dbline 272
 015C           ;               // Load the response wait on port 1.
 015C           ;               LoadConfig_response1();
 015C 7C0000            xcall _LoadConfig_response1
 015F                   .dbline 275
 015F           ;               
 015F           ;               // Clear the timeout flag.
 015F           ;               TIMEOUT = 0;
 015F 62D000            mov REG[0xd0],>_TIMEOUT
 0162 550100            mov [_TIMEOUT+1],0
 0165 550000            mov [_TIMEOUT],0
 0168                   .dbline 278
 0168           ;               
 0168           ;               // Start listening for a response through child port 1.
 0168           ;               CHILD_1_Start(CHILD_1_PARITY_NONE);
 0168 10                push X
 0169 5000              mov A,0
 016B 7C0000            xcall _CHILD_1_Start
 016E                   .dbline 280
 016E           ;               
 016E           ;               CHILD_1_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 016E 7C0000            xcall _CHILD_1_TIMEOUT_EnableInt
 0171                   .dbline 281
 0171           ;               CHILD_1_TIMEOUT_Start();                        // Start the timer.
 0171 7C0000            xcall _CHILD_1_TIMEOUT_Start
 0174 20                pop X
 0175                   .dbline 284
 0175           ;               
 0175           ;               // Set the current state.
 0175           ;               STATE = RESPONSE_1;
 0175 62D000            mov REG[0xd0],>_STATE
 0178 550103            mov [_STATE+1],3
 017B 550000            mov [_STATE],0
 017E                   .dbline 285
 017E           ;       }
 017E 8122              xjmp L22
 0180           L21:
 0180                   .dbline 286
 0180           ;       else if(mode == RESPONSE_2)
 0180 3DFB00            cmp [X-5],0
 0183 B02A              jnz L23
 0185 3DFC04            cmp [X-4],4
 0188 B025              jnz L23
 018A           X7:
 018A                   .dbline 287
 018A           ;       {
 018A                   .dbline 289
 018A           ;               // Load the response wait on port 2.
 018A           ;               LoadConfig_response2();
 018A 7C0000            xcall _LoadConfig_response2
 018D                   .dbline 292
 018D           ;               
 018D           ;               // Clear the timeout flag.
 018D           ;               TIMEOUT = 0;
 018D 62D000            mov REG[0xd0],>_TIMEOUT
 0190 550100            mov [_TIMEOUT+1],0
 0193 550000            mov [_TIMEOUT],0
 0196                   .dbline 295
 0196           ;               
 0196           ;               // Start listening for a response through child port 2.
 0196           ;               CHILD_2_Start(CHILD_2_PARITY_NONE);
 0196 10                push X
 0197 5000              mov A,0
 0199 7C0000            xcall _CHILD_2_Start
 019C                   .dbline 297
 019C           ;               
 019C           ;               CHILD_2_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 019C 7C0000            xcall _CHILD_2_TIMEOUT_EnableInt
 019F                   .dbline 298
 019F           ;               CHILD_2_TIMEOUT_Start();                        // Start the timer.
 019F 7C0000            xcall _CHILD_2_TIMEOUT_Start
 01A2 20                pop X
 01A3                   .dbline 301
 01A3           ;               
 01A3           ;               // Set the current state.
 01A3           ;               STATE = RESPONSE_2;
 01A3 62D000            mov REG[0xd0],>_STATE
 01A6 550104            mov [_STATE+1],4
 01A9 550000            mov [_STATE],0
 01AC                   .dbline 302
 01AC           ;       }
 01AC 80F4              xjmp L24
 01AE           L23:
 01AE                   .dbline 303
 01AE           ;       else if(mode == RESPONSE_3)
 01AE 3DFB00            cmp [X-5],0
 01B1 B02A              jnz L25
 01B3 3DFC05            cmp [X-4],5
 01B6 B025              jnz L25
 01B8           X8:
 01B8                   .dbline 304
 01B8           ;       {
 01B8                   .dbline 306
 01B8           ;               // Load the response wait on port 3.
 01B8           ;               LoadConfig_response3();
 01B8 7C0000            xcall _LoadConfig_response3
 01BB                   .dbline 309
 01BB           ;               
 01BB           ;               // Clear the timeout flag.
 01BB           ;               TIMEOUT = 0;
 01BB 62D000            mov REG[0xd0],>_TIMEOUT
 01BE 550100            mov [_TIMEOUT+1],0
 01C1 550000            mov [_TIMEOUT],0
 01C4                   .dbline 312
 01C4           ;               
 01C4           ;               // Start listening for a response through child port 3.
 01C4           ;               CHILD_3_Start(CHILD_3_PARITY_NONE);
 01C4 10                push X
 01C5 5000              mov A,0
 01C7 7C0000            xcall _CHILD_3_Start
 01CA                   .dbline 314
 01CA           ;               
 01CA           ;               CHILD_3_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 01CA 7C0000            xcall _CHILD_3_TIMEOUT_EnableInt
 01CD                   .dbline 315
 01CD           ;               CHILD_3_TIMEOUT_Start();                        // Start the timer.
 01CD 7C0000            xcall _CHILD_3_TIMEOUT_Start
 01D0 20                pop X
 01D1                   .dbline 318
 01D1           ;               
 01D1           ;               // Set the current state.
 01D1           ;               STATE = RESPONSE_3;
 01D1 62D000            mov REG[0xd0],>_STATE
 01D4 550105            mov [_STATE+1],5
 01D7 550000            mov [_STATE],0
 01DA                   .dbline 319
 01DA           ;       }
 01DA 80C6              xjmp L26
 01DC           L25:
 01DC                   .dbline 320
 01DC           ;       else if(mode == RESPONSE_4)
 01DC 3DFB00            cmp [X-5],0
 01DF B02A              jnz L27
 01E1 3DFC06            cmp [X-4],6
 01E4 B025              jnz L27
 01E6           X9:
 01E6                   .dbline 321
 01E6           ;       {
 01E6                   .dbline 323
 01E6           ;               // Load the response wait on port 4.
 01E6           ;               LoadConfig_response4();
 01E6 7C0000            xcall _LoadConfig_response4
 01E9                   .dbline 326
 01E9           ;               
 01E9           ;               // Clear the timeout flag.
 01E9           ;               TIMEOUT = 0;
 01E9 62D000            mov REG[0xd0],>_TIMEOUT
 01EC 550100            mov [_TIMEOUT+1],0
 01EF 550000            mov [_TIMEOUT],0
 01F2                   .dbline 329
 01F2           ;               
 01F2           ;               // Start listening for a response through child port 4.
 01F2           ;               CHILD_4_Start(CHILD_4_PARITY_NONE);
 01F2 10                push X
 01F3 5000              mov A,0
 01F5 7C0000            xcall _CHILD_4_Start
 01F8                   .dbline 331
 01F8           ;               
 01F8           ;               CHILD_4_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 01F8 7C0000            xcall _CHILD_4_TIMEOUT_EnableInt
 01FB                   .dbline 332
 01FB           ;               CHILD_4_TIMEOUT_Start();                        // Start the timer.
 01FB 7C0000            xcall _CHILD_4_TIMEOUT_Start
 01FE 20                pop X
 01FF                   .dbline 335
 01FF           ;               
 01FF           ;               // Set the current state.
 01FF           ;               STATE = RESPONSE_4;
 01FF 62D000            mov REG[0xd0],>_STATE
 0202 550106            mov [_STATE+1],6
 0205 550000            mov [_STATE],0
 0208                   .dbline 336
 0208           ;       }
 0208 8098              xjmp L28
 020A           L27:
 020A                   .dbline 337
 020A           ;       else if(mode == HELLO_MODE)
 020A 3DFB00            cmp [X-5],0
 020D B03F              jnz L29
 020F 3DFC07            cmp [X-4],7
 0212 B03A              jnz L29
 0214           X10:
 0214                   .dbline 338
 0214           ;       {
 0214                   .dbline 340
 0214           ;               // Load the hello wait mode.  This is for listening on all ports for a hello response.
 0214           ;               LoadConfig_hello();
 0214 7C0000            xcall _LoadConfig_hello
 0217                   .dbline 343
 0217           ;               
 0217           ;               // Clear the timeout flag.
 0217           ;               TIMEOUT = 0;
 0217 62D000            mov REG[0xd0],>_TIMEOUT
 021A 550100            mov [_TIMEOUT+1],0
 021D 550000            mov [_TIMEOUT],0
 0220                   .dbline 347
 0220           ;               
 0220           ;               // The seemingly unnecessary brackets around each line are unfortunately needed.
 0220           ;       
 0220           ;               {
 0220                   .dbline 349
 0220           ;               // Start listening for a response through child port 1.
 0220           ;               HELLO_1_Start(HELLO_1_PARITY_NONE);
 0220 10                push X
 0221 5000              mov A,0
 0223 7C0000            xcall _HELLO_1_Start
 0226 20                pop X
 0227                   .dbline 350
 0227           ;               }
 0227                   .dbline 352
 0227           ;               
 0227           ;               {
 0227                   .dbline 354
 0227           ;               // Start listening for a response through child port 2.
 0227           ;               HELLO_2_Start(HELLO_2_PARITY_NONE);
 0227 10                push X
 0228 5000              mov A,0
 022A 7C0000            xcall _HELLO_2_Start
 022D 20                pop X
 022E                   .dbline 355
 022E           ;               }
 022E                   .dbline 357
 022E           ;               
 022E           ;               {
 022E                   .dbline 359
 022E           ;               // Start listening for a response through child port 3.
 022E           ;               HELLO_3_Start(HELLO_3_PARITY_NONE);
 022E 10                push X
 022F 5000              mov A,0
 0231 7C0000            xcall _HELLO_3_Start
 0234 20                pop X
 0235                   .dbline 360
 0235           ;               }
 0235                   .dbline 362
 0235           ;               
 0235           ;               {
 0235                   .dbline 364
 0235           ;               // Start listening for a response through child port 4.
 0235           ;               HELLO_4_Start(HELLO_4_PARITY_NONE);
 0235 10                push X
 0236 5000              mov A,0
 0238 7C0000            xcall _HELLO_4_Start
 023B                   .dbline 365
 023B           ;               }
 023B                   .dbline 367
 023B           ;               
 023B           ;               HELLO_TIMEOUT_EnableInt();      // Make sure interrupts are enabled.
 023B 7C0000            xcall _HELLO_TIMEOUT_EnableInt
 023E                   .dbline 368
 023E           ;               HELLO_TIMEOUT_Start();          // Start the timer.
 023E 7C0000            xcall _HELLO_TIMEOUT_Start
 0241 20                pop X
 0242                   .dbline 371
 0242           ;               
 0242           ;               // Set the current state.
 0242           ;               STATE = HELLO_MODE;
 0242 62D000            mov REG[0xd0],>_STATE
 0245 550107            mov [_STATE+1],7
 0248 550000            mov [_STATE],0
 024B                   .dbline 372
 024B           ;       }
 024B 8055              xjmp L30
 024D           L29:
 024D                   .dbline 373
 024D           ;       else if(mode == INITIALIZE)
 024D 3DFB00            cmp [X-5],0
 0250 B02A              jnz L31
 0252 3DFC08            cmp [X-4],8
 0255 B025              jnz L31
 0257           X11:
 0257                   .dbline 374
 0257           ;       {
 0257                   .dbline 376
 0257           ;               // Load the configuration for initialization.  This config listens but does not forward.
 0257           ;               LoadConfig_initial();
 0257 7C0000            xcall _LoadConfig_initial
 025A                   .dbline 379
 025A           ;               
 025A           ;               // Clear the timeout flag.
 025A           ;               TIMEOUT = 0;
 025A 62D000            mov REG[0xd0],>_TIMEOUT
 025D 550100            mov [_TIMEOUT+1],0
 0260 550000            mov [_TIMEOUT],0
 0263                   .dbline 382
 0263           ;               
 0263           ;               // Start the receiver.
 0263           ;               INIT_RX_Start(INIT_RX_PARITY_NONE);
 0263 10                push X
 0264 5000              mov A,0
 0266 7C0000            xcall _INIT_RX_Start
 0269                   .dbline 384
 0269           ;               
 0269           ;               INIT_TIMEOUT_EnableInt();       // Make sure interrupts are enabled.
 0269 7C0000            xcall _INIT_TIMEOUT_EnableInt
 026C                   .dbline 385
 026C           ;               INIT_TIMEOUT_Start();           // Start the timer.
 026C 7C0000            xcall _INIT_TIMEOUT_Start
 026F 20                pop X
 0270                   .dbline 388
 0270           ;               
 0270           ;               // Set the current state.
 0270           ;               STATE = INITIALIZE;
 0270 62D000            mov REG[0xd0],>_STATE
 0273 550108            mov [_STATE+1],8
 0276 550000            mov [_STATE],0
 0279                   .dbline 389
 0279           ;       }
 0279 8027              xjmp L32
 027B           L31:
 027B                   .dbline 390
 027B           ;       else if(mode == SERVO_COMM)
 027B 3DFB00            cmp [X-5],0
 027E B022              jnz L33
 0280 3DFC09            cmp [X-4],9
 0283 B01D              jnz L33
 0285           X12:
 0285                   .dbline 391
 0285           ;       {
 0285                   .dbline 393
 0285           ;               // Load the configuration for servo communication.  This config only transmits on P00.
 0285           ;               LoadConfig_servo_transmit();
 0285 7C0000            xcall _LoadConfig_servo_transmit
 0288                   .dbline 396
 0288           ;               
 0288           ;               // Clear the timeout flag.
 0288           ;               TIMEOUT = 0;
 0288 62D000            mov REG[0xd0],>_TIMEOUT
 028B 550100            mov [_TIMEOUT+1],0
 028E 550000            mov [_TIMEOUT],0
 0291                   .dbline 399
 0291           ;               
 0291           ;               // Start the transmitter.
 0291           ;               SERVO_TX_Start(SERVO_TX_PARITY_NONE);
 0291 10                push X
 0292 5000              mov A,0
 0294 7C0000            xcall _SERVO_TX_Start
 0297 20                pop X
 0298                   .dbline 402
 0298           ;       
 0298           ;               // Set the current state.
 0298           ;               STATE = SERVO_COMM;
 0298 62D000            mov REG[0xd0],>_STATE
 029B 550109            mov [_STATE+1],9
 029E 550000            mov [_STATE],0
 02A1                   .dbline 403
 02A1           ;       }
 02A1           L33:
 02A1           L32:
 02A1           L30:
 02A1           L28:
 02A1           L26:
 02A1           L24:
 02A1           L22:
 02A1           L17:
 02A1           L15:
 02A1                   .dbline 406
 02A1           ;       
 02A1           ;       // If this module is configured, talk on all pins for potential children.
 02A1           ;       if(CONFIGURED)
 02A1 62D000            mov REG[0xd0],>_CONFIGURED
 02A4 3C0000            cmp [_CONFIGURED],0
 02A7 B006              jnz X13
 02A9 3C0100            cmp [_CONFIGURED+1],0
 02AC A009              jz L35
 02AE           X13:
 02AE                   .dbline 407
 02AE           ;       {
 02AE                   .dbline 408
 02AE           ;               PRT0GS |= 0b00011111;   // Connect all pins to the global bus.
 02AE 43021F            or REG[0x2],31
 02B1                   .dbline 409
 02B1           ;               PRT2DR &= 0b11111110;   // Turn on the LED (active low).
 02B1 4108FE            and REG[0x8],-2
 02B4                   .dbline 410
 02B4           ;       }
 02B4 8007              xjmp L36
 02B6           L35:
 02B6                   .dbline 412
 02B6           ;       else
 02B6           ;       {
 02B6                   .dbline 413
 02B6           ;               PRT0GS |= 0b00000001;   // Just connect pin 0;
 02B6 430201            or REG[0x2],1
 02B9                   .dbline 414
 02B9           ;               PRT2DR |= 0b00000001;   // Turn off the LED (active low).
 02B9 430801            or REG[0x8],1
 02BC                   .dbline 415
 02BC           ;       }
 02BC           L36:
 02BC                   .dbline -2
 02BC           L11:
 02BC 20                pop X
 02BD                   .dbline 0 ; func end
 02BD 7F                ret
 02BE                   .dbsym l mode -5 I
 02BE                   .dbend
 02BE                   .dbfunc e commandReady _commandReady fI
 02BE           ;              i -> X+1
 02BE           ;       tempByte -> X+0
 02BE           _commandReady::
 02BE                   .dbline -1
 02BE 10                push X
 02BF 4F                mov X,SP
 02C0 3803              add SP,3
 02C2                   .dbline 422
 02C2           ; }
 02C2           ; 
 02C2           ; // This function tries to peek and see if a start byte has been written to the bus.
 02C2           ; // If there is no start byte, the function exits.  If a start byte is detected, the function
 02C2           ; // blocks and waits for the transmission to finish.
 02C2           ; int commandReady(void)
 02C2           ; {
 02C2                   .dbline 423
 02C2           ;       int i = 0;                      // This integer is used for looping through the remaining bytes of commands.
 02C2 560200            mov [X+2],0
 02C5 560100            mov [X+1],0
 02C8                   .dbline 424
 02C8           ;       char tempByte = 0;      // This byte is used to store each byte for comparison as it comes in.
 02C8 560000            mov [X+0],0
 02CB                   .dbline 428
 02CB           ;       
 02CB           ;       // This conditional checks which configuration is loaded and uses the proper devices to
 02CB           ;       // read a transmission and store the important information from that transmission.
 02CB           ;       if(STATE == WAIT)
 02CB 62D000            mov REG[0xd0],>_STATE
 02CE 3C0000            cmp [_STATE],0
 02D1 B0D4              jnz L38
 02D3 3C0101            cmp [_STATE+1],1
 02D6 B0CF              jnz L38
 02D8           X14:
 02D8                   .dbline 429
 02D8           ;       {       
 02D8                   .dbline 432
 02D8           ;               // In wait mode, the only thing that progresses things forward is a master node transmission.
 02D8           ;               // With this being the case, we use a blocking operation to sit and wait for a byte.
 02D8           ;               tempByte = WAIT_RECV_cGetChar();
 02D8 10                push X
 02D9 7C0000            xcall _WAIT_RECV_cGetChar
 02DC 62D000            mov REG[0xd0],>__r0
 02DF 20                pop X
 02E0 5400              mov [X+0],A
 02E2                   .dbline 435
 02E2           ;               
 02E2           ;               // If a transmission has started for either a controller or a servo...
 02E2           ;               if(tempByte == START_TRANSMIT)
 02E2 3D00FC            cmp [X+0],-4
 02E5 B047              jnz L40
 02E7                   .dbline 436
 02E7           ;               {
 02E7 800B              xjmp L43
 02E9           L42:
 02E9                   .dbline 439
 02E9           ;                       // While we keep reading start bytes, sit and spin.
 02E9           ;                       while(tempByte == START_TRANSMIT)
 02E9           ;                       {
 02E9                   .dbline 440
 02E9           ;                               tempByte = WAIT_RECV_cGetChar();
 02E9 10                push X
 02EA 7C0000            xcall _WAIT_RECV_cGetChar
 02ED 62D000            mov REG[0xd0],>__r0
 02F0 20                pop X
 02F1 5400              mov [X+0],A
 02F3                   .dbline 441
 02F3           ;                       }
 02F3           L43:
 02F3                   .dbline 438
 02F3 3D00FC            cmp [X+0],-4
 02F6 AFF2              jz L42
 02F8                   .dbline 444
 02F8           ;                       
 02F8           ;                       // The tempByte variable contains the source ID.  If the source is good, store all bytes.
 02F8           ;                       if(tempByte == MASTER_ID)
 02F8 3D0000            cmp [X+0],0
 02FB B397              jnz L39
 02FD                   .dbline 445
 02FD           ;                       {
 02FD                   .dbline 446
 02FD           ;                               COMMAND_SOURCE = tempByte;
 02FD 5200              mov A,[X+0]
 02FF 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0302 5300              mov [_COMMAND_SOURCE],A
 0304                   .dbline 447
 0304           ;                               COMMAND_DESTINATION = WAIT_RECV_cGetChar();
 0304 10                push X
 0305 7C0000            xcall _WAIT_RECV_cGetChar
 0308 20                pop X
 0309 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 030C 5300              mov [_COMMAND_DESTINATION],A
 030E                   .dbline 448
 030E           ;                               COMMAND_TYPE = WAIT_RECV_cGetChar();
 030E 10                push X
 030F 7C0000            xcall _WAIT_RECV_cGetChar
 0312 20                pop X
 0313 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0316 5300              mov [_COMMAND_TYPE],A
 0318                   .dbline 449
 0318           ;                               COMMAND_PARAM = WAIT_RECV_cGetChar();
 0318 10                push X
 0319 7C0000            xcall _WAIT_RECV_cGetChar
 031C 20                pop X
 031D 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0320 5300              mov [_COMMAND_PARAM],A
 0322                   .dbline 451
 0322           ;                               
 0322           ;                               return 1;
 0322 62D000            mov REG[0xd0],>__r0
 0325 550001            mov [__r1],1
 0328 550000            mov [__r0],0
 032B 8370              xjmp L37
 032D           L40:
 032D                   .dbline 454
 032D           ;                       }
 032D           ;               }
 032D           ;               else if(tempByte == SERVO_START)
 032D 3D00FF            cmp [X+0],-1
 0330 B362              jnz L39
 0332                   .dbline 455
 0332           ;               {
 0332 800B              xjmp L50
 0334           L49:
 0334                   .dbline 458
 0334           ;                       // While we keep reading start bytes, sit and spin.
 0334           ;                       while(tempByte == SERVO_START)
 0334           ;                       {
 0334                   .dbline 459
 0334           ;                               tempByte = WAIT_RECV_cGetChar();
 0334 10                push X
 0335 7C0000            xcall _WAIT_RECV_cGetChar
 0338 62D000            mov REG[0xd0],>__r0
 033B 20                pop X
 033C 5400              mov [X+0],A
 033E                   .dbline 460
 033E           ;                       }
 033E           L50:
 033E                   .dbline 457
 033E 3D00FF            cmp [X+0],-1
 0341 AFF2              jz L49
 0343                   .dbline 463
 0343           ;                       
 0343           ;                       // We assume (and hopefully rightly so) that this is a command from master.
 0343           ;                       COMMAND_SOURCE = MASTER_ID;
 0343 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0346 550000            mov [_COMMAND_SOURCE],0
 0349                   .dbline 465
 0349           ;                       // The first parameter after the servo start is the destination.
 0349           ;                       COMMAND_DESTINATION = tempByte;
 0349 5200              mov A,[X+0]
 034B 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 034E 5300              mov [_COMMAND_DESTINATION],A
 0350                   .dbline 470
 0350           ;                       // The second parameter after the servo start is the command length.
 0350           ;                       // We don't need it to wait for the transmission to go through since the
 0350           ;                       // transmission goes through the chip with a delay of approximately 100 ns
 0350           ;                       // (it is already in and out by the time you read this byte).
 0350           ;                       tempByte = WAIT_RECV_cGetChar();
 0350 10                push X
 0351 7C0000            xcall _WAIT_RECV_cGetChar
 0354 62D000            mov REG[0xd0],>__r0
 0357 20                pop X
 0358 5400              mov [X+0],A
 035A                   .dbline 473
 035A           ;                       // Now we store the command type.  Depending on what the status return level
 035A           ;                       // is, we have special duties.
 035A           ;                       COMMAND_TYPE = WAIT_RECV_cGetChar();
 035A 10                push X
 035B 7C0000            xcall _WAIT_RECV_cGetChar
 035E 20                pop X
 035F 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0362 5300              mov [_COMMAND_TYPE],A
 0364                   .dbline 476
 0364           ;                       
 0364           ;                       // This basically waits for the rest of the command to pass through.
 0364           ;                       for(i = 0; i < (tempByte - 1); i++)
 0364 560200            mov [X+2],0
 0367 560100            mov [X+1],0
 036A 800E              xjmp L55
 036C           L52:
 036C                   .dbline 477
 036C           ;                       {
 036C                   .dbline 478
 036C           ;                               WAIT_RECV_cGetChar();
 036C 10                push X
 036D 7C0000            xcall _WAIT_RECV_cGetChar
 0370 62D000            mov REG[0xd0],>__r0
 0373 20                pop X
 0374                   .dbline 479
 0374           ;                       }
 0374           L53:
 0374                   .dbline 476
 0374 7702              inc [X+2]
 0376 0F0100            adc [X+1],0
 0379           L55:
 0379                   .dbline 476
 0379 62D000            mov REG[0xd0],>__r0
 037C 5200              mov A,[X+0]
 037E 5300              mov [__r1],A
 0380 550000            mov [__r0],0
 0383 160001            sub [__r1],1
 0386 1E0000            sbb [__r0],0
 0389 5202              mov A,[X+2]
 038B 1200              sub A,[__r1]
 038D 5100              mov A,[__r0]
 038F 3180              xor A,-128
 0391 5300              mov [__rX],A
 0393 5201              mov A,[X+1]
 0395 3180              xor A,-128
 0397 1A00              sbb A,[__rX]
 0399 CFD2              jc L52
 039B           X15:
 039B                   .dbline 481
 039B           ;                               
 039B           ;                       return 1;
 039B 62D000            mov REG[0xd0],>__r0
 039E 550001            mov [__r1],1
 03A1 550000            mov [__r0],0
 03A4 82F7              xjmp L37
 03A6           L38:
 03A6                   .dbline 484
 03A6           ;               }
 03A6           ;       }
 03A6           ;       else if(STATE == HELLO_MODE)
 03A6 62D000            mov REG[0xd0],>_STATE
 03A9 3C0000            cmp [_STATE],0
 03AC B06E              jnz L56
 03AE 3C0107            cmp [_STATE+1],7
 03B1 B069              jnz L56
 03B3           X16:
 03B3                   .dbline 485
 03B3           ;       {
 03B3                   .dbline 487
 03B3           ;               // Check all of the ports for a start byte.  Only one port will produce one.
 03B3           ;               if(HELLO_1_cReadChar() == START_TRANSMIT)
 03B3 10                push X
 03B4 7C0000            xcall _HELLO_1_cReadChar
 03B7 20                pop X
 03B8 39FC              cmp A,-4
 03BA B012              jnz L58
 03BC                   .dbline 488
 03BC           ;               {               
 03BC                   .dbline 489
 03BC           ;                       CHILD = PORT_A;
 03BC 62D000            mov REG[0xd0],>_CHILD
 03BF 550041            mov [_CHILD],65
 03C2                   .dbline 491
 03C2           ;                       
 03C2           ;                       return 1;
 03C2 62D000            mov REG[0xd0],>__r0
 03C5 550001            mov [__r1],1
 03C8 550000            mov [__r0],0
 03CB 82D0              xjmp L37
 03CD           L58:
 03CD                   .dbline 493
 03CD           ;               }
 03CD           ;               else if(HELLO_2_cReadChar() == START_TRANSMIT)
 03CD 10                push X
 03CE 7C0000            xcall _HELLO_2_cReadChar
 03D1 20                pop X
 03D2 39FC              cmp A,-4
 03D4 B012              jnz L60
 03D6                   .dbline 494
 03D6           ;               {               
 03D6                   .dbline 495
 03D6           ;                       CHILD = PORT_B;
 03D6 62D000            mov REG[0xd0],>_CHILD
 03D9 550042            mov [_CHILD],66
 03DC                   .dbline 497
 03DC           ;                       
 03DC           ;                       return 1;
 03DC 62D000            mov REG[0xd0],>__r0
 03DF 550001            mov [__r1],1
 03E2 550000            mov [__r0],0
 03E5 82B6              xjmp L37
 03E7           L60:
 03E7                   .dbline 499
 03E7           ;               }
 03E7           ;               else if(HELLO_3_cReadChar() == START_TRANSMIT)
 03E7 10                push X
 03E8 7C0000            xcall _HELLO_3_cReadChar
 03EB 20                pop X
 03EC 39FC              cmp A,-4
 03EE B012              jnz L62
 03F0                   .dbline 500
 03F0           ;               {
 03F0                   .dbline 501
 03F0           ;                       CHILD = PORT_C;
 03F0 62D000            mov REG[0xd0],>_CHILD
 03F3 550043            mov [_CHILD],67
 03F6                   .dbline 503
 03F6           ;                       
 03F6           ;                       return 1;
 03F6 62D000            mov REG[0xd0],>__r0
 03F9 550001            mov [__r1],1
 03FC 550000            mov [__r0],0
 03FF 829C              xjmp L37
 0401           L62:
 0401                   .dbline 505
 0401           ;               }
 0401           ;               else if(HELLO_4_cReadChar() == START_TRANSMIT)
 0401 10                push X
 0402 7C0000            xcall _HELLO_4_cReadChar
 0405 20                pop X
 0406 39FC              cmp A,-4
 0408 B28A              jnz L57
 040A                   .dbline 506
 040A           ;               {
 040A                   .dbline 507
 040A           ;                       CHILD = PORT_D;
 040A 62D000            mov REG[0xd0],>_CHILD
 040D 550044            mov [_CHILD],68
 0410                   .dbline 509
 0410           ;                       
 0410           ;                       return 1;
 0410 62D000            mov REG[0xd0],>__r0
 0413 550001            mov [__r1],1
 0416 550000            mov [__r0],0
 0419 8282              xjmp L37
 041B           L56:
 041B                   .dbline 512
 041B           ;               }
 041B           ;       }
 041B           ;       else if(STATE == RESPONSE_1)
 041B 62D000            mov REG[0xd0],>_STATE
 041E 3C0000            cmp [_STATE],0
 0421 B081              jnz L66
 0423 3C0103            cmp [_STATE+1],3
 0426 B07C              jnz L66
 0428           X17:
 0428                   .dbline 513
 0428           ;       {
 0428                   .dbline 514
 0428           ;               if(tempByte = CHILD_1_cReadChar())
 0428 10                push X
 0429 7C0000            xcall _CHILD_1_cReadChar
 042C 62D000            mov REG[0xd0],>__r0
 042F 20                pop X
 0430 5400              mov [X+0],A
 0432 3900              cmp A,0
 0434 A25E              jz L67
 0436                   .dbline 515
 0436           ;               {
 0436                   .dbline 516
 0436           ;                       if(tempByte == SERVO_START)                             // We have a servo response coming.
 0436 3D00FF            cmp [X+0],-1
 0439 B050              jnz L70
 043B                   .dbline 517
 043B           ;                       {
 043B           L72:
 043B                   .dbline 519
 043B           ;                               // Burn through the rest of the start bytes and the servo length.
 043B           ;                               while(CHILD_1_cGetChar() == SERVO_START) { }
 043B                   .dbline 519
 043B           L73:
 043B                   .dbline 519
 043B 10                push X
 043C 7C0000            xcall _CHILD_1_cGetChar
 043F 62D000            mov REG[0xd0],>__r0
 0442 20                pop X
 0443 39FF              cmp A,-1
 0445 AFF5              jz L72
 0447                   .dbline 522
 0447           ;                               
 0447           ;                               // We store the length, since it is the next byte from the servo.
 0447           ;                               tempByte = CHILD_1_cGetChar();
 0447 10                push X
 0448 7C0000            xcall _CHILD_1_cGetChar
 044B 62D000            mov REG[0xd0],>__r0
 044E 20                pop X
 044F 5400              mov [X+0],A
 0451                   .dbline 525
 0451           ;                               
 0451           ;                               // This basically waits for the rest of the command to pass through.
 0451           ;                               for(i = 0; i < tempByte; i++)
 0451 560200            mov [X+2],0
 0454 560100            mov [X+1],0
 0457 800E              xjmp L78
 0459           L75:
 0459                   .dbline 526
 0459           ;                               {
 0459                   .dbline 527
 0459           ;                                       CHILD_1_cGetChar();
 0459 10                push X
 045A 7C0000            xcall _CHILD_1_cGetChar
 045D 62D000            mov REG[0xd0],>__r0
 0460 20                pop X
 0461                   .dbline 528
 0461           ;                               }
 0461           L76:
 0461                   .dbline 525
 0461 7702              inc [X+2]
 0463 0F0100            adc [X+1],0
 0466           L78:
 0466                   .dbline 525
 0466 62D000            mov REG[0xd0],>__r0
 0469 5200              mov A,[X+0]
 046B 5300              mov [__r1],A
 046D 5202              mov A,[X+2]
 046F 1200              sub A,[__r1]
 0471 5000              mov A,0
 0473 3180              xor A,-128
 0475 5300              mov [__rX],A
 0477 5201              mov A,[X+1]
 0479 3180              xor A,-128
 047B 1A00              sbb A,[__rX]
 047D CFDB              jc L75
 047F           X18:
 047F                   .dbline 530
 047F           ;                               
 047F           ;                               return 1;
 047F 62D000            mov REG[0xd0],>__r0
 0482 550001            mov [__r1],1
 0485 550000            mov [__r0],0
 0488 8213              xjmp L37
 048A           L70:
 048A                   .dbline 532
 048A           ;                       }
 048A           ;                       else if (tempByte == START_TRANSMIT)    // We have a controller response coming.
 048A 3D00FC            cmp [X+0],-4
 048D B205              jnz L67
 048F                   .dbline 533
 048F           ;                       {
 048F           L81:
 048F                   .dbline 535
 048F           ;                               // We simply wait for the end transmit indicator.
 048F           ;                               while(CHILD_1_cGetChar() != END_TRANSMIT) { }
 048F                   .dbline 535
 048F           L82:
 048F                   .dbline 535
 048F 10                push X
 0490 7C0000            xcall _CHILD_1_cGetChar
 0493 62D000            mov REG[0xd0],>__r0
 0496 20                pop X
 0497 39FD              cmp A,-3
 0499 BFF5              jnz L81
 049B                   .dbline 537
 049B           ;                               
 049B           ;                               return 1;
 049B 550001            mov [__r1],1
 049E 550000            mov [__r0],0
 04A1 81FA              xjmp L37
 04A3           L66:
 04A3                   .dbline 541
 04A3           ;                       }
 04A3           ;               }
 04A3           ;       }
 04A3           ;       else if(STATE == RESPONSE_2)
 04A3 62D000            mov REG[0xd0],>_STATE
 04A6 3C0000            cmp [_STATE],0
 04A9 B081              jnz L84
 04AB 3C0104            cmp [_STATE+1],4
 04AE B07C              jnz L84
 04B0           X19:
 04B0                   .dbline 542
 04B0           ;       {
 04B0                   .dbline 543
 04B0           ;               if(tempByte = CHILD_2_cReadChar())
 04B0 10                push X
 04B1 7C0000            xcall _CHILD_2_cReadChar
 04B4 62D000            mov REG[0xd0],>__r0
 04B7 20                pop X
 04B8 5400              mov [X+0],A
 04BA 3900              cmp A,0
 04BC A1D6              jz L85
 04BE                   .dbline 544
 04BE           ;               {
 04BE                   .dbline 545
 04BE           ;                       if(tempByte == SERVO_START)                             // We have a servo response coming.
 04BE 3D00FF            cmp [X+0],-1
 04C1 B050              jnz L88
 04C3                   .dbline 546
 04C3           ;                       {
 04C3           L90:
 04C3                   .dbline 548
 04C3           ;                               // Burn through the rest of the start bytes and the servo length.
 04C3           ;                               while(CHILD_2_cGetChar() == SERVO_START) { }
 04C3                   .dbline 548
 04C3           L91:
 04C3                   .dbline 548
 04C3 10                push X
 04C4 7C0000            xcall _CHILD_2_cGetChar
 04C7 62D000            mov REG[0xd0],>__r0
 04CA 20                pop X
 04CB 39FF              cmp A,-1
 04CD AFF5              jz L90
 04CF                   .dbline 551
 04CF           ;                               
 04CF           ;                               // We store the length, since it is the next byte from the servo.
 04CF           ;                               tempByte = CHILD_2_cGetChar();
 04CF 10                push X
 04D0 7C0000            xcall _CHILD_2_cGetChar
 04D3 62D000            mov REG[0xd0],>__r0
 04D6 20                pop X
 04D7 5400              mov [X+0],A
 04D9                   .dbline 554
 04D9           ;                               
 04D9           ;                               // This basically waits for the rest of the command to pass through.
 04D9           ;                               for(i = 0; i < tempByte; i++)
 04D9 560200            mov [X+2],0
 04DC 560100            mov [X+1],0
 04DF 800E              xjmp L96
 04E1           L93:
 04E1                   .dbline 555
 04E1           ;                               {
 04E1                   .dbline 556
 04E1           ;                                       CHILD_2_cGetChar();
 04E1 10                push X
 04E2 7C0000            xcall _CHILD_2_cGetChar
 04E5 62D000            mov REG[0xd0],>__r0
 04E8 20                pop X
 04E9                   .dbline 557
 04E9           ;                               }
 04E9           L94:
 04E9                   .dbline 554
 04E9 7702              inc [X+2]
 04EB 0F0100            adc [X+1],0
 04EE           L96:
 04EE                   .dbline 554
 04EE 62D000            mov REG[0xd0],>__r0
 04F1 5200              mov A,[X+0]
 04F3 5300              mov [__r1],A
 04F5 5202              mov A,[X+2]
 04F7 1200              sub A,[__r1]
 04F9 5000              mov A,0
 04FB 3180              xor A,-128
 04FD 5300              mov [__rX],A
 04FF 5201              mov A,[X+1]
 0501 3180              xor A,-128
 0503 1A00              sbb A,[__rX]
 0505 CFDB              jc L93
 0507           X20:
 0507                   .dbline 559
 0507           ;                               
 0507           ;                               return 1;
 0507 62D000            mov REG[0xd0],>__r0
 050A 550001            mov [__r1],1
 050D 550000            mov [__r0],0
 0510 818B              xjmp L37
 0512           L88:
 0512                   .dbline 561
 0512           ;                       }
 0512           ;                       else if (tempByte == START_TRANSMIT)    // We have a controller response coming.
 0512 3D00FC            cmp [X+0],-4
 0515 B17D              jnz L85
 0517                   .dbline 562
 0517           ;                       {
 0517           L99:
 0517                   .dbline 564
 0517           ;                               // We simply wait for the end transmit indicator.
 0517           ;                               while(CHILD_2_cGetChar() != END_TRANSMIT) { }
 0517                   .dbline 564
 0517           L100:
 0517                   .dbline 564
 0517 10                push X
 0518 7C0000            xcall _CHILD_2_cGetChar
 051B 62D000            mov REG[0xd0],>__r0
 051E 20                pop X
 051F 39FD              cmp A,-3
 0521 BFF5              jnz L99
 0523                   .dbline 566
 0523           ;                               
 0523           ;                               return 1;
 0523 550001            mov [__r1],1
 0526 550000            mov [__r0],0
 0529 8172              xjmp L37
 052B           L84:
 052B                   .dbline 570
 052B           ;                       }
 052B           ;               }
 052B           ;       }
 052B           ;       else if(STATE == RESPONSE_3)
 052B 62D000            mov REG[0xd0],>_STATE
 052E 3C0000            cmp [_STATE],0
 0531 B081              jnz L102
 0533 3C0105            cmp [_STATE+1],5
 0536 B07C              jnz L102
 0538           X21:
 0538                   .dbline 571
 0538           ;       {
 0538                   .dbline 572
 0538           ;               if(tempByte = CHILD_3_cReadChar())
 0538 10                push X
 0539 7C0000            xcall _CHILD_3_cReadChar
 053C 62D000            mov REG[0xd0],>__r0
 053F 20                pop X
 0540 5400              mov [X+0],A
 0542 3900              cmp A,0
 0544 A14E              jz L103
 0546                   .dbline 573
 0546           ;               {
 0546                   .dbline 574
 0546           ;                       if(tempByte == SERVO_START)                             // We have a servo response coming.
 0546 3D00FF            cmp [X+0],-1
 0549 B050              jnz L106
 054B                   .dbline 575
 054B           ;                       {
 054B           L108:
 054B                   .dbline 577
 054B           ;                               // Burn through the rest of the start bytes and the servo length.
 054B           ;                               while(CHILD_3_cGetChar() == SERVO_START) { }
 054B                   .dbline 577
 054B           L109:
 054B                   .dbline 577
 054B 10                push X
 054C 7C0000            xcall _CHILD_3_cGetChar
 054F 62D000            mov REG[0xd0],>__r0
 0552 20                pop X
 0553 39FF              cmp A,-1
 0555 AFF5              jz L108
 0557                   .dbline 580
 0557           ;                               
 0557           ;                               // We store the length, since it is the next byte from the servo.
 0557           ;                               tempByte = CHILD_3_cGetChar();
 0557 10                push X
 0558 7C0000            xcall _CHILD_3_cGetChar
 055B 62D000            mov REG[0xd0],>__r0
 055E 20                pop X
 055F 5400              mov [X+0],A
 0561                   .dbline 583
 0561           ;                               
 0561           ;                               // This basically waits for the rest of the command to pass through.
 0561           ;                               for(i = 0; i < tempByte; i++)
 0561 560200            mov [X+2],0
 0564 560100            mov [X+1],0
 0567 800E              xjmp L114
 0569           L111:
 0569                   .dbline 584
 0569           ;                               {
 0569                   .dbline 585
 0569           ;                                       CHILD_3_cGetChar();
 0569 10                push X
 056A 7C0000            xcall _CHILD_3_cGetChar
 056D 62D000            mov REG[0xd0],>__r0
 0570 20                pop X
 0571                   .dbline 586
 0571           ;                               }
 0571           L112:
 0571                   .dbline 583
 0571 7702              inc [X+2]
 0573 0F0100            adc [X+1],0
 0576           L114:
 0576                   .dbline 583
 0576 62D000            mov REG[0xd0],>__r0
 0579 5200              mov A,[X+0]
 057B 5300              mov [__r1],A
 057D 5202              mov A,[X+2]
 057F 1200              sub A,[__r1]
 0581 5000              mov A,0
 0583 3180              xor A,-128
 0585 5300              mov [__rX],A
 0587 5201              mov A,[X+1]
 0589 3180              xor A,-128
 058B 1A00              sbb A,[__rX]
 058D CFDB              jc L111
 058F           X22:
 058F                   .dbline 588
 058F           ;                               
 058F           ;                               return 1;
 058F 62D000            mov REG[0xd0],>__r0
 0592 550001            mov [__r1],1
 0595 550000            mov [__r0],0
 0598 8103              xjmp L37
 059A           L106:
 059A                   .dbline 590
 059A           ;                       }
 059A           ;                       else if (tempByte == START_TRANSMIT)    // We have a controller response coming.
 059A 3D00FC            cmp [X+0],-4
 059D B0F5              jnz L103
 059F                   .dbline 591
 059F           ;                       {
 059F           L117:
 059F                   .dbline 593
 059F           ;                               // We simply wait for the end transmit indicator.
 059F           ;                               while(CHILD_3_cGetChar() != END_TRANSMIT) { }
 059F                   .dbline 593
 059F           L118:
 059F                   .dbline 593
 059F 10                push X
 05A0 7C0000            xcall _CHILD_3_cGetChar
 05A3 62D000            mov REG[0xd0],>__r0
 05A6 20                pop X
 05A7 39FD              cmp A,-3
 05A9 BFF5              jnz L117
 05AB                   .dbline 595
 05AB           ;                               
 05AB           ;                               return 1;
 05AB 550001            mov [__r1],1
 05AE 550000            mov [__r0],0
 05B1 80EA              xjmp L37
 05B3           L102:
 05B3                   .dbline 599
 05B3           ;                       }
 05B3           ;               }
 05B3           ;       }
 05B3           ;       else if(STATE == RESPONSE_4)
 05B3 62D000            mov REG[0xd0],>_STATE
 05B6 3C0000            cmp [_STATE],0
 05B9 B081              jnz L120
 05BB 3C0106            cmp [_STATE+1],6
 05BE B07C              jnz L120
 05C0           X23:
 05C0                   .dbline 600
 05C0           ;       {
 05C0                   .dbline 601
 05C0           ;               if(tempByte = CHILD_4_cReadChar())
 05C0 10                push X
 05C1 7C0000            xcall _CHILD_4_cReadChar
 05C4 62D000            mov REG[0xd0],>__r0
 05C7 20                pop X
 05C8 5400              mov [X+0],A
 05CA 3900              cmp A,0
 05CC A0C6              jz L121
 05CE                   .dbline 602
 05CE           ;               {
 05CE                   .dbline 603
 05CE           ;                       if(tempByte == SERVO_START)                             // We have a servo response coming.
 05CE 3D00FF            cmp [X+0],-1
 05D1 B050              jnz L124
 05D3                   .dbline 604
 05D3           ;                       {
 05D3           L126:
 05D3                   .dbline 606
 05D3           ;                               // Burn through the rest of the start bytes and the servo length.
 05D3           ;                               while(CHILD_4_cGetChar() == SERVO_START) { }
 05D3                   .dbline 606
 05D3           L127:
 05D3                   .dbline 606
 05D3 10                push X
 05D4 7C0000            xcall _CHILD_4_cGetChar
 05D7 62D000            mov REG[0xd0],>__r0
 05DA 20                pop X
 05DB 39FF              cmp A,-1
 05DD AFF5              jz L126
 05DF                   .dbline 609
 05DF           ;                               
 05DF           ;                               // We store the length, since it is the next byte from the servo.
 05DF           ;                               tempByte = CHILD_4_cGetChar();
 05DF 10                push X
 05E0 7C0000            xcall _CHILD_4_cGetChar
 05E3 62D000            mov REG[0xd0],>__r0
 05E6 20                pop X
 05E7 5400              mov [X+0],A
 05E9                   .dbline 612
 05E9           ;                               
 05E9           ;                               // This basically waits for the rest of the command to pass through.
 05E9           ;                               for(i = 0; i < tempByte; i++)
 05E9 560200            mov [X+2],0
 05EC 560100            mov [X+1],0
 05EF 800E              xjmp L132
 05F1           L129:
 05F1                   .dbline 613
 05F1           ;                               {
 05F1                   .dbline 614
 05F1           ;                                       CHILD_4_cGetChar();
 05F1 10                push X
 05F2 7C0000            xcall _CHILD_4_cGetChar
 05F5 62D000            mov REG[0xd0],>__r0
 05F8 20                pop X
 05F9                   .dbline 615
 05F9           ;                               }
 05F9           L130:
 05F9                   .dbline 612
 05F9 7702              inc [X+2]
 05FB 0F0100            adc [X+1],0
 05FE           L132:
 05FE                   .dbline 612
 05FE 62D000            mov REG[0xd0],>__r0
 0601 5200              mov A,[X+0]
 0603 5300              mov [__r1],A
 0605 5202              mov A,[X+2]
 0607 1200              sub A,[__r1]
 0609 5000              mov A,0
 060B 3180              xor A,-128
 060D 5300              mov [__rX],A
 060F 5201              mov A,[X+1]
 0611 3180              xor A,-128
 0613 1A00              sbb A,[__rX]
 0615 CFDB              jc L129
 0617           X24:
 0617                   .dbline 617
 0617           ;                               
 0617           ;                               return 1;
 0617 62D000            mov REG[0xd0],>__r0
 061A 550001            mov [__r1],1
 061D 550000            mov [__r0],0
 0620 807B              xjmp L37
 0622           L124:
 0622                   .dbline 619
 0622           ;                       }
 0622           ;                       else if (tempByte == START_TRANSMIT)    // We have a controller response coming.
 0622 3D00FC            cmp [X+0],-4
 0625 B06D              jnz L121
 0627                   .dbline 620
 0627           ;                       {
 0627           L135:
 0627                   .dbline 622
 0627           ;                               // We simply wait for the end transmit indicator.
 0627           ;                               while(CHILD_4_cGetChar() != END_TRANSMIT) { }
 0627                   .dbline 622
 0627           L136:
 0627                   .dbline 622
 0627 10                push X
 0628 7C0000            xcall _CHILD_4_cGetChar
 062B 62D000            mov REG[0xd0],>__r0
 062E 20                pop X
 062F 39FD              cmp A,-3
 0631 BFF5              jnz L135
 0633                   .dbline 624
 0633           ;                               
 0633           ;                               return 1;
 0633 550001            mov [__r1],1
 0636 550000            mov [__r0],0
 0639 8062              xjmp L37
 063B           L120:
 063B                   .dbline 628
 063B           ;                       }
 063B           ;               }
 063B           ;       }
 063B           ;       else if(STATE == INITIALIZE)
 063B 62D000            mov REG[0xd0],>_STATE
 063E 3C0000            cmp [_STATE],0
 0641 B051              jnz L138
 0643 3C0108            cmp [_STATE+1],8
 0646 B04C              jnz L138
 0648           X25:
 0648                   .dbline 629
 0648           ;       {
 0648                   .dbline 630
 0648           ;               if(INIT_RX_cReadChar() == SERVO_START)
 0648 10                push X
 0649 7C0000            xcall _INIT_RX_cReadChar
 064C 62D000            mov REG[0xd0],>__r0
 064F 20                pop X
 0650 39FF              cmp A,-1
 0652 B040              jnz L140
 0654                   .dbline 631
 0654           ;               {
 0654                   .dbline 633
 0654           ;                       // We officially have a transmission.
 0654           ;                       if(INIT_RX_cGetChar() == SERVO_START)
 0654 10                push X
 0655 7C0000            xcall _INIT_RX_cGetChar
 0658 62D000            mov REG[0xd0],>__r0
 065B 20                pop X
 065C 39FF              cmp A,-1
 065E B034              jnz L142
 0660                   .dbline 634
 0660           ;                       {
 0660                   .dbline 637
 0660           ;                               // If we definitely have a transmission starting, grab all bytes from the rx buffer
 0660           ;                               // and store them in the proper variables for actions to be taken later.
 0660           ;                               COMMAND_SOURCE = INIT_RX_cGetChar();
 0660 10                push X
 0661 7C0000            xcall _INIT_RX_cGetChar
 0664 20                pop X
 0665 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0668 5300              mov [_COMMAND_SOURCE],A
 066A                   .dbline 638
 066A           ;                               COMMAND_LENGTH = INIT_RX_cGetChar();
 066A 10                push X
 066B 7C0000            xcall _INIT_RX_cGetChar
 066E 20                pop X
 066F 62D000            mov REG[0xd0],>_COMMAND_LENGTH
 0672 5300              mov [_COMMAND_LENGTH],A
 0674                   .dbline 639
 0674           ;                               COMMAND_ERROR = INIT_RX_cGetChar();
 0674 10                push X
 0675 7C0000            xcall _INIT_RX_cGetChar
 0678 20                pop X
 0679 62D000            mov REG[0xd0],>_COMMAND_ERROR
 067C 5300              mov [_COMMAND_ERROR],A
 067E                   .dbline 640
 067E           ;                               COMMAND_PARAM = INIT_RX_cGetChar();
 067E 10                push X
 067F 7C0000            xcall _INIT_RX_cGetChar
 0682 20                pop X
 0683 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0686 5300              mov [_COMMAND_PARAM],A
 0688                   .dbline 642
 0688           ;                               
 0688           ;                               return 1;
 0688 62D000            mov REG[0xd0],>__r0
 068B 550001            mov [__r1],1
 068E 550000            mov [__r0],0
 0691 800A              xjmp L37
 0693           L142:
 0693                   .dbline 644
 0693           ;                       }
 0693           ;               }
 0693           L140:
 0693                   .dbline 645
 0693           ;       }
 0693           L138:
 0693           L121:
 0693           L103:
 0693           L85:
 0693           L67:
 0693           L57:
 0693           L39:
 0693                   .dbline 647
 0693           ;       
 0693           ;       return 0;
 0693 62D000            mov REG[0xd0],>__r0
 0696 550000            mov [__r1],0
 0699 550000            mov [__r0],0
 069C                   .dbline -2
 069C           L37:
 069C 38FD              add SP,-3
 069E 20                pop X
 069F                   .dbline 0 ; func end
 069F 7F                ret
 06A0                   .dbsym l i 1 I
 06A0                   .dbsym l tempByte 0 c
 06A0                   .dbend
 06A0                   .dbfunc e takeAction _takeAction fV
 06A0           ;              j -> X+4
 06A0           ;              i -> X+2
 06A0           ;              i -> X+0
 06A0           _takeAction::
 06A0                   .dbline -1
 06A0 10                push X
 06A1 4F                mov X,SP
 06A2 3806              add SP,6
 06A4                   .dbline 653
 06A4           ; }
 06A4           ; 
 06A4           ; // This function interprets what has been read by the command ready function
 06A4           ; // and performs the appropriate action.
 06A4           ; void takeAction(void)
 06A4           ; {
 06A4                   .dbline 654
 06A4           ;       int i = 0;                                                      // An index variable for looping.
 06A4 560100            mov [X+1],0
 06A7 560000            mov [X+0],0
 06AA                   .dbline 656
 06AA           ;       
 06AA           ;       if(COMMAND_TYPE == HELLO_BYTE)          // The master is probing for new modules.
 06AA 62D000            mov REG[0xd0],>_COMMAND_TYPE
 06AD 3C00C8            cmp [_COMMAND_TYPE],-56
 06B0 B039              jnz L145
 06B2                   .dbline 657
 06B2           ;       {
 06B2                   .dbline 658
 06B2           ;               if(!CONFIGURED)
 06B2 62D000            mov REG[0xd0],>_CONFIGURED
 06B5 3C0000            cmp [_CONFIGURED],0
 06B8 B00A              jnz L147
 06BA 3C0100            cmp [_CONFIGURED+1],0
 06BD B005              jnz L147
 06BF           X26:
 06BF                   .dbline 659
 06BF           ;               {
 06BF                   .dbline 661
 06BF           ;                       // Announce this module's presence if not configured.
 06BF           ;                       sayHello();
 06BF 998E              xcall _sayHello
 06C1                   .dbline 662
 06C1           ;               }
 06C1 820D              xjmp L146
 06C3           L147:
 06C3                   .dbline 663
 06C3           ;               else if(!CHILD)
 06C3 62D000            mov REG[0xd0],>_CHILD
 06C6 3C0000            cmp [_CHILD],0
 06C9 B014              jnz L149
 06CB                   .dbline 664
 06CB           ;               {
 06CB                   .dbline 666
 06CB           ;                       // Listen for children if we have none.
 06CB           ;                       if(childListen())
 06CB 9488              xcall _childListen
 06CD 62D000            mov REG[0xd0],>__r0
 06D0 3C0000            cmp [__r0],0
 06D3 B006              jnz X27
 06D5 3C0000            cmp [__r1],0
 06D8 A1F6              jz L146
 06DA           X27:
 06DA                   .dbline 667
 06DA           ;                       {
 06DA                   .dbline 669
 06DA           ;                               // If a child was heard saying hello, forward the command with the port number added.
 06DA           ;                               sayHello();
 06DA 9973              xcall _sayHello
 06DC                   .dbline 670
 06DC           ;                       }
 06DC                   .dbline 671
 06DC           ;               }
 06DC 81F2              xjmp L146
 06DE           L149:
 06DE                   .dbline 672
 06DE           ;               else if(CHILD)
 06DE 62D000            mov REG[0xd0],>_CHILD
 06E1 3C0000            cmp [_CHILD],0
 06E4 A1EA              jz L146
 06E6                   .dbline 673
 06E6           ;               {
 06E6                   .dbline 675
 06E6           ;                       // If you have a child established, listen to that child.
 06E6           ;                       childResponse();
 06E6 94C5              xcall _childResponse
 06E8                   .dbline 676
 06E8           ;               }
 06E8                   .dbline 677
 06E8           ;       }
 06E8 81E6              xjmp L146
 06EA           L145:
 06EA                   .dbline 678
 06EA           ;       else if(COMMAND_TYPE == PING)           // The master is trying to find a module that is configured.
 06EA 62D000            mov REG[0xd0],>_COMMAND_TYPE
 06ED 3C00CB            cmp [_COMMAND_TYPE],-53
 06F0 B021              jnz L155
 06F2                   .dbline 679
 06F2           ;       {
 06F2                   .dbline 681
 06F2           ;               // If this is to me, act accordingly.
 06F2           ;               if(COMMAND_DESTINATION == ID)
 06F2 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 06F5 5100              mov A,[_COMMAND_DESTINATION]
 06F7 62D000            mov REG[0xd0],>_ID
 06FA 3A00              cmp A,[_ID]
 06FC B005              jnz L157
 06FE                   .dbline 682
 06FE           ;               {
 06FE                   .dbline 684
 06FE           ;                       // Ping back to the master.
 06FE           ;                       pingResponse();
 06FE 9272              xcall _pingResponse
 0700                   .dbline 685
 0700           ;               }
 0700 81CE              xjmp L156
 0702           L157:
 0702                   .dbline 686
 0702           ;               else if(COMMAND_DESTINATION > ID)
 0702 62D000            mov REG[0xd0],>_ID
 0705 5100              mov A,[_ID]
 0707 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 070A 3A00              cmp A,[_COMMAND_DESTINATION]
 070C D1C2              jnc L156
 070E           X28:
 070E                   .dbline 687
 070E           ;               {
 070E                   .dbline 689
 070E           ;                       // If you have a child established, listen to that child.
 070E           ;                       childResponse();
 070E 949D              xcall _childResponse
 0710                   .dbline 690
 0710           ;               }
 0710                   .dbline 691
 0710           ;       }
 0710 81BE              xjmp L156
 0712           L155:
 0712                   .dbline 692
 0712           ;       else if(COMMAND_TYPE == ID_ASSIGNMENT)  // The master is assigning an ID to someone.
 0712 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0715 3C00C9            cmp [_COMMAND_TYPE],-55
 0718 B110              jnz L161
 071A                   .dbline 693
 071A           ;       {
 071A                   .dbline 695
 071A           ;               // If this is meant for me, change my ID.
 071A           ;               if(COMMAND_DESTINATION == ID)
 071A 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 071D 5100              mov A,[_COMMAND_DESTINATION]
 071F 62D000            mov REG[0xd0],>_ID
 0722 3A00              cmp A,[_ID]
 0724 B0F4              jnz L163
 0726                   .dbline 696
 0726           ;               {
 0726                   .dbline 697
 0726           ;                       if((COMMAND_PARAM > MASTER_ID) && (COMMAND_PARAM < DEFAULT_ID))
 0726 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0729 5000              mov A,0
 072B 3A00              cmp A,[_COMMAND_PARAM]
 072D D1A1              jnc L162
 072F           X29:
 072F 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0732 3C00FB            cmp [_COMMAND_PARAM],-5
 0735 D199              jnc L162
 0737           X30:
 0737                   .dbline 698
 0737           ;                       {
 0737                   .dbline 700
 0737           ;                               // Assign this module the ID that has been passed by the master.
 0737           ;                               ID = COMMAND_PARAM;
 0737 62D000            mov REG[0xd0],>_COMMAND_PARAM
 073A 5100              mov A,[_COMMAND_PARAM]
 073C 62D000            mov REG[0xd0],>_ID
 073F 5300              mov [_ID],A
 0741                   .dbline 703
 0741           ;                               
 0741           ;                               // This module is now configured.
 0741           ;                               CONFIGURED = 1;
 0741 62D000            mov REG[0xd0],>_CONFIGURED
 0744 550101            mov [_CONFIGURED+1],1
 0747 550000            mov [_CONFIGURED],0
 074A                   .dbline 706
 074A           ;                               
 074A           ;                               // If the servo ID doesn't match what we want, change it to match.
 074A           ;                               if(ID != SERVO_ID)
 074A 62D000            mov REG[0xd0],>_ID
 074D 5100              mov A,[_ID]
 074F 62D000            mov REG[0xd0],>_SERVO_ID
 0752 3A00              cmp A,[_SERVO_ID]
 0754 A0A8              jz L167
 0756                   .dbline 707
 0756           ;                               {
 0756                   .dbline 714
 0756           ;                                       // These are our index variables for communication attempt timeouts.
 0756           ;                                       int i;
 0756           ;                                       int j;
 0756           ;                                       
 0756           ;                                       //while(ID != SERVO_ID)
 0756           ;                                       
 0756           ;                                       for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0756 560500            mov [X+5],0
 0759 560400            mov [X+4],0
 075C           L169:
 075C                   .dbline 715
 075C           ;                                       {       
 075C                   .dbline 717
 075C           ;                                               // Send a request to change the servo ID to match the controller ID.
 075C           ;                                               servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, ID_ADDRESS, ID);
 075C 62D000            mov REG[0xd0],>_ID
 075F 5100              mov A,[_ID]
 0761 08                push A
 0762 5003              mov A,3
 0764 08                push A
 0765 08                push A
 0766 5004              mov A,4
 0768 08                push A
 0769 62D000            mov REG[0xd0],>_SERVO_ID
 076C 5100              mov A,[_SERVO_ID]
 076E 08                push A
 076F 96F2              xcall _servoInstruction
 0771 38FB              add SP,-5
 0773                   .dbline 720
 0773           ;                                       
 0773           ;                                               // Try to read the servo's ID several times.
 0773           ;                                               for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0773 560300            mov [X+3],0
 0776 560200            mov [X+2],0
 0779           L173:
 0779                   .dbline 721
 0779           ;                                               {
 0779                   .dbline 723
 0779           ;                                                       // Send a request for the servo ID, which is presumably now equal to ID.
 0779           ;                                                       servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
 0779 5000              mov A,0
 077B 08                push A
 077C 08                push A
 077D 5001              mov A,1
 077F 08                push A
 0780 5002              mov A,2
 0782 08                push A
 0783 50FE              mov A,-2
 0785 08                push A
 0786 96DB              xcall _servoInstruction
 0788 38FB              add SP,-5
 078A 8043              xjmp L178
 078C           L177:
 078C                   .dbline 727
 078C           ;                                                       
 078C           ;                                                       // Wait for either a timeout or an indication that we want to exit the loop.
 078C           ;                                                       while(!TIMEOUT)
 078C           ;                                                       {
 078C                   .dbline 729
 078C           ;                                                               // If we have a command to interpret, read it.
 078C           ;                                                               if(commandReady())
 078C 9B30              xcall _commandReady
 078E 62D000            mov REG[0xd0],>__r0
 0791 3C0000            cmp [__r0],0
 0794 B006              jnz X31
 0796 3C0000            cmp [__r1],0
 0799 A034              jz L180
 079B           X31:
 079B                   .dbline 730
 079B           ;                                                               {
 079B                   .dbline 731
 079B           ;                                                                       if(!COMMAND_ERROR)
 079B 62D000            mov REG[0xd0],>_COMMAND_ERROR
 079E 3C0000            cmp [_COMMAND_ERROR],0
 07A1 B02C              jnz L182
 07A3                   .dbline 732
 07A3           ;                                                                       {
 07A3                   .dbline 734
 07A3           ;                                                                               // If we have a valid servo ID, exit the loop.
 07A3           ;                                                                               if(COMMAND_SOURCE == ID)
 07A3 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 07A6 5100              mov A,[_COMMAND_SOURCE]
 07A8 62D000            mov REG[0xd0],>_ID
 07AB 3A00              cmp A,[_ID]
 07AD B020              jnz L184
 07AF                   .dbline 735
 07AF           ;                                                                               {
 07AF                   .dbline 737
 07AF           ;                                                                                       // Set the timeout flag to exit the while loop.
 07AF           ;                                                                                       TIMEOUT = 1;
 07AF 62D000            mov REG[0xd0],>_TIMEOUT
 07B2 550101            mov [_TIMEOUT+1],1
 07B5 550000            mov [_TIMEOUT],0
 07B8                   .dbline 739
 07B8           ;                                                                                       // Set i such that the for loop is exited.
 07B8           ;                                                                                       i = SERVO_COMM_ATTEMPTS;
 07B8 56030A            mov [X+3],10
 07BB 560200            mov [X+2],0
 07BE                   .dbline 741
 07BE           ;                                                                                       // Set j such that we exit the outer loop as well.
 07BE           ;                                                                                       j = SERVO_COMM_LOOPS;
 07BE 560502            mov [X+5],2
 07C1 560400            mov [X+4],0
 07C4                   .dbline 743
 07C4           ;                                                                                       // Store the ID value.
 07C4           ;                                                                                       SERVO_ID = ID;
 07C4 62D000            mov REG[0xd0],>_ID
 07C7 5100              mov A,[_ID]
 07C9 62D000            mov REG[0xd0],>_SERVO_ID
 07CC 5300              mov [_SERVO_ID],A
 07CE                   .dbline 744
 07CE           ;                                                                               }
 07CE           L184:
 07CE                   .dbline 745
 07CE           ;                                                                       }
 07CE           L182:
 07CE                   .dbline 746
 07CE           ;                                                               }
 07CE           L180:
 07CE                   .dbline 747
 07CE           ;                                                       }
 07CE           L178:
 07CE                   .dbline 726
 07CE 62D000            mov REG[0xd0],>_TIMEOUT
 07D1 3C0000            cmp [_TIMEOUT],0
 07D4 B006              jnz X32
 07D6 3C0100            cmp [_TIMEOUT+1],0
 07D9 AFB2              jz L177
 07DB           X32:
 07DB                   .dbline 748
 07DB           ;                                               }
 07DB           L174:
 07DB                   .dbline 720
 07DB 7703              inc [X+3]
 07DD 0F0200            adc [X+2],0
 07E0                   .dbline 720
 07E0 5203              mov A,[X+3]
 07E2 110A              sub A,10
 07E4 5202              mov A,[X+2]
 07E6 3180              xor A,-128
 07E8 1980              sbb A,(0 ^ 0x80)
 07EA CF8E              jc L173
 07EC           X33:
 07EC                   .dbline 749
 07EC           ;                                       }       
 07EC           L170:
 07EC                   .dbline 714
 07EC 7705              inc [X+5]
 07EE 0F0400            adc [X+4],0
 07F1                   .dbline 714
 07F1 5205              mov A,[X+5]
 07F3 1102              sub A,2
 07F5 5204              mov A,[X+4]
 07F7 3180              xor A,-128
 07F9 1980              sbb A,(0 ^ 0x80)
 07FB CF60              jc L169
 07FD           X34:
 07FD                   .dbline 750
 07FD           ;                               }
 07FD           L167:
 07FD                   .dbline 752
 07FD           ;                               
 07FD           ;                               if(ID != SERVO_ID)
 07FD 62D000            mov REG[0xd0],>_ID
 0800 5100              mov A,[_ID]
 0802 62D000            mov REG[0xd0],>_SERVO_ID
 0805 3A00              cmp A,[_SERVO_ID]
 0807 A00D              jz L186
 0809                   .dbline 753
 0809           ;                               {
 0809                   .dbline 755
 0809           ;                                       // Toggle back to normal wait mode.
 0809           ;                                       configToggle(WAIT);
 0809 5000              mov A,0
 080B 08                push A
 080C 5001              mov A,1
 080E 08                push A
 080F 98A3              xcall _configToggle
 0811 38FE              add SP,-2
 0813                   .dbline 756
 0813           ;                               }
 0813 80BB              xjmp L162
 0815           L186:
 0815                   .dbline 758
 0815           ;                               else
 0815           ;                               {
 0815                   .dbline 760
 0815           ;                                       // Let the master node know that you got the ID assignment.
 0815           ;                                       assignedID();
 0815 929F              xcall _assignedID
 0817                   .dbline 761
 0817           ;                               }
 0817                   .dbline 762
 0817           ;                       }
 0817                   .dbline 763
 0817           ;               }
 0817 80B7              xjmp L162
 0819           L163:
 0819                   .dbline 764
 0819           ;               else if(COMMAND_DESTINATION > ID)
 0819 62D000            mov REG[0xd0],>_ID
 081C 5100              mov A,[_ID]
 081E 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0821 3A00              cmp A,[_COMMAND_DESTINATION]
 0823 D0AB              jnc L162
 0825           X35:
 0825                   .dbline 765
 0825           ;               {
 0825                   .dbline 767
 0825           ;                       // Switch to listen to your child.
 0825           ;                       childResponse();
 0825 9386              xcall _childResponse
 0827                   .dbline 768
 0827           ;               }
 0827                   .dbline 769
 0827           ;       }
 0827 80A7              xjmp L162
 0829           L161:
 0829                   .dbline 770
 0829           ;       else if(COMMAND_TYPE == CLEAR_CONFIG)   // The master wants to clear one or all configurations.
 0829 62D000            mov REG[0xd0],>_COMMAND_TYPE
 082C 3C00CC            cmp [_COMMAND_TYPE],-52
 082F B03D              jnz L190
 0831                   .dbline 771
 0831           ;       {
 0831                   .dbline 773
 0831           ;               // Only respond if this is directly to me and not a mass config clear.
 0831           ;               if(COMMAND_DESTINATION == ID)
 0831 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0834 5100              mov A,[_COMMAND_DESTINATION]
 0836 62D000            mov REG[0xd0],>_ID
 0839 3A00              cmp A,[_ID]
 083B B003              jnz L192
 083D                   .dbline 774
 083D           ;               {
 083D                   .dbline 775
 083D           ;                       configCleared();        // Notify the master that I am clearing my config.
 083D 9094              xcall _configCleared
 083F                   .dbline 776
 083F           ;               }
 083F           L192:
 083F                   .dbline 781
 083F           ;               
 083F           ;               // If this is meant for me, deconfigure.  Also, if a module ahead of you is
 083F           ;               // getting deconfigured, you have no choice but to deconfigure as well to
 083F           ;               // avoid errors on reconfiguration.
 083F           ;               if((COMMAND_DESTINATION <= ID) || (COMMAND_DESTINATION == BROADCAST))
 083F 62D000            mov REG[0xd0],>_ID
 0842 5100              mov A,[_ID]
 0844 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0847 3A00              cmp A,[_COMMAND_DESTINATION]
 0849 D009              jnc L196
 084B           X36:
 084B 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 084E 3C00FE            cmp [_COMMAND_DESTINATION],-2
 0851 B016              jnz L194
 0853           L196:
 0853                   .dbline 782
 0853           ;               {
 0853                   .dbline 783
 0853           ;                       ID = DEFAULT_ID;        // Reset my ID to the default.
 0853 62D000            mov REG[0xd0],>_ID
 0856 5500FB            mov [_ID],-5
 0859                   .dbline 784
 0859           ;                       CONFIGURED = 0;         // I am no longer configured.
 0859 62D000            mov REG[0xd0],>_CONFIGURED
 085C 550100            mov [_CONFIGURED+1],0
 085F 550000            mov [_CONFIGURED],0
 0862                   .dbline 785
 0862           ;                       CHILD = 0;                      // No one can depend on you anymore.
 0862 62D000            mov REG[0xd0],>_CHILD
 0865 550000            mov [_CHILD],0
 0868                   .dbline 786
 0868           ;               }
 0868           L194:
 0868                   .dbline 797
 0868           ; //            else if(COMMAND_DESTINATION > ID)
 0868           ; //            {
 0868           ; //                    // Switch to listen to your child.
 0868           ; //                    childResponse();
 0868           ; //                    // Switch back to wait for a master response.
 0868           ; //                    configToggle(WAIT);
 0868           ; //            }
 0868           ; //            Going to also have to take into account of this is my child.
 0868           ;               
 0868           ;               // Turn off the LED.
 0868           ;               PRT2DR |= 0b00000001;
 0868 430801            or REG[0x8],1
 086B                   .dbline 798
 086B           ;       }
 086B 8063              xjmp L191
 086D           L190:
 086D                   .dbline 799
 086D           ;       else if((COMMAND_TYPE == PING_SERVO) || (COMMAND_TYPE == READ_SERVO))
 086D 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0870 3C0001            cmp [_COMMAND_TYPE],1
 0873 A006              jz L199
 0875 3C0002            cmp [_COMMAND_TYPE],2
 0878 B056              jnz L197
 087A           L199:
 087A                   .dbline 800
 087A           ;       {
 087A                   .dbline 801
 087A           ;               if(COMMAND_DESTINATION > ID)
 087A 62D000            mov REG[0xd0],>_ID
 087D 5100              mov A,[_ID]
 087F 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0882 3A00              cmp A,[_COMMAND_DESTINATION]
 0884 D005              jnc L200
 0886           X37:
 0886                   .dbline 802
 0886           ;               {
 0886                   .dbline 804
 0886           ;                       // Allow the child response through.
 0886           ;                       childResponse();
 0886 9325              xcall _childResponse
 0888                   .dbline 805
 0888           ;               }
 0888 8046              xjmp L201
 088A           L200:
 088A                   .dbline 806
 088A           ;               else if(COMMAND_DESTINATION <= ID)
 088A 62D000            mov REG[0xd0],>_ID
 088D 5100              mov A,[_ID]
 088F 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0892 3A00              cmp A,[_COMMAND_DESTINATION]
 0894 C03A              jc L202
 0896           X38:
 0896                   .dbline 807
 0896           ;               {
 0896           L204:
 0896                   .dbline 809
 0896           ;                       // Sit and spin while we wait for the transmission to start.
 0896           ;                       while(WAIT_RECV_cReadChar() != SERVO_START) { }
 0896                   .dbline 809
 0896           L205:
 0896                   .dbline 809
 0896 10                push X
 0897 7C0000            xcall _WAIT_RECV_cReadChar
 089A 62D000            mov REG[0xd0],>__r0
 089D 20                pop X
 089E 39FF              cmp A,-1
 08A0 BFF5              jnz L204
 08A2                   .dbline 812
 08A2           ;                       
 08A2           ;                       // Reset the index variable.
 08A2           ;                       i = 0;
 08A2 560100            mov [X+1],0
 08A5 560000            mov [X+0],0
 08A8 801A              xjmp L208
 08AA           L207:
 08AA                   .dbline 817
 08AA           ;                       
 08AA           ;                       // Wait for the transmission to go through.
 08AA           ;                       // If no chars are read for RESPONSE_ITERATIONS iterations, move on.
 08AA           ;                       while(i < RESPONSE_ITERATIONS)
 08AA           ;                       {
 08AA                   .dbline 818
 08AA           ;                               if(WAIT_RECV_cReadChar())
 08AA 10                push X
 08AB 7C0000            xcall _WAIT_RECV_cReadChar
 08AE 62D000            mov REG[0xd0],>__r0
 08B1 20                pop X
 08B2 3900              cmp A,0
 08B4 A009              jz L210
 08B6                   .dbline 819
 08B6           ;                               {
 08B6                   .dbline 820
 08B6           ;                                       i = 0;
 08B6 560100            mov [X+1],0
 08B9 560000            mov [X+0],0
 08BC                   .dbline 821
 08BC           ;                               }
 08BC 8006              xjmp L211
 08BE           L210:
 08BE                   .dbline 823
 08BE           ;                               else
 08BE           ;                               {
 08BE                   .dbline 824
 08BE           ;                                       i++;
 08BE 7701              inc [X+1]
 08C0 0F0000            adc [X+0],0
 08C3                   .dbline 825
 08C3           ;                               }
 08C3           L211:
 08C3                   .dbline 826
 08C3           ;                       }
 08C3           L208:
 08C3                   .dbline 816
 08C3 5201              mov A,[X+1]
 08C5 110A              sub A,10
 08C7 5200              mov A,[X+0]
 08C9 3180              xor A,-128
 08CB 1980              sbb A,(0 ^ 0x80)
 08CD CFDC              jc L207
 08CF           X39:
 08CF                   .dbline 827
 08CF           ;               }
 08CF           L202:
 08CF           L201:
 08CF                   .dbline 828
 08CF           ;       }
 08CF           L197:
 08CF           L191:
 08CF           L162:
 08CF           L156:
 08CF           L146:
 08CF                   .dbline -2
 08CF           L144:
 08CF 38FA              add SP,-6
 08D1 20                pop X
 08D2                   .dbline 0 ; func end
 08D2 7F                ret
 08D3                   .dbsym l j 4 I
 08D3                   .dbsym l i 2 I
 08D3                   .dbsym l i 0 I
 08D3                   .dbend
 08D3                   .dbfunc e configCleared _configCleared fV
 08D3           _configCleared::
 08D3                   .dbline -1
 08D3                   .dbline 833
 08D3           ; }
 08D3           ; 
 08D3           ; // This function sends out an acknowledgement of a configuration reset.
 08D3           ; void configCleared(void)
 08D3           ; {
 08D3                   .dbline 834
 08D3           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 08D3 5000              mov A,0
 08D5 08                push A
 08D6 5002              mov A,2
 08D8 08                push A
 08D9 7C00B4            xcall _configToggle
 08DC 38FE              add SP,-2
 08DE                   .dbline 837
 08DE           ;       
 08DE           ;       // Transmit a ping to everyone.
 08DE           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 08DE 10                push X
 08DF 50FC              mov A,-4
 08E1 7C0000            xcall _TX_014_PutChar
 08E4 20                pop X
 08E5                   .dbline 838
 08E5           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 08E5 10                push X
 08E6 50FC              mov A,-4
 08E8 7C0000            xcall _TX_23_PutChar
 08EB 20                pop X
 08EC                   .dbline 839
 08EC           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 08EC 10                push X
 08ED 50FC              mov A,-4
 08EF 7C0000            xcall _TX_014_PutChar
 08F2 20                pop X
 08F3                   .dbline 840
 08F3           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 08F3 10                push X
 08F4 50FC              mov A,-4
 08F6 7C0000            xcall _TX_23_PutChar
 08F9 20                pop X
 08FA                   .dbline 841
 08FA           ;       TX_014_PutChar(ID);                             // My ID
 08FA 10                push X
 08FB 62D000            mov REG[0xd0],>_ID
 08FE 5100              mov A,[_ID]
 0900 7C0000            xcall _TX_014_PutChar
 0903 20                pop X
 0904                   .dbline 842
 0904           ;       TX_23_PutChar(ID);                              // My ID
 0904 10                push X
 0905 62D000            mov REG[0xd0],>_ID
 0908 5100              mov A,[_ID]
 090A 7C0000            xcall _TX_23_PutChar
 090D 20                pop X
 090E                   .dbline 843
 090E           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 090E 10                push X
 090F 5000              mov A,0
 0911 7C0000            xcall _TX_014_PutChar
 0914 20                pop X
 0915                   .dbline 844
 0915           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 0915 10                push X
 0916 5000              mov A,0
 0918 7C0000            xcall _TX_23_PutChar
 091B 20                pop X
 091C                   .dbline 845
 091C           ;       TX_014_PutChar(CONFIG_CLEARED); // This is a ping response
 091C 10                push X
 091D 50CD              mov A,-51
 091F 7C0000            xcall _TX_014_PutChar
 0922 20                pop X
 0923                   .dbline 846
 0923           ;       TX_23_PutChar(CONFIG_CLEARED);  // This is a ping response
 0923 10                push X
 0924 50CD              mov A,-51
 0926 7C0000            xcall _TX_23_PutChar
 0929 20                pop X
 092A                   .dbline 847
 092A           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 092A 10                push X
 092B 50FD              mov A,-3
 092D 7C0000            xcall _TX_014_PutChar
 0930 20                pop X
 0931                   .dbline 848
 0931           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0931 10                push X
 0932 50FD              mov A,-3
 0934 7C0000            xcall _TX_23_PutChar
 0937 20                pop X
 0938                   .dbline 849
 0938           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0938 10                push X
 0939 50FD              mov A,-3
 093B 7C0000            xcall _TX_014_PutChar
 093E 20                pop X
 093F                   .dbline 850
 093F           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 093F 10                push X
 0940 50FD              mov A,-3
 0942 7C0000            xcall _TX_23_PutChar
 0945 20                pop X
 0946           L213:
 0946                   .dbline 853
 0946           ;       
 0946           ;       // Wait for the transmission to finish.
 0946           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0946           L214:
 0946                   .dbline 853
 0946 10                push X
 0947 7C0000            xcall _TX_014_bReadTxStatus
 094A 62D000            mov REG[0xd0],>__r0
 094D 20                pop X
 094E 5300              mov [__r0],A
 0950 470020            tst [__r0],32
 0953 AFF2              jz L213
 0955           L216:
 0955                   .dbline 854
 0955           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 0955           L217:
 0955                   .dbline 854
 0955 10                push X
 0956 7C0000            xcall _TX_23_bReadTxStatus
 0959 62D000            mov REG[0xd0],>__r0
 095C 20                pop X
 095D 5300              mov [__r0],A
 095F 470020            tst [__r0],32
 0962 AFF2              jz L216
 0964                   .dbline 857
 0964           ;       
 0964           ;       // Make completely sure we're done.
 0964           ;       xmitWait();
 0964 95DB              xcall _xmitWait
 0966                   .dbline 859
 0966           ;       
 0966           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0966 5000              mov A,0
 0968 08                push A
 0969 5001              mov A,1
 096B 08                push A
 096C 7C00B4            xcall _configToggle
 096F 38FE              add SP,-2
 0971                   .dbline -2
 0971           L212:
 0971                   .dbline 0 ; func end
 0971 7F                ret
 0972                   .dbend
 0972                   .dbfunc e pingResponse _pingResponse fV
 0972           _pingResponse::
 0972                   .dbline -1
 0972                   .dbline 864
 0972           ; }
 0972           ; 
 0972           ; // This function sends out a ping response for everyone to hear.
 0972           ; void pingResponse(void)
 0972           ; {
 0972                   .dbline 865
 0972           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 0972 5000              mov A,0
 0974 08                push A
 0975 5002              mov A,2
 0977 08                push A
 0978 7C00B4            xcall _configToggle
 097B 38FE              add SP,-2
 097D                   .dbline 868
 097D           ;       
 097D           ;       // Transmit a ping to everyone.
 097D           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 097D 10                push X
 097E 50FC              mov A,-4
 0980 7C0000            xcall _TX_014_PutChar
 0983 20                pop X
 0984                   .dbline 869
 0984           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 0984 10                push X
 0985 50FC              mov A,-4
 0987 7C0000            xcall _TX_23_PutChar
 098A 20                pop X
 098B                   .dbline 870
 098B           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 098B 10                push X
 098C 50FC              mov A,-4
 098E 7C0000            xcall _TX_014_PutChar
 0991 20                pop X
 0992                   .dbline 871
 0992           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 0992 10                push X
 0993 50FC              mov A,-4
 0995 7C0000            xcall _TX_23_PutChar
 0998 20                pop X
 0999                   .dbline 872
 0999           ;       TX_014_PutChar(ID);                             // My ID
 0999 10                push X
 099A 62D000            mov REG[0xd0],>_ID
 099D 5100              mov A,[_ID]
 099F 7C0000            xcall _TX_014_PutChar
 09A2 20                pop X
 09A3                   .dbline 873
 09A3           ;       TX_23_PutChar(ID);                              // My ID
 09A3 10                push X
 09A4 62D000            mov REG[0xd0],>_ID
 09A7 5100              mov A,[_ID]
 09A9 7C0000            xcall _TX_23_PutChar
 09AC 20                pop X
 09AD                   .dbline 874
 09AD           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 09AD 10                push X
 09AE 5000              mov A,0
 09B0 7C0000            xcall _TX_014_PutChar
 09B3 20                pop X
 09B4                   .dbline 875
 09B4           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 09B4 10                push X
 09B5 5000              mov A,0
 09B7 7C0000            xcall _TX_23_PutChar
 09BA 20                pop X
 09BB                   .dbline 876
 09BB           ;       TX_014_PutChar(PING);                   // This is a ping response
 09BB 10                push X
 09BC 50CB              mov A,-53
 09BE 7C0000            xcall _TX_014_PutChar
 09C1 20                pop X
 09C2                   .dbline 877
 09C2           ;       TX_23_PutChar(PING);                    // This is a ping response
 09C2 10                push X
 09C3 50CB              mov A,-53
 09C5 7C0000            xcall _TX_23_PutChar
 09C8 20                pop X
 09C9                   .dbline 878
 09C9           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 09C9 10                push X
 09CA 50FD              mov A,-3
 09CC 7C0000            xcall _TX_014_PutChar
 09CF 20                pop X
 09D0                   .dbline 879
 09D0           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 09D0 10                push X
 09D1 50FD              mov A,-3
 09D3 7C0000            xcall _TX_23_PutChar
 09D6 20                pop X
 09D7                   .dbline 880
 09D7           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 09D7 10                push X
 09D8 50FD              mov A,-3
 09DA 7C0000            xcall _TX_014_PutChar
 09DD 20                pop X
 09DE                   .dbline 881
 09DE           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 09DE 10                push X
 09DF 50FD              mov A,-3
 09E1 7C0000            xcall _TX_23_PutChar
 09E4 20                pop X
 09E5           L220:
 09E5                   .dbline 884
 09E5           ;       
 09E5           ;       // Wait for the transmission to finish.
 09E5           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 09E5           L221:
 09E5                   .dbline 884
 09E5 10                push X
 09E6 7C0000            xcall _TX_014_bReadTxStatus
 09E9 62D000            mov REG[0xd0],>__r0
 09EC 20                pop X
 09ED 5300              mov [__r0],A
 09EF 470020            tst [__r0],32
 09F2 AFF2              jz L220
 09F4           L223:
 09F4                   .dbline 885
 09F4           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 09F4           L224:
 09F4                   .dbline 885
 09F4 10                push X
 09F5 7C0000            xcall _TX_23_bReadTxStatus
 09F8 62D000            mov REG[0xd0],>__r0
 09FB 20                pop X
 09FC 5300              mov [__r0],A
 09FE 470020            tst [__r0],32
 0A01 AFF2              jz L223
 0A03                   .dbline 888
 0A03           ;       
 0A03           ;       // Make completely sure we're done.
 0A03           ;       xmitWait();
 0A03 953C              xcall _xmitWait
 0A05                   .dbline 890
 0A05           ;       
 0A05           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0A05 5000              mov A,0
 0A07 08                push A
 0A08 5001              mov A,1
 0A0A 08                push A
 0A0B 7C00B4            xcall _configToggle
 0A0E 38FE              add SP,-2
 0A10                   .dbline -2
 0A10           L219:
 0A10                   .dbline 0 ; func end
 0A10 7F                ret
 0A11                   .dbend
 0A11                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0A11           _unloadAllConfigs::
 0A11                   .dbline -1
 0A11                   .dbline 896
 0A11           ; }
 0A11           ; 
 0A11           ; // This function blindly unloads all user configurations. This will be called once,
 0A11           ; // when the system initially has no known state.
 0A11           ; void unloadAllConfigs(void)
 0A11           ; {
 0A11                   .dbline 897
 0A11           ;       UnloadConfig_waiting();
 0A11 7C0000            xcall _UnloadConfig_waiting
 0A14                   .dbline 898
 0A14           ;       UnloadConfig_hello();
 0A14 7C0000            xcall _UnloadConfig_hello
 0A17                   .dbline 899
 0A17           ;       UnloadConfig_my_response();
 0A17 7C0000            xcall _UnloadConfig_my_response
 0A1A                   .dbline 900
 0A1A           ;       UnloadConfig_response1();
 0A1A 7C0000            xcall _UnloadConfig_response1
 0A1D                   .dbline 901
 0A1D           ;       UnloadConfig_response2();
 0A1D 7C0000            xcall _UnloadConfig_response2
 0A20                   .dbline 902
 0A20           ;       UnloadConfig_response3();
 0A20 7C0000            xcall _UnloadConfig_response3
 0A23                   .dbline 903
 0A23           ;       UnloadConfig_response4();
 0A23 7C0000            xcall _UnloadConfig_response4
 0A26                   .dbline 904
 0A26           ;       UnloadConfig_initial();
 0A26 7C0000            xcall _UnloadConfig_initial
 0A29                   .dbline 905
 0A29           ;       UnloadConfig_servo_transmit();
 0A29 7C0000            xcall _UnloadConfig_servo_transmit
 0A2C                   .dbline -2
 0A2C           L226:
 0A2C                   .dbline 0 ; func end
 0A2C 7F                ret
 0A2D                   .dbend
 0A2D                   .dbfunc e unloadConfig _unloadConfig fV
 0A2D           ;     config_num -> X-5
 0A2D           _unloadConfig::
 0A2D                   .dbline -1
 0A2D 10                push X
 0A2E 4F                mov X,SP
 0A2F                   .dbline 911
 0A2F           ; }
 0A2F           ; 
 0A2F           ; // This function unloads the configuration corresponding to the config number passed to it.
 0A2F           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0A2F           ; void unloadConfig(int config_num)
 0A2F           ; {
 0A2F                   .dbline 912
 0A2F           ;       if(config_num == WAIT)
 0A2F 3DFB00            cmp [X-5],0
 0A32 B00B              jnz L228
 0A34 3DFC01            cmp [X-4],1
 0A37 B006              jnz L228
 0A39           X40:
 0A39                   .dbline 913
 0A39           ;       {
 0A39                   .dbline 914
 0A39           ;               UnloadConfig_waiting();
 0A39 7C0000            xcall _UnloadConfig_waiting
 0A3C                   .dbline 915
 0A3C           ;       }
 0A3C 8077              xjmp L229
 0A3E           L228:
 0A3E                   .dbline 916
 0A3E           ;       else if(config_num == HELLO_MODE)
 0A3E 3DFB00            cmp [X-5],0
 0A41 B00B              jnz L230
 0A43 3DFC07            cmp [X-4],7
 0A46 B006              jnz L230
 0A48           X41:
 0A48                   .dbline 917
 0A48           ;       {
 0A48                   .dbline 918
 0A48           ;               UnloadConfig_hello();
 0A48 7C0000            xcall _UnloadConfig_hello
 0A4B                   .dbline 919
 0A4B           ;       }
 0A4B 8068              xjmp L231
 0A4D           L230:
 0A4D                   .dbline 920
 0A4D           ;       else if(config_num == MY_RESPONSE)
 0A4D 3DFB00            cmp [X-5],0
 0A50 B00B              jnz L232
 0A52 3DFC02            cmp [X-4],2
 0A55 B006              jnz L232
 0A57           X42:
 0A57                   .dbline 921
 0A57           ;       {
 0A57                   .dbline 922
 0A57           ;               UnloadConfig_my_response();
 0A57 7C0000            xcall _UnloadConfig_my_response
 0A5A                   .dbline 923
 0A5A           ;       }
 0A5A 8059              xjmp L233
 0A5C           L232:
 0A5C                   .dbline 924
 0A5C           ;       else if(config_num == RESPONSE_1)
 0A5C 3DFB00            cmp [X-5],0
 0A5F B00B              jnz L234
 0A61 3DFC03            cmp [X-4],3
 0A64 B006              jnz L234
 0A66           X43:
 0A66                   .dbline 925
 0A66           ;       {
 0A66                   .dbline 926
 0A66           ;               UnloadConfig_response1();
 0A66 7C0000            xcall _UnloadConfig_response1
 0A69                   .dbline 927
 0A69           ;       }
 0A69 804A              xjmp L235
 0A6B           L234:
 0A6B                   .dbline 928
 0A6B           ;       else if(config_num == RESPONSE_2)
 0A6B 3DFB00            cmp [X-5],0
 0A6E B00B              jnz L236
 0A70 3DFC04            cmp [X-4],4
 0A73 B006              jnz L236
 0A75           X44:
 0A75                   .dbline 929
 0A75           ;       {
 0A75                   .dbline 930
 0A75           ;               UnloadConfig_response2();
 0A75 7C0000            xcall _UnloadConfig_response2
 0A78                   .dbline 931
 0A78           ;       }
 0A78 803B              xjmp L237
 0A7A           L236:
 0A7A                   .dbline 932
 0A7A           ;       else if(config_num == RESPONSE_3)
 0A7A 3DFB00            cmp [X-5],0
 0A7D B00B              jnz L238
 0A7F 3DFC05            cmp [X-4],5
 0A82 B006              jnz L238
 0A84           X45:
 0A84                   .dbline 933
 0A84           ;       {
 0A84                   .dbline 934
 0A84           ;               UnloadConfig_response3();
 0A84 7C0000            xcall _UnloadConfig_response3
 0A87                   .dbline 935
 0A87           ;       }
 0A87 802C              xjmp L239
 0A89           L238:
 0A89                   .dbline 936
 0A89           ;       else if(config_num == RESPONSE_4)
 0A89 3DFB00            cmp [X-5],0
 0A8C B00B              jnz L240
 0A8E 3DFC06            cmp [X-4],6
 0A91 B006              jnz L240
 0A93           X46:
 0A93                   .dbline 937
 0A93           ;       {
 0A93                   .dbline 938
 0A93           ;               UnloadConfig_response4();
 0A93 7C0000            xcall _UnloadConfig_response4
 0A96                   .dbline 939
 0A96           ;       }
 0A96 801D              xjmp L241
 0A98           L240:
 0A98                   .dbline 940
 0A98           ;       else if(config_num == INITIALIZE)
 0A98 3DFB00            cmp [X-5],0
 0A9B B00B              jnz L242
 0A9D 3DFC08            cmp [X-4],8
 0AA0 B006              jnz L242
 0AA2           X47:
 0AA2                   .dbline 941
 0AA2           ;       {
 0AA2                   .dbline 942
 0AA2           ;               UnloadConfig_initial();
 0AA2 7C0000            xcall _UnloadConfig_initial
 0AA5                   .dbline 943
 0AA5           ;       }
 0AA5 800E              xjmp L243
 0AA7           L242:
 0AA7                   .dbline 944
 0AA7           ;       else if(config_num == SERVO_COMM)
 0AA7 3DFB00            cmp [X-5],0
 0AAA B009              jnz L244
 0AAC 3DFC09            cmp [X-4],9
 0AAF B004              jnz L244
 0AB1           X48:
 0AB1                   .dbline 945
 0AB1           ;       {
 0AB1                   .dbline 946
 0AB1           ;               UnloadConfig_servo_transmit();
 0AB1 7C0000            xcall _UnloadConfig_servo_transmit
 0AB4                   .dbline 947
 0AB4           ;       }
 0AB4           L244:
 0AB4           L243:
 0AB4           L241:
 0AB4           L239:
 0AB4           L237:
 0AB4           L235:
 0AB4           L233:
 0AB4           L231:
 0AB4           L229:
 0AB4                   .dbline -2
 0AB4           L227:
 0AB4 20                pop X
 0AB5                   .dbline 0 ; func end
 0AB5 7F                ret
 0AB6                   .dbsym l config_num -5 I
 0AB6                   .dbend
 0AB6                   .dbfunc e assignedID _assignedID fV
 0AB6           _assignedID::
 0AB6                   .dbline -1
 0AB6                   .dbline 952
 0AB6           ; }
 0AB6           ; 
 0AB6           ; // This function responds that an ID has been assigned to it.
 0AB6           ; void assignedID(void)
 0AB6           ; {
 0AB6                   .dbline 953
 0AB6           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 0AB6 5000              mov A,0
 0AB8 08                push A
 0AB9 5002              mov A,2
 0ABB 08                push A
 0ABC 7C00B4            xcall _configToggle
 0ABF 38FE              add SP,-2
 0AC1                   .dbline 956
 0AC1           ;       
 0AC1           ;       // Transmit a ping to everyone.
 0AC1           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 0AC1 10                push X
 0AC2 50FC              mov A,-4
 0AC4 7C0000            xcall _TX_014_PutChar
 0AC7 20                pop X
 0AC8                   .dbline 957
 0AC8           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 0AC8 10                push X
 0AC9 50FC              mov A,-4
 0ACB 7C0000            xcall _TX_23_PutChar
 0ACE 20                pop X
 0ACF                   .dbline 958
 0ACF           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 0ACF 10                push X
 0AD0 50FC              mov A,-4
 0AD2 7C0000            xcall _TX_014_PutChar
 0AD5 20                pop X
 0AD6                   .dbline 959
 0AD6           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 0AD6 10                push X
 0AD7 50FC              mov A,-4
 0AD9 7C0000            xcall _TX_23_PutChar
 0ADC 20                pop X
 0ADD                   .dbline 960
 0ADD           ;       TX_014_PutChar(ID);                             // My ID
 0ADD 10                push X
 0ADE 62D000            mov REG[0xd0],>_ID
 0AE1 5100              mov A,[_ID]
 0AE3 7C0000            xcall _TX_014_PutChar
 0AE6 20                pop X
 0AE7                   .dbline 961
 0AE7           ;       TX_23_PutChar(ID);                              // My ID
 0AE7 10                push X
 0AE8 62D000            mov REG[0xd0],>_ID
 0AEB 5100              mov A,[_ID]
 0AED 7C0000            xcall _TX_23_PutChar
 0AF0 20                pop X
 0AF1                   .dbline 962
 0AF1           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 0AF1 10                push X
 0AF2 5000              mov A,0
 0AF4 7C0000            xcall _TX_014_PutChar
 0AF7 20                pop X
 0AF8                   .dbline 963
 0AF8           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 0AF8 10                push X
 0AF9 5000              mov A,0
 0AFB 7C0000            xcall _TX_23_PutChar
 0AFE 20                pop X
 0AFF                   .dbline 964
 0AFF           ;       TX_014_PutChar(ID_ASSIGN_OK);   // This is an assignment ack response
 0AFF 10                push X
 0B00 50CA              mov A,-54
 0B02 7C0000            xcall _TX_014_PutChar
 0B05 20                pop X
 0B06                   .dbline 965
 0B06           ;       TX_23_PutChar(ID_ASSIGN_OK);    // This is an assignment ack response
 0B06 10                push X
 0B07 50CA              mov A,-54
 0B09 7C0000            xcall _TX_23_PutChar
 0B0C 20                pop X
 0B0D                   .dbline 966
 0B0D           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0B0D 10                push X
 0B0E 50FD              mov A,-3
 0B10 7C0000            xcall _TX_014_PutChar
 0B13 20                pop X
 0B14                   .dbline 967
 0B14           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0B14 10                push X
 0B15 50FD              mov A,-3
 0B17 7C0000            xcall _TX_23_PutChar
 0B1A 20                pop X
 0B1B                   .dbline 968
 0B1B           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0B1B 10                push X
 0B1C 50FD              mov A,-3
 0B1E 7C0000            xcall _TX_014_PutChar
 0B21 20                pop X
 0B22                   .dbline 969
 0B22           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0B22 10                push X
 0B23 50FD              mov A,-3
 0B25 7C0000            xcall _TX_23_PutChar
 0B28 20                pop X
 0B29           L247:
 0B29                   .dbline 972
 0B29           ;       
 0B29           ;       // Wait for the transmission to finish.
 0B29           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0B29           L248:
 0B29                   .dbline 972
 0B29 10                push X
 0B2A 7C0000            xcall _TX_014_bReadTxStatus
 0B2D 62D000            mov REG[0xd0],>__r0
 0B30 20                pop X
 0B31 5300              mov [__r0],A
 0B33 470020            tst [__r0],32
 0B36 AFF2              jz L247
 0B38           L250:
 0B38                   .dbline 973
 0B38           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 0B38           L251:
 0B38                   .dbline 973
 0B38 10                push X
 0B39 7C0000            xcall _TX_23_bReadTxStatus
 0B3C 62D000            mov REG[0xd0],>__r0
 0B3F 20                pop X
 0B40 5300              mov [__r0],A
 0B42 470020            tst [__r0],32
 0B45 AFF2              jz L250
 0B47                   .dbline 976
 0B47           ;       
 0B47           ;       // Make completely sure we're done.
 0B47           ;       xmitWait();
 0B47 93F8              xcall _xmitWait
 0B49                   .dbline 978
 0B49           ;       
 0B49           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0B49 5000              mov A,0
 0B4B 08                push A
 0B4C 5001              mov A,1
 0B4E 08                push A
 0B4F 7C00B4            xcall _configToggle
 0B52 38FE              add SP,-2
 0B54                   .dbline -2
 0B54           L246:
 0B54                   .dbline 0 ; func end
 0B54 7F                ret
 0B55                   .dbend
 0B55                   .dbfunc e childListen _childListen fI
 0B55           _childListen::
 0B55                   .dbline -1
 0B55                   .dbline 983
 0B55           ; }
 0B55           ; 
 0B55           ; // This function listens for children and registers the port that they talk to.
 0B55           ; int childListen(void)
 0B55           ; {
 0B55                   .dbline 984
 0B55           ;       configToggle(HELLO_MODE);       // Switch to listen for hellos on every port.
 0B55 5000              mov A,0
 0B57 08                push A
 0B58 5007              mov A,7
 0B5A 08                push A
 0B5B 7C00B4            xcall _configToggle
 0B5E 38FE              add SP,-2
 0B60 801C              xjmp L255
 0B62           L254:
 0B62                   .dbline 988
 0B62           ;       
 0B62           ;       // Wait to either hear a child or time out.
 0B62           ;       while(!TIMEOUT)
 0B62           ;       {               
 0B62                   .dbline 989
 0B62           ;               if(commandReady())
 0B62 7C02BE            xcall _commandReady
 0B65 62D000            mov REG[0xd0],>__r0
 0B68 3C0000            cmp [__r0],0
 0B6B B006              jnz X49
 0B6D 3C0000            cmp [__r1],0
 0B70 A00C              jz L257
 0B72           X49:
 0B72                   .dbline 990
 0B72           ;               {
 0B72                   .dbline 991
 0B72           ;                       return 1;
 0B72 62D000            mov REG[0xd0],>__r0
 0B75 550001            mov [__r1],1
 0B78 550000            mov [__r0],0
 0B7B 8030              xjmp L253
 0B7D           L257:
 0B7D                   .dbline 993
 0B7D           ;               }
 0B7D           ;       }
 0B7D           L255:
 0B7D                   .dbline 987
 0B7D 62D000            mov REG[0xd0],>_TIMEOUT
 0B80 3C0000            cmp [_TIMEOUT],0
 0B83 B006              jnz X50
 0B85 3C0100            cmp [_TIMEOUT+1],0
 0B88 AFD9              jz L254
 0B8A           X50:
 0B8A                   .dbline 995
 0B8A           ;       
 0B8A           ;       HELLO_TIMEOUT_Stop();           // Stop the timer.
 0B8A 10                push X
 0B8B 7C0000            xcall _HELLO_TIMEOUT_Stop
 0B8E 20                pop X
 0B8F                   .dbline 996
 0B8F           ;       TIMEOUT = 0;                            // Clear the timeout flag.
 0B8F 62D000            mov REG[0xd0],>_TIMEOUT
 0B92 550100            mov [_TIMEOUT+1],0
 0B95 550000            mov [_TIMEOUT],0
 0B98                   .dbline 998
 0B98           ;       
 0B98           ;       configToggle(WAIT);                     // Switch back to wait for a master response.
 0B98 5000              mov A,0
 0B9A 08                push A
 0B9B 5001              mov A,1
 0B9D 08                push A
 0B9E 7C00B4            xcall _configToggle
 0BA1 38FE              add SP,-2
 0BA3                   .dbline 1000
 0BA3           ;       
 0BA3           ;       return 0;                                       // Return the result of our listening session.
 0BA3 62D000            mov REG[0xd0],>__r0
 0BA6 550000            mov [__r1],0
 0BA9 550000            mov [__r0],0
 0BAC                   .dbline -2
 0BAC           L253:
 0BAC                   .dbline 0 ; func end
 0BAC 7F                ret
 0BAD                   .dbend
 0BAD                   .dbfunc e childResponse _childResponse fI
 0BAD           ; child_responded -> X+0
 0BAD           _childResponse::
 0BAD                   .dbline -1
 0BAD 10                push X
 0BAE 4F                mov X,SP
 0BAF 3802              add SP,2
 0BB1                   .dbline 1005
 0BB1           ; }
 0BB1           ; 
 0BB1           ; // This function waits for a child response.
 0BB1           ; int childResponse(void)
 0BB1           ; {
 0BB1                   .dbline 1006
 0BB1           ;       int child_responded = 0;
 0BB1 560100            mov [X+1],0
 0BB4 560000            mov [X+0],0
 0BB7                   .dbline 1009
 0BB7           ;       
 0BB7           ;       // Switch to the right port.
 0BB7           ;       if(CHILD == PORT_A)
 0BB7 62D000            mov REG[0xd0],>_CHILD
 0BBA 3C0041            cmp [_CHILD],65
 0BBD B00E              jnz L260
 0BBF                   .dbline 1010
 0BBF           ;       {
 0BBF                   .dbline 1011
 0BBF           ;               configToggle(RESPONSE_1);
 0BBF 5000              mov A,0
 0BC1 08                push A
 0BC2 5003              mov A,3
 0BC4 08                push A
 0BC5 7C00B4            xcall _configToggle
 0BC8 38FE              add SP,-2
 0BCA                   .dbline 1012
 0BCA           ;       }
 0BCA 8056              xjmp L269
 0BCC           L260:
 0BCC                   .dbline 1013
 0BCC           ;       else if(CHILD == PORT_B)
 0BCC 62D000            mov REG[0xd0],>_CHILD
 0BCF 3C0042            cmp [_CHILD],66
 0BD2 B00E              jnz L262
 0BD4                   .dbline 1014
 0BD4           ;       {
 0BD4                   .dbline 1015
 0BD4           ;               configToggle(RESPONSE_2);
 0BD4 5000              mov A,0
 0BD6 08                push A
 0BD7 5004              mov A,4
 0BD9 08                push A
 0BDA 7C00B4            xcall _configToggle
 0BDD 38FE              add SP,-2
 0BDF                   .dbline 1016
 0BDF           ;       }
 0BDF 8041              xjmp L269
 0BE1           L262:
 0BE1                   .dbline 1017
 0BE1           ;       else if(CHILD == PORT_C)
 0BE1 62D000            mov REG[0xd0],>_CHILD
 0BE4 3C0043            cmp [_CHILD],67
 0BE7 B00E              jnz L264
 0BE9                   .dbline 1018
 0BE9           ;       {
 0BE9                   .dbline 1019
 0BE9           ;               configToggle(RESPONSE_3);
 0BE9 5000              mov A,0
 0BEB 08                push A
 0BEC 5005              mov A,5
 0BEE 08                push A
 0BEF 7C00B4            xcall _configToggle
 0BF2 38FE              add SP,-2
 0BF4                   .dbline 1020
 0BF4           ;       }
 0BF4 802C              xjmp L269
 0BF6           L264:
 0BF6                   .dbline 1021
 0BF6           ;       else if(CHILD == PORT_D)
 0BF6 62D000            mov REG[0xd0],>_CHILD
 0BF9 3C0044            cmp [_CHILD],68
 0BFC B024              jnz L269
 0BFE                   .dbline 1022
 0BFE           ;       {
 0BFE                   .dbline 1023
 0BFE           ;               configToggle(RESPONSE_4);
 0BFE 5000              mov A,0
 0C00 08                push A
 0C01 5006              mov A,6
 0C03 08                push A
 0C04 7C00B4            xcall _configToggle
 0C07 38FE              add SP,-2
 0C09                   .dbline 1024
 0C09           ;       }
 0C09 8017              xjmp L269
 0C0B           L268:
 0C0B                   .dbline 1028
 0C0B           ;       
 0C0B           ;       // Wait for a response or a timeout.
 0C0B           ;       while((!child_responded) && (!TIMEOUT))
 0C0B           ;       {
 0C0B                   .dbline 1029
 0C0B           ;               if(commandReady())
 0C0B 7C02BE            xcall _commandReady
 0C0E 62D000            mov REG[0xd0],>__r0
 0C11 3C0000            cmp [__r0],0
 0C14 B006              jnz X51
 0C16 3C0000            cmp [__r1],0
 0C19 A007              jz L271
 0C1B           X51:
 0C1B                   .dbline 1030
 0C1B           ;               {
 0C1B                   .dbline 1031
 0C1B           ;                       child_responded = 1;
 0C1B 560101            mov [X+1],1
 0C1E 560000            mov [X+0],0
 0C21                   .dbline 1032
 0C21           ;               }
 0C21           L271:
 0C21                   .dbline 1033
 0C21           ;       }
 0C21           L269:
 0C21                   .dbline 1027
 0C21 3D0000            cmp [X+0],0
 0C24 B013              jnz L273
 0C26 3D0100            cmp [X+1],0
 0C29 B00E              jnz L273
 0C2B           X52:
 0C2B 62D000            mov REG[0xd0],>_TIMEOUT
 0C2E 3C0000            cmp [_TIMEOUT],0
 0C31 B006              jnz X53
 0C33 3C0100            cmp [_TIMEOUT+1],0
 0C36 AFD4              jz L268
 0C38           X53:
 0C38           L273:
 0C38                   .dbline 1036
 0C38           ;       
 0C38           ;       // Stop the right timer.
 0C38           ;       if(CHILD == PORT_A)
 0C38 62D000            mov REG[0xd0],>_CHILD
 0C3B 3C0041            cmp [_CHILD],65
 0C3E B008              jnz L274
 0C40                   .dbline 1037
 0C40           ;       {
 0C40                   .dbline 1038
 0C40           ;               CHILD_1_TIMEOUT_Stop();
 0C40 10                push X
 0C41 7C0000            xcall _CHILD_1_TIMEOUT_Stop
 0C44 20                pop X
 0C45                   .dbline 1039
 0C45           ;       }
 0C45 802C              xjmp L275
 0C47           L274:
 0C47                   .dbline 1040
 0C47           ;       else if(CHILD == PORT_B)
 0C47 62D000            mov REG[0xd0],>_CHILD
 0C4A 3C0042            cmp [_CHILD],66
 0C4D B008              jnz L276
 0C4F                   .dbline 1041
 0C4F           ;       {
 0C4F                   .dbline 1042
 0C4F           ;               CHILD_2_TIMEOUT_Stop();
 0C4F 10                push X
 0C50 7C0000            xcall _CHILD_2_TIMEOUT_Stop
 0C53 20                pop X
 0C54                   .dbline 1043
 0C54           ;       }
 0C54 801D              xjmp L277
 0C56           L276:
 0C56                   .dbline 1044
 0C56           ;       else if(CHILD == PORT_C)
 0C56 62D000            mov REG[0xd0],>_CHILD
 0C59 3C0043            cmp [_CHILD],67
 0C5C B008              jnz L278
 0C5E                   .dbline 1045
 0C5E           ;       {
 0C5E                   .dbline 1046
 0C5E           ;               CHILD_3_TIMEOUT_Stop();
 0C5E 10                push X
 0C5F 7C0000            xcall _CHILD_3_TIMEOUT_Stop
 0C62 20                pop X
 0C63                   .dbline 1047
 0C63           ;       }
 0C63 800E              xjmp L279
 0C65           L278:
 0C65                   .dbline 1048
 0C65           ;       else if(CHILD == PORT_D)
 0C65 62D000            mov REG[0xd0],>_CHILD
 0C68 3C0044            cmp [_CHILD],68
 0C6B B006              jnz L280
 0C6D                   .dbline 1049
 0C6D           ;       {
 0C6D                   .dbline 1050
 0C6D           ;               CHILD_4_TIMEOUT_Stop();
 0C6D 10                push X
 0C6E 7C0000            xcall _CHILD_4_TIMEOUT_Stop
 0C71 20                pop X
 0C72                   .dbline 1051
 0C72           ;       }
 0C72           L280:
 0C72           L279:
 0C72           L277:
 0C72           L275:
 0C72                   .dbline 1053
 0C72           ;       
 0C72           ;       TIMEOUT = 0;                                    // Reset the timeout flag.
 0C72 62D000            mov REG[0xd0],>_TIMEOUT
 0C75 550100            mov [_TIMEOUT+1],0
 0C78 550000            mov [_TIMEOUT],0
 0C7B                   .dbline 1055
 0C7B           ;       
 0C7B           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0C7B 5000              mov A,0
 0C7D 08                push A
 0C7E 5001              mov A,1
 0C80 08                push A
 0C81 7C00B4            xcall _configToggle
 0C84 38FE              add SP,-2
 0C86                   .dbline 1057
 0C86           ;       
 0C86           ;       return child_responded;
 0C86 62D000            mov REG[0xd0],>__r0
 0C89 5201              mov A,[X+1]
 0C8B 5300              mov [__r1],A
 0C8D 5200              mov A,[X+0]
 0C8F 5300              mov [__r0],A
 0C91                   .dbline -2
 0C91           L259:
 0C91 38FE              add SP,-2
 0C93 20                pop X
 0C94                   .dbline 0 ; func end
 0C94 7F                ret
 0C95                   .dbsym l child_responded 0 I
 0C95                   .dbend
 0C95                   .dbfunc e servoFinder _servoFinder fV
 0C95           ;     flashWrite -> X+7
 0C95           ; status_return_level -> X+6
 0C95           ; total_attempts -> X+4
 0C95           ;              j -> X+2
 0C95           ;              i -> X+0
 0C95           _servoFinder::
 0C95                   .dbline -1
 0C95 10                push X
 0C96 4F                mov X,SP
 0C97 3809              add SP,9
 0C99                   .dbline 1064
 0C99           ; }
 0C99           ; 
 0C99           ; // This function is used to find the servo that is directly connected to this module's controller.
 0C99           ; // After the servo ID is found, the status return level is changed so that packets are only
 0C99           ; // returned for the desired status return level defined at the top of this file.
 0C99           ; void servoFinder(void)
 0C99           ; {                             
 0C99                   .dbline 1066
 0C99           ;       // Index variables for incrementing and checking against the maximum servo comm attempts.
 0C99           ;       int i = 0;
 0C99 560100            mov [X+1],0
 0C9C 560000            mov [X+0],0
 0C9F                   .dbline 1067
 0C9F           ;       int j = 0;
 0C9F 560300            mov [X+3],0
 0CA2 560200            mov [X+2],0
 0CA5                   .dbline 1069
 0CA5           ;       
 0CA5           ;       int total_attempts = 0;
 0CA5 560500            mov [X+5],0
 0CA8 560400            mov [X+4],0
 0CAB                   .dbline 1072
 0CAB           ;       
 0CAB           ;       // Integer used as a flag so that EEPROM writes aren't done more than once.
 0CAB           ;       int flashWrite = 0;
 0CAB 560800            mov [X+8],0
 0CAE 560700            mov [X+7],0
 0CB1                   .dbline 1075
 0CB1           ;       
 0CB1           ;       // Create a status return level variable and set it to an out of range value initially.
 0CB1           ;       char status_return_level = 3;
 0CB1 560603            mov [X+6],3
 0CB4                   .dbline 1078
 0CB4           ;       
 0CB4           ;       // Start with a servo ID of 255 (out of valid range).
 0CB4           ;       SERVO_ID = SERVO_START;
 0CB4 62D000            mov REG[0xd0],>_SERVO_ID
 0CB7 5500FF            mov [_SERVO_ID],-1
 0CBA                   .dbline 1087
 0CBA           ; 
 0CBA           ;       // This for loop will loop SERVO_COMM_LOOPS number of times and ping the servo SERVO_COMM_ATTEMPTS
 0CBA           ;       // number of times in each loop (unless stopped short due to early success).  If this fails for the
 0CBA           ;       // first round of pings, a broadcast reset will be performed to reset the servo.  This is done
 0CBA           ;       // because we assume that the baud rate is matching up, but the servo's return delay time is too
 0CBA           ;       // fast for the controller to switch into receive mode to read the response.  The default return
 0CBA           ;       // delay time is 500 microseconds. If we loop for SERVO_COMM_LOOPS number of times and still don't
 0CBA           ;       // see anything, we assume that there is something is too wrong for us to fix.
 0CBA           ;       for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0CBA 560300            mov [X+3],0
 0CBD 560200            mov [X+2],0
 0CC0           L283:
 0CC0                   .dbline 1088
 0CC0           ;       {       
 0CC0                   .dbline 1090
 0CC0           ;               // Ping SERVO_COMM_ATTEMPTS times to try and extract the servo ID.
 0CC0           ;               for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0CC0 560100            mov [X+1],0
 0CC3 560000            mov [X+0],0
 0CC6           L287:
 0CC6                   .dbline 1091
 0CC6           ;               {
 0CC6                   .dbline 1093
 0CC6           ;                       // Send a ping out for any servo connected to me (will only be one).
 0CC6           ;                       servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
 0CC6 5000              mov A,0
 0CC8 08                push A
 0CC9 08                push A
 0CCA 5001              mov A,1
 0CCC 08                push A
 0CCD 5002              mov A,2
 0CCF 08                push A
 0CD0 50FE              mov A,-2
 0CD2 08                push A
 0CD3 918E              xcall _servoInstruction
 0CD5 38FB              add SP,-5
 0CD7                   .dbline 1095
 0CD7           ;                       
 0CD7           ;                       total_attempts++;
 0CD7 7705              inc [X+5]
 0CD9 0F0400            adc [X+4],0
 0CDC 804C              xjmp L292
 0CDE           L291:
 0CDE                   .dbline 1099
 0CDE           ;                       
 0CDE           ;                       // Wait for either a timeout or a valid servo ID (which will trigger a timeout).
 0CDE           ;                       while(!TIMEOUT)
 0CDE           ;                       {       
 0CDE                   .dbline 1100
 0CDE           ;                               if(commandReady())
 0CDE 7C02BE            xcall _commandReady
 0CE1 62D000            mov REG[0xd0],>__r0
 0CE4 3C0000            cmp [__r0],0
 0CE7 B006              jnz X54
 0CE9 3C0000            cmp [__r1],0
 0CEC A03C              jz L294
 0CEE           X54:
 0CEE                   .dbline 1101
 0CEE           ;                               {
 0CEE                   .dbline 1103
 0CEE           ;                                       // If we read a source ID within the range, exit the loop.
 0CEE           ;                                       if((COMMAND_SOURCE >= SERVO_ID_MIN) && (COMMAND_SOURCE <= SERVO_ID_MAX))
 0CEE 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0CF1 3C0000            cmp [_COMMAND_SOURCE],0
 0CF4 C02B              jc L296
 0CF6           X55:
 0CF6 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0CF9 50FD              mov A,-3
 0CFB 3A00              cmp A,[_COMMAND_SOURCE]
 0CFD C022              jc L296
 0CFF           X56:
 0CFF                   .dbline 1104
 0CFF           ;                                       {       
 0CFF                   .dbline 1106
 0CFF           ;                                               // Exit this while loop by setting the timeout flag.
 0CFF           ;                                               TIMEOUT = 1;
 0CFF 62D000            mov REG[0xd0],>_TIMEOUT
 0D02 550101            mov [_TIMEOUT+1],1
 0D05 550000            mov [_TIMEOUT],0
 0D08                   .dbline 1108
 0D08           ;                                               // Set the servo ID variable to where the ping came from.
 0D08           ;                                               SERVO_ID = COMMAND_SOURCE;
 0D08 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0D0B 5100              mov A,[_COMMAND_SOURCE]
 0D0D 62D000            mov REG[0xd0],>_SERVO_ID
 0D10 5300              mov [_SERVO_ID],A
 0D12                   .dbline 1110
 0D12           ;                                               // Set the index variable such that the for loop exits.
 0D12           ;                                               i = SERVO_COMM_ATTEMPTS;
 0D12 56010A            mov [X+1],10
 0D15 560000            mov [X+0],0
 0D18                   .dbline 1112
 0D18           ;                                               // Set the outer index variable to 2 to not attempt again for no reason.
 0D18           ;                                               j = SERVO_COMM_LOOPS;
 0D18 560302            mov [X+3],2
 0D1B 560200            mov [X+2],0
 0D1E                   .dbline 1113
 0D1E           ;                                       }
 0D1E 800A              xjmp L297
 0D20           L296:
 0D20                   .dbline 1115
 0D20           ;                                       else
 0D20           ;                                       {
 0D20                   .dbline 1117
 0D20           ;                                               // Exit this while loop and try to ping again.
 0D20           ;                                               TIMEOUT = 1;
 0D20 62D000            mov REG[0xd0],>_TIMEOUT
 0D23 550101            mov [_TIMEOUT+1],1
 0D26 550000            mov [_TIMEOUT],0
 0D29                   .dbline 1118
 0D29           ;                                       }
 0D29           L297:
 0D29                   .dbline 1119
 0D29           ;                               }
 0D29           L294:
 0D29                   .dbline 1120
 0D29           ;                       }
 0D29           L292:
 0D29                   .dbline 1098
 0D29 62D000            mov REG[0xd0],>_TIMEOUT
 0D2C 3C0000            cmp [_TIMEOUT],0
 0D2F B006              jnz X57
 0D31 3C0100            cmp [_TIMEOUT+1],0
 0D34 AFA9              jz L291
 0D36           X57:
 0D36                   .dbline 1121
 0D36           ;               }
 0D36           L288:
 0D36                   .dbline 1090
 0D36 7701              inc [X+1]
 0D38 0F0000            adc [X+0],0
 0D3B                   .dbline 1090
 0D3B 5201              mov A,[X+1]
 0D3D 110A              sub A,10
 0D3F 5200              mov A,[X+0]
 0D41 3180              xor A,-128
 0D43 1980              sbb A,(0 ^ 0x80)
 0D45 CF80              jc L287
 0D47           X58:
 0D47                   .dbline 1125
 0D47           ;               
 0D47           ;               // If we didn't get a response and haven't written to the flash of the
 0D47           ;               // servo (first time through), send out a broadcast reset.
 0D47           ;               if((SERVO_ID == SERVO_START) && (!flashWrite))
 0D47 62D000            mov REG[0xd0],>_SERVO_ID
 0D4A 3C00FF            cmp [_SERVO_ID],-1
 0D4D B022              jnz L298
 0D4F 3D0700            cmp [X+7],0
 0D52 B01D              jnz L298
 0D54 3D0800            cmp [X+8],0
 0D57 B018              jnz L298
 0D59           X59:
 0D59                   .dbline 1126
 0D59           ;               {
 0D59                   .dbline 1128
 0D59           ;                       // Set the flash write flag so that we only do this once per power cycle.
 0D59           ;                       flashWrite = 1;
 0D59 560801            mov [X+8],1
 0D5C 560700            mov [X+7],0
 0D5F                   .dbline 1132
 0D5F           ;                       
 0D5F           ;                       // Send out a broadcast reset so that we know that the response time interval
 0D5F           ;                       // is large enough (default delay time for a servo is 500 microseconds).
 0D5F           ;                       servoInstruction(BROADCAST, RESET_LENGTH, RESET_SERVO, 0, 0);
 0D5F 5000              mov A,0
 0D61 08                push A
 0D62 08                push A
 0D63 5006              mov A,6
 0D65 08                push A
 0D66 5002              mov A,2
 0D68 08                push A
 0D69 50FE              mov A,-2
 0D6B 08                push A
 0D6C 90F5              xcall _servoInstruction
 0D6E 38FB              add SP,-5
 0D70                   .dbline 1133
 0D70           ;               }
 0D70           L298:
 0D70                   .dbline 1134
 0D70           ;       }
 0D70           L284:
 0D70                   .dbline 1087
 0D70 7703              inc [X+3]
 0D72 0F0200            adc [X+2],0
 0D75                   .dbline 1087
 0D75 5203              mov A,[X+3]
 0D77 1102              sub A,2
 0D79 5202              mov A,[X+2]
 0D7B 3180              xor A,-128
 0D7D 1980              sbb A,(0 ^ 0x80)
 0D7F CF40              jc L283
 0D81           X60:
 0D81                   .dbline 1137
 0D81           ; 
 0D81           ;       // Reset flash write flag.
 0D81           ;       flashWrite = 0;
 0D81 560800            mov [X+8],0
 0D84 560700            mov [X+7],0
 0D87                   .dbline 1141
 0D87           ;       
 0D87           ;       // If we have a valid servo ID, set the status return level.  If we don't, just skip this
 0D87           ;       // because all hope is lost.
 0D87           ;       if(SERVO_ID < BROADCAST)
 0D87 62D000            mov REG[0xd0],>_SERVO_ID
 0D8A 3C00FE            cmp [_SERVO_ID],-2
 0D8D D0CD              jnc L327
 0D8F           X61:
 0D8F                   .dbline 1142
 0D8F           ;       {
 0D8F                   .dbline 1147
 0D8F           ;               // This for loop will loop SERVO_COMM_LOOPS number of times and poll for the servo's status
 0D8F           ;               // return level SERVO_COMM_ATTEMPTS number of times in each loop (unless stopped short due
 0D8F           ;               // to early success).  If this fails for the first iteration, or we read a status return level
 0D8F           ;               // other than what we want, we will attempt to write the desired status return level onto the servo.
 0D8F           ;               for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0D8F 560300            mov [X+3],0
 0D92 560200            mov [X+2],0
 0D95           L302:
 0D95                   .dbline 1148
 0D95           ;               {
 0D95                   .dbline 1150
 0D95           ;                       // Attempt to read the status return level for the defined number of attempts.
 0D95           ;                       for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0D95 560100            mov [X+1],0
 0D98 560000            mov [X+0],0
 0D9B           L306:
 0D9B                   .dbline 1151
 0D9B           ;                       {
 0D9B                   .dbline 1153
 0D9B           ;                               // Send a request for the servo's status return level.
 0D9B           ;                               servoInstruction(SERVO_ID, READ_LENGTH, READ_SERVO, STATUS_RET_ADDRESS, 1);
 0D9B 5001              mov A,1
 0D9D 08                push A
 0D9E 5010              mov A,16
 0DA0 08                push A
 0DA1 5002              mov A,2
 0DA3 08                push A
 0DA4 5004              mov A,4
 0DA6 08                push A
 0DA7 62D000            mov REG[0xd0],>_SERVO_ID
 0DAA 5100              mov A,[_SERVO_ID]
 0DAC 08                push A
 0DAD 90B4              xcall _servoInstruction
 0DAF 38FB              add SP,-5
 0DB1 8048              xjmp L311
 0DB3           L310:
 0DB3                   .dbline 1157
 0DB3           ;                               
 0DB3           ;                               // Wait for either a timeout or an indication that we want to exit the loop.
 0DB3           ;                               while(!TIMEOUT)
 0DB3           ;                               {
 0DB3                   .dbline 1159
 0DB3           ;                                       // If a valid command is ready, interpret it.
 0DB3           ;                                       if(commandReady())
 0DB3 7C02BE            xcall _commandReady
 0DB6 62D000            mov REG[0xd0],>__r0
 0DB9 3C0000            cmp [__r0],0
 0DBC B006              jnz X62
 0DBE 3C0000            cmp [__r1],0
 0DC1 A038              jz L313
 0DC3           X62:
 0DC3                   .dbline 1160
 0DC3           ;                                       {
 0DC3                   .dbline 1161
 0DC3           ;                                               if(!COMMAND_ERROR)
 0DC3 62D000            mov REG[0xd0],>_COMMAND_ERROR
 0DC6 3C0000            cmp [_COMMAND_ERROR],0
 0DC9 B030              jnz L315
 0DCB                   .dbline 1162
 0DCB           ;                                               {
 0DCB                   .dbline 1164
 0DCB           ;                                                       // If the return level is equal to what is desired, store it.
 0DCB           ;                                                       if(COMMAND_PARAM == STATUS_RET_LEVEL)
 0DCB 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0DCE 3C0001            cmp [_COMMAND_PARAM],1
 0DD1 B01F              jnz L317
 0DD3                   .dbline 1165
 0DD3           ;                                                       {
 0DD3                   .dbline 1167
 0DD3           ;                                                               // Set the timeout flag to exit the loop.
 0DD3           ;                                                               TIMEOUT = 1;
 0DD3 62D000            mov REG[0xd0],>_TIMEOUT
 0DD6 550101            mov [_TIMEOUT+1],1
 0DD9 550000            mov [_TIMEOUT],0
 0DDC                   .dbline 1169
 0DDC           ;                                                               // Store the status return level.
 0DDC           ;                                                               status_return_level = COMMAND_PARAM;
 0DDC 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0DDF 5100              mov A,[_COMMAND_PARAM]
 0DE1 5406              mov [X+6],A
 0DE3                   .dbline 1171
 0DE3           ;                                                               // Set i so that we exit the for loop.
 0DE3           ;                                                               i = SERVO_COMM_ATTEMPTS;
 0DE3 56010A            mov [X+1],10
 0DE6 560000            mov [X+0],0
 0DE9                   .dbline 1173
 0DE9           ;                                                               // Set the outer loop's variable so that we don't loop again.
 0DE9           ;                                                               j = SERVO_COMM_LOOPS;
 0DE9 560302            mov [X+3],2
 0DEC 560200            mov [X+2],0
 0DEF                   .dbline 1174
 0DEF           ;                                                       }
 0DEF 800A              xjmp L318
 0DF1           L317:
 0DF1                   .dbline 1176
 0DF1           ;                                                       else
 0DF1           ;                                                       {       
 0DF1                   .dbline 1178
 0DF1           ;                                                               // Set the timeout flag to exit the loop.
 0DF1           ;                                                               TIMEOUT = 1;
 0DF1 62D000            mov REG[0xd0],>_TIMEOUT
 0DF4 550101            mov [_TIMEOUT+1],1
 0DF7 550000            mov [_TIMEOUT],0
 0DFA                   .dbline 1179
 0DFA           ;                                                       }
 0DFA           L318:
 0DFA                   .dbline 1180
 0DFA           ;                                               }
 0DFA           L315:
 0DFA                   .dbline 1181
 0DFA           ;                                       }
 0DFA           L313:
 0DFA                   .dbline 1182
 0DFA           ;                               }
 0DFA           L311:
 0DFA                   .dbline 1156
 0DFA 62D000            mov REG[0xd0],>_TIMEOUT
 0DFD 3C0000            cmp [_TIMEOUT],0
 0E00 B006              jnz X63
 0E02 3C0100            cmp [_TIMEOUT+1],0
 0E05 AFAD              jz L310
 0E07           X63:
 0E07                   .dbline 1183
 0E07           ;                       }
 0E07           L307:
 0E07                   .dbline 1150
 0E07 7701              inc [X+1]
 0E09 0F0000            adc [X+0],0
 0E0C                   .dbline 1150
 0E0C 5201              mov A,[X+1]
 0E0E 110A              sub A,10
 0E10 5200              mov A,[X+0]
 0E12 3180              xor A,-128
 0E14 1980              sbb A,(0 ^ 0x80)
 0E16 CF84              jc L306
 0E18           X64:
 0E18                   .dbline 1187
 0E18           ;               
 0E18           ;                       // If we didn't get a good response and haven't written to the flash of the servo,
 0E18           ;                       // force a change in the status return level with an EEPROM write.
 0E18           ;                       if((status_return_level != STATUS_RET_LEVEL) && (!flashWrite))
 0E18 3D0601            cmp [X+6],1
 0E1B A027              jz L319
 0E1D 3D0700            cmp [X+7],0
 0E20 B022              jnz L319
 0E22 3D0800            cmp [X+8],0
 0E25 B01D              jnz L319
 0E27           X65:
 0E27                   .dbline 1188
 0E27           ;                       {       
 0E27                   .dbline 1189
 0E27           ;                               flashWrite = 1;
 0E27 560801            mov [X+8],1
 0E2A 560700            mov [X+7],0
 0E2D                   .dbline 1192
 0E2D           ;                               
 0E2D           ;                               // Try to force the return status to what we want.
 0E2D           ;                               servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, STATUS_RET_ADDRESS, STATUS_RET_LEVEL);
 0E2D 5001              mov A,1
 0E2F 08                push A
 0E30 5010              mov A,16
 0E32 08                push A
 0E33 5003              mov A,3
 0E35 08                push A
 0E36 5004              mov A,4
 0E38 08                push A
 0E39 62D000            mov REG[0xd0],>_SERVO_ID
 0E3C 5100              mov A,[_SERVO_ID]
 0E3E 08                push A
 0E3F 9022              xcall _servoInstruction
 0E41 38FB              add SP,-5
 0E43                   .dbline 1193
 0E43           ;                       }
 0E43           L319:
 0E43                   .dbline 1194
 0E43           ;               }
 0E43           L303:
 0E43                   .dbline 1147
 0E43 7703              inc [X+3]
 0E45 0F0200            adc [X+2],0
 0E48                   .dbline 1147
 0E48 5203              mov A,[X+3]
 0E4A 1102              sub A,2
 0E4C 5202              mov A,[X+2]
 0E4E 3180              xor A,-128
 0E50 1980              sbb A,(0 ^ 0x80)
 0E52 CF42              jc L302
 0E54           X66:
 0E54                   .dbline 1196
 0E54           ;               
 0E54           ;               if(status_return_level != STATUS_RET_LEVEL)
 0E54 3D0601            cmp [X+6],1
 0E57 A005              jz L301
 0E59                   .dbline 1197
 0E59           ;               {
 0E59           L323:
 0E59                   .dbline 1199
 0E59           ;                       // Break on purpose to show that the status return is not correct.
 0E59           ;                       while(1) { }
 0E59                   .dbline 1199
 0E59           L324:
 0E59                   .dbline 1199
 0E59 8FFF              xjmp L323
 0E5B           L326:
 0E5B                   .dbline 1205
 0E5B           ;               }
 0E5B           ;       }
 0E5B           ;       else
 0E5B           ;       {
 0E5B           ;               // Purposely break the module to show that we did not resolve the communication with our servo.
 0E5B           ;               while(1) { }
 0E5B                   .dbline 1205
 0E5B           L327:
 0E5B                   .dbline 1205
 0E5B 8FFF              xjmp L326
 0E5D           L301:
 0E5D                   .dbline 1209
 0E5D           ;       }
 0E5D           ;       
 0E5D           ;       // Wait for the other controllers to find their servos.
 0E5D           ;       servoConfigWait();
 0E5D 9155              xcall _servoConfigWait
 0E5F                   .dbline -2
 0E5F           L282:
 0E5F 38F7              add SP,-9
 0E61 20                pop X
 0E62                   .dbline 0 ; func end
 0E62 7F                ret
 0E63                   .dbsym l flashWrite 7 I
 0E63                   .dbsym l status_return_level 6 c
 0E63                   .dbsym l total_attempts 4 I
 0E63                   .dbsym l j 2 I
 0E63                   .dbsym l i 0 I
 0E63                   .dbend
 0E63                   .dbfunc e servoInstruction _servoInstruction fV
 0E63           ;       checksum -> X+0
 0E63           ;          value -> X-8
 0E63           ;        address -> X-7
 0E63           ;    instruction -> X-6
 0E63           ;         length -> X-5
 0E63           ;             id -> X-4
 0E63           _servoInstruction::
 0E63                   .dbline -1
 0E63 10                push X
 0E64 4F                mov X,SP
 0E65 3801              add SP,1
 0E67                   .dbline 1215
 0E67           ; }
 0E67           ; 
 0E67           ; // This function receives a destination, command length, instruction type, address, and value.
 0E67           ; // With these parameters, the function sends a packet to the communication bus.
 0E67           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 0E67           ; {
 0E67                   .dbline 1219
 0E67           ;       char checksum;
 0E67           ;       
 0E67           ;       // Toggle into transmit mode.
 0E67           ;       configToggle(SERVO_COMM);
 0E67 5000              mov A,0
 0E69 08                push A
 0E6A 5009              mov A,9
 0E6C 08                push A
 0E6D 7C00B4            xcall _configToggle
 0E70 38FE              add SP,-2
 0E72                   .dbline 1222
 0E72           ;       
 0E72           ;       // Calculate the checksum value for our servo communication.
 0E72           ;       checksum = 255-((id + length + instruction + address + value)%256);
 0E72 62D000            mov REG[0xd0],>__r0
 0E75 52FB              mov A,[X-5]
 0E77 5300              mov [__r1],A
 0E79 550000            mov [__r0],0
 0E7C 52FC              mov A,[X-4]
 0E7E 0200              add A,[__r1]
 0E80 5300              mov [__r1],A
 0E82 5000              mov A,0
 0E84 0A00              adc A,[__r0]
 0E86 5300              mov [__r0],A
 0E88 52FA              mov A,[X-6]
 0E8A 0400              add [__r1],A
 0E8C 0E0000            adc [__r0],0
 0E8F 52F9              mov A,[X-7]
 0E91 0400              add [__r1],A
 0E93 0E0000            adc [__r0],0
 0E96 52F8              mov A,[X-8]
 0E98 0400              add [__r1],A
 0E9A 0E0000            adc [__r0],0
 0E9D 5001              mov A,1
 0E9F 08                push A
 0EA0 5000              mov A,0
 0EA2 08                push A
 0EA3 5100              mov A,[__r0]
 0EA5 08                push A
 0EA6 5100              mov A,[__r1]
 0EA8 08                push A
 0EA9 7C0000            xcall __divmod_16X16_16
 0EAC 38FE              add SP,-2
 0EAE 18                pop A
 0EAF 5300              mov [__r1],A
 0EB1 18                pop A
 0EB2 50FF              mov A,-1
 0EB4 1200              sub A,[__r1]
 0EB6 5400              mov [X+0],A
 0EB8                   .dbline 1225
 0EB8           ;       
 0EB8           ;       // Talk to the servo.
 0EB8           ;       if(instruction == PING_SERVO)
 0EB8 3DFA01            cmp [X-6],1
 0EBB B02D              jnz L330
 0EBD                   .dbline 1226
 0EBD           ;       {
 0EBD                   .dbline 1227
 0EBD           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte one
 0EBD 10                push X
 0EBE 50FF              mov A,-1
 0EC0 7C0000            xcall _SERVO_TX_PutChar
 0EC3 20                pop X
 0EC4                   .dbline 1228
 0EC4           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte two
 0EC4 10                push X
 0EC5 50FF              mov A,-1
 0EC7 7C0000            xcall _SERVO_TX_PutChar
 0ECA 20                pop X
 0ECB                   .dbline 1229
 0ECB           ;               SERVO_TX_PutChar(id);                   // Servo ID
 0ECB 10                push X
 0ECC 52FC              mov A,[X-4]
 0ECE 7C0000            xcall _SERVO_TX_PutChar
 0ED1 20                pop X
 0ED2                   .dbline 1230
 0ED2           ;               SERVO_TX_PutChar(length);               // The instruction length.
 0ED2 10                push X
 0ED3 52FB              mov A,[X-5]
 0ED5 7C0000            xcall _SERVO_TX_PutChar
 0ED8 20                pop X
 0ED9                   .dbline 1231
 0ED9           ;               SERVO_TX_PutChar(instruction);  // The instruction to carry out.
 0ED9 10                push X
 0EDA 52FA              mov A,[X-6]
 0EDC 7C0000            xcall _SERVO_TX_PutChar
 0EDF 20                pop X
 0EE0                   .dbline 1232
 0EE0           ;               SERVO_TX_PutChar(checksum);             // This is the checksum.
 0EE0 10                push X
 0EE1 5200              mov A,[X+0]
 0EE3 7C0000            xcall _SERVO_TX_PutChar
 0EE6 20                pop X
 0EE7                   .dbline 1233
 0EE7           ;       }
 0EE7 8039              xjmp L333
 0EE9           L330:
 0EE9                   .dbline 1235
 0EE9           ;       else
 0EE9           ;       {
 0EE9                   .dbline 1236
 0EE9           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte one
 0EE9 10                push X
 0EEA 50FF              mov A,-1
 0EEC 7C0000            xcall _SERVO_TX_PutChar
 0EEF 20                pop X
 0EF0                   .dbline 1237
 0EF0           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte two
 0EF0 10                push X
 0EF1 50FF              mov A,-1
 0EF3 7C0000            xcall _SERVO_TX_PutChar
 0EF6 20                pop X
 0EF7                   .dbline 1238
 0EF7           ;               SERVO_TX_PutChar(id);                   // Servo ID
 0EF7 10                push X
 0EF8 52FC              mov A,[X-4]
 0EFA 7C0000            xcall _SERVO_TX_PutChar
 0EFD 20                pop X
 0EFE                   .dbline 1239
 0EFE           ;               SERVO_TX_PutChar(length);               // The instruction length.
 0EFE 10                push X
 0EFF 52FB              mov A,[X-5]
 0F01 7C0000            xcall _SERVO_TX_PutChar
 0F04 20                pop X
 0F05                   .dbline 1240
 0F05           ;               SERVO_TX_PutChar(instruction);  // The instruction to carry out.
 0F05 10                push X
 0F06 52FA              mov A,[X-6]
 0F08 7C0000            xcall _SERVO_TX_PutChar
 0F0B 20                pop X
 0F0C                   .dbline 1241
 0F0C           ;               SERVO_TX_PutChar(address);              // The address to read/write from/to.
 0F0C 10                push X
 0F0D 52F9              mov A,[X-7]
 0F0F 7C0000            xcall _SERVO_TX_PutChar
 0F12 20                pop X
 0F13                   .dbline 1242
 0F13           ;               SERVO_TX_PutChar(value);                // The value to write or number of bytes to read.
 0F13 10                push X
 0F14 52F8              mov A,[X-8]
 0F16 7C0000            xcall _SERVO_TX_PutChar
 0F19 20                pop X
 0F1A                   .dbline 1243
 0F1A           ;               SERVO_TX_PutChar(checksum);             // This is the checksum.
 0F1A 10                push X
 0F1B 5200              mov A,[X+0]
 0F1D 7C0000            xcall _SERVO_TX_PutChar
 0F20 20                pop X
 0F21                   .dbline 1244
 0F21           ;       }
 0F21           L332:
 0F21                   .dbline 1247
 0F21           ;       
 0F21           ;       // Wait for the transmission to finish.
 0F21           ;       while(!(SERVO_TX_bReadTxStatus() & SERVO_TX_TX_COMPLETE));
 0F21           L333:
 0F21                   .dbline 1247
 0F21 10                push X
 0F22 7C0000            xcall _SERVO_TX_bReadTxStatus
 0F25 62D000            mov REG[0xd0],>__r0
 0F28 20                pop X
 0F29 5300              mov [__r0],A
 0F2B 470020            tst [__r0],32
 0F2E AFF2              jz L332
 0F30                   .dbline 1250
 0F30           ;       
 0F30           ;       // Make completely sure we're done.
 0F30           ;       xmitWait();
 0F30 900F              xcall _xmitWait
 0F32                   .dbline 1253
 0F32           ;       
 0F32           ;       // Switch back to wait for a servo response.
 0F32           ;       configToggle(INITIALIZE);
 0F32 5000              mov A,0
 0F34 08                push A
 0F35 5008              mov A,8
 0F37 08                push A
 0F38 7C00B4            xcall _configToggle
 0F3B 38FE              add SP,-2
 0F3D                   .dbline -2
 0F3D           L329:
 0F3D 38FF              add SP,-1
 0F3F 20                pop X
 0F40                   .dbline 0 ; func end
 0F40 7F                ret
 0F41                   .dbsym l checksum 0 c
 0F41                   .dbsym l value -8 c
 0F41                   .dbsym l address -7 c
 0F41                   .dbsym l instruction -6 c
 0F41                   .dbsym l length -5 c
 0F41                   .dbsym l id -4 c
 0F41                   .dbend
 0F41                   .dbfunc e xmitWait _xmitWait fV
 0F41           ;              i -> X+0
 0F41           _xmitWait::
 0F41                   .dbline -1
 0F41 10                push X
 0F42 4F                mov X,SP
 0F43 3802              add SP,2
 0F45                   .dbline 1257
 0F45           ; }
 0F45           ; 
 0F45           ; void xmitWait(void)
 0F45           ; {
 0F45                   .dbline 1260
 0F45           ;       int i;
 0F45           ;       
 0F45           ;       for(i = 0; i < 25; i++)
 0F45 560100            mov [X+1],0
 0F48 560000            mov [X+0],0
 0F4B           L336:
 0F4B                   .dbline 1261
 0F4B           ;       {
 0F4B                   .dbline 1263
 0F4B           ;               // Does nothing and wastes approximately 50 microseconds.
 0F4B           ;       }
 0F4B           L337:
 0F4B                   .dbline 1260
 0F4B 7701              inc [X+1]
 0F4D 0F0000            adc [X+0],0
 0F50                   .dbline 1260
 0F50 5201              mov A,[X+1]
 0F52 1119              sub A,25
 0F54 5200              mov A,[X+0]
 0F56 3180              xor A,-128
 0F58 1980              sbb A,(0 ^ 0x80)
 0F5A CFF0              jc L336
 0F5C           X67:
 0F5C                   .dbline -2
 0F5C           L335:
 0F5C 38FE              add SP,-2
 0F5E 20                pop X
 0F5F                   .dbline 0 ; func end
 0F5F 7F                ret
 0F60                   .dbsym l i 0 I
 0F60                   .dbend
 0F60                   .dbfunc e servoBootWait _servoBootWait fV
 0F60           ;              i -> X+0
 0F60           _servoBootWait::
 0F60                   .dbline -1
 0F60 10                push X
 0F61 4F                mov X,SP
 0F62 3802              add SP,2
 0F64                   .dbline 1270
 0F64           ; }
 0F64           ; 
 0F64           ; // This function wastes time while the servo that is attached to this controller boots up.
 0F64           ; // Once that happens, communications should happen quickly and reliably.  The estimated boot
 0F64           ; // time in testing was approximately 120 ms.
 0F64           ; void servoBootWait(void)
 0F64           ; {
 0F64                   .dbline 1271
 0F64           ;       int i = 0;                                      // Index integer used for looping.
 0F64 560100            mov [X+1],0
 0F67 560000            mov [X+0],0
 0F6A                   .dbline 1273
 0F6A           ; 
 0F6A           ;       configToggle(INITIALIZE);       // Switch to initialize mode to do this timeout routine.
 0F6A 5000              mov A,0
 0F6C 08                push A
 0F6D 5008              mov A,8
 0F6F 08                push A
 0F70 7C00B4            xcall _configToggle
 0F73 38FE              add SP,-2
 0F75                   .dbline 1276
 0F75           ;       
 0F75           ;       // Loop and wait for enough timeouts to happen before we talk to the servo.
 0F75           ;       for(i = 0; i < SERVO_BOOT_TIMEOUTS; i++)
 0F75 560100            mov [X+1],0
 0F78 560000            mov [X+0],0
 0F7B                   .dbline 1277
 0F7B           ;       {
 0F7B           L345:
 0F7B                   .dbline 1278
 0F7B           ;               while(!TIMEOUT) { }             // Do nothing while we wait for one timeout period.
 0F7B                   .dbline 1278
 0F7B           L346:
 0F7B                   .dbline 1278
 0F7B 62D000            mov REG[0xd0],>_TIMEOUT
 0F7E 3C0000            cmp [_TIMEOUT],0
 0F81 B006              jnz X68
 0F83 3C0100            cmp [_TIMEOUT+1],0
 0F86 AFF4              jz L345
 0F88           X68:
 0F88                   .dbline 1279
 0F88           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 0F88 62D000            mov REG[0xd0],>_TIMEOUT
 0F8B 550100            mov [_TIMEOUT+1],0
 0F8E 550000            mov [_TIMEOUT],0
 0F91                   .dbline 1280
 0F91           ;       }
 0F91           L342:
 0F91                   .dbline 1276
 0F91 7701              inc [X+1]
 0F93 0F0000            adc [X+0],0
 0F96                   .dbline 1276
 0F96 5201              mov A,[X+1]
 0F98 114B              sub A,75
 0F9A 5200              mov A,[X+0]
 0F9C 3180              xor A,-128
 0F9E 1980              sbb A,(0 ^ 0x80)
 0FA0 CFDA              jc L346
 0FA2           X69:
 0FA2                   .dbline 1282
 0FA2           ;       
 0FA2           ;       INIT_TIMEOUT_Stop();            // Stop the timeout timer.
 0FA2 10                push X
 0FA3 7C0000            xcall _INIT_TIMEOUT_Stop
 0FA6 20                pop X
 0FA7                   .dbline 1283
 0FA7           ;       TIMEOUT = 0;                            // Clear the timeout flag.
 0FA7 62D000            mov REG[0xd0],>_TIMEOUT
 0FAA 550100            mov [_TIMEOUT+1],0
 0FAD 550000            mov [_TIMEOUT],0
 0FB0                   .dbline -2
 0FB0           L340:
 0FB0 38FE              add SP,-2
 0FB2 20                pop X
 0FB3                   .dbline 0 ; func end
 0FB3 7F                ret
 0FB4                   .dbsym l i 0 I
 0FB4                   .dbend
 0FB4                   .dbfunc e servoConfigWait _servoConfigWait fV
 0FB4           ;              i -> X+0
 0FB4           _servoConfigWait::
 0FB4                   .dbline -1
 0FB4 10                push X
 0FB5 4F                mov X,SP
 0FB6 3802              add SP,2
 0FB8                   .dbline 1289
 0FB8           ; }
 0FB8           ; 
 0FB8           ; // Sits and spins for the amount of time it takes for a worst case scenario for setup time
 0FB8           ; // to take place.  This allows all other modules to initialize.
 0FB8           ; void servoConfigWait(void)
 0FB8           ; {
 0FB8                   .dbline 1290
 0FB8           ;       int i = 0;                                      // Index integer for looping purposes.
 0FB8 560100            mov [X+1],0
 0FBB 560000            mov [X+0],0
 0FBE                   .dbline 1292
 0FBE           ;       
 0FBE           ;       configToggle(INITIALIZE);       // Switch to initialize mode to do this timeout routine.
 0FBE 5000              mov A,0
 0FC0 08                push A
 0FC1 5008              mov A,8
 0FC3 08                push A
 0FC4 7C00B4            xcall _configToggle
 0FC7 38FE              add SP,-2
 0FC9                   .dbline 1297
 0FC9           ;       
 0FC9           ;       // For SERVO_COMM_ATTEMPTS*SERVO_COMM_LOOPS cycles, let the other controllers find
 0FC9           ;       // their servos.  The reason we loop this many times is to allow for a possible worst
 0FC9           ;       // case scenario of setup time to complete.
 0FC9           ;       for(i = 0; i < (SERVO_COMM_ATTEMPTS*SERVO_COMM_LOOPS); i++)
 0FC9 560100            mov [X+1],0
 0FCC 560000            mov [X+0],0
 0FCF                   .dbline 1298
 0FCF           ;       {
 0FCF           L353:
 0FCF                   .dbline 1299
 0FCF           ;               while(!TIMEOUT) { }             // Do nothing while we wait for one timeout period.
 0FCF                   .dbline 1299
 0FCF           L354:
 0FCF                   .dbline 1299
 0FCF 62D000            mov REG[0xd0],>_TIMEOUT
 0FD2 3C0000            cmp [_TIMEOUT],0
 0FD5 B006              jnz X70
 0FD7 3C0100            cmp [_TIMEOUT+1],0
 0FDA AFF4              jz L353
 0FDC           X70:
 0FDC                   .dbline 1300
 0FDC           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 0FDC 62D000            mov REG[0xd0],>_TIMEOUT
 0FDF 550100            mov [_TIMEOUT+1],0
 0FE2 550000            mov [_TIMEOUT],0
 0FE5                   .dbline 1301
 0FE5           ;       }
 0FE5           L350:
 0FE5                   .dbline 1297
 0FE5 7701              inc [X+1]
 0FE7 0F0000            adc [X+0],0
 0FEA                   .dbline 1297
 0FEA 5201              mov A,[X+1]
 0FEC 1114              sub A,20
 0FEE 5200              mov A,[X+0]
 0FF0 3180              xor A,-128
 0FF2 1980              sbb A,(0 ^ 0x80)
 0FF4 CFDA              jc L354
 0FF6           X71:
 0FF6                   .dbline 1303
 0FF6           ;       
 0FF6           ;       INIT_TIMEOUT_Stop();            // Stop the timer.
 0FF6 10                push X
 0FF7 7C0000            xcall _INIT_TIMEOUT_Stop
 0FFA 20                pop X
 0FFB                   .dbline 1304
 0FFB           ;       TIMEOUT = 0;                            // Reset the timeout flag.
 0FFB 62D000            mov REG[0xd0],>_TIMEOUT
 0FFE 550100            mov [_TIMEOUT+1],0
 1001 550000            mov [_TIMEOUT],0
 1004                   .dbline 1306
 1004           ; 
 1004           ;       configToggle(WAIT);                     // Switch to wait for the master node to speak to you.
 1004 5000              mov A,0
 1006 08                push A
 1007 5001              mov A,1
 1009 08                push A
 100A 7C00B4            xcall _configToggle
 100D 38FE              add SP,-2
 100F                   .dbline -2
 100F           L348:
 100F 38FE              add SP,-2
 1011 20                pop X
 1012                   .dbline 0 ; func end
 1012 7F                ret
 1013                   .dbsym l i 0 I
 1013                   .dbend
 1013                   .dbfunc e TX_01234_TIMEOUT_ISR _TX_01234_TIMEOUT_ISR fV
 1013           _TX_01234_TIMEOUT_ISR::
 1013                   .dbline -1
 1013 71C0              or F,-64
 1015 08                push A
 1016 5DD0              mov A,REG[0xd0]
 1018 08                push A
 1019                   .dbline 1314
 1019           ; }
 1019           ; 
 1019           ; // This timeout ISR is for waiting before a transmission is made from this module.
 1019           ; // This is to give all the other modules a chance to set up and clear their buffers.
 1019           ; // It is currently set so that there is 1 ms of down time between the last transmission
 1019           ; // and this module's transmission.
 1019           ; void TX_01234_TIMEOUT_ISR(void)
 1019           ; {
 1019                   .dbline 1315
 1019           ;       TIMEOUT = 1;    // Set the timeout flag.
 1019 62D000            mov REG[0xd0],>_TIMEOUT
 101C 550101            mov [_TIMEOUT+1],1
 101F 550000            mov [_TIMEOUT],0
 1022                   .dbline 1316
 1022           ;       M8C_ClearIntFlag(INT_CLR0,TX_01234_TIMEOUT_INT_MASK);
 1022 62DAFD            mov REG[0xda],-3
 1025                   .dbline -2
 1025           L356:
 1025 18                pop A
 1026 60D0              mov REG[208],A
 1028 18                pop A
 1029                   .dbline 0 ; func end
 1029 7E                reti
 102A                   .dbend
 102A                   .dbfunc e HELLO_TIMEOUT_ISR _HELLO_TIMEOUT_ISR fV
 102A           _HELLO_TIMEOUT_ISR::
 102A                   .dbline -1
 102A 71C0              or F,-64
 102C 08                push A
 102D 5DD0              mov A,REG[0xd0]
 102F 08                push A
 1030                   .dbline 1321
 1030           ; }
 1030           ; 
 1030           ; // This is the ISR for a hello response timeout.
 1030           ; void HELLO_TIMEOUT_ISR(void)
 1030           ; {
 1030                   .dbline 1322
 1030           ;       TIMEOUT = 1;    // Set the timeout flag.
 1030 62D000            mov REG[0xd0],>_TIMEOUT
 1033 550101            mov [_TIMEOUT+1],1
 1036 550000            mov [_TIMEOUT],0
 1039                   .dbline 1323
 1039           ;       M8C_ClearIntFlag(INT_CLR0,HELLO_TIMEOUT_INT_MASK);
 1039 62DAFD            mov REG[0xda],-3
 103C                   .dbline -2
 103C           L357:
 103C 18                pop A
 103D 60D0              mov REG[208],A
 103F 18                pop A
 1040                   .dbline 0 ; func end
 1040 7E                reti
 1041                   .dbend
 1041                   .dbfunc e CHILD_1_TIMEOUT_ISR _CHILD_1_TIMEOUT_ISR fV
 1041           _CHILD_1_TIMEOUT_ISR::
 1041                   .dbline -1
 1041 71C0              or F,-64
 1043 08                push A
 1044 5DD0              mov A,REG[0xd0]
 1046 08                push A
 1047                   .dbline 1328
 1047           ; }
 1047           ; 
 1047           ; // These remaining ISRs are for all the child timeout scenarios.
 1047           ; void CHILD_1_TIMEOUT_ISR(void)
 1047           ; {
 1047                   .dbline 1329
 1047           ;       TIMEOUT = 1;    // Set the timeout flag.
 1047 62D000            mov REG[0xd0],>_TIMEOUT
 104A 550101            mov [_TIMEOUT+1],1
 104D 550000            mov [_TIMEOUT],0
 1050                   .dbline 1330
 1050           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_1_TIMEOUT_INT_MASK);
 1050 62DAFD            mov REG[0xda],-3
 1053                   .dbline -2
 1053           L358:
 1053 18                pop A
 1054 60D0              mov REG[208],A
 1056 18                pop A
 1057                   .dbline 0 ; func end
 1057 7E                reti
 1058                   .dbend
 1058                   .dbfunc e CHILD_2_TIMEOUT_ISR _CHILD_2_TIMEOUT_ISR fV
 1058           _CHILD_2_TIMEOUT_ISR::
 1058                   .dbline -1
 1058 71C0              or F,-64
 105A 08                push A
 105B 5DD0              mov A,REG[0xd0]
 105D 08                push A
 105E                   .dbline 1334
 105E           ; }
 105E           ; 
 105E           ; void CHILD_2_TIMEOUT_ISR(void)
 105E           ; {
 105E                   .dbline 1335
 105E           ;       TIMEOUT = 1;    // Set the timeout flag.
 105E 62D000            mov REG[0xd0],>_TIMEOUT
 1061 550101            mov [_TIMEOUT+1],1
 1064 550000            mov [_TIMEOUT],0
 1067                   .dbline 1336
 1067           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_2_TIMEOUT_INT_MASK);
 1067 62DAFD            mov REG[0xda],-3
 106A                   .dbline -2
 106A           L359:
 106A 18                pop A
 106B 60D0              mov REG[208],A
 106D 18                pop A
 106E                   .dbline 0 ; func end
 106E 7E                reti
 106F                   .dbend
 106F                   .dbfunc e CHILD_3_TIMEOUT_ISR _CHILD_3_TIMEOUT_ISR fV
 106F           _CHILD_3_TIMEOUT_ISR::
 106F                   .dbline -1
 106F 71C0              or F,-64
 1071 08                push A
 1072 5DD0              mov A,REG[0xd0]
 1074 08                push A
 1075                   .dbline 1340
 1075           ; }
 1075           ; 
 1075           ; void CHILD_3_TIMEOUT_ISR(void)
 1075           ; {
 1075                   .dbline 1341
 1075           ;       TIMEOUT = 1;    // Set the timeout flag.
 1075 62D000            mov REG[0xd0],>_TIMEOUT
 1078 550101            mov [_TIMEOUT+1],1
 107B 550000            mov [_TIMEOUT],0
 107E                   .dbline 1342
 107E           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_3_TIMEOUT_INT_MASK);
 107E 62DAFD            mov REG[0xda],-3
 1081                   .dbline -2
 1081           L360:
 1081 18                pop A
 1082 60D0              mov REG[208],A
 1084 18                pop A
 1085                   .dbline 0 ; func end
 1085 7E                reti
 1086                   .dbend
 1086                   .dbfunc e CHILD_4_TIMEOUT_ISR _CHILD_4_TIMEOUT_ISR fV
 1086           _CHILD_4_TIMEOUT_ISR::
 1086                   .dbline -1
 1086 71C0              or F,-64
 1088 08                push A
 1089 5DD0              mov A,REG[0xd0]
 108B 08                push A
 108C                   .dbline 1346
 108C           ; }
 108C           ; 
 108C           ; void CHILD_4_TIMEOUT_ISR(void)
 108C           ; {
 108C                   .dbline 1347
 108C           ;       TIMEOUT = 1;    // Set the timeout flag.
 108C 62D000            mov REG[0xd0],>_TIMEOUT
 108F 550101            mov [_TIMEOUT+1],1
 1092 550000            mov [_TIMEOUT],0
 1095                   .dbline 1348
 1095           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_4_TIMEOUT_INT_MASK);
 1095 62DAFD            mov REG[0xda],-3
 1098                   .dbline -2
 1098           L361:
 1098 18                pop A
 1099 60D0              mov REG[208],A
 109B 18                pop A
 109C                   .dbline 0 ; func end
 109C 7E                reti
 109D                   .dbend
 109D                   .dbfunc e INIT_TIMEOUT_ISR _INIT_TIMEOUT_ISR fV
 109D           _INIT_TIMEOUT_ISR::
 109D                   .dbline -1
 109D 71C0              or F,-64
 109F 08                push A
 10A0 5DD0              mov A,REG[0xd0]
 10A2 08                push A
 10A3                   .dbline 1352
 10A3           ; }
 10A3           ; 
 10A3           ; void INIT_TIMEOUT_ISR(void)
 10A3           ; {
 10A3                   .dbline 1353
 10A3           ;       TIMEOUT = 1;    // Set the timeout flag.
 10A3 62D000            mov REG[0xd0],>_TIMEOUT
 10A6 550101            mov [_TIMEOUT+1],1
 10A9 550000            mov [_TIMEOUT],0
 10AC                   .dbline 1354
 10AC           ;       M8C_ClearIntFlag(INT_CLR0,INIT_TIMEOUT_INT_MASK);
 10AC 62DAFD            mov REG[0xda],-3
 10AF                   .dbline -2
 10AF           L362:
 10AF 18                pop A
 10B0 60D0              mov REG[208],A
 10B2 18                pop A
 10B3                   .dbline 0 ; func end
 10B3 7E                reti
 10B4                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _SERVO_ID::
 0000 00                .byte 0
 0001                   .dbsym e SERVO_ID _SERVO_ID c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_ERROR::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_ERROR _COMMAND_ERROR c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_LENGTH::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_LENGTH _COMMAND_LENGTH c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_PARAM::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_PARAM _COMMAND_PARAM c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _CONFIGURED::
 0000 0000              .byte 0,0
 0002                   .dbsym e CONFIGURED _CONFIGURED I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _ID::
 0000 00                .byte 0
 0001                   .dbsym e ID _ID c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _CHILD::
 0000 00                .byte 0
 0001                   .dbsym e CHILD _CHILD c
