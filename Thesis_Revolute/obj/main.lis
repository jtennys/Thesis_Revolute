 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 155
 0000           ; // Author: Jason Tennyson
 0000           ; // Date: 1-25-11
 0000           ; // File: main.c
 0000           ; //
 0000           ; // This is the design for the revolute modules for Jason Tennyson's Thesis.
 0000           ; // This design is made for a PSoC CY8C28433-24PVXI.
 0000           ; //
 0000           ; // Packet Structure
 0000           ; // ----------------
 0000           ; // START BYTE/START BYTE/SOURCE ID BYTE/DESTINATION ID BYTE/COMMAND TYPE/PARAM 1/.../PARAM N/END TRANSMIT
 0000           ; 
 0000           ; #include <m8c.h>              // Part-specific constants and macros.
 0000           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules.
 0000           ; #include "psocdynamic.h"      // Required for dynamically swapping configurations at run time.
 0000           ; 
 0000           ; // These are declarations of all of the timer interrupts that are used for all configurations.
 0000           ; #pragma interrupt_handler WAIT_NC_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler TX_01234_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_1_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_2_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_3_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_4_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler HELLO_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler INIT_TIMEOUT_ISR
 0000           ; 
 0000           ; // These defines are used as parameters of the configToggle function.  Passing one of
 0000           ; // these identifiers to configToggle will put the chip in that device configuration.
 0000           ; #define               WAIT                                            (1)
 0000           ; #define               MY_RESPONSE                                     (2)
 0000           ; #define       RESPONSE_1                                      (3)
 0000           ; #define       RESPONSE_2                                      (4)
 0000           ; #define       RESPONSE_3                                      (5)
 0000           ; #define       RESPONSE_4                                      (6)
 0000           ; #define               HELLO_MODE                                      (7)
 0000           ; #define               INITIALIZE                                      (8)
 0000           ; #define               SERVO_COMM                                      (9)
 0000           ; 
 0000           ; // These defines are used as comparisons to find what port the next module connected to.
 0000           ; #define               PORT_A                                          ('A')
 0000           ; #define               PORT_B                                          ('B')
 0000           ; #define               PORT_C                                          ('C')
 0000           ; #define               PORT_D                                          ('D')
 0000           ; 
 0000           ; // These defines are used as transmission indicators for transmissions between PSoC controllers.
 0000           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0000           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0000           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0000           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0000           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is complete.
 0000           ; #define               PING                                            (203)   // Indicates a ping message to or from the master.
 0000           ; #define               CLEAR_CONFIG                            (204)   // Indicates that the master is asking for a config clear.
 0000           ; #define               CONFIG_CLEARED                          (205)   // Indicates that a module has cleared its own config.
 0000           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0000           ; #define               DEFAULT_ID                                      (251)   // The ID that all modules start with.
 0000           ; #define               BROADCAST                                       (254)   // The broadcast ID for all controllers and servos.
 0000           ; 
 0000           ; // SERVO DEFINES
 0000           ; // These numbers can all be found in the AX-12+ datasheet.
 0000           ; // These defines cover the range of IDs these servos are capable of.
 0000           ; #define               SERVO_ID_MIN                            (0)             // This is the lowest servo ID possible.
 0000           ; #define               SERVO_ID_MAX                            (253)   // This is the highest servo ID possible.
 0000           ; // These defines are servo transmission indicators.
 0000           ; #define               SERVO_START                                     (255)   // This is the start byte for a servo transmission.
 0000           ; // These defines are used to fill in the length parameter for a given command type.  These are the only
 0000           ; // lengths used by this controller for servo configuration purposes.  It is worth noting that any type
 0000           ; // and length of command can be issued from the master after configuration is complete.
 0000           ; #define               READ_LENGTH                                     (4)             // This is the length value for all reads.
 0000           ; #define               WRITE_LENGTH                            (4)             // This is the length value for all writes.
 0000           ; #define               PING_LENGTH                                     (2)             // This is the length value for a ping.
 0000           ; #define               RESET_LENGTH                            (2)             // This is the length value for a reset.
 0000           ; // These defines are used to fill in the servo's EEPROM address parameter for a given command type.
 0000           ; #define               ID_ADDRESS                                      (3)             // This is the address where servo ID is stored.
 0000           ; #define               STATUS_RET_ADDRESS                      (16)    // This is where the status return level is stored.
 0000           ; // These defines are used to fill in the instruction we are using on the servo.
 0000           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0000           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0000           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0000           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0000           ; // These defines cover all of the status return level possibilities.
 0000           ; #define               STATUS_RET_NEVER                        (0)             // Only respond to ping commands.
 0000           ; #define               STATUS_RET_READ                         (1)             // Only respond to read data commands (recommended).
 0000           ; #define               STATUS_RET_ALL                          (2)             // Respond to every command.
 0000           ; 
 0000           ; // This is the number of attempts we make to contact the servo per sweep of attempts before
 0000           ; // writing to its EEPROM in an attempt to alter settings that keep us from communicating.
 0000           ; #define               SERVO_COMM_ATTEMPTS                     (10)
 0000           ; // This is the number of times we do a loop of SERVO_COMM_ATTEMPTS.  We would like this to be at least 2.
 0000           ; // This is because we do an EEPROM write after the first unsuccessful loop of SERVO_COMM_ATTEMPTS.
 0000           ; // If we don't then do at least one more loop, the EEPROM write was done for no reason.
 0000           ; #define               SERVO_COMM_LOOPS                        (2)
 0000           ; // This is the number of timeout periods to wait through while the servo boots up (2 ms per period).
 0000           ; #define               SERVO_BOOT_TIMEOUTS                     (75)
 0000           ; 
 0000           ; // This is the number of iterations we loop waiting for bytes to reset the timeout on a child response.
 0000           ; // This will be the amount of iterations we do after the last byte has been received as well.
 0000           ; #define               RESPONSE_ITERATIONS                     (10)
 0000           ; 
 0000           ; // This is the status return level, which is set to one of the possible status return values above.
 0000           ; // We want the status return level to be return on read commands only so that we don't have garbage
 0000           ; // return packets flying around every time we tell the servo to move.
 0000           ; #define               STATUS_RET_LEVEL                        (STATUS_RET_READ)
 0000           ; 
 0000           ; // This function receives a mode identifier as a parameter and toggles the system configuration.
 0000           ; void configToggle(int mode);
 0000           ; // This function unloads all configurations.  This should only be needed at startup.
 0000           ; void unloadAllConfigs(void);
 0000           ; // This function unloads the configuration corresponding to the number passed to it.
 0000           ; void unloadConfig(int config_num);
 0000           ; // This function is a response to the master sending out a hello message.
 0000           ; void sayHello(void);
 0000           ; // This function looks for commands and returns 1 if a command has been read, 0 if not.
 0000           ; int commandReady(void);
 0000           ; // This function interprets the command that has just been read and performs an action accordingly.
 0000           ; void takeAction(void);
 0000           ; // This function responds to a ping.
 0000           ; void pingResponse(void);
 0000           ; // This function tells the master node that an ID assignment was completed on this module.
 0000           ; void assignedID(void);
 0000           ; // This function sends out an acknowledgement of a configuration reset.
 0000           ; void configCleared(void);
 0000           ; // This function listens for children and registers the port that they talk to.
 0000           ; int childListen(void);
 0000           ; // This function waits for a known child's response to a command to that child from the master.
 0000           ; int childResponse(void);
 0000           ; // This function does everything it can to find the servo attached to this controller.
 0000           ; void servoFinder(void);
 0000           ; // This function carries out the passed servo instruction.
 0000           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0000           ; // This function does a simple for loop to stall and make doubly sure that the transmission finished.
 0000           ; // It is meant to be used as a definite amount of wait time after the transmission complete flag is set.
 0000           ; void xmitWait(void);
 0000           ; // This function is called to do nothing while we wait for the servo to boot up.
 0000           ; void servoBootWait(void);
 0000           ; // This function is used to wait for other controllers to find their servos while not
 0000           ; // driving any pins (which would keep a child from talking to its servo).
 0000           ; void servoConfigWait(void);
 0000           ; 
 0000           ; char CHILD;           // Keeps track of where the child is connected.
 0000           ; char ID;              // Stores the ID that the master gives this module.
 0000           ; 
 0000           ; int CONFIGURED;       // Keeps track of whether or not this module has been configured by the master.
 0000           ; int TIMEOUT;  // This flag is set if a timeout occurs.
 0000           ; int STATE;            // This stores the ID of the currently-loaded configuration.
 0000           ; 
 0000           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0000           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0000           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0000           ; char COMMAND_PARAM;                   // Stores a parameter that accompanies the command (if any).
 0000           ; char COMMAND_LENGTH;          // Stores the length parameter of a servo command.
 0000           ; char COMMAND_ERROR;                   // Stores the error code of a servo command.
 0000           ; 
 0000           ; char SERVO_ID;                                // Stores the ID of the servo inside of this module.
 0000           ; 
 0000           ; void main()
 0000           ; {     
 0000                   .dbline 157
 0000           ;       // Initial value assignment for variables of importance.
 0000           ;       CHILD = 0;                              // There is no child yet.
 0000 62D000            mov REG[0xd0],>_CHILD
 0003 550000            mov [_CHILD],0
 0006                   .dbline 158
 0006           ;       CONFIGURED = 0;                 // This module is not configured yet.
 0006 62D000            mov REG[0xd0],>_CONFIGURED
 0009 550100            mov [_CONFIGURED+1],0
 000C 550000            mov [_CONFIGURED],0
 000F                   .dbline 159
 000F           ;       TIMEOUT = 0;                    // Set the timeout flag low to start.
 000F 62D000            mov REG[0xd0],>_TIMEOUT
 0012 550100            mov [_TIMEOUT+1],0
 0015 550000            mov [_TIMEOUT],0
 0018                   .dbline 160
 0018           ;       COMMAND_PARAM = 0;              // There is no parameter yet.
 0018 62D000            mov REG[0xd0],>_COMMAND_PARAM
 001B 550000            mov [_COMMAND_PARAM],0
 001E                   .dbline 161
 001E           ;       STATE = 0;                              // There is no state yet.
 001E 62D000            mov REG[0xd0],>_STATE
 0021 550100            mov [_STATE+1],0
 0024 550000            mov [_STATE],0
 0027                   .dbline 162
 0027           ;       ID = DEFAULT_ID;                // Set the ID of this controller to the default to start with.
 0027 62D000            mov REG[0xd0],>_ID
 002A 5500FB            mov [_ID],-5
 002D                   .dbline 164
 002D           ; 
 002D           ;       M8C_EnableGInt;                 // Turn on global interrupts for the transmission timeout timer.
 002D 7101                      or  F, 01h
 002F           
 002F                   .dbline 166
 002F           ;       
 002F           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); // Activate GPIO ISR
 002F 43E020            or REG[0xe0],32
 0032                   .dbline 169
 0032           ;       
 0032           ;       // Find the servo that is inside of this module.
 0032           ;       servoFinder();
 0032 7C0C92            xcall _servoFinder
 0035 8012              xjmp L3
 0037           L2:
 0037                   .dbline 173
 0037           ;       
 0037           ;       // Loop and wait for commands.
 0037           ;       while(1)
 0037           ;       {       
 0037                   .dbline 174
 0037           ;               if(commandReady())
 0037 9282              xcall _commandReady
 0039 62D000            mov REG[0xd0],>__r0
 003C 3C0000            cmp [__r0],0
 003F B006              jnz X1
 0041 3C0000            cmp [__r1],0
 0044 A003              jz L5
 0046           X1:
 0046                   .dbline 175
 0046           ;               {
 0046                   .dbline 177
 0046           ;                       // If the command is ready, take action.
 0046           ;                       takeAction();
 0046 9655              xcall _takeAction
 0048                   .dbline 178
 0048           ;               }
 0048           L5:
 0048                   .dbline 179
 0048           ;       }
 0048           L3:
 0048                   .dbline 172
 0048 8FEE              xjmp L2
 004A           X0:
 004A                   .dbline -2
 004A           L1:
 004A                   .dbline 0 ; func end
 004A 8FFF              jmp .
 004C                   .dbend
 004C                   .dbfunc e sayHello _sayHello fV
 004C           _sayHello::
 004C                   .dbline -1
 004C                   .dbline 184
 004C           ; }
 004C           ; 
 004C           ; // This function transmits a response to a hello command from the master.
 004C           ; void sayHello(void)
 004C           ; {     
 004C                   .dbline 185
 004C           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 004C 5000              mov A,0
 004E 08                push A
 004F 5002              mov A,2
 0051 08                push A
 0052 905D              xcall _configToggle
 0054 38FE              add SP,-2
 0056                   .dbline 188
 0056           ;       
 0056           ;       // Transmit a hello response to the master node.
 0056           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 0056 10                push X
 0057 50FC              mov A,-4
 0059 7C0000            xcall _TX_014_PutChar
 005C 20                pop X
 005D                   .dbline 189
 005D           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 005D 10                push X
 005E 50FC              mov A,-4
 0060 7C0000            xcall _TX_014_PutChar
 0063 20                pop X
 0064                   .dbline 190
 0064           ;       TX_014_PutChar(ID);                             // My ID (source)
 0064 10                push X
 0065 62D000            mov REG[0xd0],>_ID
 0068 5100              mov A,[_ID]
 006A 7C0000            xcall _TX_014_PutChar
 006D 20                pop X
 006E                   .dbline 191
 006E           ;       TX_014_PutChar(MASTER_ID);              // Master ID (destination)
 006E 10                push X
 006F 5000              mov A,0
 0071 7C0000            xcall _TX_014_PutChar
 0074 20                pop X
 0075                   .dbline 192
 0075           ;       TX_014_PutChar(HELLO_BYTE);             // This is a hello command.
 0075 10                push X
 0076 50C8              mov A,-56
 0078 7C0000            xcall _TX_014_PutChar
 007B 20                pop X
 007C                   .dbline 193
 007C           ;       TX_014_PutChar(CHILD);                  // Sends child port value, default 0.
 007C 10                push X
 007D 62D000            mov REG[0xd0],>_CHILD
 0080 5100              mov A,[_CHILD]
 0082 7C0000            xcall _TX_014_PutChar
 0085 20                pop X
 0086                   .dbline 194
 0086           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission.
 0086 10                push X
 0087 50FD              mov A,-3
 0089 7C0000            xcall _TX_014_PutChar
 008C 20                pop X
 008D                   .dbline 195
 008D           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission.
 008D 10                push X
 008E 50FD              mov A,-3
 0090 7C0000            xcall _TX_014_PutChar
 0093 20                pop X
 0094           L8:
 0094                   .dbline 198
 0094           ;       
 0094           ;       // Wait for the transmission to finish.
 0094           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0094           L9:
 0094                   .dbline 198
 0094 10                push X
 0095 7C0000            xcall _TX_014_bReadTxStatus
 0098 62D000            mov REG[0xd0],>__r0
 009B 20                pop X
 009C 5300              mov [__r0],A
 009E 470020            tst [__r0],32
 00A1 AFF2              jz L8
 00A3                   .dbline 201
 00A3           ;       
 00A3           ;       // Make completely sure we're done.
 00A3           ;       xmitWait();
 00A3 7C0F40            xcall _xmitWait
 00A6                   .dbline 203
 00A6           ; 
 00A6           ;       configToggle(WAIT);                             // Switch back to wait mode.
 00A6 5000              mov A,0
 00A8 08                push A
 00A9 5001              mov A,1
 00AB 08                push A
 00AC 9003              xcall _configToggle
 00AE 38FE              add SP,-2
 00B0                   .dbline -2
 00B0           L7:
 00B0                   .dbline 0 ; func end
 00B0 7F                ret
 00B1                   .dbend
 00B1                   .dbfunc e configToggle _configToggle fV
 00B1           ;           mode -> X-5
 00B1           _configToggle::
 00B1                   .dbline -1
 00B1 10                push X
 00B2 4F                mov X,SP
 00B3                   .dbline 209
 00B3           ; }
 00B3           ; 
 00B3           ; // This function receives a mode flag and switches the microcontroller to the
 00B3           ; // desired hardware configuration.
 00B3           ; void configToggle(int mode)
 00B3           ; {     
 00B3                   .dbline 212
 00B3           ;       // Set the pins high and disconnect from the global bus.
 00B3           ;       // This keeps false start bits from happening while we swap configs.
 00B3           ;       PRT0DR |= 0b00011111;   // Set pins P00 through P04 high.
 00B3 43001F            or REG[0],31
 00B6                   .dbline 213
 00B6           ;       PRT0GS &= 0b11100000;   // Disconnect pins P00 through P04 from the global bus.
 00B6 4102E0            and REG[0x2],-32
 00B9                   .dbline 217
 00B9           ;       
 00B9           ;       // Unload the configuration of the current state.
 00B9           ;       // If there is no state, blindly wipe all configurations.
 00B9           ;       if(STATE)
 00B9 62D000            mov REG[0xd0],>_STATE
 00BC 3C0000            cmp [_STATE],0
 00BF B006              jnz X2
 00C1 3C0100            cmp [_STATE+1],0
 00C4 A011              jz L12
 00C6           X2:
 00C6                   .dbline 218
 00C6           ;       {
 00C6                   .dbline 219
 00C6           ;               unloadConfig(STATE);
 00C6 62D000            mov REG[0xd0],>_STATE
 00C9 5100              mov A,[_STATE]
 00CB 08                push A
 00CC 5101              mov A,[_STATE+1]
 00CE 08                push A
 00CF 7C0A2A            xcall _unloadConfig
 00D2 38FE              add SP,-2
 00D4                   .dbline 220
 00D4           ;       }
 00D4 8004              xjmp L13
 00D6           L12:
 00D6                   .dbline 222
 00D6           ;       else
 00D6           ;       {
 00D6                   .dbline 223
 00D6           ;               unloadAllConfigs();
 00D6 7C0A0E            xcall _unloadAllConfigs
 00D9                   .dbline 224
 00D9           ;       }
 00D9           L13:
 00D9                   .dbline 228
 00D9           ;       
 00D9           ;       // Go through the list of possible modes until we find the one that was passed in to us.
 00D9           ;       // Then, load that configuration and initialize whatever needs to be initialized.
 00D9           ;       if(mode == WAIT)
 00D9 3DFB00            cmp [X-5],0
 00DC B022              jnz L14
 00DE 3DFC01            cmp [X-4],1
 00E1 B01D              jnz L14
 00E3           X3:
 00E3                   .dbline 229
 00E3           ;       {
 00E3                   .dbline 232
 00E3           ;               // Load the wait receiver configuration.  This is the receiver configuration used after
 00E3           ;               // initialization is complete.  It listens and forwards everything it hears.
 00E3           ;               LoadConfig_waiting();
 00E3 7C0000            xcall _LoadConfig_waiting
 00E6                   .dbline 235
 00E6           ;               
 00E6           ;               // Start the receivers.
 00E6           ;               WAIT_RECV_Start(WAIT_RECV_PARITY_NONE);
 00E6 10                push X
 00E7 5000              mov A,0
 00E9 7C0000            xcall _WAIT_RECV_Start
 00EC 20                pop X
 00ED                   .dbline 236
 00ED           ;               RX8_2_Start(RX8_2_PARITY_NONE);
 00ED 10                push X
 00EE 5000              mov A,0
 00F0 7C0000            xcall _RX8_2_Start
 00F3 20                pop X
 00F4                   .dbline 239
 00F4           ;               
 00F4           ;               // Set the current state.
 00F4           ;               STATE = WAIT;
 00F4 62D000            mov REG[0xd0],>_STATE
 00F7 550101            mov [_STATE+1],1
 00FA 550000            mov [_STATE],0
 00FD                   .dbline 240
 00FD           ;       }
 00FD 81A0              xjmp L15
 00FF           L14:
 00FF                   .dbline 241
 00FF           ;       else if(mode == MY_RESPONSE)
 00FF 3DFB00            cmp [X-5],0
 0102 B04C              jnz L16
 0104 3DFC02            cmp [X-4],2
 0107 B047              jnz L16
 0109           X4:
 0109                   .dbline 242
 0109           ;       {
 0109                   .dbline 244
 0109           ;               // Load the transmitter configuration.  This is for transmitting messages on all ports.
 0109           ;               LoadConfig_my_response();
 0109 7C0000            xcall _LoadConfig_my_response
 010C                   .dbline 247
 010C           ;               
 010C           ;               // Clear the timeout flag.
 010C           ;               TIMEOUT = 0;
 010C 62D000            mov REG[0xd0],>_TIMEOUT
 010F 550100            mov [_TIMEOUT+1],0
 0112 550000            mov [_TIMEOUT],0
 0115                   .dbline 250
 0115           ;               
 0115           ;               // Start the transmitters.
 0115           ;               TX_014_Start(TX_014_PARITY_NONE);       // Transmits on P00, P01, and P04.
 0115 10                push X
 0116 5000              mov A,0
 0118 7C0000            xcall _TX_014_Start
 011B 20                pop X
 011C                   .dbline 251
 011C           ;               TX_23_Start(TX_23_PARITY_NONE);         // Transmits on P02 and P03.
 011C 10                push X
 011D 5000              mov A,0
 011F 7C0000            xcall _TX_23_Start
 0122                   .dbline 253
 0122           ;               
 0122           ;               TX_01234_TIMEOUT_EnableInt();           // Make sure interrupts are enabled.
 0122 7C0000            xcall _TX_01234_TIMEOUT_EnableInt
 0125                   .dbline 254
 0125           ;               TX_01234_TIMEOUT_Start();                       // Start the timer.
 0125 7C0000            xcall _TX_01234_TIMEOUT_Start
 0128 20                pop X
 0129           L18:
 0129                   .dbline 258
 0129           ;               
 0129           ;               // Do nothing while we wait for one timeout period (1 ms).
 0129           ;               // This is to allow everyone to get in the right configuration before talking.
 0129           ;               while(!TIMEOUT) { }
 0129                   .dbline 258
 0129           L19:
 0129                   .dbline 258
 0129 62D000            mov REG[0xd0],>_TIMEOUT
 012C 3C0000            cmp [_TIMEOUT],0
 012F B006              jnz X5
 0131 3C0100            cmp [_TIMEOUT+1],0
 0134 AFF4              jz L18
 0136           X5:
 0136                   .dbline 260
 0136           ;               
 0136           ;               TX_01234_TIMEOUT_Stop();                        // Stop the timer.
 0136 10                push X
 0137 7C0000            xcall _TX_01234_TIMEOUT_Stop
 013A 20                pop X
 013B                   .dbline 261
 013B           ;               TIMEOUT = 0;                                            // Reset the timeout flag.
 013B 62D000            mov REG[0xd0],>_TIMEOUT
 013E 550100            mov [_TIMEOUT+1],0
 0141 550000            mov [_TIMEOUT],0
 0144                   .dbline 264
 0144           ;       
 0144           ;               // Set the current state.
 0144           ;               STATE = MY_RESPONSE;
 0144 62D000            mov REG[0xd0],>_STATE
 0147 550102            mov [_STATE+1],2
 014A 550000            mov [_STATE],0
 014D                   .dbline 265
 014D           ;       }
 014D 8150              xjmp L17
 014F           L16:
 014F                   .dbline 266
 014F           ;       else if(mode == RESPONSE_1)
 014F 3DFB00            cmp [X-5],0
 0152 B02A              jnz L21
 0154 3DFC03            cmp [X-4],3
 0157 B025              jnz L21
 0159           X6:
 0159                   .dbline 267
 0159           ;       {
 0159                   .dbline 269
 0159           ;               // Load the response wait on port 1.
 0159           ;               LoadConfig_response1();
 0159 7C0000            xcall _LoadConfig_response1
 015C                   .dbline 272
 015C           ;               
 015C           ;               // Clear the timeout flag.
 015C           ;               TIMEOUT = 0;
 015C 62D000            mov REG[0xd0],>_TIMEOUT
 015F 550100            mov [_TIMEOUT+1],0
 0162 550000            mov [_TIMEOUT],0
 0165                   .dbline 275
 0165           ;               
 0165           ;               // Start listening for a response through child port 1.
 0165           ;               CHILD_1_Start(CHILD_1_PARITY_NONE);
 0165 10                push X
 0166 5000              mov A,0
 0168 7C0000            xcall _CHILD_1_Start
 016B                   .dbline 277
 016B           ;               
 016B           ;               CHILD_1_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 016B 7C0000            xcall _CHILD_1_TIMEOUT_EnableInt
 016E                   .dbline 278
 016E           ;               CHILD_1_TIMEOUT_Start();                        // Start the timer.
 016E 7C0000            xcall _CHILD_1_TIMEOUT_Start
 0171 20                pop X
 0172                   .dbline 281
 0172           ;               
 0172           ;               // Set the current state.
 0172           ;               STATE = RESPONSE_1;
 0172 62D000            mov REG[0xd0],>_STATE
 0175 550103            mov [_STATE+1],3
 0178 550000            mov [_STATE],0
 017B                   .dbline 282
 017B           ;       }
 017B 8122              xjmp L22
 017D           L21:
 017D                   .dbline 283
 017D           ;       else if(mode == RESPONSE_2)
 017D 3DFB00            cmp [X-5],0
 0180 B02A              jnz L23
 0182 3DFC04            cmp [X-4],4
 0185 B025              jnz L23
 0187           X7:
 0187                   .dbline 284
 0187           ;       {
 0187                   .dbline 286
 0187           ;               // Load the response wait on port 2.
 0187           ;               LoadConfig_response2();
 0187 7C0000            xcall _LoadConfig_response2
 018A                   .dbline 289
 018A           ;               
 018A           ;               // Clear the timeout flag.
 018A           ;               TIMEOUT = 0;
 018A 62D000            mov REG[0xd0],>_TIMEOUT
 018D 550100            mov [_TIMEOUT+1],0
 0190 550000            mov [_TIMEOUT],0
 0193                   .dbline 292
 0193           ;               
 0193           ;               // Start listening for a response through child port 2.
 0193           ;               CHILD_2_Start(CHILD_2_PARITY_NONE);
 0193 10                push X
 0194 5000              mov A,0
 0196 7C0000            xcall _CHILD_2_Start
 0199                   .dbline 294
 0199           ;               
 0199           ;               CHILD_2_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 0199 7C0000            xcall _CHILD_2_TIMEOUT_EnableInt
 019C                   .dbline 295
 019C           ;               CHILD_2_TIMEOUT_Start();                        // Start the timer.
 019C 7C0000            xcall _CHILD_2_TIMEOUT_Start
 019F 20                pop X
 01A0                   .dbline 298
 01A0           ;               
 01A0           ;               // Set the current state.
 01A0           ;               STATE = RESPONSE_2;
 01A0 62D000            mov REG[0xd0],>_STATE
 01A3 550104            mov [_STATE+1],4
 01A6 550000            mov [_STATE],0
 01A9                   .dbline 299
 01A9           ;       }
 01A9 80F4              xjmp L24
 01AB           L23:
 01AB                   .dbline 300
 01AB           ;       else if(mode == RESPONSE_3)
 01AB 3DFB00            cmp [X-5],0
 01AE B02A              jnz L25
 01B0 3DFC05            cmp [X-4],5
 01B3 B025              jnz L25
 01B5           X8:
 01B5                   .dbline 301
 01B5           ;       {
 01B5                   .dbline 303
 01B5           ;               // Load the response wait on port 3.
 01B5           ;               LoadConfig_response3();
 01B5 7C0000            xcall _LoadConfig_response3
 01B8                   .dbline 306
 01B8           ;               
 01B8           ;               // Clear the timeout flag.
 01B8           ;               TIMEOUT = 0;
 01B8 62D000            mov REG[0xd0],>_TIMEOUT
 01BB 550100            mov [_TIMEOUT+1],0
 01BE 550000            mov [_TIMEOUT],0
 01C1                   .dbline 309
 01C1           ;               
 01C1           ;               // Start listening for a response through child port 3.
 01C1           ;               CHILD_3_Start(CHILD_3_PARITY_NONE);
 01C1 10                push X
 01C2 5000              mov A,0
 01C4 7C0000            xcall _CHILD_3_Start
 01C7                   .dbline 311
 01C7           ;               
 01C7           ;               CHILD_3_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 01C7 7C0000            xcall _CHILD_3_TIMEOUT_EnableInt
 01CA                   .dbline 312
 01CA           ;               CHILD_3_TIMEOUT_Start();                        // Start the timer.
 01CA 7C0000            xcall _CHILD_3_TIMEOUT_Start
 01CD 20                pop X
 01CE                   .dbline 315
 01CE           ;               
 01CE           ;               // Set the current state.
 01CE           ;               STATE = RESPONSE_3;
 01CE 62D000            mov REG[0xd0],>_STATE
 01D1 550105            mov [_STATE+1],5
 01D4 550000            mov [_STATE],0
 01D7                   .dbline 316
 01D7           ;       }
 01D7 80C6              xjmp L26
 01D9           L25:
 01D9                   .dbline 317
 01D9           ;       else if(mode == RESPONSE_4)
 01D9 3DFB00            cmp [X-5],0
 01DC B02A              jnz L27
 01DE 3DFC06            cmp [X-4],6
 01E1 B025              jnz L27
 01E3           X9:
 01E3                   .dbline 318
 01E3           ;       {
 01E3                   .dbline 320
 01E3           ;               // Load the response wait on port 4.
 01E3           ;               LoadConfig_response4();
 01E3 7C0000            xcall _LoadConfig_response4
 01E6                   .dbline 323
 01E6           ;               
 01E6           ;               // Clear the timeout flag.
 01E6           ;               TIMEOUT = 0;
 01E6 62D000            mov REG[0xd0],>_TIMEOUT
 01E9 550100            mov [_TIMEOUT+1],0
 01EC 550000            mov [_TIMEOUT],0
 01EF                   .dbline 326
 01EF           ;               
 01EF           ;               // Start listening for a response through child port 4.
 01EF           ;               CHILD_4_Start(CHILD_4_PARITY_NONE);
 01EF 10                push X
 01F0 5000              mov A,0
 01F2 7C0000            xcall _CHILD_4_Start
 01F5                   .dbline 328
 01F5           ;               
 01F5           ;               CHILD_4_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 01F5 7C0000            xcall _CHILD_4_TIMEOUT_EnableInt
 01F8                   .dbline 329
 01F8           ;               CHILD_4_TIMEOUT_Start();                        // Start the timer.
 01F8 7C0000            xcall _CHILD_4_TIMEOUT_Start
 01FB 20                pop X
 01FC                   .dbline 332
 01FC           ;               
 01FC           ;               // Set the current state.
 01FC           ;               STATE = RESPONSE_4;
 01FC 62D000            mov REG[0xd0],>_STATE
 01FF 550106            mov [_STATE+1],6
 0202 550000            mov [_STATE],0
 0205                   .dbline 333
 0205           ;       }
 0205 8098              xjmp L28
 0207           L27:
 0207                   .dbline 334
 0207           ;       else if(mode == HELLO_MODE)
 0207 3DFB00            cmp [X-5],0
 020A B03F              jnz L29
 020C 3DFC07            cmp [X-4],7
 020F B03A              jnz L29
 0211           X10:
 0211                   .dbline 335
 0211           ;       {
 0211                   .dbline 337
 0211           ;               // Load the hello wait mode.  This is for listening on all ports for a hello response.
 0211           ;               LoadConfig_hello();
 0211 7C0000            xcall _LoadConfig_hello
 0214                   .dbline 340
 0214           ;               
 0214           ;               // Clear the timeout flag.
 0214           ;               TIMEOUT = 0;
 0214 62D000            mov REG[0xd0],>_TIMEOUT
 0217 550100            mov [_TIMEOUT+1],0
 021A 550000            mov [_TIMEOUT],0
 021D                   .dbline 344
 021D           ;               
 021D           ;               // The seemingly unnecessary brackets around each line are unfortunately needed.
 021D           ;       
 021D           ;               {
 021D                   .dbline 346
 021D           ;               // Start listening for a response through child port 1.
 021D           ;               HELLO_1_Start(HELLO_1_PARITY_NONE);
 021D 10                push X
 021E 5000              mov A,0
 0220 7C0000            xcall _HELLO_1_Start
 0223 20                pop X
 0224                   .dbline 347
 0224           ;               }
 0224                   .dbline 349
 0224           ;               
 0224           ;               {
 0224                   .dbline 351
 0224           ;               // Start listening for a response through child port 2.
 0224           ;               HELLO_2_Start(HELLO_2_PARITY_NONE);
 0224 10                push X
 0225 5000              mov A,0
 0227 7C0000            xcall _HELLO_2_Start
 022A 20                pop X
 022B                   .dbline 352
 022B           ;               }
 022B                   .dbline 354
 022B           ;               
 022B           ;               {
 022B                   .dbline 356
 022B           ;               // Start listening for a response through child port 3.
 022B           ;               HELLO_3_Start(HELLO_3_PARITY_NONE);
 022B 10                push X
 022C 5000              mov A,0
 022E 7C0000            xcall _HELLO_3_Start
 0231 20                pop X
 0232                   .dbline 357
 0232           ;               }
 0232                   .dbline 359
 0232           ;               
 0232           ;               {
 0232                   .dbline 361
 0232           ;               // Start listening for a response through child port 4.
 0232           ;               HELLO_4_Start(HELLO_4_PARITY_NONE);
 0232 10                push X
 0233 5000              mov A,0
 0235 7C0000            xcall _HELLO_4_Start
 0238                   .dbline 362
 0238           ;               }
 0238                   .dbline 364
 0238           ;               
 0238           ;               HELLO_TIMEOUT_EnableInt();      // Make sure interrupts are enabled.
 0238 7C0000            xcall _HELLO_TIMEOUT_EnableInt
 023B                   .dbline 365
 023B           ;               HELLO_TIMEOUT_Start();          // Start the timer.
 023B 7C0000            xcall _HELLO_TIMEOUT_Start
 023E 20                pop X
 023F                   .dbline 368
 023F           ;               
 023F           ;               // Set the current state.
 023F           ;               STATE = HELLO_MODE;
 023F 62D000            mov REG[0xd0],>_STATE
 0242 550107            mov [_STATE+1],7
 0245 550000            mov [_STATE],0
 0248                   .dbline 369
 0248           ;       }
 0248 8055              xjmp L30
 024A           L29:
 024A                   .dbline 370
 024A           ;       else if(mode == INITIALIZE)
 024A 3DFB00            cmp [X-5],0
 024D B02A              jnz L31
 024F 3DFC08            cmp [X-4],8
 0252 B025              jnz L31
 0254           X11:
 0254                   .dbline 371
 0254           ;       {
 0254                   .dbline 373
 0254           ;               // Load the configuration for initialization.  This config listens but does not forward.
 0254           ;               LoadConfig_initial();
 0254 7C0000            xcall _LoadConfig_initial
 0257                   .dbline 376
 0257           ;               
 0257           ;               // Clear the timeout flag.
 0257           ;               TIMEOUT = 0;
 0257 62D000            mov REG[0xd0],>_TIMEOUT
 025A 550100            mov [_TIMEOUT+1],0
 025D 550000            mov [_TIMEOUT],0
 0260                   .dbline 379
 0260           ;               
 0260           ;               // Start the receiver.
 0260           ;               INIT_RX_Start(INIT_RX_PARITY_NONE);
 0260 10                push X
 0261 5000              mov A,0
 0263 7C0000            xcall _INIT_RX_Start
 0266                   .dbline 381
 0266           ;               
 0266           ;               INIT_TIMEOUT_EnableInt();       // Make sure interrupts are enabled.
 0266 7C0000            xcall _INIT_TIMEOUT_EnableInt
 0269                   .dbline 382
 0269           ;               INIT_TIMEOUT_Start();           // Start the timer.
 0269 7C0000            xcall _INIT_TIMEOUT_Start
 026C 20                pop X
 026D                   .dbline 385
 026D           ;               
 026D           ;               // Set the current state.
 026D           ;               STATE = INITIALIZE;
 026D 62D000            mov REG[0xd0],>_STATE
 0270 550108            mov [_STATE+1],8
 0273 550000            mov [_STATE],0
 0276                   .dbline 386
 0276           ;       }
 0276 8027              xjmp L32
 0278           L31:
 0278                   .dbline 387
 0278           ;       else if(mode == SERVO_COMM)
 0278 3DFB00            cmp [X-5],0
 027B B022              jnz L33
 027D 3DFC09            cmp [X-4],9
 0280 B01D              jnz L33
 0282           X12:
 0282                   .dbline 388
 0282           ;       {
 0282                   .dbline 390
 0282           ;               // Load the configuration for servo communication.  This config only transmits on P00.
 0282           ;               LoadConfig_servo_transmit();
 0282 7C0000            xcall _LoadConfig_servo_transmit
 0285                   .dbline 393
 0285           ;               
 0285           ;               // Clear the timeout flag.
 0285           ;               TIMEOUT = 0;
 0285 62D000            mov REG[0xd0],>_TIMEOUT
 0288 550100            mov [_TIMEOUT+1],0
 028B 550000            mov [_TIMEOUT],0
 028E                   .dbline 396
 028E           ;               
 028E           ;               // Start the transmitter.
 028E           ;               SERVO_TX_Start(SERVO_TX_PARITY_NONE);
 028E 10                push X
 028F 5000              mov A,0
 0291 7C0000            xcall _SERVO_TX_Start
 0294 20                pop X
 0295                   .dbline 399
 0295           ;       
 0295           ;               // Set the current state.
 0295           ;               STATE = SERVO_COMM;
 0295 62D000            mov REG[0xd0],>_STATE
 0298 550109            mov [_STATE+1],9
 029B 550000            mov [_STATE],0
 029E                   .dbline 400
 029E           ;       }
 029E           L33:
 029E           L32:
 029E           L30:
 029E           L28:
 029E           L26:
 029E           L24:
 029E           L22:
 029E           L17:
 029E           L15:
 029E                   .dbline 403
 029E           ;       
 029E           ;       // If this module is configured, talk on all pins for potential children.
 029E           ;       if(CONFIGURED)
 029E 62D000            mov REG[0xd0],>_CONFIGURED
 02A1 3C0000            cmp [_CONFIGURED],0
 02A4 B006              jnz X13
 02A6 3C0100            cmp [_CONFIGURED+1],0
 02A9 A009              jz L35
 02AB           X13:
 02AB                   .dbline 404
 02AB           ;       {
 02AB                   .dbline 405
 02AB           ;               PRT0GS |= 0b00011111;   // Connect all pins to the global bus.
 02AB 43021F            or REG[0x2],31
 02AE                   .dbline 406
 02AE           ;               PRT2DR &= 0b11111110;   // Turn on the LED (active low).
 02AE 4108FE            and REG[0x8],-2
 02B1                   .dbline 407
 02B1           ;       }
 02B1 8007              xjmp L36
 02B3           L35:
 02B3                   .dbline 409
 02B3           ;       else
 02B3           ;       {
 02B3                   .dbline 410
 02B3           ;               PRT0GS |= 0b00000001;   // Just connect pin 0;
 02B3 430201            or REG[0x2],1
 02B6                   .dbline 411
 02B6           ;               PRT2DR |= 0b00000001;   // Turn off the LED (active low).
 02B6 430801            or REG[0x8],1
 02B9                   .dbline 412
 02B9           ;       }
 02B9           L36:
 02B9                   .dbline -2
 02B9           L11:
 02B9 20                pop X
 02BA                   .dbline 0 ; func end
 02BA 7F                ret
 02BB                   .dbsym l mode -5 I
 02BB                   .dbend
 02BB                   .dbfunc e commandReady _commandReady fI
 02BB           ;              i -> X+1
 02BB           ;       tempByte -> X+0
 02BB           _commandReady::
 02BB                   .dbline -1
 02BB 10                push X
 02BC 4F                mov X,SP
 02BD 3803              add SP,3
 02BF                   .dbline 419
 02BF           ; }
 02BF           ; 
 02BF           ; // This function tries to peek and see if a start byte has been written to the bus.
 02BF           ; // If there is no start byte, the function exits.  If a start byte is detected, the function
 02BF           ; // blocks and waits for the transmission to finish.
 02BF           ; int commandReady(void)
 02BF           ; {
 02BF                   .dbline 420
 02BF           ;       int i = 0;                      // This integer is used for looping through the remaining bytes of commands.
 02BF 560200            mov [X+2],0
 02C2 560100            mov [X+1],0
 02C5                   .dbline 421
 02C5           ;       char tempByte = 0;      // This byte is used to store each byte for comparison as it comes in.
 02C5 560000            mov [X+0],0
 02C8                   .dbline 425
 02C8           ;       
 02C8           ;       // This conditional checks which configuration is loaded and uses the proper devices to
 02C8           ;       // read a transmission and store the important information from that transmission.
 02C8           ;       if(STATE == WAIT)
 02C8 62D000            mov REG[0xd0],>_STATE
 02CB 3C0000            cmp [_STATE],0
 02CE B0D4              jnz L38
 02D0 3C0101            cmp [_STATE+1],1
 02D3 B0CF              jnz L38
 02D5           X14:
 02D5                   .dbline 426
 02D5           ;       {       
 02D5                   .dbline 429
 02D5           ;               // In wait mode, the only thing that progresses things forward is a master node transmission.
 02D5           ;               // With this being the case, we use a blocking operation to sit and wait for a byte.
 02D5           ;               tempByte = WAIT_RECV_cGetChar();
 02D5 10                push X
 02D6 7C0000            xcall _WAIT_RECV_cGetChar
 02D9 62D000            mov REG[0xd0],>__r0
 02DC 20                pop X
 02DD 5400              mov [X+0],A
 02DF                   .dbline 432
 02DF           ;               
 02DF           ;               // If a transmission has started for either a controller or a servo...
 02DF           ;               if(tempByte == START_TRANSMIT)
 02DF 3D00FC            cmp [X+0],-4
 02E2 B047              jnz L40
 02E4                   .dbline 433
 02E4           ;               {
 02E4 800B              xjmp L43
 02E6           L42:
 02E6                   .dbline 436
 02E6           ;                       // While we keep reading start bytes, sit and spin.
 02E6           ;                       while(tempByte == START_TRANSMIT)
 02E6           ;                       {
 02E6                   .dbline 437
 02E6           ;                               tempByte = WAIT_RECV_cGetChar();
 02E6 10                push X
 02E7 7C0000            xcall _WAIT_RECV_cGetChar
 02EA 62D000            mov REG[0xd0],>__r0
 02ED 20                pop X
 02EE 5400              mov [X+0],A
 02F0                   .dbline 438
 02F0           ;                       }
 02F0           L43:
 02F0                   .dbline 435
 02F0 3D00FC            cmp [X+0],-4
 02F3 AFF2              jz L42
 02F5                   .dbline 441
 02F5           ;                       
 02F5           ;                       // The tempByte variable contains the source ID.  If the source is good, store all bytes.
 02F5           ;                       if(tempByte == MASTER_ID)
 02F5 3D0000            cmp [X+0],0
 02F8 B397              jnz L39
 02FA                   .dbline 442
 02FA           ;                       {
 02FA                   .dbline 443
 02FA           ;                               COMMAND_SOURCE = tempByte;
 02FA 5200              mov A,[X+0]
 02FC 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 02FF 5300              mov [_COMMAND_SOURCE],A
 0301                   .dbline 444
 0301           ;                               COMMAND_DESTINATION = WAIT_RECV_cGetChar();
 0301 10                push X
 0302 7C0000            xcall _WAIT_RECV_cGetChar
 0305 20                pop X
 0306 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0309 5300              mov [_COMMAND_DESTINATION],A
 030B                   .dbline 445
 030B           ;                               COMMAND_TYPE = WAIT_RECV_cGetChar();
 030B 10                push X
 030C 7C0000            xcall _WAIT_RECV_cGetChar
 030F 20                pop X
 0310 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0313 5300              mov [_COMMAND_TYPE],A
 0315                   .dbline 446
 0315           ;                               COMMAND_PARAM = WAIT_RECV_cGetChar();
 0315 10                push X
 0316 7C0000            xcall _WAIT_RECV_cGetChar
 0319 20                pop X
 031A 62D000            mov REG[0xd0],>_COMMAND_PARAM
 031D 5300              mov [_COMMAND_PARAM],A
 031F                   .dbline 448
 031F           ;                               
 031F           ;                               return 1;
 031F 62D000            mov REG[0xd0],>__r0
 0322 550001            mov [__r1],1
 0325 550000            mov [__r0],0
 0328 8370              xjmp L37
 032A           L40:
 032A                   .dbline 451
 032A           ;                       }
 032A           ;               }
 032A           ;               else if(tempByte == SERVO_START)
 032A 3D00FF            cmp [X+0],-1
 032D B362              jnz L39
 032F                   .dbline 452
 032F           ;               {
 032F 800B              xjmp L50
 0331           L49:
 0331                   .dbline 455
 0331           ;                       // While we keep reading start bytes, sit and spin.
 0331           ;                       while(tempByte == SERVO_START)
 0331           ;                       {
 0331                   .dbline 456
 0331           ;                               tempByte = WAIT_RECV_cGetChar();
 0331 10                push X
 0332 7C0000            xcall _WAIT_RECV_cGetChar
 0335 62D000            mov REG[0xd0],>__r0
 0338 20                pop X
 0339 5400              mov [X+0],A
 033B                   .dbline 457
 033B           ;                       }
 033B           L50:
 033B                   .dbline 454
 033B 3D00FF            cmp [X+0],-1
 033E AFF2              jz L49
 0340                   .dbline 460
 0340           ;                       
 0340           ;                       // We assume (and hopefully rightly so) that this is a command from master.
 0340           ;                       COMMAND_SOURCE = MASTER_ID;
 0340 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0343 550000            mov [_COMMAND_SOURCE],0
 0346                   .dbline 462
 0346           ;                       // The first parameter after the servo start is the destination.
 0346           ;                       COMMAND_DESTINATION = tempByte;
 0346 5200              mov A,[X+0]
 0348 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 034B 5300              mov [_COMMAND_DESTINATION],A
 034D                   .dbline 467
 034D           ;                       // The second parameter after the servo start is the command length.
 034D           ;                       // We don't need it to wait for the transmission to go through since the
 034D           ;                       // transmission goes through the chip with a delay of approximately 100 ns
 034D           ;                       // (it is already in and out by the time you read this byte).
 034D           ;                       tempByte = WAIT_RECV_cGetChar();
 034D 10                push X
 034E 7C0000            xcall _WAIT_RECV_cGetChar
 0351 62D000            mov REG[0xd0],>__r0
 0354 20                pop X
 0355 5400              mov [X+0],A
 0357                   .dbline 470
 0357           ;                       // Now we store the command type.  Depending on what the status return level
 0357           ;                       // is, we have special duties.
 0357           ;                       COMMAND_TYPE = WAIT_RECV_cGetChar();
 0357 10                push X
 0358 7C0000            xcall _WAIT_RECV_cGetChar
 035B 20                pop X
 035C 62D000            mov REG[0xd0],>_COMMAND_TYPE
 035F 5300              mov [_COMMAND_TYPE],A
 0361                   .dbline 473
 0361           ;                       
 0361           ;                       // This basically waits for the rest of the command to pass through.
 0361           ;                       for(i = 0; i < (tempByte - 1); i++)
 0361 560200            mov [X+2],0
 0364 560100            mov [X+1],0
 0367 800E              xjmp L55
 0369           L52:
 0369                   .dbline 474
 0369           ;                       {
 0369                   .dbline 475
 0369           ;                               WAIT_RECV_cGetChar();
 0369 10                push X
 036A 7C0000            xcall _WAIT_RECV_cGetChar
 036D 62D000            mov REG[0xd0],>__r0
 0370 20                pop X
 0371                   .dbline 476
 0371           ;                       }
 0371           L53:
 0371                   .dbline 473
 0371 7702              inc [X+2]
 0373 0F0100            adc [X+1],0
 0376           L55:
 0376                   .dbline 473
 0376 62D000            mov REG[0xd0],>__r0
 0379 5200              mov A,[X+0]
 037B 5300              mov [__r1],A
 037D 550000            mov [__r0],0
 0380 160001            sub [__r1],1
 0383 1E0000            sbb [__r0],0
 0386 5202              mov A,[X+2]
 0388 1200              sub A,[__r1]
 038A 5100              mov A,[__r0]
 038C 3180              xor A,-128
 038E 5300              mov [__rX],A
 0390 5201              mov A,[X+1]
 0392 3180              xor A,-128
 0394 1A00              sbb A,[__rX]
 0396 CFD2              jc L52
 0398           X15:
 0398                   .dbline 478
 0398           ;                               
 0398           ;                       return 1;
 0398 62D000            mov REG[0xd0],>__r0
 039B 550001            mov [__r1],1
 039E 550000            mov [__r0],0
 03A1 82F7              xjmp L37
 03A3           L38:
 03A3                   .dbline 481
 03A3           ;               }
 03A3           ;       }
 03A3           ;       else if(STATE == HELLO_MODE)
 03A3 62D000            mov REG[0xd0],>_STATE
 03A6 3C0000            cmp [_STATE],0
 03A9 B06E              jnz L56
 03AB 3C0107            cmp [_STATE+1],7
 03AE B069              jnz L56
 03B0           X16:
 03B0                   .dbline 482
 03B0           ;       {
 03B0                   .dbline 484
 03B0           ;               // Check all of the ports for a start byte.  Only one port will produce one.
 03B0           ;               if(HELLO_1_cReadChar() == START_TRANSMIT)
 03B0 10                push X
 03B1 7C0000            xcall _HELLO_1_cReadChar
 03B4 20                pop X
 03B5 39FC              cmp A,-4
 03B7 B012              jnz L58
 03B9                   .dbline 485
 03B9           ;               {               
 03B9                   .dbline 486
 03B9           ;                       CHILD = PORT_A;
 03B9 62D000            mov REG[0xd0],>_CHILD
 03BC 550041            mov [_CHILD],65
 03BF                   .dbline 488
 03BF           ;                       
 03BF           ;                       return 1;
 03BF 62D000            mov REG[0xd0],>__r0
 03C2 550001            mov [__r1],1
 03C5 550000            mov [__r0],0
 03C8 82D0              xjmp L37
 03CA           L58:
 03CA                   .dbline 490
 03CA           ;               }
 03CA           ;               else if(HELLO_2_cReadChar() == START_TRANSMIT)
 03CA 10                push X
 03CB 7C0000            xcall _HELLO_2_cReadChar
 03CE 20                pop X
 03CF 39FC              cmp A,-4
 03D1 B012              jnz L60
 03D3                   .dbline 491
 03D3           ;               {               
 03D3                   .dbline 492
 03D3           ;                       CHILD = PORT_B;
 03D3 62D000            mov REG[0xd0],>_CHILD
 03D6 550042            mov [_CHILD],66
 03D9                   .dbline 494
 03D9           ;                       
 03D9           ;                       return 1;
 03D9 62D000            mov REG[0xd0],>__r0
 03DC 550001            mov [__r1],1
 03DF 550000            mov [__r0],0
 03E2 82B6              xjmp L37
 03E4           L60:
 03E4                   .dbline 496
 03E4           ;               }
 03E4           ;               else if(HELLO_3_cReadChar() == START_TRANSMIT)
 03E4 10                push X
 03E5 7C0000            xcall _HELLO_3_cReadChar
 03E8 20                pop X
 03E9 39FC              cmp A,-4
 03EB B012              jnz L62
 03ED                   .dbline 497
 03ED           ;               {
 03ED                   .dbline 498
 03ED           ;                       CHILD = PORT_C;
 03ED 62D000            mov REG[0xd0],>_CHILD
 03F0 550043            mov [_CHILD],67
 03F3                   .dbline 500
 03F3           ;                       
 03F3           ;                       return 1;
 03F3 62D000            mov REG[0xd0],>__r0
 03F6 550001            mov [__r1],1
 03F9 550000            mov [__r0],0
 03FC 829C              xjmp L37
 03FE           L62:
 03FE                   .dbline 502
 03FE           ;               }
 03FE           ;               else if(HELLO_4_cReadChar() == START_TRANSMIT)
 03FE 10                push X
 03FF 7C0000            xcall _HELLO_4_cReadChar
 0402 20                pop X
 0403 39FC              cmp A,-4
 0405 B28A              jnz L57
 0407                   .dbline 503
 0407           ;               {
 0407                   .dbline 504
 0407           ;                       CHILD = PORT_D;
 0407 62D000            mov REG[0xd0],>_CHILD
 040A 550044            mov [_CHILD],68
 040D                   .dbline 506
 040D           ;                       
 040D           ;                       return 1;
 040D 62D000            mov REG[0xd0],>__r0
 0410 550001            mov [__r1],1
 0413 550000            mov [__r0],0
 0416 8282              xjmp L37
 0418           L56:
 0418                   .dbline 509
 0418           ;               }
 0418           ;       }
 0418           ;       else if(STATE == RESPONSE_1)
 0418 62D000            mov REG[0xd0],>_STATE
 041B 3C0000            cmp [_STATE],0
 041E B081              jnz L66
 0420 3C0103            cmp [_STATE+1],3
 0423 B07C              jnz L66
 0425           X17:
 0425                   .dbline 510
 0425           ;       {
 0425                   .dbline 511
 0425           ;               if(tempByte = CHILD_1_cReadChar())
 0425 10                push X
 0426 7C0000            xcall _CHILD_1_cReadChar
 0429 62D000            mov REG[0xd0],>__r0
 042C 20                pop X
 042D 5400              mov [X+0],A
 042F 3900              cmp A,0
 0431 A25E              jz L67
 0433                   .dbline 512
 0433           ;               {
 0433                   .dbline 513
 0433           ;                       if(tempByte == SERVO_START)                             // We have a servo response coming.
 0433 3D00FF            cmp [X+0],-1
 0436 B050              jnz L70
 0438                   .dbline 514
 0438           ;                       {
 0438           L72:
 0438                   .dbline 516
 0438           ;                               // Burn through the rest of the start bytes and the servo length.
 0438           ;                               while(CHILD_1_cGetChar() == SERVO_START) { }
 0438                   .dbline 516
 0438           L73:
 0438                   .dbline 516
 0438 10                push X
 0439 7C0000            xcall _CHILD_1_cGetChar
 043C 62D000            mov REG[0xd0],>__r0
 043F 20                pop X
 0440 39FF              cmp A,-1
 0442 AFF5              jz L72
 0444                   .dbline 519
 0444           ;                               
 0444           ;                               // We store the length, since it is the next byte from the servo.
 0444           ;                               tempByte = CHILD_1_cGetChar();
 0444 10                push X
 0445 7C0000            xcall _CHILD_1_cGetChar
 0448 62D000            mov REG[0xd0],>__r0
 044B 20                pop X
 044C 5400              mov [X+0],A
 044E                   .dbline 522
 044E           ;                               
 044E           ;                               // This basically waits for the rest of the command to pass through.
 044E           ;                               for(i = 0; i < tempByte; i++)
 044E 560200            mov [X+2],0
 0451 560100            mov [X+1],0
 0454 800E              xjmp L78
 0456           L75:
 0456                   .dbline 523
 0456           ;                               {
 0456                   .dbline 524
 0456           ;                                       CHILD_1_cGetChar();
 0456 10                push X
 0457 7C0000            xcall _CHILD_1_cGetChar
 045A 62D000            mov REG[0xd0],>__r0
 045D 20                pop X
 045E                   .dbline 525
 045E           ;                               }
 045E           L76:
 045E                   .dbline 522
 045E 7702              inc [X+2]
 0460 0F0100            adc [X+1],0
 0463           L78:
 0463                   .dbline 522
 0463 62D000            mov REG[0xd0],>__r0
 0466 5200              mov A,[X+0]
 0468 5300              mov [__r1],A
 046A 5202              mov A,[X+2]
 046C 1200              sub A,[__r1]
 046E 5000              mov A,0
 0470 3180              xor A,-128
 0472 5300              mov [__rX],A
 0474 5201              mov A,[X+1]
 0476 3180              xor A,-128
 0478 1A00              sbb A,[__rX]
 047A CFDB              jc L75
 047C           X18:
 047C                   .dbline 527
 047C           ;                               
 047C           ;                               return 1;
 047C 62D000            mov REG[0xd0],>__r0
 047F 550001            mov [__r1],1
 0482 550000            mov [__r0],0
 0485 8213              xjmp L37
 0487           L70:
 0487                   .dbline 529
 0487           ;                       }
 0487           ;                       else if (tempByte == START_TRANSMIT)    // We have a controller response coming.
 0487 3D00FC            cmp [X+0],-4
 048A B205              jnz L67
 048C                   .dbline 530
 048C           ;                       {
 048C           L81:
 048C                   .dbline 532
 048C           ;                               // We simply wait for the end transmit indicator.
 048C           ;                               while(CHILD_1_cGetChar() != END_TRANSMIT) { }
 048C                   .dbline 532
 048C           L82:
 048C                   .dbline 532
 048C 10                push X
 048D 7C0000            xcall _CHILD_1_cGetChar
 0490 62D000            mov REG[0xd0],>__r0
 0493 20                pop X
 0494 39FD              cmp A,-3
 0496 BFF5              jnz L81
 0498                   .dbline 534
 0498           ;                               
 0498           ;                               return 1;
 0498 550001            mov [__r1],1
 049B 550000            mov [__r0],0
 049E 81FA              xjmp L37
 04A0           L66:
 04A0                   .dbline 538
 04A0           ;                       }
 04A0           ;               }
 04A0           ;       }
 04A0           ;       else if(STATE == RESPONSE_2)
 04A0 62D000            mov REG[0xd0],>_STATE
 04A3 3C0000            cmp [_STATE],0
 04A6 B081              jnz L84
 04A8 3C0104            cmp [_STATE+1],4
 04AB B07C              jnz L84
 04AD           X19:
 04AD                   .dbline 539
 04AD           ;       {
 04AD                   .dbline 540
 04AD           ;               if(tempByte = CHILD_2_cReadChar())
 04AD 10                push X
 04AE 7C0000            xcall _CHILD_2_cReadChar
 04B1 62D000            mov REG[0xd0],>__r0
 04B4 20                pop X
 04B5 5400              mov [X+0],A
 04B7 3900              cmp A,0
 04B9 A1D6              jz L85
 04BB                   .dbline 541
 04BB           ;               {
 04BB                   .dbline 542
 04BB           ;                       if(tempByte == SERVO_START)                             // We have a servo response coming.
 04BB 3D00FF            cmp [X+0],-1
 04BE B050              jnz L88
 04C0                   .dbline 543
 04C0           ;                       {
 04C0           L90:
 04C0                   .dbline 545
 04C0           ;                               // Burn through the rest of the start bytes and the servo length.
 04C0           ;                               while(CHILD_2_cGetChar() == SERVO_START) { }
 04C0                   .dbline 545
 04C0           L91:
 04C0                   .dbline 545
 04C0 10                push X
 04C1 7C0000            xcall _CHILD_2_cGetChar
 04C4 62D000            mov REG[0xd0],>__r0
 04C7 20                pop X
 04C8 39FF              cmp A,-1
 04CA AFF5              jz L90
 04CC                   .dbline 548
 04CC           ;                               
 04CC           ;                               // We store the length, since it is the next byte from the servo.
 04CC           ;                               tempByte = CHILD_2_cGetChar();
 04CC 10                push X
 04CD 7C0000            xcall _CHILD_2_cGetChar
 04D0 62D000            mov REG[0xd0],>__r0
 04D3 20                pop X
 04D4 5400              mov [X+0],A
 04D6                   .dbline 551
 04D6           ;                               
 04D6           ;                               // This basically waits for the rest of the command to pass through.
 04D6           ;                               for(i = 0; i < tempByte; i++)
 04D6 560200            mov [X+2],0
 04D9 560100            mov [X+1],0
 04DC 800E              xjmp L96
 04DE           L93:
 04DE                   .dbline 552
 04DE           ;                               {
 04DE                   .dbline 553
 04DE           ;                                       CHILD_2_cGetChar();
 04DE 10                push X
 04DF 7C0000            xcall _CHILD_2_cGetChar
 04E2 62D000            mov REG[0xd0],>__r0
 04E5 20                pop X
 04E6                   .dbline 554
 04E6           ;                               }
 04E6           L94:
 04E6                   .dbline 551
 04E6 7702              inc [X+2]
 04E8 0F0100            adc [X+1],0
 04EB           L96:
 04EB                   .dbline 551
 04EB 62D000            mov REG[0xd0],>__r0
 04EE 5200              mov A,[X+0]
 04F0 5300              mov [__r1],A
 04F2 5202              mov A,[X+2]
 04F4 1200              sub A,[__r1]
 04F6 5000              mov A,0
 04F8 3180              xor A,-128
 04FA 5300              mov [__rX],A
 04FC 5201              mov A,[X+1]
 04FE 3180              xor A,-128
 0500 1A00              sbb A,[__rX]
 0502 CFDB              jc L93
 0504           X20:
 0504                   .dbline 556
 0504           ;                               
 0504           ;                               return 1;
 0504 62D000            mov REG[0xd0],>__r0
 0507 550001            mov [__r1],1
 050A 550000            mov [__r0],0
 050D 818B              xjmp L37
 050F           L88:
 050F                   .dbline 558
 050F           ;                       }
 050F           ;                       else if (tempByte == START_TRANSMIT)    // We have a controller response coming.
 050F 3D00FC            cmp [X+0],-4
 0512 B17D              jnz L85
 0514                   .dbline 559
 0514           ;                       {
 0514           L99:
 0514                   .dbline 561
 0514           ;                               // We simply wait for the end transmit indicator.
 0514           ;                               while(CHILD_2_cGetChar() != END_TRANSMIT) { }
 0514                   .dbline 561
 0514           L100:
 0514                   .dbline 561
 0514 10                push X
 0515 7C0000            xcall _CHILD_2_cGetChar
 0518 62D000            mov REG[0xd0],>__r0
 051B 20                pop X
 051C 39FD              cmp A,-3
 051E BFF5              jnz L99
 0520                   .dbline 563
 0520           ;                               
 0520           ;                               return 1;
 0520 550001            mov [__r1],1
 0523 550000            mov [__r0],0
 0526 8172              xjmp L37
 0528           L84:
 0528                   .dbline 567
 0528           ;                       }
 0528           ;               }
 0528           ;       }
 0528           ;       else if(STATE == RESPONSE_3)
 0528 62D000            mov REG[0xd0],>_STATE
 052B 3C0000            cmp [_STATE],0
 052E B081              jnz L102
 0530 3C0105            cmp [_STATE+1],5
 0533 B07C              jnz L102
 0535           X21:
 0535                   .dbline 568
 0535           ;       {
 0535                   .dbline 569
 0535           ;               if(tempByte = CHILD_3_cReadChar())
 0535 10                push X
 0536 7C0000            xcall _CHILD_3_cReadChar
 0539 62D000            mov REG[0xd0],>__r0
 053C 20                pop X
 053D 5400              mov [X+0],A
 053F 3900              cmp A,0
 0541 A14E              jz L103
 0543                   .dbline 570
 0543           ;               {
 0543                   .dbline 571
 0543           ;                       if(tempByte == SERVO_START)                             // We have a servo response coming.
 0543 3D00FF            cmp [X+0],-1
 0546 B050              jnz L106
 0548                   .dbline 572
 0548           ;                       {
 0548           L108:
 0548                   .dbline 574
 0548           ;                               // Burn through the rest of the start bytes and the servo length.
 0548           ;                               while(CHILD_3_cGetChar() == SERVO_START) { }
 0548                   .dbline 574
 0548           L109:
 0548                   .dbline 574
 0548 10                push X
 0549 7C0000            xcall _CHILD_3_cGetChar
 054C 62D000            mov REG[0xd0],>__r0
 054F 20                pop X
 0550 39FF              cmp A,-1
 0552 AFF5              jz L108
 0554                   .dbline 577
 0554           ;                               
 0554           ;                               // We store the length, since it is the next byte from the servo.
 0554           ;                               tempByte = CHILD_3_cGetChar();
 0554 10                push X
 0555 7C0000            xcall _CHILD_3_cGetChar
 0558 62D000            mov REG[0xd0],>__r0
 055B 20                pop X
 055C 5400              mov [X+0],A
 055E                   .dbline 580
 055E           ;                               
 055E           ;                               // This basically waits for the rest of the command to pass through.
 055E           ;                               for(i = 0; i < tempByte; i++)
 055E 560200            mov [X+2],0
 0561 560100            mov [X+1],0
 0564 800E              xjmp L114
 0566           L111:
 0566                   .dbline 581
 0566           ;                               {
 0566                   .dbline 582
 0566           ;                                       CHILD_3_cGetChar();
 0566 10                push X
 0567 7C0000            xcall _CHILD_3_cGetChar
 056A 62D000            mov REG[0xd0],>__r0
 056D 20                pop X
 056E                   .dbline 583
 056E           ;                               }
 056E           L112:
 056E                   .dbline 580
 056E 7702              inc [X+2]
 0570 0F0100            adc [X+1],0
 0573           L114:
 0573                   .dbline 580
 0573 62D000            mov REG[0xd0],>__r0
 0576 5200              mov A,[X+0]
 0578 5300              mov [__r1],A
 057A 5202              mov A,[X+2]
 057C 1200              sub A,[__r1]
 057E 5000              mov A,0
 0580 3180              xor A,-128
 0582 5300              mov [__rX],A
 0584 5201              mov A,[X+1]
 0586 3180              xor A,-128
 0588 1A00              sbb A,[__rX]
 058A CFDB              jc L111
 058C           X22:
 058C                   .dbline 585
 058C           ;                               
 058C           ;                               return 1;
 058C 62D000            mov REG[0xd0],>__r0
 058F 550001            mov [__r1],1
 0592 550000            mov [__r0],0
 0595 8103              xjmp L37
 0597           L106:
 0597                   .dbline 587
 0597           ;                       }
 0597           ;                       else if (tempByte == START_TRANSMIT)    // We have a controller response coming.
 0597 3D00FC            cmp [X+0],-4
 059A B0F5              jnz L103
 059C                   .dbline 588
 059C           ;                       {
 059C           L117:
 059C                   .dbline 590
 059C           ;                               // We simply wait for the end transmit indicator.
 059C           ;                               while(CHILD_3_cGetChar() != END_TRANSMIT) { }
 059C                   .dbline 590
 059C           L118:
 059C                   .dbline 590
 059C 10                push X
 059D 7C0000            xcall _CHILD_3_cGetChar
 05A0 62D000            mov REG[0xd0],>__r0
 05A3 20                pop X
 05A4 39FD              cmp A,-3
 05A6 BFF5              jnz L117
 05A8                   .dbline 592
 05A8           ;                               
 05A8           ;                               return 1;
 05A8 550001            mov [__r1],1
 05AB 550000            mov [__r0],0
 05AE 80EA              xjmp L37
 05B0           L102:
 05B0                   .dbline 596
 05B0           ;                       }
 05B0           ;               }
 05B0           ;       }
 05B0           ;       else if(STATE == RESPONSE_4)
 05B0 62D000            mov REG[0xd0],>_STATE
 05B3 3C0000            cmp [_STATE],0
 05B6 B081              jnz L120
 05B8 3C0106            cmp [_STATE+1],6
 05BB B07C              jnz L120
 05BD           X23:
 05BD                   .dbline 597
 05BD           ;       {
 05BD                   .dbline 598
 05BD           ;               if(tempByte = CHILD_4_cReadChar())
 05BD 10                push X
 05BE 7C0000            xcall _CHILD_4_cReadChar
 05C1 62D000            mov REG[0xd0],>__r0
 05C4 20                pop X
 05C5 5400              mov [X+0],A
 05C7 3900              cmp A,0
 05C9 A0C6              jz L121
 05CB                   .dbline 599
 05CB           ;               {
 05CB                   .dbline 600
 05CB           ;                       if(tempByte == SERVO_START)                             // We have a servo response coming.
 05CB 3D00FF            cmp [X+0],-1
 05CE B050              jnz L124
 05D0                   .dbline 601
 05D0           ;                       {
 05D0           L126:
 05D0                   .dbline 603
 05D0           ;                               // Burn through the rest of the start bytes and the servo length.
 05D0           ;                               while(CHILD_4_cGetChar() == SERVO_START) { }
 05D0                   .dbline 603
 05D0           L127:
 05D0                   .dbline 603
 05D0 10                push X
 05D1 7C0000            xcall _CHILD_4_cGetChar
 05D4 62D000            mov REG[0xd0],>__r0
 05D7 20                pop X
 05D8 39FF              cmp A,-1
 05DA AFF5              jz L126
 05DC                   .dbline 606
 05DC           ;                               
 05DC           ;                               // We store the length, since it is the next byte from the servo.
 05DC           ;                               tempByte = CHILD_4_cGetChar();
 05DC 10                push X
 05DD 7C0000            xcall _CHILD_4_cGetChar
 05E0 62D000            mov REG[0xd0],>__r0
 05E3 20                pop X
 05E4 5400              mov [X+0],A
 05E6                   .dbline 609
 05E6           ;                               
 05E6           ;                               // This basically waits for the rest of the command to pass through.
 05E6           ;                               for(i = 0; i < tempByte; i++)
 05E6 560200            mov [X+2],0
 05E9 560100            mov [X+1],0
 05EC 800E              xjmp L132
 05EE           L129:
 05EE                   .dbline 610
 05EE           ;                               {
 05EE                   .dbline 611
 05EE           ;                                       CHILD_4_cGetChar();
 05EE 10                push X
 05EF 7C0000            xcall _CHILD_4_cGetChar
 05F2 62D000            mov REG[0xd0],>__r0
 05F5 20                pop X
 05F6                   .dbline 612
 05F6           ;                               }
 05F6           L130:
 05F6                   .dbline 609
 05F6 7702              inc [X+2]
 05F8 0F0100            adc [X+1],0
 05FB           L132:
 05FB                   .dbline 609
 05FB 62D000            mov REG[0xd0],>__r0
 05FE 5200              mov A,[X+0]
 0600 5300              mov [__r1],A
 0602 5202              mov A,[X+2]
 0604 1200              sub A,[__r1]
 0606 5000              mov A,0
 0608 3180              xor A,-128
 060A 5300              mov [__rX],A
 060C 5201              mov A,[X+1]
 060E 3180              xor A,-128
 0610 1A00              sbb A,[__rX]
 0612 CFDB              jc L129
 0614           X24:
 0614                   .dbline 614
 0614           ;                               
 0614           ;                               return 1;
 0614 62D000            mov REG[0xd0],>__r0
 0617 550001            mov [__r1],1
 061A 550000            mov [__r0],0
 061D 807B              xjmp L37
 061F           L124:
 061F                   .dbline 616
 061F           ;                       }
 061F           ;                       else if (tempByte == START_TRANSMIT)    // We have a controller response coming.
 061F 3D00FC            cmp [X+0],-4
 0622 B06D              jnz L121
 0624                   .dbline 617
 0624           ;                       {
 0624           L135:
 0624                   .dbline 619
 0624           ;                               // We simply wait for the end transmit indicator.
 0624           ;                               while(CHILD_4_cGetChar() != END_TRANSMIT) { }
 0624                   .dbline 619
 0624           L136:
 0624                   .dbline 619
 0624 10                push X
 0625 7C0000            xcall _CHILD_4_cGetChar
 0628 62D000            mov REG[0xd0],>__r0
 062B 20                pop X
 062C 39FD              cmp A,-3
 062E BFF5              jnz L135
 0630                   .dbline 621
 0630           ;                               
 0630           ;                               return 1;
 0630 550001            mov [__r1],1
 0633 550000            mov [__r0],0
 0636 8062              xjmp L37
 0638           L120:
 0638                   .dbline 625
 0638           ;                       }
 0638           ;               }
 0638           ;       }
 0638           ;       else if(STATE == INITIALIZE)
 0638 62D000            mov REG[0xd0],>_STATE
 063B 3C0000            cmp [_STATE],0
 063E B051              jnz L138
 0640 3C0108            cmp [_STATE+1],8
 0643 B04C              jnz L138
 0645           X25:
 0645                   .dbline 626
 0645           ;       {
 0645                   .dbline 627
 0645           ;               if(INIT_RX_cReadChar() == SERVO_START)
 0645 10                push X
 0646 7C0000            xcall _INIT_RX_cReadChar
 0649 62D000            mov REG[0xd0],>__r0
 064C 20                pop X
 064D 39FF              cmp A,-1
 064F B040              jnz L140
 0651                   .dbline 628
 0651           ;               {
 0651                   .dbline 630
 0651           ;                       // We officially have a transmission.
 0651           ;                       if(INIT_RX_cGetChar() == SERVO_START)
 0651 10                push X
 0652 7C0000            xcall _INIT_RX_cGetChar
 0655 62D000            mov REG[0xd0],>__r0
 0658 20                pop X
 0659 39FF              cmp A,-1
 065B B034              jnz L142
 065D                   .dbline 631
 065D           ;                       {
 065D                   .dbline 634
 065D           ;                               // If we definitely have a transmission starting, grab all bytes from the rx buffer
 065D           ;                               // and store them in the proper variables for actions to be taken later.
 065D           ;                               COMMAND_SOURCE = INIT_RX_cGetChar();
 065D 10                push X
 065E 7C0000            xcall _INIT_RX_cGetChar
 0661 20                pop X
 0662 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0665 5300              mov [_COMMAND_SOURCE],A
 0667                   .dbline 635
 0667           ;                               COMMAND_LENGTH = INIT_RX_cGetChar();
 0667 10                push X
 0668 7C0000            xcall _INIT_RX_cGetChar
 066B 20                pop X
 066C 62D000            mov REG[0xd0],>_COMMAND_LENGTH
 066F 5300              mov [_COMMAND_LENGTH],A
 0671                   .dbline 636
 0671           ;                               COMMAND_ERROR = INIT_RX_cGetChar();
 0671 10                push X
 0672 7C0000            xcall _INIT_RX_cGetChar
 0675 20                pop X
 0676 62D000            mov REG[0xd0],>_COMMAND_ERROR
 0679 5300              mov [_COMMAND_ERROR],A
 067B                   .dbline 637
 067B           ;                               COMMAND_PARAM = INIT_RX_cGetChar();
 067B 10                push X
 067C 7C0000            xcall _INIT_RX_cGetChar
 067F 20                pop X
 0680 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0683 5300              mov [_COMMAND_PARAM],A
 0685                   .dbline 639
 0685           ;                               
 0685           ;                               return 1;
 0685 62D000            mov REG[0xd0],>__r0
 0688 550001            mov [__r1],1
 068B 550000            mov [__r0],0
 068E 800A              xjmp L37
 0690           L142:
 0690                   .dbline 641
 0690           ;                       }
 0690           ;               }
 0690           L140:
 0690                   .dbline 642
 0690           ;       }
 0690           L138:
 0690           L121:
 0690           L103:
 0690           L85:
 0690           L67:
 0690           L57:
 0690           L39:
 0690                   .dbline 644
 0690           ;       
 0690           ;       return 0;
 0690 62D000            mov REG[0xd0],>__r0
 0693 550000            mov [__r1],0
 0696 550000            mov [__r0],0
 0699                   .dbline -2
 0699           L37:
 0699 38FD              add SP,-3
 069B 20                pop X
 069C                   .dbline 0 ; func end
 069C 7F                ret
 069D                   .dbsym l i 1 I
 069D                   .dbsym l tempByte 0 c
 069D                   .dbend
 069D                   .dbfunc e takeAction _takeAction fV
 069D           ;              j -> X+4
 069D           ;              i -> X+2
 069D           ;              i -> X+0
 069D           _takeAction::
 069D                   .dbline -1
 069D 10                push X
 069E 4F                mov X,SP
 069F 3806              add SP,6
 06A1                   .dbline 650
 06A1           ; }
 06A1           ; 
 06A1           ; // This function interprets what has been read by the command ready function
 06A1           ; // and performs the appropriate action.
 06A1           ; void takeAction(void)
 06A1           ; {
 06A1                   .dbline 651
 06A1           ;       int i = 0;                                                      // An index variable for looping.
 06A1 560100            mov [X+1],0
 06A4 560000            mov [X+0],0
 06A7                   .dbline 653
 06A7           ;       
 06A7           ;       if(COMMAND_TYPE == HELLO_BYTE)          // The master is probing for new modules.
 06A7 62D000            mov REG[0xd0],>_COMMAND_TYPE
 06AA 3C00C8            cmp [_COMMAND_TYPE],-56
 06AD B039              jnz L145
 06AF                   .dbline 654
 06AF           ;       {
 06AF                   .dbline 655
 06AF           ;               if(!CONFIGURED)
 06AF 62D000            mov REG[0xd0],>_CONFIGURED
 06B2 3C0000            cmp [_CONFIGURED],0
 06B5 B00A              jnz L147
 06B7 3C0100            cmp [_CONFIGURED+1],0
 06BA B005              jnz L147
 06BC           X26:
 06BC                   .dbline 656
 06BC           ;               {
 06BC                   .dbline 658
 06BC           ;                       // Announce this module's presence if not configured.
 06BC           ;                       sayHello();
 06BC 998E              xcall _sayHello
 06BE                   .dbline 659
 06BE           ;               }
 06BE 820D              xjmp L146
 06C0           L147:
 06C0                   .dbline 660
 06C0           ;               else if(!CHILD)
 06C0 62D000            mov REG[0xd0],>_CHILD
 06C3 3C0000            cmp [_CHILD],0
 06C6 B014              jnz L149
 06C8                   .dbline 661
 06C8           ;               {
 06C8                   .dbline 663
 06C8           ;                       // Listen for children if we have none.
 06C8           ;                       if(childListen())
 06C8 9488              xcall _childListen
 06CA 62D000            mov REG[0xd0],>__r0
 06CD 3C0000            cmp [__r0],0
 06D0 B006              jnz X27
 06D2 3C0000            cmp [__r1],0
 06D5 A1F6              jz L146
 06D7           X27:
 06D7                   .dbline 664
 06D7           ;                       {
 06D7                   .dbline 666
 06D7           ;                               // If a child was heard saying hello, forward the command with the port number added.
 06D7           ;                               sayHello();
 06D7 9973              xcall _sayHello
 06D9                   .dbline 667
 06D9           ;                       }
 06D9                   .dbline 668
 06D9           ;               }
 06D9 81F2              xjmp L146
 06DB           L149:
 06DB                   .dbline 669
 06DB           ;               else if(CHILD)
 06DB 62D000            mov REG[0xd0],>_CHILD
 06DE 3C0000            cmp [_CHILD],0
 06E1 A1EA              jz L146
 06E3                   .dbline 670
 06E3           ;               {
 06E3                   .dbline 672
 06E3           ;                       // If you have a child established, listen to that child.
 06E3           ;                       childResponse();
 06E3 94C5              xcall _childResponse
 06E5                   .dbline 673
 06E5           ;               }
 06E5                   .dbline 674
 06E5           ;       }
 06E5 81E6              xjmp L146
 06E7           L145:
 06E7                   .dbline 675
 06E7           ;       else if(COMMAND_TYPE == PING)           // The master is trying to find a module that is configured.
 06E7 62D000            mov REG[0xd0],>_COMMAND_TYPE
 06EA 3C00CB            cmp [_COMMAND_TYPE],-53
 06ED B021              jnz L155
 06EF                   .dbline 676
 06EF           ;       {
 06EF                   .dbline 678
 06EF           ;               // If this is to me, act accordingly.
 06EF           ;               if(COMMAND_DESTINATION == ID)
 06EF 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 06F2 5100              mov A,[_COMMAND_DESTINATION]
 06F4 62D000            mov REG[0xd0],>_ID
 06F7 3A00              cmp A,[_ID]
 06F9 B005              jnz L157
 06FB                   .dbline 679
 06FB           ;               {
 06FB                   .dbline 681
 06FB           ;                       // Ping back to the master.
 06FB           ;                       pingResponse();
 06FB 9272              xcall _pingResponse
 06FD                   .dbline 682
 06FD           ;               }
 06FD 81CE              xjmp L156
 06FF           L157:
 06FF                   .dbline 683
 06FF           ;               else if(COMMAND_DESTINATION > ID)
 06FF 62D000            mov REG[0xd0],>_ID
 0702 5100              mov A,[_ID]
 0704 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0707 3A00              cmp A,[_COMMAND_DESTINATION]
 0709 D1C2              jnc L156
 070B           X28:
 070B                   .dbline 684
 070B           ;               {
 070B                   .dbline 686
 070B           ;                       // If you have a child established, listen to that child.
 070B           ;                       childResponse();
 070B 949D              xcall _childResponse
 070D                   .dbline 687
 070D           ;               }
 070D                   .dbline 688
 070D           ;       }
 070D 81BE              xjmp L156
 070F           L155:
 070F                   .dbline 689
 070F           ;       else if(COMMAND_TYPE == ID_ASSIGNMENT)  // The master is assigning an ID to someone.
 070F 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0712 3C00C9            cmp [_COMMAND_TYPE],-55
 0715 B110              jnz L161
 0717                   .dbline 690
 0717           ;       {
 0717                   .dbline 692
 0717           ;               // If this is meant for me, change my ID.
 0717           ;               if(COMMAND_DESTINATION == ID)
 0717 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 071A 5100              mov A,[_COMMAND_DESTINATION]
 071C 62D000            mov REG[0xd0],>_ID
 071F 3A00              cmp A,[_ID]
 0721 B0F4              jnz L163
 0723                   .dbline 693
 0723           ;               {
 0723                   .dbline 694
 0723           ;                       if((COMMAND_PARAM > MASTER_ID) && (COMMAND_PARAM < DEFAULT_ID))
 0723 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0726 5000              mov A,0
 0728 3A00              cmp A,[_COMMAND_PARAM]
 072A D1A1              jnc L162
 072C           X29:
 072C 62D000            mov REG[0xd0],>_COMMAND_PARAM
 072F 3C00FB            cmp [_COMMAND_PARAM],-5
 0732 D199              jnc L162
 0734           X30:
 0734                   .dbline 695
 0734           ;                       {
 0734                   .dbline 697
 0734           ;                               // Assign this module the ID that has been passed by the master.
 0734           ;                               ID = COMMAND_PARAM;
 0734 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0737 5100              mov A,[_COMMAND_PARAM]
 0739 62D000            mov REG[0xd0],>_ID
 073C 5300              mov [_ID],A
 073E                   .dbline 700
 073E           ;                               
 073E           ;                               // This module is now configured.
 073E           ;                               CONFIGURED = 1;
 073E 62D000            mov REG[0xd0],>_CONFIGURED
 0741 550101            mov [_CONFIGURED+1],1
 0744 550000            mov [_CONFIGURED],0
 0747                   .dbline 703
 0747           ;                               
 0747           ;                               // If the servo ID doesn't match what we want, change it to match.
 0747           ;                               if(ID != SERVO_ID)
 0747 62D000            mov REG[0xd0],>_ID
 074A 5100              mov A,[_ID]
 074C 62D000            mov REG[0xd0],>_SERVO_ID
 074F 3A00              cmp A,[_SERVO_ID]
 0751 A0A8              jz L167
 0753                   .dbline 704
 0753           ;                               {
 0753                   .dbline 711
 0753           ;                                       // These are our index variables for communication attempt timeouts.
 0753           ;                                       int i;
 0753           ;                                       int j;
 0753           ;                                       
 0753           ;                                       //while(ID != SERVO_ID)
 0753           ;                                       
 0753           ;                                       for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0753 560500            mov [X+5],0
 0756 560400            mov [X+4],0
 0759           L169:
 0759                   .dbline 712
 0759           ;                                       {       
 0759                   .dbline 714
 0759           ;                                               // Send a request to change the servo ID to match the controller ID.
 0759           ;                                               servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, ID_ADDRESS, ID);
 0759 62D000            mov REG[0xd0],>_ID
 075C 5100              mov A,[_ID]
 075E 08                push A
 075F 5003              mov A,3
 0761 08                push A
 0762 08                push A
 0763 5004              mov A,4
 0765 08                push A
 0766 62D000            mov REG[0xd0],>_SERVO_ID
 0769 5100              mov A,[_SERVO_ID]
 076B 08                push A
 076C 96F4              xcall _servoInstruction
 076E 38FB              add SP,-5
 0770                   .dbline 717
 0770           ;                                       
 0770           ;                                               // Try to read the servo's ID several times.
 0770           ;                                               for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0770 560300            mov [X+3],0
 0773 560200            mov [X+2],0
 0776           L173:
 0776                   .dbline 718
 0776           ;                                               {
 0776                   .dbline 720
 0776           ;                                                       // Send a request for the servo ID, which is presumably now equal to ID.
 0776           ;                                                       servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
 0776 5000              mov A,0
 0778 08                push A
 0779 08                push A
 077A 5001              mov A,1
 077C 08                push A
 077D 5002              mov A,2
 077F 08                push A
 0780 50FE              mov A,-2
 0782 08                push A
 0783 96DD              xcall _servoInstruction
 0785 38FB              add SP,-5
 0787 8043              xjmp L178
 0789           L177:
 0789                   .dbline 724
 0789           ;                                                       
 0789           ;                                                       // Wait for either a timeout or an indication that we want to exit the loop.
 0789           ;                                                       while(!TIMEOUT)
 0789           ;                                                       {
 0789                   .dbline 726
 0789           ;                                                               // If we have a command to interpret, read it.
 0789           ;                                                               if(commandReady())
 0789 9B30              xcall _commandReady
 078B 62D000            mov REG[0xd0],>__r0
 078E 3C0000            cmp [__r0],0
 0791 B006              jnz X31
 0793 3C0000            cmp [__r1],0
 0796 A034              jz L180
 0798           X31:
 0798                   .dbline 727
 0798           ;                                                               {
 0798                   .dbline 728
 0798           ;                                                                       if(!COMMAND_ERROR)
 0798 62D000            mov REG[0xd0],>_COMMAND_ERROR
 079B 3C0000            cmp [_COMMAND_ERROR],0
 079E B02C              jnz L182
 07A0                   .dbline 729
 07A0           ;                                                                       {
 07A0                   .dbline 731
 07A0           ;                                                                               // If we have a valid servo ID, exit the loop.
 07A0           ;                                                                               if(COMMAND_SOURCE == ID)
 07A0 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 07A3 5100              mov A,[_COMMAND_SOURCE]
 07A5 62D000            mov REG[0xd0],>_ID
 07A8 3A00              cmp A,[_ID]
 07AA B020              jnz L184
 07AC                   .dbline 732
 07AC           ;                                                                               {
 07AC                   .dbline 734
 07AC           ;                                                                                       // Set the timeout flag to exit the while loop.
 07AC           ;                                                                                       TIMEOUT = 1;
 07AC 62D000            mov REG[0xd0],>_TIMEOUT
 07AF 550101            mov [_TIMEOUT+1],1
 07B2 550000            mov [_TIMEOUT],0
 07B5                   .dbline 736
 07B5           ;                                                                                       // Set i such that the for loop is exited.
 07B5           ;                                                                                       i = SERVO_COMM_ATTEMPTS;
 07B5 56030A            mov [X+3],10
 07B8 560200            mov [X+2],0
 07BB                   .dbline 738
 07BB           ;                                                                                       // Set j such that we exit the outer loop as well.
 07BB           ;                                                                                       j = SERVO_COMM_LOOPS;
 07BB 560502            mov [X+5],2
 07BE 560400            mov [X+4],0
 07C1                   .dbline 740
 07C1           ;                                                                                       // Store the ID value.
 07C1           ;                                                                                       SERVO_ID = ID;
 07C1 62D000            mov REG[0xd0],>_ID
 07C4 5100              mov A,[_ID]
 07C6 62D000            mov REG[0xd0],>_SERVO_ID
 07C9 5300              mov [_SERVO_ID],A
 07CB                   .dbline 741
 07CB           ;                                                                               }
 07CB           L184:
 07CB                   .dbline 742
 07CB           ;                                                                       }
 07CB           L182:
 07CB                   .dbline 743
 07CB           ;                                                               }
 07CB           L180:
 07CB                   .dbline 744
 07CB           ;                                                       }
 07CB           L178:
 07CB                   .dbline 723
 07CB 62D000            mov REG[0xd0],>_TIMEOUT
 07CE 3C0000            cmp [_TIMEOUT],0
 07D1 B006              jnz X32
 07D3 3C0100            cmp [_TIMEOUT+1],0
 07D6 AFB2              jz L177
 07D8           X32:
 07D8                   .dbline 745
 07D8           ;                                               }
 07D8           L174:
 07D8                   .dbline 717
 07D8 7703              inc [X+3]
 07DA 0F0200            adc [X+2],0
 07DD                   .dbline 717
 07DD 5203              mov A,[X+3]
 07DF 110A              sub A,10
 07E1 5202              mov A,[X+2]
 07E3 3180              xor A,-128
 07E5 1980              sbb A,(0 ^ 0x80)
 07E7 CF8E              jc L173
 07E9           X33:
 07E9                   .dbline 746
 07E9           ;                                       }       
 07E9           L170:
 07E9                   .dbline 711
 07E9 7705              inc [X+5]
 07EB 0F0400            adc [X+4],0
 07EE                   .dbline 711
 07EE 5205              mov A,[X+5]
 07F0 1102              sub A,2
 07F2 5204              mov A,[X+4]
 07F4 3180              xor A,-128
 07F6 1980              sbb A,(0 ^ 0x80)
 07F8 CF60              jc L169
 07FA           X34:
 07FA                   .dbline 747
 07FA           ;                               }
 07FA           L167:
 07FA                   .dbline 749
 07FA           ;                               
 07FA           ;                               if(ID != SERVO_ID)
 07FA 62D000            mov REG[0xd0],>_ID
 07FD 5100              mov A,[_ID]
 07FF 62D000            mov REG[0xd0],>_SERVO_ID
 0802 3A00              cmp A,[_SERVO_ID]
 0804 A00D              jz L186
 0806                   .dbline 750
 0806           ;                               {
 0806                   .dbline 752
 0806           ;                                       // Toggle back to normal wait mode.
 0806           ;                                       configToggle(WAIT);
 0806 5000              mov A,0
 0808 08                push A
 0809 5001              mov A,1
 080B 08                push A
 080C 98A3              xcall _configToggle
 080E 38FE              add SP,-2
 0810                   .dbline 753
 0810           ;                               }
 0810 80BB              xjmp L162
 0812           L186:
 0812                   .dbline 755
 0812           ;                               else
 0812           ;                               {
 0812                   .dbline 757
 0812           ;                                       // Let the master node know that you got the ID assignment.
 0812           ;                                       assignedID();
 0812 929F              xcall _assignedID
 0814                   .dbline 758
 0814           ;                               }
 0814                   .dbline 759
 0814           ;                       }
 0814                   .dbline 760
 0814           ;               }
 0814 80B7              xjmp L162
 0816           L163:
 0816                   .dbline 761
 0816           ;               else if(COMMAND_DESTINATION > ID)
 0816 62D000            mov REG[0xd0],>_ID
 0819 5100              mov A,[_ID]
 081B 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 081E 3A00              cmp A,[_COMMAND_DESTINATION]
 0820 D0AB              jnc L162
 0822           X35:
 0822                   .dbline 762
 0822           ;               {
 0822                   .dbline 764
 0822           ;                       // Switch to listen to your child.
 0822           ;                       childResponse();
 0822 9386              xcall _childResponse
 0824                   .dbline 765
 0824           ;               }
 0824                   .dbline 766
 0824           ;       }
 0824 80A7              xjmp L162
 0826           L161:
 0826                   .dbline 767
 0826           ;       else if(COMMAND_TYPE == CLEAR_CONFIG)   // The master wants to clear one or all configurations.
 0826 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0829 3C00CC            cmp [_COMMAND_TYPE],-52
 082C B03D              jnz L190
 082E                   .dbline 768
 082E           ;       {
 082E                   .dbline 770
 082E           ;               // Only respond if this is directly to me and not a mass config clear.
 082E           ;               if(COMMAND_DESTINATION == ID)
 082E 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0831 5100              mov A,[_COMMAND_DESTINATION]
 0833 62D000            mov REG[0xd0],>_ID
 0836 3A00              cmp A,[_ID]
 0838 B003              jnz L192
 083A                   .dbline 771
 083A           ;               {
 083A                   .dbline 772
 083A           ;                       configCleared();        // Notify the master that I am clearing my config.
 083A 9094              xcall _configCleared
 083C                   .dbline 773
 083C           ;               }
 083C           L192:
 083C                   .dbline 778
 083C           ;               
 083C           ;               // If this is meant for me, deconfigure.  Also, if a module ahead of you is
 083C           ;               // getting deconfigured, you have no choice but to deconfigure as well to
 083C           ;               // avoid errors on reconfiguration.
 083C           ;               if((COMMAND_DESTINATION <= ID) || (COMMAND_DESTINATION == BROADCAST))
 083C 62D000            mov REG[0xd0],>_ID
 083F 5100              mov A,[_ID]
 0841 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0844 3A00              cmp A,[_COMMAND_DESTINATION]
 0846 D009              jnc L196
 0848           X36:
 0848 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 084B 3C00FE            cmp [_COMMAND_DESTINATION],-2
 084E B016              jnz L194
 0850           L196:
 0850                   .dbline 779
 0850           ;               {
 0850                   .dbline 780
 0850           ;                       ID = DEFAULT_ID;        // Reset my ID to the default.
 0850 62D000            mov REG[0xd0],>_ID
 0853 5500FB            mov [_ID],-5
 0856                   .dbline 781
 0856           ;                       CONFIGURED = 0;         // I am no longer configured.
 0856 62D000            mov REG[0xd0],>_CONFIGURED
 0859 550100            mov [_CONFIGURED+1],0
 085C 550000            mov [_CONFIGURED],0
 085F                   .dbline 782
 085F           ;                       CHILD = 0;                      // No one can depend on you anymore.
 085F 62D000            mov REG[0xd0],>_CHILD
 0862 550000            mov [_CHILD],0
 0865                   .dbline 783
 0865           ;               }
 0865           L194:
 0865                   .dbline 794
 0865           ; //            else if(COMMAND_DESTINATION > ID)
 0865           ; //            {
 0865           ; //                    // Switch to listen to your child.
 0865           ; //                    childResponse();
 0865           ; //                    // Switch back to wait for a master response.
 0865           ; //                    configToggle(WAIT);
 0865           ; //            }
 0865           ; //            Going to also have to take into account of this is my child.
 0865           ;               
 0865           ;               // Turn off the LED.
 0865           ;               PRT2DR |= 0b00000001;
 0865 430801            or REG[0x8],1
 0868                   .dbline 795
 0868           ;       }
 0868 8063              xjmp L191
 086A           L190:
 086A                   .dbline 796
 086A           ;       else if((COMMAND_TYPE == PING_SERVO) || (COMMAND_TYPE == READ_SERVO))
 086A 62D000            mov REG[0xd0],>_COMMAND_TYPE
 086D 3C0001            cmp [_COMMAND_TYPE],1
 0870 A006              jz L199
 0872 3C0002            cmp [_COMMAND_TYPE],2
 0875 B056              jnz L197
 0877           L199:
 0877                   .dbline 797
 0877           ;       {
 0877                   .dbline 798
 0877           ;               if(COMMAND_DESTINATION > ID)
 0877 62D000            mov REG[0xd0],>_ID
 087A 5100              mov A,[_ID]
 087C 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 087F 3A00              cmp A,[_COMMAND_DESTINATION]
 0881 D005              jnc L200
 0883           X37:
 0883                   .dbline 799
 0883           ;               {
 0883                   .dbline 801
 0883           ;                       // Allow the child response through.
 0883           ;                       childResponse();
 0883 9325              xcall _childResponse
 0885                   .dbline 802
 0885           ;               }
 0885 8046              xjmp L201
 0887           L200:
 0887                   .dbline 803
 0887           ;               else if(COMMAND_DESTINATION <= ID)
 0887 62D000            mov REG[0xd0],>_ID
 088A 5100              mov A,[_ID]
 088C 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 088F 3A00              cmp A,[_COMMAND_DESTINATION]
 0891 C03A              jc L202
 0893           X38:
 0893                   .dbline 804
 0893           ;               {
 0893           L204:
 0893                   .dbline 806
 0893           ;                       // Sit and spin while we wait for the transmission to start.
 0893           ;                       while(WAIT_RECV_cReadChar() != SERVO_START) { }
 0893                   .dbline 806
 0893           L205:
 0893                   .dbline 806
 0893 10                push X
 0894 7C0000            xcall _WAIT_RECV_cReadChar
 0897 62D000            mov REG[0xd0],>__r0
 089A 20                pop X
 089B 39FF              cmp A,-1
 089D BFF5              jnz L204
 089F                   .dbline 809
 089F           ;                       
 089F           ;                       // Reset the index variable.
 089F           ;                       i = 0;
 089F 560100            mov [X+1],0
 08A2 560000            mov [X+0],0
 08A5 801A              xjmp L208
 08A7           L207:
 08A7                   .dbline 814
 08A7           ;                       
 08A7           ;                       // Wait for the transmission to go through.
 08A7           ;                       // If no chars are read for RESPONSE_ITERATIONS iterations, move on.
 08A7           ;                       while(i < RESPONSE_ITERATIONS)
 08A7           ;                       {
 08A7                   .dbline 815
 08A7           ;                               if(WAIT_RECV_cReadChar())
 08A7 10                push X
 08A8 7C0000            xcall _WAIT_RECV_cReadChar
 08AB 62D000            mov REG[0xd0],>__r0
 08AE 20                pop X
 08AF 3900              cmp A,0
 08B1 A009              jz L210
 08B3                   .dbline 816
 08B3           ;                               {
 08B3                   .dbline 817
 08B3           ;                                       i = 0;
 08B3 560100            mov [X+1],0
 08B6 560000            mov [X+0],0
 08B9                   .dbline 818
 08B9           ;                               }
 08B9 8006              xjmp L211
 08BB           L210:
 08BB                   .dbline 820
 08BB           ;                               else
 08BB           ;                               {
 08BB                   .dbline 821
 08BB           ;                                       i++;
 08BB 7701              inc [X+1]
 08BD 0F0000            adc [X+0],0
 08C0                   .dbline 822
 08C0           ;                               }
 08C0           L211:
 08C0                   .dbline 823
 08C0           ;                       }
 08C0           L208:
 08C0                   .dbline 813
 08C0 5201              mov A,[X+1]
 08C2 110A              sub A,10
 08C4 5200              mov A,[X+0]
 08C6 3180              xor A,-128
 08C8 1980              sbb A,(0 ^ 0x80)
 08CA CFDC              jc L207
 08CC           X39:
 08CC                   .dbline 824
 08CC           ;               }
 08CC           L202:
 08CC           L201:
 08CC                   .dbline 825
 08CC           ;       }
 08CC           L197:
 08CC           L191:
 08CC           L162:
 08CC           L156:
 08CC           L146:
 08CC                   .dbline -2
 08CC           L144:
 08CC 38FA              add SP,-6
 08CE 20                pop X
 08CF                   .dbline 0 ; func end
 08CF 7F                ret
 08D0                   .dbsym l j 4 I
 08D0                   .dbsym l i 2 I
 08D0                   .dbsym l i 0 I
 08D0                   .dbend
 08D0                   .dbfunc e configCleared _configCleared fV
 08D0           _configCleared::
 08D0                   .dbline -1
 08D0                   .dbline 830
 08D0           ; }
 08D0           ; 
 08D0           ; // This function sends out an acknowledgement of a configuration reset.
 08D0           ; void configCleared(void)
 08D0           ; {
 08D0                   .dbline 831
 08D0           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 08D0 5000              mov A,0
 08D2 08                push A
 08D3 5002              mov A,2
 08D5 08                push A
 08D6 7C00B1            xcall _configToggle
 08D9 38FE              add SP,-2
 08DB                   .dbline 834
 08DB           ;       
 08DB           ;       // Transmit a ping to everyone.
 08DB           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 08DB 10                push X
 08DC 50FC              mov A,-4
 08DE 7C0000            xcall _TX_014_PutChar
 08E1 20                pop X
 08E2                   .dbline 835
 08E2           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 08E2 10                push X
 08E3 50FC              mov A,-4
 08E5 7C0000            xcall _TX_23_PutChar
 08E8 20                pop X
 08E9                   .dbline 836
 08E9           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 08E9 10                push X
 08EA 50FC              mov A,-4
 08EC 7C0000            xcall _TX_014_PutChar
 08EF 20                pop X
 08F0                   .dbline 837
 08F0           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 08F0 10                push X
 08F1 50FC              mov A,-4
 08F3 7C0000            xcall _TX_23_PutChar
 08F6 20                pop X
 08F7                   .dbline 838
 08F7           ;       TX_014_PutChar(ID);                             // My ID
 08F7 10                push X
 08F8 62D000            mov REG[0xd0],>_ID
 08FB 5100              mov A,[_ID]
 08FD 7C0000            xcall _TX_014_PutChar
 0900 20                pop X
 0901                   .dbline 839
 0901           ;       TX_23_PutChar(ID);                              // My ID
 0901 10                push X
 0902 62D000            mov REG[0xd0],>_ID
 0905 5100              mov A,[_ID]
 0907 7C0000            xcall _TX_23_PutChar
 090A 20                pop X
 090B                   .dbline 840
 090B           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 090B 10                push X
 090C 5000              mov A,0
 090E 7C0000            xcall _TX_014_PutChar
 0911 20                pop X
 0912                   .dbline 841
 0912           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 0912 10                push X
 0913 5000              mov A,0
 0915 7C0000            xcall _TX_23_PutChar
 0918 20                pop X
 0919                   .dbline 842
 0919           ;       TX_014_PutChar(CONFIG_CLEARED); // This is a ping response
 0919 10                push X
 091A 50CD              mov A,-51
 091C 7C0000            xcall _TX_014_PutChar
 091F 20                pop X
 0920                   .dbline 843
 0920           ;       TX_23_PutChar(CONFIG_CLEARED);  // This is a ping response
 0920 10                push X
 0921 50CD              mov A,-51
 0923 7C0000            xcall _TX_23_PutChar
 0926 20                pop X
 0927                   .dbline 844
 0927           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0927 10                push X
 0928 50FD              mov A,-3
 092A 7C0000            xcall _TX_014_PutChar
 092D 20                pop X
 092E                   .dbline 845
 092E           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 092E 10                push X
 092F 50FD              mov A,-3
 0931 7C0000            xcall _TX_23_PutChar
 0934 20                pop X
 0935                   .dbline 846
 0935           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0935 10                push X
 0936 50FD              mov A,-3
 0938 7C0000            xcall _TX_014_PutChar
 093B 20                pop X
 093C                   .dbline 847
 093C           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 093C 10                push X
 093D 50FD              mov A,-3
 093F 7C0000            xcall _TX_23_PutChar
 0942 20                pop X
 0943           L213:
 0943                   .dbline 850
 0943           ;       
 0943           ;       // Wait for the transmission to finish.
 0943           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0943           L214:
 0943                   .dbline 850
 0943 10                push X
 0944 7C0000            xcall _TX_014_bReadTxStatus
 0947 62D000            mov REG[0xd0],>__r0
 094A 20                pop X
 094B 5300              mov [__r0],A
 094D 470020            tst [__r0],32
 0950 AFF2              jz L213
 0952           L216:
 0952                   .dbline 851
 0952           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 0952           L217:
 0952                   .dbline 851
 0952 10                push X
 0953 7C0000            xcall _TX_23_bReadTxStatus
 0956 62D000            mov REG[0xd0],>__r0
 0959 20                pop X
 095A 5300              mov [__r0],A
 095C 470020            tst [__r0],32
 095F AFF2              jz L216
 0961                   .dbline 854
 0961           ;       
 0961           ;       // Make completely sure we're done.
 0961           ;       xmitWait();
 0961 95DD              xcall _xmitWait
 0963                   .dbline 856
 0963           ;       
 0963           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0963 5000              mov A,0
 0965 08                push A
 0966 5001              mov A,1
 0968 08                push A
 0969 7C00B1            xcall _configToggle
 096C 38FE              add SP,-2
 096E                   .dbline -2
 096E           L212:
 096E                   .dbline 0 ; func end
 096E 7F                ret
 096F                   .dbend
 096F                   .dbfunc e pingResponse _pingResponse fV
 096F           _pingResponse::
 096F                   .dbline -1
 096F                   .dbline 861
 096F           ; }
 096F           ; 
 096F           ; // This function sends out a ping response for everyone to hear.
 096F           ; void pingResponse(void)
 096F           ; {
 096F                   .dbline 862
 096F           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 096F 5000              mov A,0
 0971 08                push A
 0972 5002              mov A,2
 0974 08                push A
 0975 7C00B1            xcall _configToggle
 0978 38FE              add SP,-2
 097A                   .dbline 865
 097A           ;       
 097A           ;       // Transmit a ping to everyone.
 097A           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 097A 10                push X
 097B 50FC              mov A,-4
 097D 7C0000            xcall _TX_014_PutChar
 0980 20                pop X
 0981                   .dbline 866
 0981           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 0981 10                push X
 0982 50FC              mov A,-4
 0984 7C0000            xcall _TX_23_PutChar
 0987 20                pop X
 0988                   .dbline 867
 0988           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 0988 10                push X
 0989 50FC              mov A,-4
 098B 7C0000            xcall _TX_014_PutChar
 098E 20                pop X
 098F                   .dbline 868
 098F           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 098F 10                push X
 0990 50FC              mov A,-4
 0992 7C0000            xcall _TX_23_PutChar
 0995 20                pop X
 0996                   .dbline 869
 0996           ;       TX_014_PutChar(ID);                             // My ID
 0996 10                push X
 0997 62D000            mov REG[0xd0],>_ID
 099A 5100              mov A,[_ID]
 099C 7C0000            xcall _TX_014_PutChar
 099F 20                pop X
 09A0                   .dbline 870
 09A0           ;       TX_23_PutChar(ID);                              // My ID
 09A0 10                push X
 09A1 62D000            mov REG[0xd0],>_ID
 09A4 5100              mov A,[_ID]
 09A6 7C0000            xcall _TX_23_PutChar
 09A9 20                pop X
 09AA                   .dbline 871
 09AA           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 09AA 10                push X
 09AB 5000              mov A,0
 09AD 7C0000            xcall _TX_014_PutChar
 09B0 20                pop X
 09B1                   .dbline 872
 09B1           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 09B1 10                push X
 09B2 5000              mov A,0
 09B4 7C0000            xcall _TX_23_PutChar
 09B7 20                pop X
 09B8                   .dbline 873
 09B8           ;       TX_014_PutChar(PING);                   // This is a ping response
 09B8 10                push X
 09B9 50CB              mov A,-53
 09BB 7C0000            xcall _TX_014_PutChar
 09BE 20                pop X
 09BF                   .dbline 874
 09BF           ;       TX_23_PutChar(PING);                    // This is a ping response
 09BF 10                push X
 09C0 50CB              mov A,-53
 09C2 7C0000            xcall _TX_23_PutChar
 09C5 20                pop X
 09C6                   .dbline 875
 09C6           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 09C6 10                push X
 09C7 50FD              mov A,-3
 09C9 7C0000            xcall _TX_014_PutChar
 09CC 20                pop X
 09CD                   .dbline 876
 09CD           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 09CD 10                push X
 09CE 50FD              mov A,-3
 09D0 7C0000            xcall _TX_23_PutChar
 09D3 20                pop X
 09D4                   .dbline 877
 09D4           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 09D4 10                push X
 09D5 50FD              mov A,-3
 09D7 7C0000            xcall _TX_014_PutChar
 09DA 20                pop X
 09DB                   .dbline 878
 09DB           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 09DB 10                push X
 09DC 50FD              mov A,-3
 09DE 7C0000            xcall _TX_23_PutChar
 09E1 20                pop X
 09E2           L220:
 09E2                   .dbline 881
 09E2           ;       
 09E2           ;       // Wait for the transmission to finish.
 09E2           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 09E2           L221:
 09E2                   .dbline 881
 09E2 10                push X
 09E3 7C0000            xcall _TX_014_bReadTxStatus
 09E6 62D000            mov REG[0xd0],>__r0
 09E9 20                pop X
 09EA 5300              mov [__r0],A
 09EC 470020            tst [__r0],32
 09EF AFF2              jz L220
 09F1           L223:
 09F1                   .dbline 882
 09F1           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 09F1           L224:
 09F1                   .dbline 882
 09F1 10                push X
 09F2 7C0000            xcall _TX_23_bReadTxStatus
 09F5 62D000            mov REG[0xd0],>__r0
 09F8 20                pop X
 09F9 5300              mov [__r0],A
 09FB 470020            tst [__r0],32
 09FE AFF2              jz L223
 0A00                   .dbline 885
 0A00           ;       
 0A00           ;       // Make completely sure we're done.
 0A00           ;       xmitWait();
 0A00 953E              xcall _xmitWait
 0A02                   .dbline 887
 0A02           ;       
 0A02           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0A02 5000              mov A,0
 0A04 08                push A
 0A05 5001              mov A,1
 0A07 08                push A
 0A08 7C00B1            xcall _configToggle
 0A0B 38FE              add SP,-2
 0A0D                   .dbline -2
 0A0D           L219:
 0A0D                   .dbline 0 ; func end
 0A0D 7F                ret
 0A0E                   .dbend
 0A0E                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0A0E           _unloadAllConfigs::
 0A0E                   .dbline -1
 0A0E                   .dbline 893
 0A0E           ; }
 0A0E           ; 
 0A0E           ; // This function blindly unloads all user configurations. This will be called once,
 0A0E           ; // when the system initially has no known state.
 0A0E           ; void unloadAllConfigs(void)
 0A0E           ; {
 0A0E                   .dbline 894
 0A0E           ;       UnloadConfig_waiting();
 0A0E 7C0000            xcall _UnloadConfig_waiting
 0A11                   .dbline 895
 0A11           ;       UnloadConfig_hello();
 0A11 7C0000            xcall _UnloadConfig_hello
 0A14                   .dbline 896
 0A14           ;       UnloadConfig_my_response();
 0A14 7C0000            xcall _UnloadConfig_my_response
 0A17                   .dbline 897
 0A17           ;       UnloadConfig_response1();
 0A17 7C0000            xcall _UnloadConfig_response1
 0A1A                   .dbline 898
 0A1A           ;       UnloadConfig_response2();
 0A1A 7C0000            xcall _UnloadConfig_response2
 0A1D                   .dbline 899
 0A1D           ;       UnloadConfig_response3();
 0A1D 7C0000            xcall _UnloadConfig_response3
 0A20                   .dbline 900
 0A20           ;       UnloadConfig_response4();
 0A20 7C0000            xcall _UnloadConfig_response4
 0A23                   .dbline 901
 0A23           ;       UnloadConfig_initial();
 0A23 7C0000            xcall _UnloadConfig_initial
 0A26                   .dbline 902
 0A26           ;       UnloadConfig_servo_transmit();
 0A26 7C0000            xcall _UnloadConfig_servo_transmit
 0A29                   .dbline -2
 0A29           L226:
 0A29                   .dbline 0 ; func end
 0A29 7F                ret
 0A2A                   .dbend
 0A2A                   .dbfunc e unloadConfig _unloadConfig fV
 0A2A           ;     config_num -> X-5
 0A2A           _unloadConfig::
 0A2A                   .dbline -1
 0A2A 10                push X
 0A2B 4F                mov X,SP
 0A2C                   .dbline 908
 0A2C           ; }
 0A2C           ; 
 0A2C           ; // This function unloads the configuration corresponding to the config number passed to it.
 0A2C           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0A2C           ; void unloadConfig(int config_num)
 0A2C           ; {
 0A2C                   .dbline 909
 0A2C           ;       if(config_num == WAIT)
 0A2C 3DFB00            cmp [X-5],0
 0A2F B00B              jnz L228
 0A31 3DFC01            cmp [X-4],1
 0A34 B006              jnz L228
 0A36           X40:
 0A36                   .dbline 910
 0A36           ;       {
 0A36                   .dbline 911
 0A36           ;               UnloadConfig_waiting();
 0A36 7C0000            xcall _UnloadConfig_waiting
 0A39                   .dbline 912
 0A39           ;       }
 0A39 8077              xjmp L229
 0A3B           L228:
 0A3B                   .dbline 913
 0A3B           ;       else if(config_num == HELLO_MODE)
 0A3B 3DFB00            cmp [X-5],0
 0A3E B00B              jnz L230
 0A40 3DFC07            cmp [X-4],7
 0A43 B006              jnz L230
 0A45           X41:
 0A45                   .dbline 914
 0A45           ;       {
 0A45                   .dbline 915
 0A45           ;               UnloadConfig_hello();
 0A45 7C0000            xcall _UnloadConfig_hello
 0A48                   .dbline 916
 0A48           ;       }
 0A48 8068              xjmp L231
 0A4A           L230:
 0A4A                   .dbline 917
 0A4A           ;       else if(config_num == MY_RESPONSE)
 0A4A 3DFB00            cmp [X-5],0
 0A4D B00B              jnz L232
 0A4F 3DFC02            cmp [X-4],2
 0A52 B006              jnz L232
 0A54           X42:
 0A54                   .dbline 918
 0A54           ;       {
 0A54                   .dbline 919
 0A54           ;               UnloadConfig_my_response();
 0A54 7C0000            xcall _UnloadConfig_my_response
 0A57                   .dbline 920
 0A57           ;       }
 0A57 8059              xjmp L233
 0A59           L232:
 0A59                   .dbline 921
 0A59           ;       else if(config_num == RESPONSE_1)
 0A59 3DFB00            cmp [X-5],0
 0A5C B00B              jnz L234
 0A5E 3DFC03            cmp [X-4],3
 0A61 B006              jnz L234
 0A63           X43:
 0A63                   .dbline 922
 0A63           ;       {
 0A63                   .dbline 923
 0A63           ;               UnloadConfig_response1();
 0A63 7C0000            xcall _UnloadConfig_response1
 0A66                   .dbline 924
 0A66           ;       }
 0A66 804A              xjmp L235
 0A68           L234:
 0A68                   .dbline 925
 0A68           ;       else if(config_num == RESPONSE_2)
 0A68 3DFB00            cmp [X-5],0
 0A6B B00B              jnz L236
 0A6D 3DFC04            cmp [X-4],4
 0A70 B006              jnz L236
 0A72           X44:
 0A72                   .dbline 926
 0A72           ;       {
 0A72                   .dbline 927
 0A72           ;               UnloadConfig_response2();
 0A72 7C0000            xcall _UnloadConfig_response2
 0A75                   .dbline 928
 0A75           ;       }
 0A75 803B              xjmp L237
 0A77           L236:
 0A77                   .dbline 929
 0A77           ;       else if(config_num == RESPONSE_3)
 0A77 3DFB00            cmp [X-5],0
 0A7A B00B              jnz L238
 0A7C 3DFC05            cmp [X-4],5
 0A7F B006              jnz L238
 0A81           X45:
 0A81                   .dbline 930
 0A81           ;       {
 0A81                   .dbline 931
 0A81           ;               UnloadConfig_response3();
 0A81 7C0000            xcall _UnloadConfig_response3
 0A84                   .dbline 932
 0A84           ;       }
 0A84 802C              xjmp L239
 0A86           L238:
 0A86                   .dbline 933
 0A86           ;       else if(config_num == RESPONSE_4)
 0A86 3DFB00            cmp [X-5],0
 0A89 B00B              jnz L240
 0A8B 3DFC06            cmp [X-4],6
 0A8E B006              jnz L240
 0A90           X46:
 0A90                   .dbline 934
 0A90           ;       {
 0A90                   .dbline 935
 0A90           ;               UnloadConfig_response4();
 0A90 7C0000            xcall _UnloadConfig_response4
 0A93                   .dbline 936
 0A93           ;       }
 0A93 801D              xjmp L241
 0A95           L240:
 0A95                   .dbline 937
 0A95           ;       else if(config_num == INITIALIZE)
 0A95 3DFB00            cmp [X-5],0
 0A98 B00B              jnz L242
 0A9A 3DFC08            cmp [X-4],8
 0A9D B006              jnz L242
 0A9F           X47:
 0A9F                   .dbline 938
 0A9F           ;       {
 0A9F                   .dbline 939
 0A9F           ;               UnloadConfig_initial();
 0A9F 7C0000            xcall _UnloadConfig_initial
 0AA2                   .dbline 940
 0AA2           ;       }
 0AA2 800E              xjmp L243
 0AA4           L242:
 0AA4                   .dbline 941
 0AA4           ;       else if(config_num == SERVO_COMM)
 0AA4 3DFB00            cmp [X-5],0
 0AA7 B009              jnz L244
 0AA9 3DFC09            cmp [X-4],9
 0AAC B004              jnz L244
 0AAE           X48:
 0AAE                   .dbline 942
 0AAE           ;       {
 0AAE                   .dbline 943
 0AAE           ;               UnloadConfig_servo_transmit();
 0AAE 7C0000            xcall _UnloadConfig_servo_transmit
 0AB1                   .dbline 944
 0AB1           ;       }
 0AB1           L244:
 0AB1           L243:
 0AB1           L241:
 0AB1           L239:
 0AB1           L237:
 0AB1           L235:
 0AB1           L233:
 0AB1           L231:
 0AB1           L229:
 0AB1                   .dbline -2
 0AB1           L227:
 0AB1 20                pop X
 0AB2                   .dbline 0 ; func end
 0AB2 7F                ret
 0AB3                   .dbsym l config_num -5 I
 0AB3                   .dbend
 0AB3                   .dbfunc e assignedID _assignedID fV
 0AB3           _assignedID::
 0AB3                   .dbline -1
 0AB3                   .dbline 949
 0AB3           ; }
 0AB3           ; 
 0AB3           ; // This function responds that an ID has been assigned to it.
 0AB3           ; void assignedID(void)
 0AB3           ; {
 0AB3                   .dbline 950
 0AB3           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 0AB3 5000              mov A,0
 0AB5 08                push A
 0AB6 5002              mov A,2
 0AB8 08                push A
 0AB9 7C00B1            xcall _configToggle
 0ABC 38FE              add SP,-2
 0ABE                   .dbline 953
 0ABE           ;       
 0ABE           ;       // Transmit a ping to everyone.
 0ABE           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 0ABE 10                push X
 0ABF 50FC              mov A,-4
 0AC1 7C0000            xcall _TX_014_PutChar
 0AC4 20                pop X
 0AC5                   .dbline 954
 0AC5           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 0AC5 10                push X
 0AC6 50FC              mov A,-4
 0AC8 7C0000            xcall _TX_23_PutChar
 0ACB 20                pop X
 0ACC                   .dbline 955
 0ACC           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 0ACC 10                push X
 0ACD 50FC              mov A,-4
 0ACF 7C0000            xcall _TX_014_PutChar
 0AD2 20                pop X
 0AD3                   .dbline 956
 0AD3           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 0AD3 10                push X
 0AD4 50FC              mov A,-4
 0AD6 7C0000            xcall _TX_23_PutChar
 0AD9 20                pop X
 0ADA                   .dbline 957
 0ADA           ;       TX_014_PutChar(ID);                             // My ID
 0ADA 10                push X
 0ADB 62D000            mov REG[0xd0],>_ID
 0ADE 5100              mov A,[_ID]
 0AE0 7C0000            xcall _TX_014_PutChar
 0AE3 20                pop X
 0AE4                   .dbline 958
 0AE4           ;       TX_23_PutChar(ID);                              // My ID
 0AE4 10                push X
 0AE5 62D000            mov REG[0xd0],>_ID
 0AE8 5100              mov A,[_ID]
 0AEA 7C0000            xcall _TX_23_PutChar
 0AED 20                pop X
 0AEE                   .dbline 959
 0AEE           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 0AEE 10                push X
 0AEF 5000              mov A,0
 0AF1 7C0000            xcall _TX_014_PutChar
 0AF4 20                pop X
 0AF5                   .dbline 960
 0AF5           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 0AF5 10                push X
 0AF6 5000              mov A,0
 0AF8 7C0000            xcall _TX_23_PutChar
 0AFB 20                pop X
 0AFC                   .dbline 961
 0AFC           ;       TX_014_PutChar(ID_ASSIGN_OK);   // This is an assignment ack response
 0AFC 10                push X
 0AFD 50CA              mov A,-54
 0AFF 7C0000            xcall _TX_014_PutChar
 0B02 20                pop X
 0B03                   .dbline 962
 0B03           ;       TX_23_PutChar(ID_ASSIGN_OK);    // This is an assignment ack response
 0B03 10                push X
 0B04 50CA              mov A,-54
 0B06 7C0000            xcall _TX_23_PutChar
 0B09 20                pop X
 0B0A                   .dbline 963
 0B0A           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0B0A 10                push X
 0B0B 50FD              mov A,-3
 0B0D 7C0000            xcall _TX_014_PutChar
 0B10 20                pop X
 0B11                   .dbline 964
 0B11           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0B11 10                push X
 0B12 50FD              mov A,-3
 0B14 7C0000            xcall _TX_23_PutChar
 0B17 20                pop X
 0B18                   .dbline 965
 0B18           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0B18 10                push X
 0B19 50FD              mov A,-3
 0B1B 7C0000            xcall _TX_014_PutChar
 0B1E 20                pop X
 0B1F                   .dbline 966
 0B1F           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0B1F 10                push X
 0B20 50FD              mov A,-3
 0B22 7C0000            xcall _TX_23_PutChar
 0B25 20                pop X
 0B26           L247:
 0B26                   .dbline 969
 0B26           ;       
 0B26           ;       // Wait for the transmission to finish.
 0B26           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0B26           L248:
 0B26                   .dbline 969
 0B26 10                push X
 0B27 7C0000            xcall _TX_014_bReadTxStatus
 0B2A 62D000            mov REG[0xd0],>__r0
 0B2D 20                pop X
 0B2E 5300              mov [__r0],A
 0B30 470020            tst [__r0],32
 0B33 AFF2              jz L247
 0B35           L250:
 0B35                   .dbline 970
 0B35           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 0B35           L251:
 0B35                   .dbline 970
 0B35 10                push X
 0B36 7C0000            xcall _TX_23_bReadTxStatus
 0B39 62D000            mov REG[0xd0],>__r0
 0B3C 20                pop X
 0B3D 5300              mov [__r0],A
 0B3F 470020            tst [__r0],32
 0B42 AFF2              jz L250
 0B44                   .dbline 973
 0B44           ;       
 0B44           ;       // Make completely sure we're done.
 0B44           ;       xmitWait();
 0B44 93FA              xcall _xmitWait
 0B46                   .dbline 975
 0B46           ;       
 0B46           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0B46 5000              mov A,0
 0B48 08                push A
 0B49 5001              mov A,1
 0B4B 08                push A
 0B4C 7C00B1            xcall _configToggle
 0B4F 38FE              add SP,-2
 0B51                   .dbline -2
 0B51           L246:
 0B51                   .dbline 0 ; func end
 0B51 7F                ret
 0B52                   .dbend
 0B52                   .dbfunc e childListen _childListen fI
 0B52           _childListen::
 0B52                   .dbline -1
 0B52                   .dbline 980
 0B52           ; }
 0B52           ; 
 0B52           ; // This function listens for children and registers the port that they talk to.
 0B52           ; int childListen(void)
 0B52           ; {
 0B52                   .dbline 981
 0B52           ;       configToggle(HELLO_MODE);       // Switch to listen for hellos on every port.
 0B52 5000              mov A,0
 0B54 08                push A
 0B55 5007              mov A,7
 0B57 08                push A
 0B58 7C00B1            xcall _configToggle
 0B5B 38FE              add SP,-2
 0B5D 801C              xjmp L255
 0B5F           L254:
 0B5F                   .dbline 985
 0B5F           ;       
 0B5F           ;       // Wait to either hear a child or time out.
 0B5F           ;       while(!TIMEOUT)
 0B5F           ;       {               
 0B5F                   .dbline 986
 0B5F           ;               if(commandReady())
 0B5F 7C02BB            xcall _commandReady
 0B62 62D000            mov REG[0xd0],>__r0
 0B65 3C0000            cmp [__r0],0
 0B68 B006              jnz X49
 0B6A 3C0000            cmp [__r1],0
 0B6D A00C              jz L257
 0B6F           X49:
 0B6F                   .dbline 987
 0B6F           ;               {
 0B6F                   .dbline 988
 0B6F           ;                       return 1;
 0B6F 62D000            mov REG[0xd0],>__r0
 0B72 550001            mov [__r1],1
 0B75 550000            mov [__r0],0
 0B78 8030              xjmp L253
 0B7A           L257:
 0B7A                   .dbline 990
 0B7A           ;               }
 0B7A           ;       }
 0B7A           L255:
 0B7A                   .dbline 984
 0B7A 62D000            mov REG[0xd0],>_TIMEOUT
 0B7D 3C0000            cmp [_TIMEOUT],0
 0B80 B006              jnz X50
 0B82 3C0100            cmp [_TIMEOUT+1],0
 0B85 AFD9              jz L254
 0B87           X50:
 0B87                   .dbline 992
 0B87           ;       
 0B87           ;       HELLO_TIMEOUT_Stop();           // Stop the timer.
 0B87 10                push X
 0B88 7C0000            xcall _HELLO_TIMEOUT_Stop
 0B8B 20                pop X
 0B8C                   .dbline 993
 0B8C           ;       TIMEOUT = 0;                            // Clear the timeout flag.
 0B8C 62D000            mov REG[0xd0],>_TIMEOUT
 0B8F 550100            mov [_TIMEOUT+1],0
 0B92 550000            mov [_TIMEOUT],0
 0B95                   .dbline 995
 0B95           ;       
 0B95           ;       configToggle(WAIT);                     // Switch back to wait for a master response.
 0B95 5000              mov A,0
 0B97 08                push A
 0B98 5001              mov A,1
 0B9A 08                push A
 0B9B 7C00B1            xcall _configToggle
 0B9E 38FE              add SP,-2
 0BA0                   .dbline 997
 0BA0           ;       
 0BA0           ;       return 0;                                       // Return the result of our listening session.
 0BA0 62D000            mov REG[0xd0],>__r0
 0BA3 550000            mov [__r1],0
 0BA6 550000            mov [__r0],0
 0BA9                   .dbline -2
 0BA9           L253:
 0BA9                   .dbline 0 ; func end
 0BA9 7F                ret
 0BAA                   .dbend
 0BAA                   .dbfunc e childResponse _childResponse fI
 0BAA           ; child_responded -> X+0
 0BAA           _childResponse::
 0BAA                   .dbline -1
 0BAA 10                push X
 0BAB 4F                mov X,SP
 0BAC 3802              add SP,2
 0BAE                   .dbline 1002
 0BAE           ; }
 0BAE           ; 
 0BAE           ; // This function waits for a child response.
 0BAE           ; int childResponse(void)
 0BAE           ; {
 0BAE                   .dbline 1003
 0BAE           ;       int child_responded = 0;
 0BAE 560100            mov [X+1],0
 0BB1 560000            mov [X+0],0
 0BB4                   .dbline 1006
 0BB4           ;       
 0BB4           ;       // Switch to the right port.
 0BB4           ;       if(CHILD == PORT_A)
 0BB4 62D000            mov REG[0xd0],>_CHILD
 0BB7 3C0041            cmp [_CHILD],65
 0BBA B00E              jnz L260
 0BBC                   .dbline 1007
 0BBC           ;       {
 0BBC                   .dbline 1008
 0BBC           ;               configToggle(RESPONSE_1);
 0BBC 5000              mov A,0
 0BBE 08                push A
 0BBF 5003              mov A,3
 0BC1 08                push A
 0BC2 7C00B1            xcall _configToggle
 0BC5 38FE              add SP,-2
 0BC7                   .dbline 1009
 0BC7           ;       }
 0BC7 8056              xjmp L269
 0BC9           L260:
 0BC9                   .dbline 1010
 0BC9           ;       else if(CHILD == PORT_B)
 0BC9 62D000            mov REG[0xd0],>_CHILD
 0BCC 3C0042            cmp [_CHILD],66
 0BCF B00E              jnz L262
 0BD1                   .dbline 1011
 0BD1           ;       {
 0BD1                   .dbline 1012
 0BD1           ;               configToggle(RESPONSE_2);
 0BD1 5000              mov A,0
 0BD3 08                push A
 0BD4 5004              mov A,4
 0BD6 08                push A
 0BD7 7C00B1            xcall _configToggle
 0BDA 38FE              add SP,-2
 0BDC                   .dbline 1013
 0BDC           ;       }
 0BDC 8041              xjmp L269
 0BDE           L262:
 0BDE                   .dbline 1014
 0BDE           ;       else if(CHILD == PORT_C)
 0BDE 62D000            mov REG[0xd0],>_CHILD
 0BE1 3C0043            cmp [_CHILD],67
 0BE4 B00E              jnz L264
 0BE6                   .dbline 1015
 0BE6           ;       {
 0BE6                   .dbline 1016
 0BE6           ;               configToggle(RESPONSE_3);
 0BE6 5000              mov A,0
 0BE8 08                push A
 0BE9 5005              mov A,5
 0BEB 08                push A
 0BEC 7C00B1            xcall _configToggle
 0BEF 38FE              add SP,-2
 0BF1                   .dbline 1017
 0BF1           ;       }
 0BF1 802C              xjmp L269
 0BF3           L264:
 0BF3                   .dbline 1018
 0BF3           ;       else if(CHILD == PORT_D)
 0BF3 62D000            mov REG[0xd0],>_CHILD
 0BF6 3C0044            cmp [_CHILD],68
 0BF9 B024              jnz L269
 0BFB                   .dbline 1019
 0BFB           ;       {
 0BFB                   .dbline 1020
 0BFB           ;               configToggle(RESPONSE_4);
 0BFB 5000              mov A,0
 0BFD 08                push A
 0BFE 5006              mov A,6
 0C00 08                push A
 0C01 7C00B1            xcall _configToggle
 0C04 38FE              add SP,-2
 0C06                   .dbline 1021
 0C06           ;       }
 0C06 8017              xjmp L269
 0C08           L268:
 0C08                   .dbline 1025
 0C08           ;       
 0C08           ;       // Wait for a response or a timeout.
 0C08           ;       while((!child_responded) && (!TIMEOUT))
 0C08           ;       {
 0C08                   .dbline 1026
 0C08           ;               if(commandReady())
 0C08 7C02BB            xcall _commandReady
 0C0B 62D000            mov REG[0xd0],>__r0
 0C0E 3C0000            cmp [__r0],0
 0C11 B006              jnz X51
 0C13 3C0000            cmp [__r1],0
 0C16 A007              jz L271
 0C18           X51:
 0C18                   .dbline 1027
 0C18           ;               {
 0C18                   .dbline 1028
 0C18           ;                       child_responded = 1;
 0C18 560101            mov [X+1],1
 0C1B 560000            mov [X+0],0
 0C1E                   .dbline 1029
 0C1E           ;               }
 0C1E           L271:
 0C1E                   .dbline 1030
 0C1E           ;       }
 0C1E           L269:
 0C1E                   .dbline 1024
 0C1E 3D0000            cmp [X+0],0
 0C21 B013              jnz L273
 0C23 3D0100            cmp [X+1],0
 0C26 B00E              jnz L273
 0C28           X52:
 0C28 62D000            mov REG[0xd0],>_TIMEOUT
 0C2B 3C0000            cmp [_TIMEOUT],0
 0C2E B006              jnz X53
 0C30 3C0100            cmp [_TIMEOUT+1],0
 0C33 AFD4              jz L268
 0C35           X53:
 0C35           L273:
 0C35                   .dbline 1033
 0C35           ;       
 0C35           ;       // Stop the right timer.
 0C35           ;       if(CHILD == PORT_A)
 0C35 62D000            mov REG[0xd0],>_CHILD
 0C38 3C0041            cmp [_CHILD],65
 0C3B B008              jnz L274
 0C3D                   .dbline 1034
 0C3D           ;       {
 0C3D                   .dbline 1035
 0C3D           ;               CHILD_1_TIMEOUT_Stop();
 0C3D 10                push X
 0C3E 7C0000            xcall _CHILD_1_TIMEOUT_Stop
 0C41 20                pop X
 0C42                   .dbline 1036
 0C42           ;       }
 0C42 802C              xjmp L275
 0C44           L274:
 0C44                   .dbline 1037
 0C44           ;       else if(CHILD == PORT_B)
 0C44 62D000            mov REG[0xd0],>_CHILD
 0C47 3C0042            cmp [_CHILD],66
 0C4A B008              jnz L276
 0C4C                   .dbline 1038
 0C4C           ;       {
 0C4C                   .dbline 1039
 0C4C           ;               CHILD_2_TIMEOUT_Stop();
 0C4C 10                push X
 0C4D 7C0000            xcall _CHILD_2_TIMEOUT_Stop
 0C50 20                pop X
 0C51                   .dbline 1040
 0C51           ;       }
 0C51 801D              xjmp L277
 0C53           L276:
 0C53                   .dbline 1041
 0C53           ;       else if(CHILD == PORT_C)
 0C53 62D000            mov REG[0xd0],>_CHILD
 0C56 3C0043            cmp [_CHILD],67
 0C59 B008              jnz L278
 0C5B                   .dbline 1042
 0C5B           ;       {
 0C5B                   .dbline 1043
 0C5B           ;               CHILD_3_TIMEOUT_Stop();
 0C5B 10                push X
 0C5C 7C0000            xcall _CHILD_3_TIMEOUT_Stop
 0C5F 20                pop X
 0C60                   .dbline 1044
 0C60           ;       }
 0C60 800E              xjmp L279
 0C62           L278:
 0C62                   .dbline 1045
 0C62           ;       else if(CHILD == PORT_D)
 0C62 62D000            mov REG[0xd0],>_CHILD
 0C65 3C0044            cmp [_CHILD],68
 0C68 B006              jnz L280
 0C6A                   .dbline 1046
 0C6A           ;       {
 0C6A                   .dbline 1047
 0C6A           ;               CHILD_4_TIMEOUT_Stop();
 0C6A 10                push X
 0C6B 7C0000            xcall _CHILD_4_TIMEOUT_Stop
 0C6E 20                pop X
 0C6F                   .dbline 1048
 0C6F           ;       }
 0C6F           L280:
 0C6F           L279:
 0C6F           L277:
 0C6F           L275:
 0C6F                   .dbline 1050
 0C6F           ;       
 0C6F           ;       TIMEOUT = 0;                                    // Reset the timeout flag.
 0C6F 62D000            mov REG[0xd0],>_TIMEOUT
 0C72 550100            mov [_TIMEOUT+1],0
 0C75 550000            mov [_TIMEOUT],0
 0C78                   .dbline 1052
 0C78           ;       
 0C78           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0C78 5000              mov A,0
 0C7A 08                push A
 0C7B 5001              mov A,1
 0C7D 08                push A
 0C7E 7C00B1            xcall _configToggle
 0C81 38FE              add SP,-2
 0C83                   .dbline 1054
 0C83           ;       
 0C83           ;       return child_responded;
 0C83 62D000            mov REG[0xd0],>__r0
 0C86 5201              mov A,[X+1]
 0C88 5300              mov [__r1],A
 0C8A 5200              mov A,[X+0]
 0C8C 5300              mov [__r0],A
 0C8E                   .dbline -2
 0C8E           L259:
 0C8E 38FE              add SP,-2
 0C90 20                pop X
 0C91                   .dbline 0 ; func end
 0C91 7F                ret
 0C92                   .dbsym l child_responded 0 I
 0C92                   .dbend
 0C92                   .dbfunc e servoFinder _servoFinder fV
 0C92           ;     flashWrite -> X+7
 0C92           ; status_return_level -> X+6
 0C92           ; total_attempts -> X+4
 0C92           ;              j -> X+2
 0C92           ;              i -> X+0
 0C92           _servoFinder::
 0C92                   .dbline -1
 0C92 10                push X
 0C93 4F                mov X,SP
 0C94 3809              add SP,9
 0C96                   .dbline 1061
 0C96           ; }
 0C96           ; 
 0C96           ; // This function is used to find the servo that is directly connected to this module's controller.
 0C96           ; // After the servo ID is found, the status return level is changed so that packets are only
 0C96           ; // returned for the desired status return level defined at the top of this file.
 0C96           ; void servoFinder(void)
 0C96           ; {                             
 0C96                   .dbline 1063
 0C96           ;       // Index variables for incrementing and checking against the maximum servo comm attempts.
 0C96           ;       int i = 0;
 0C96 560100            mov [X+1],0
 0C99 560000            mov [X+0],0
 0C9C                   .dbline 1064
 0C9C           ;       int j = 0;
 0C9C 560300            mov [X+3],0
 0C9F 560200            mov [X+2],0
 0CA2                   .dbline 1066
 0CA2           ;       
 0CA2           ;       int total_attempts = 0;
 0CA2 560500            mov [X+5],0
 0CA5 560400            mov [X+4],0
 0CA8                   .dbline 1069
 0CA8           ;       
 0CA8           ;       // Integer used as a flag so that EEPROM writes aren't done more than once.
 0CA8           ;       int flashWrite = 0;
 0CA8 560800            mov [X+8],0
 0CAB 560700            mov [X+7],0
 0CAE                   .dbline 1072
 0CAE           ;       
 0CAE           ;       // Create a status return level variable and set it to an out of range value initially.
 0CAE           ;       char status_return_level = 3;
 0CAE 560603            mov [X+6],3
 0CB1                   .dbline 1075
 0CB1           ;       
 0CB1           ;       // Start with a servo ID of 255 (out of valid range).
 0CB1           ;       SERVO_ID = SERVO_START;
 0CB1 62D000            mov REG[0xd0],>_SERVO_ID
 0CB4 5500FF            mov [_SERVO_ID],-1
 0CB7                   .dbline 1078
 0CB7           ; 
 0CB7           ;       // We have to wait for the servo to power up and get ready for communications.
 0CB7           ;       servoBootWait();
 0CB7 92A6              xcall _servoBootWait
 0CB9                   .dbline 1087
 0CB9           ; 
 0CB9           ;       // This for loop will loop SERVO_COMM_LOOPS number of times and ping the servo SERVO_COMM_ATTEMPTS
 0CB9           ;       // number of times in each loop (unless stopped short due to early success).  If this fails for the
 0CB9           ;       // first round of pings, a broadcast reset will be performed to reset the servo.  This is done
 0CB9           ;       // because we assume that the baud rate is matching up, but the servo's return delay time is too
 0CB9           ;       // fast for the controller to switch into receive mode to read the response.  The default return
 0CB9           ;       // delay time is 500 microseconds. If we loop for SERVO_COMM_LOOPS number of times and still don't
 0CB9           ;       // see anything, we assume that there is something is too wrong for us to fix.
 0CB9           ;       for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0CB9 560300            mov [X+3],0
 0CBC 560200            mov [X+2],0
 0CBF           L283:
 0CBF                   .dbline 1088
 0CBF           ;       {       
 0CBF                   .dbline 1090
 0CBF           ;               // Ping SERVO_COMM_ATTEMPTS times to try and extract the servo ID.
 0CBF           ;               for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0CBF 560100            mov [X+1],0
 0CC2 560000            mov [X+0],0
 0CC5           L287:
 0CC5                   .dbline 1091
 0CC5           ;               {
 0CC5                   .dbline 1093
 0CC5           ;                       // Send a ping out for any servo connected to me (will only be one).
 0CC5           ;                       servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
 0CC5 5000              mov A,0
 0CC7 08                push A
 0CC8 08                push A
 0CC9 5001              mov A,1
 0CCB 08                push A
 0CCC 5002              mov A,2
 0CCE 08                push A
 0CCF 50FE              mov A,-2
 0CD1 08                push A
 0CD2 918E              xcall _servoInstruction
 0CD4 38FB              add SP,-5
 0CD6                   .dbline 1095
 0CD6           ;                       
 0CD6           ;                       total_attempts++;
 0CD6 7705              inc [X+5]
 0CD8 0F0400            adc [X+4],0
 0CDB 804C              xjmp L292
 0CDD           L291:
 0CDD                   .dbline 1099
 0CDD           ;                       
 0CDD           ;                       // Wait for either a timeout or a valid servo ID (which will trigger a timeout).
 0CDD           ;                       while(!TIMEOUT)
 0CDD           ;                       {       
 0CDD                   .dbline 1100
 0CDD           ;                               if(commandReady())
 0CDD 7C02BB            xcall _commandReady
 0CE0 62D000            mov REG[0xd0],>__r0
 0CE3 3C0000            cmp [__r0],0
 0CE6 B006              jnz X54
 0CE8 3C0000            cmp [__r1],0
 0CEB A03C              jz L294
 0CED           X54:
 0CED                   .dbline 1101
 0CED           ;                               {
 0CED                   .dbline 1103
 0CED           ;                                       // If we read a source ID within the range, exit the loop.
 0CED           ;                                       if((COMMAND_SOURCE >= SERVO_ID_MIN) && (COMMAND_SOURCE <= SERVO_ID_MAX))
 0CED 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0CF0 3C0000            cmp [_COMMAND_SOURCE],0
 0CF3 C02B              jc L296
 0CF5           X55:
 0CF5 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0CF8 50FD              mov A,-3
 0CFA 3A00              cmp A,[_COMMAND_SOURCE]
 0CFC C022              jc L296
 0CFE           X56:
 0CFE                   .dbline 1104
 0CFE           ;                                       {       
 0CFE                   .dbline 1106
 0CFE           ;                                               // Exit this while loop by setting the timeout flag.
 0CFE           ;                                               TIMEOUT = 1;
 0CFE 62D000            mov REG[0xd0],>_TIMEOUT
 0D01 550101            mov [_TIMEOUT+1],1
 0D04 550000            mov [_TIMEOUT],0
 0D07                   .dbline 1108
 0D07           ;                                               // Set the servo ID variable to where the ping came from.
 0D07           ;                                               SERVO_ID = COMMAND_SOURCE;
 0D07 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0D0A 5100              mov A,[_COMMAND_SOURCE]
 0D0C 62D000            mov REG[0xd0],>_SERVO_ID
 0D0F 5300              mov [_SERVO_ID],A
 0D11                   .dbline 1110
 0D11           ;                                               // Set the index variable such that the for loop exits.
 0D11           ;                                               i = SERVO_COMM_ATTEMPTS;
 0D11 56010A            mov [X+1],10
 0D14 560000            mov [X+0],0
 0D17                   .dbline 1112
 0D17           ;                                               // Set the outer index variable to 2 to not attempt again for no reason.
 0D17           ;                                               j = SERVO_COMM_LOOPS;
 0D17 560302            mov [X+3],2
 0D1A 560200            mov [X+2],0
 0D1D                   .dbline 1113
 0D1D           ;                                       }
 0D1D 800A              xjmp L297
 0D1F           L296:
 0D1F                   .dbline 1115
 0D1F           ;                                       else
 0D1F           ;                                       {
 0D1F                   .dbline 1117
 0D1F           ;                                               // Exit this while loop and try to ping again.
 0D1F           ;                                               TIMEOUT = 1;
 0D1F 62D000            mov REG[0xd0],>_TIMEOUT
 0D22 550101            mov [_TIMEOUT+1],1
 0D25 550000            mov [_TIMEOUT],0
 0D28                   .dbline 1118
 0D28           ;                                       }
 0D28           L297:
 0D28                   .dbline 1119
 0D28           ;                               }
 0D28           L294:
 0D28                   .dbline 1120
 0D28           ;                       }
 0D28           L292:
 0D28                   .dbline 1098
 0D28 62D000            mov REG[0xd0],>_TIMEOUT
 0D2B 3C0000            cmp [_TIMEOUT],0
 0D2E B006              jnz X57
 0D30 3C0100            cmp [_TIMEOUT+1],0
 0D33 AFA9              jz L291
 0D35           X57:
 0D35                   .dbline 1121
 0D35           ;               }
 0D35           L288:
 0D35                   .dbline 1090
 0D35 7701              inc [X+1]
 0D37 0F0000            adc [X+0],0
 0D3A                   .dbline 1090
 0D3A 5201              mov A,[X+1]
 0D3C 110A              sub A,10
 0D3E 5200              mov A,[X+0]
 0D40 3180              xor A,-128
 0D42 1980              sbb A,(0 ^ 0x80)
 0D44 CF80              jc L287
 0D46           X58:
 0D46                   .dbline 1125
 0D46           ;               
 0D46           ;               // If we didn't get a response and haven't written to the flash of the
 0D46           ;               // servo (first time through), send out a broadcast reset.
 0D46           ;               if((SERVO_ID == SERVO_START) && (!flashWrite))
 0D46 62D000            mov REG[0xd0],>_SERVO_ID
 0D49 3C00FF            cmp [_SERVO_ID],-1
 0D4C B022              jnz L298
 0D4E 3D0700            cmp [X+7],0
 0D51 B01D              jnz L298
 0D53 3D0800            cmp [X+8],0
 0D56 B018              jnz L298
 0D58           X59:
 0D58                   .dbline 1126
 0D58           ;               {
 0D58                   .dbline 1128
 0D58           ;                       // Set the flash write flag so that we only do this once per power cycle.
 0D58           ;                       flashWrite = 1;
 0D58 560801            mov [X+8],1
 0D5B 560700            mov [X+7],0
 0D5E                   .dbline 1132
 0D5E           ;                       
 0D5E           ;                       // Send out a broadcast reset so that we know that the response time interval
 0D5E           ;                       // is large enough (default delay time for a servo is 500 microseconds).
 0D5E           ;                       servoInstruction(BROADCAST, RESET_LENGTH, RESET_SERVO, 0, 0);
 0D5E 5000              mov A,0
 0D60 08                push A
 0D61 08                push A
 0D62 5006              mov A,6
 0D64 08                push A
 0D65 5002              mov A,2
 0D67 08                push A
 0D68 50FE              mov A,-2
 0D6A 08                push A
 0D6B 90F5              xcall _servoInstruction
 0D6D 38FB              add SP,-5
 0D6F                   .dbline 1133
 0D6F           ;               }
 0D6F           L298:
 0D6F                   .dbline 1134
 0D6F           ;       }
 0D6F           L284:
 0D6F                   .dbline 1087
 0D6F 7703              inc [X+3]
 0D71 0F0200            adc [X+2],0
 0D74                   .dbline 1087
 0D74 5203              mov A,[X+3]
 0D76 1102              sub A,2
 0D78 5202              mov A,[X+2]
 0D7A 3180              xor A,-128
 0D7C 1980              sbb A,(0 ^ 0x80)
 0D7E CF40              jc L283
 0D80           X60:
 0D80                   .dbline 1137
 0D80           ; 
 0D80           ;       // Reset flash write flag.
 0D80           ;       flashWrite = 0;
 0D80 560800            mov [X+8],0
 0D83 560700            mov [X+7],0
 0D86                   .dbline 1141
 0D86           ;       
 0D86           ;       // If we have a valid servo ID, set the status return level.  If we don't, just skip this
 0D86           ;       // because all hope is lost.
 0D86           ;       if(SERVO_ID < BROADCAST)
 0D86 62D000            mov REG[0xd0],>_SERVO_ID
 0D89 3C00FE            cmp [_SERVO_ID],-2
 0D8C D0CD              jnc L327
 0D8E           X61:
 0D8E                   .dbline 1142
 0D8E           ;       {
 0D8E                   .dbline 1147
 0D8E           ;               // This for loop will loop SERVO_COMM_LOOPS number of times and poll for the servo's status
 0D8E           ;               // return level SERVO_COMM_ATTEMPTS number of times in each loop (unless stopped short due
 0D8E           ;               // to early success).  If this fails for the first iteration, or we read a status return level
 0D8E           ;               // other than what we want, we will attempt to write the desired status return level onto the servo.
 0D8E           ;               for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0D8E 560300            mov [X+3],0
 0D91 560200            mov [X+2],0
 0D94           L302:
 0D94                   .dbline 1148
 0D94           ;               {
 0D94                   .dbline 1150
 0D94           ;                       // Attempt to read the status return level for the defined number of attempts.
 0D94           ;                       for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0D94 560100            mov [X+1],0
 0D97 560000            mov [X+0],0
 0D9A           L306:
 0D9A                   .dbline 1151
 0D9A           ;                       {
 0D9A                   .dbline 1153
 0D9A           ;                               // Send a request for the servo's status return level.
 0D9A           ;                               servoInstruction(SERVO_ID, READ_LENGTH, READ_SERVO, STATUS_RET_ADDRESS, 1);
 0D9A 5001              mov A,1
 0D9C 08                push A
 0D9D 5010              mov A,16
 0D9F 08                push A
 0DA0 5002              mov A,2
 0DA2 08                push A
 0DA3 5004              mov A,4
 0DA5 08                push A
 0DA6 62D000            mov REG[0xd0],>_SERVO_ID
 0DA9 5100              mov A,[_SERVO_ID]
 0DAB 08                push A
 0DAC 90B4              xcall _servoInstruction
 0DAE 38FB              add SP,-5
 0DB0 8048              xjmp L311
 0DB2           L310:
 0DB2                   .dbline 1157
 0DB2           ;                               
 0DB2           ;                               // Wait for either a timeout or an indication that we want to exit the loop.
 0DB2           ;                               while(!TIMEOUT)
 0DB2           ;                               {
 0DB2                   .dbline 1159
 0DB2           ;                                       // If a valid command is ready, interpret it.
 0DB2           ;                                       if(commandReady())
 0DB2 7C02BB            xcall _commandReady
 0DB5 62D000            mov REG[0xd0],>__r0
 0DB8 3C0000            cmp [__r0],0
 0DBB B006              jnz X62
 0DBD 3C0000            cmp [__r1],0
 0DC0 A038              jz L313
 0DC2           X62:
 0DC2                   .dbline 1160
 0DC2           ;                                       {
 0DC2                   .dbline 1161
 0DC2           ;                                               if(!COMMAND_ERROR)
 0DC2 62D000            mov REG[0xd0],>_COMMAND_ERROR
 0DC5 3C0000            cmp [_COMMAND_ERROR],0
 0DC8 B030              jnz L315
 0DCA                   .dbline 1162
 0DCA           ;                                               {
 0DCA                   .dbline 1164
 0DCA           ;                                                       // If the return level is equal to what is desired, store it.
 0DCA           ;                                                       if(COMMAND_PARAM == STATUS_RET_LEVEL)
 0DCA 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0DCD 3C0001            cmp [_COMMAND_PARAM],1
 0DD0 B01F              jnz L317
 0DD2                   .dbline 1165
 0DD2           ;                                                       {
 0DD2                   .dbline 1167
 0DD2           ;                                                               // Set the timeout flag to exit the loop.
 0DD2           ;                                                               TIMEOUT = 1;
 0DD2 62D000            mov REG[0xd0],>_TIMEOUT
 0DD5 550101            mov [_TIMEOUT+1],1
 0DD8 550000            mov [_TIMEOUT],0
 0DDB                   .dbline 1169
 0DDB           ;                                                               // Store the status return level.
 0DDB           ;                                                               status_return_level = COMMAND_PARAM;
 0DDB 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0DDE 5100              mov A,[_COMMAND_PARAM]
 0DE0 5406              mov [X+6],A
 0DE2                   .dbline 1171
 0DE2           ;                                                               // Set i so that we exit the for loop.
 0DE2           ;                                                               i = SERVO_COMM_ATTEMPTS;
 0DE2 56010A            mov [X+1],10
 0DE5 560000            mov [X+0],0
 0DE8                   .dbline 1173
 0DE8           ;                                                               // Set the outer loop's variable so that we don't loop again.
 0DE8           ;                                                               j = SERVO_COMM_LOOPS;
 0DE8 560302            mov [X+3],2
 0DEB 560200            mov [X+2],0
 0DEE                   .dbline 1174
 0DEE           ;                                                       }
 0DEE 800A              xjmp L318
 0DF0           L317:
 0DF0                   .dbline 1176
 0DF0           ;                                                       else
 0DF0           ;                                                       {       
 0DF0                   .dbline 1178
 0DF0           ;                                                               // Set the timeout flag to exit the loop.
 0DF0           ;                                                               TIMEOUT = 1;
 0DF0 62D000            mov REG[0xd0],>_TIMEOUT
 0DF3 550101            mov [_TIMEOUT+1],1
 0DF6 550000            mov [_TIMEOUT],0
 0DF9                   .dbline 1179
 0DF9           ;                                                       }
 0DF9           L318:
 0DF9                   .dbline 1180
 0DF9           ;                                               }
 0DF9           L315:
 0DF9                   .dbline 1181
 0DF9           ;                                       }
 0DF9           L313:
 0DF9                   .dbline 1182
 0DF9           ;                               }
 0DF9           L311:
 0DF9                   .dbline 1156
 0DF9 62D000            mov REG[0xd0],>_TIMEOUT
 0DFC 3C0000            cmp [_TIMEOUT],0
 0DFF B006              jnz X63
 0E01 3C0100            cmp [_TIMEOUT+1],0
 0E04 AFAD              jz L310
 0E06           X63:
 0E06                   .dbline 1183
 0E06           ;                       }
 0E06           L307:
 0E06                   .dbline 1150
 0E06 7701              inc [X+1]
 0E08 0F0000            adc [X+0],0
 0E0B                   .dbline 1150
 0E0B 5201              mov A,[X+1]
 0E0D 110A              sub A,10
 0E0F 5200              mov A,[X+0]
 0E11 3180              xor A,-128
 0E13 1980              sbb A,(0 ^ 0x80)
 0E15 CF84              jc L306
 0E17           X64:
 0E17                   .dbline 1187
 0E17           ;               
 0E17           ;                       // If we didn't get a good response and haven't written to the flash of the servo,
 0E17           ;                       // force a change in the status return level with an EEPROM write.
 0E17           ;                       if((status_return_level != STATUS_RET_LEVEL) && (!flashWrite))
 0E17 3D0601            cmp [X+6],1
 0E1A A027              jz L319
 0E1C 3D0700            cmp [X+7],0
 0E1F B022              jnz L319
 0E21 3D0800            cmp [X+8],0
 0E24 B01D              jnz L319
 0E26           X65:
 0E26                   .dbline 1188
 0E26           ;                       {       
 0E26                   .dbline 1189
 0E26           ;                               flashWrite = 1;
 0E26 560801            mov [X+8],1
 0E29 560700            mov [X+7],0
 0E2C                   .dbline 1192
 0E2C           ;                               
 0E2C           ;                               // Try to force the return status to what we want.
 0E2C           ;                               servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, STATUS_RET_ADDRESS, STATUS_RET_LEVEL);
 0E2C 5001              mov A,1
 0E2E 08                push A
 0E2F 5010              mov A,16
 0E31 08                push A
 0E32 5003              mov A,3
 0E34 08                push A
 0E35 5004              mov A,4
 0E37 08                push A
 0E38 62D000            mov REG[0xd0],>_SERVO_ID
 0E3B 5100              mov A,[_SERVO_ID]
 0E3D 08                push A
 0E3E 9022              xcall _servoInstruction
 0E40 38FB              add SP,-5
 0E42                   .dbline 1193
 0E42           ;                       }
 0E42           L319:
 0E42                   .dbline 1194
 0E42           ;               }
 0E42           L303:
 0E42                   .dbline 1147
 0E42 7703              inc [X+3]
 0E44 0F0200            adc [X+2],0
 0E47                   .dbline 1147
 0E47 5203              mov A,[X+3]
 0E49 1102              sub A,2
 0E4B 5202              mov A,[X+2]
 0E4D 3180              xor A,-128
 0E4F 1980              sbb A,(0 ^ 0x80)
 0E51 CF42              jc L302
 0E53           X66:
 0E53                   .dbline 1196
 0E53           ;               
 0E53           ;               if(status_return_level != STATUS_RET_LEVEL)
 0E53 3D0601            cmp [X+6],1
 0E56 A005              jz L301
 0E58                   .dbline 1197
 0E58           ;               {
 0E58           L323:
 0E58                   .dbline 1199
 0E58           ;                       // Break on purpose to show that the status return is not correct.
 0E58           ;                       while(1) { }
 0E58                   .dbline 1199
 0E58           L324:
 0E58                   .dbline 1199
 0E58 8FFF              xjmp L323
 0E5A           L326:
 0E5A                   .dbline 1205
 0E5A           ;               }
 0E5A           ;       }
 0E5A           ;       else
 0E5A           ;       {
 0E5A           ;               // Purposely break the module to show that we did not resolve the communication with our servo.
 0E5A           ;               while(1) { }
 0E5A                   .dbline 1205
 0E5A           L327:
 0E5A                   .dbline 1205
 0E5A 8FFF              xjmp L326
 0E5C           L301:
 0E5C                   .dbline 1220
 0E5C           ;       }
 0E5C           ; 
 0E5C           ; //    if(total_attempts <= SERVO_COMM_ATTEMPTS)
 0E5C           ; //    {
 0E5C           ; //            PRT2DR &= 0b11111110;
 0E5C           ; //    }
 0E5C           ; //    else
 0E5C           ; //    {
 0E5C           ; //            PRT2DR |= 0b00000001;
 0E5C           ; //    }
 0E5C           ; //    
 0E5C           ; //    while(1) { }
 0E5C           ;       
 0E5C           ;       // Wait for the other controllers to find their servos.
 0E5C           ;       servoConfigWait();
 0E5C 9155              xcall _servoConfigWait
 0E5E                   .dbline -2
 0E5E           L282:
 0E5E 38F7              add SP,-9
 0E60 20                pop X
 0E61                   .dbline 0 ; func end
 0E61 7F                ret
 0E62                   .dbsym l flashWrite 7 I
 0E62                   .dbsym l status_return_level 6 c
 0E62                   .dbsym l total_attempts 4 I
 0E62                   .dbsym l j 2 I
 0E62                   .dbsym l i 0 I
 0E62                   .dbend
 0E62                   .dbfunc e servoInstruction _servoInstruction fV
 0E62           ;       checksum -> X+0
 0E62           ;          value -> X-8
 0E62           ;        address -> X-7
 0E62           ;    instruction -> X-6
 0E62           ;         length -> X-5
 0E62           ;             id -> X-4
 0E62           _servoInstruction::
 0E62                   .dbline -1
 0E62 10                push X
 0E63 4F                mov X,SP
 0E64 3801              add SP,1
 0E66                   .dbline 1226
 0E66           ; }
 0E66           ; 
 0E66           ; // This function receives a destination, command length, instruction type, address, and value.
 0E66           ; // With these parameters, the function sends a packet to the communication bus.
 0E66           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 0E66           ; {
 0E66                   .dbline 1230
 0E66           ;       char checksum;
 0E66           ;       
 0E66           ;       // Toggle into transmit mode.
 0E66           ;       configToggle(SERVO_COMM);
 0E66 5000              mov A,0
 0E68 08                push A
 0E69 5009              mov A,9
 0E6B 08                push A
 0E6C 7C00B1            xcall _configToggle
 0E6F 38FE              add SP,-2
 0E71                   .dbline 1233
 0E71           ;       
 0E71           ;       // Calculate the checksum value for our servo communication.
 0E71           ;       checksum = 255-((id + length + instruction + address + value)%256);
 0E71 62D000            mov REG[0xd0],>__r0
 0E74 52FB              mov A,[X-5]
 0E76 5300              mov [__r1],A
 0E78 550000            mov [__r0],0
 0E7B 52FC              mov A,[X-4]
 0E7D 0200              add A,[__r1]
 0E7F 5300              mov [__r1],A
 0E81 5000              mov A,0
 0E83 0A00              adc A,[__r0]
 0E85 5300              mov [__r0],A
 0E87 52FA              mov A,[X-6]
 0E89 0400              add [__r1],A
 0E8B 0E0000            adc [__r0],0
 0E8E 52F9              mov A,[X-7]
 0E90 0400              add [__r1],A
 0E92 0E0000            adc [__r0],0
 0E95 52F8              mov A,[X-8]
 0E97 0400              add [__r1],A
 0E99 0E0000            adc [__r0],0
 0E9C 5001              mov A,1
 0E9E 08                push A
 0E9F 5000              mov A,0
 0EA1 08                push A
 0EA2 5100              mov A,[__r0]
 0EA4 08                push A
 0EA5 5100              mov A,[__r1]
 0EA7 08                push A
 0EA8 7C0000            xcall __divmod_16X16_16
 0EAB 38FE              add SP,-2
 0EAD 18                pop A
 0EAE 5300              mov [__r1],A
 0EB0 18                pop A
 0EB1 50FF              mov A,-1
 0EB3 1200              sub A,[__r1]
 0EB5 5400              mov [X+0],A
 0EB7                   .dbline 1236
 0EB7           ;       
 0EB7           ;       // Talk to the servo.
 0EB7           ;       if(instruction == PING_SERVO)
 0EB7 3DFA01            cmp [X-6],1
 0EBA B02D              jnz L330
 0EBC                   .dbline 1237
 0EBC           ;       {
 0EBC                   .dbline 1238
 0EBC           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte one
 0EBC 10                push X
 0EBD 50FF              mov A,-1
 0EBF 7C0000            xcall _SERVO_TX_PutChar
 0EC2 20                pop X
 0EC3                   .dbline 1239
 0EC3           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte two
 0EC3 10                push X
 0EC4 50FF              mov A,-1
 0EC6 7C0000            xcall _SERVO_TX_PutChar
 0EC9 20                pop X
 0ECA                   .dbline 1240
 0ECA           ;               SERVO_TX_PutChar(id);                   // Servo ID
 0ECA 10                push X
 0ECB 52FC              mov A,[X-4]
 0ECD 7C0000            xcall _SERVO_TX_PutChar
 0ED0 20                pop X
 0ED1                   .dbline 1241
 0ED1           ;               SERVO_TX_PutChar(length);               // The instruction length.
 0ED1 10                push X
 0ED2 52FB              mov A,[X-5]
 0ED4 7C0000            xcall _SERVO_TX_PutChar
 0ED7 20                pop X
 0ED8                   .dbline 1242
 0ED8           ;               SERVO_TX_PutChar(instruction);  // The instruction to carry out.
 0ED8 10                push X
 0ED9 52FA              mov A,[X-6]
 0EDB 7C0000            xcall _SERVO_TX_PutChar
 0EDE 20                pop X
 0EDF                   .dbline 1243
 0EDF           ;               SERVO_TX_PutChar(checksum);             // This is the checksum.
 0EDF 10                push X
 0EE0 5200              mov A,[X+0]
 0EE2 7C0000            xcall _SERVO_TX_PutChar
 0EE5 20                pop X
 0EE6                   .dbline 1244
 0EE6           ;       }
 0EE6 8039              xjmp L333
 0EE8           L330:
 0EE8                   .dbline 1246
 0EE8           ;       else
 0EE8           ;       {
 0EE8                   .dbline 1247
 0EE8           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte one
 0EE8 10                push X
 0EE9 50FF              mov A,-1
 0EEB 7C0000            xcall _SERVO_TX_PutChar
 0EEE 20                pop X
 0EEF                   .dbline 1248
 0EEF           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte two
 0EEF 10                push X
 0EF0 50FF              mov A,-1
 0EF2 7C0000            xcall _SERVO_TX_PutChar
 0EF5 20                pop X
 0EF6                   .dbline 1249
 0EF6           ;               SERVO_TX_PutChar(id);                   // Servo ID
 0EF6 10                push X
 0EF7 52FC              mov A,[X-4]
 0EF9 7C0000            xcall _SERVO_TX_PutChar
 0EFC 20                pop X
 0EFD                   .dbline 1250
 0EFD           ;               SERVO_TX_PutChar(length);               // The instruction length.
 0EFD 10                push X
 0EFE 52FB              mov A,[X-5]
 0F00 7C0000            xcall _SERVO_TX_PutChar
 0F03 20                pop X
 0F04                   .dbline 1251
 0F04           ;               SERVO_TX_PutChar(instruction);  // The instruction to carry out.
 0F04 10                push X
 0F05 52FA              mov A,[X-6]
 0F07 7C0000            xcall _SERVO_TX_PutChar
 0F0A 20                pop X
 0F0B                   .dbline 1252
 0F0B           ;               SERVO_TX_PutChar(address);              // The address to read/write from/to.
 0F0B 10                push X
 0F0C 52F9              mov A,[X-7]
 0F0E 7C0000            xcall _SERVO_TX_PutChar
 0F11 20                pop X
 0F12                   .dbline 1253
 0F12           ;               SERVO_TX_PutChar(value);                // The value to write or number of bytes to read.
 0F12 10                push X
 0F13 52F8              mov A,[X-8]
 0F15 7C0000            xcall _SERVO_TX_PutChar
 0F18 20                pop X
 0F19                   .dbline 1254
 0F19           ;               SERVO_TX_PutChar(checksum);             // This is the checksum.
 0F19 10                push X
 0F1A 5200              mov A,[X+0]
 0F1C 7C0000            xcall _SERVO_TX_PutChar
 0F1F 20                pop X
 0F20                   .dbline 1255
 0F20           ;       }
 0F20           L332:
 0F20                   .dbline 1258
 0F20           ;       
 0F20           ;       // Wait for the transmission to finish.
 0F20           ;       while(!(SERVO_TX_bReadTxStatus() & SERVO_TX_TX_COMPLETE));
 0F20           L333:
 0F20                   .dbline 1258
 0F20 10                push X
 0F21 7C0000            xcall _SERVO_TX_bReadTxStatus
 0F24 62D000            mov REG[0xd0],>__r0
 0F27 20                pop X
 0F28 5300              mov [__r0],A
 0F2A 470020            tst [__r0],32
 0F2D AFF2              jz L332
 0F2F                   .dbline 1261
 0F2F           ;       
 0F2F           ;       // Make completely sure we're done.
 0F2F           ;       xmitWait();
 0F2F 900F              xcall _xmitWait
 0F31                   .dbline 1264
 0F31           ;       
 0F31           ;       // Switch back to wait for a servo response.
 0F31           ;       configToggle(INITIALIZE);
 0F31 5000              mov A,0
 0F33 08                push A
 0F34 5008              mov A,8
 0F36 08                push A
 0F37 7C00B1            xcall _configToggle
 0F3A 38FE              add SP,-2
 0F3C                   .dbline -2
 0F3C           L329:
 0F3C 38FF              add SP,-1
 0F3E 20                pop X
 0F3F                   .dbline 0 ; func end
 0F3F 7F                ret
 0F40                   .dbsym l checksum 0 c
 0F40                   .dbsym l value -8 c
 0F40                   .dbsym l address -7 c
 0F40                   .dbsym l instruction -6 c
 0F40                   .dbsym l length -5 c
 0F40                   .dbsym l id -4 c
 0F40                   .dbend
 0F40                   .dbfunc e xmitWait _xmitWait fV
 0F40           ;              i -> X+0
 0F40           _xmitWait::
 0F40                   .dbline -1
 0F40 10                push X
 0F41 4F                mov X,SP
 0F42 3802              add SP,2
 0F44                   .dbline 1268
 0F44           ; }
 0F44           ; 
 0F44           ; void xmitWait(void)
 0F44           ; {
 0F44                   .dbline 1271
 0F44           ;       int i;
 0F44           ;       
 0F44           ;       for(i = 0; i < 25; i++)
 0F44 560100            mov [X+1],0
 0F47 560000            mov [X+0],0
 0F4A           L336:
 0F4A                   .dbline 1272
 0F4A           ;       {
 0F4A                   .dbline 1274
 0F4A           ;               // Does nothing and wastes approximately 50 microseconds.
 0F4A           ;       }
 0F4A           L337:
 0F4A                   .dbline 1271
 0F4A 7701              inc [X+1]
 0F4C 0F0000            adc [X+0],0
 0F4F                   .dbline 1271
 0F4F 5201              mov A,[X+1]
 0F51 1119              sub A,25
 0F53 5200              mov A,[X+0]
 0F55 3180              xor A,-128
 0F57 1980              sbb A,(0 ^ 0x80)
 0F59 CFF0              jc L336
 0F5B           X67:
 0F5B                   .dbline -2
 0F5B           L335:
 0F5B 38FE              add SP,-2
 0F5D 20                pop X
 0F5E                   .dbline 0 ; func end
 0F5E 7F                ret
 0F5F                   .dbsym l i 0 I
 0F5F                   .dbend
 0F5F                   .dbfunc e servoBootWait _servoBootWait fV
 0F5F           ;              i -> X+0
 0F5F           _servoBootWait::
 0F5F                   .dbline -1
 0F5F 10                push X
 0F60 4F                mov X,SP
 0F61 3802              add SP,2
 0F63                   .dbline 1281
 0F63           ; }
 0F63           ; 
 0F63           ; // This function wastes time while the servo that is attached to this controller boots up.
 0F63           ; // Once that happens, communications should happen quickly and reliably.  The estimated boot
 0F63           ; // time in testing was approximately 120 ms.
 0F63           ; void servoBootWait(void)
 0F63           ; {
 0F63                   .dbline 1282
 0F63           ;       int i = 0;                                      // Index integer used for looping.
 0F63 560100            mov [X+1],0
 0F66 560000            mov [X+0],0
 0F69                   .dbline 1284
 0F69           ; 
 0F69           ;       configToggle(INITIALIZE);       // Switch to initialize mode to do this timeout routine.
 0F69 5000              mov A,0
 0F6B 08                push A
 0F6C 5008              mov A,8
 0F6E 08                push A
 0F6F 7C00B1            xcall _configToggle
 0F72 38FE              add SP,-2
 0F74                   .dbline 1287
 0F74           ;       
 0F74           ;       // Loop and wait for enough timeouts to happen before we talk to the servo.
 0F74           ;       for(i = 0; i < SERVO_BOOT_TIMEOUTS; i++)
 0F74 560100            mov [X+1],0
 0F77 560000            mov [X+0],0
 0F7A                   .dbline 1288
 0F7A           ;       {
 0F7A           L345:
 0F7A                   .dbline 1289
 0F7A           ;               while(!TIMEOUT) { }             // Do nothing while we wait for one timeout period.
 0F7A                   .dbline 1289
 0F7A           L346:
 0F7A                   .dbline 1289
 0F7A 62D000            mov REG[0xd0],>_TIMEOUT
 0F7D 3C0000            cmp [_TIMEOUT],0
 0F80 B006              jnz X68
 0F82 3C0100            cmp [_TIMEOUT+1],0
 0F85 AFF4              jz L345
 0F87           X68:
 0F87                   .dbline 1290
 0F87           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 0F87 62D000            mov REG[0xd0],>_TIMEOUT
 0F8A 550100            mov [_TIMEOUT+1],0
 0F8D 550000            mov [_TIMEOUT],0
 0F90                   .dbline 1291
 0F90           ;       }
 0F90           L342:
 0F90                   .dbline 1287
 0F90 7701              inc [X+1]
 0F92 0F0000            adc [X+0],0
 0F95                   .dbline 1287
 0F95 5201              mov A,[X+1]
 0F97 114B              sub A,75
 0F99 5200              mov A,[X+0]
 0F9B 3180              xor A,-128
 0F9D 1980              sbb A,(0 ^ 0x80)
 0F9F CFDA              jc L346
 0FA1           X69:
 0FA1                   .dbline 1293
 0FA1           ;       
 0FA1           ;       INIT_TIMEOUT_Stop();            // Stop the timeout timer.
 0FA1 10                push X
 0FA2 7C0000            xcall _INIT_TIMEOUT_Stop
 0FA5 20                pop X
 0FA6                   .dbline 1294
 0FA6           ;       TIMEOUT = 0;                            // Clear the timeout flag.
 0FA6 62D000            mov REG[0xd0],>_TIMEOUT
 0FA9 550100            mov [_TIMEOUT+1],0
 0FAC 550000            mov [_TIMEOUT],0
 0FAF                   .dbline -2
 0FAF           L340:
 0FAF 38FE              add SP,-2
 0FB1 20                pop X
 0FB2                   .dbline 0 ; func end
 0FB2 7F                ret
 0FB3                   .dbsym l i 0 I
 0FB3                   .dbend
 0FB3                   .dbfunc e servoConfigWait _servoConfigWait fV
 0FB3           ;              i -> X+0
 0FB3           _servoConfigWait::
 0FB3                   .dbline -1
 0FB3 10                push X
 0FB4 4F                mov X,SP
 0FB5 3802              add SP,2
 0FB7                   .dbline 1300
 0FB7           ; }
 0FB7           ; 
 0FB7           ; // Sits and spins for the amount of time it takes for a worst case scenario for setup time
 0FB7           ; // to take place.  This allows all other modules to initialize.
 0FB7           ; void servoConfigWait(void)
 0FB7           ; {
 0FB7                   .dbline 1301
 0FB7           ;       int i = 0;                                      // Index integer for looping purposes.
 0FB7 560100            mov [X+1],0
 0FBA 560000            mov [X+0],0
 0FBD                   .dbline 1303
 0FBD           ;       
 0FBD           ;       configToggle(INITIALIZE);       // Switch to initialize mode to do this timeout routine.
 0FBD 5000              mov A,0
 0FBF 08                push A
 0FC0 5008              mov A,8
 0FC2 08                push A
 0FC3 7C00B1            xcall _configToggle
 0FC6 38FE              add SP,-2
 0FC8                   .dbline 1308
 0FC8           ;       
 0FC8           ;       // For SERVO_COMM_ATTEMPTS*SERVO_COMM_LOOPS cycles, let the other controllers find
 0FC8           ;       // their servos.  The reason we loop this many times is to allow for a possible worst
 0FC8           ;       // case scenario of setup time to complete.
 0FC8           ;       for(i = 0; i < (SERVO_COMM_ATTEMPTS*SERVO_COMM_LOOPS); i++)
 0FC8 560100            mov [X+1],0
 0FCB 560000            mov [X+0],0
 0FCE                   .dbline 1309
 0FCE           ;       {
 0FCE           L353:
 0FCE                   .dbline 1310
 0FCE           ;               while(!TIMEOUT) { }             // Do nothing while we wait for one timeout period.
 0FCE                   .dbline 1310
 0FCE           L354:
 0FCE                   .dbline 1310
 0FCE 62D000            mov REG[0xd0],>_TIMEOUT
 0FD1 3C0000            cmp [_TIMEOUT],0
 0FD4 B006              jnz X70
 0FD6 3C0100            cmp [_TIMEOUT+1],0
 0FD9 AFF4              jz L353
 0FDB           X70:
 0FDB                   .dbline 1311
 0FDB           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 0FDB 62D000            mov REG[0xd0],>_TIMEOUT
 0FDE 550100            mov [_TIMEOUT+1],0
 0FE1 550000            mov [_TIMEOUT],0
 0FE4                   .dbline 1312
 0FE4           ;       }
 0FE4           L350:
 0FE4                   .dbline 1308
 0FE4 7701              inc [X+1]
 0FE6 0F0000            adc [X+0],0
 0FE9                   .dbline 1308
 0FE9 5201              mov A,[X+1]
 0FEB 1114              sub A,20
 0FED 5200              mov A,[X+0]
 0FEF 3180              xor A,-128
 0FF1 1980              sbb A,(0 ^ 0x80)
 0FF3 CFDA              jc L354
 0FF5           X71:
 0FF5                   .dbline 1314
 0FF5           ;       
 0FF5           ;       INIT_TIMEOUT_Stop();            // Stop the timer.
 0FF5 10                push X
 0FF6 7C0000            xcall _INIT_TIMEOUT_Stop
 0FF9 20                pop X
 0FFA                   .dbline 1315
 0FFA           ;       TIMEOUT = 0;                            // Reset the timeout flag.
 0FFA 62D000            mov REG[0xd0],>_TIMEOUT
 0FFD 550100            mov [_TIMEOUT+1],0
 1000 550000            mov [_TIMEOUT],0
 1003                   .dbline 1317
 1003           ; 
 1003           ;       configToggle(WAIT);                     // Switch to wait for the master node to speak to you.
 1003 5000              mov A,0
 1005 08                push A
 1006 5001              mov A,1
 1008 08                push A
 1009 7C00B1            xcall _configToggle
 100C 38FE              add SP,-2
 100E                   .dbline -2
 100E           L348:
 100E 38FE              add SP,-2
 1010 20                pop X
 1011                   .dbline 0 ; func end
 1011 7F                ret
 1012                   .dbsym l i 0 I
 1012                   .dbend
 1012                   .dbfunc e TX_01234_TIMEOUT_ISR _TX_01234_TIMEOUT_ISR fV
 1012           _TX_01234_TIMEOUT_ISR::
 1012                   .dbline -1
 1012 71C0              or F,-64
 1014 08                push A
 1015 5DD0              mov A,REG[0xd0]
 1017 08                push A
 1018                   .dbline 1325
 1018           ; }
 1018           ; 
 1018           ; // This timeout ISR is for waiting before a transmission is made from this module.
 1018           ; // This is to give all the other modules a chance to set up and clear their buffers.
 1018           ; // It is currently set so that there is 1 ms of down time between the last transmission
 1018           ; // and this module's transmission.
 1018           ; void TX_01234_TIMEOUT_ISR(void)
 1018           ; {
 1018                   .dbline 1326
 1018           ;       TIMEOUT = 1;    // Set the timeout flag.
 1018 62D000            mov REG[0xd0],>_TIMEOUT
 101B 550101            mov [_TIMEOUT+1],1
 101E 550000            mov [_TIMEOUT],0
 1021                   .dbline 1327
 1021           ;       M8C_ClearIntFlag(INT_CLR0,TX_01234_TIMEOUT_INT_MASK);
 1021 62DAFD            mov REG[0xda],-3
 1024                   .dbline -2
 1024           L356:
 1024 18                pop A
 1025 60D0              mov REG[208],A
 1027 18                pop A
 1028                   .dbline 0 ; func end
 1028 7E                reti
 1029                   .dbend
 1029                   .dbfunc e HELLO_TIMEOUT_ISR _HELLO_TIMEOUT_ISR fV
 1029           _HELLO_TIMEOUT_ISR::
 1029                   .dbline -1
 1029 71C0              or F,-64
 102B 08                push A
 102C 5DD0              mov A,REG[0xd0]
 102E 08                push A
 102F                   .dbline 1332
 102F           ; }
 102F           ; 
 102F           ; // This is the ISR for a hello response timeout.
 102F           ; void HELLO_TIMEOUT_ISR(void)
 102F           ; {
 102F                   .dbline 1333
 102F           ;       TIMEOUT = 1;    // Set the timeout flag.
 102F 62D000            mov REG[0xd0],>_TIMEOUT
 1032 550101            mov [_TIMEOUT+1],1
 1035 550000            mov [_TIMEOUT],0
 1038                   .dbline 1334
 1038           ;       M8C_ClearIntFlag(INT_CLR0,HELLO_TIMEOUT_INT_MASK);
 1038 62DAFD            mov REG[0xda],-3
 103B                   .dbline -2
 103B           L357:
 103B 18                pop A
 103C 60D0              mov REG[208],A
 103E 18                pop A
 103F                   .dbline 0 ; func end
 103F 7E                reti
 1040                   .dbend
 1040                   .dbfunc e CHILD_1_TIMEOUT_ISR _CHILD_1_TIMEOUT_ISR fV
 1040           _CHILD_1_TIMEOUT_ISR::
 1040                   .dbline -1
 1040 71C0              or F,-64
 1042 08                push A
 1043 5DD0              mov A,REG[0xd0]
 1045 08                push A
 1046                   .dbline 1339
 1046           ; }
 1046           ; 
 1046           ; // These remaining ISRs are for all the child timeout scenarios.
 1046           ; void CHILD_1_TIMEOUT_ISR(void)
 1046           ; {
 1046                   .dbline 1340
 1046           ;       TIMEOUT = 1;    // Set the timeout flag.
 1046 62D000            mov REG[0xd0],>_TIMEOUT
 1049 550101            mov [_TIMEOUT+1],1
 104C 550000            mov [_TIMEOUT],0
 104F                   .dbline 1341
 104F           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_1_TIMEOUT_INT_MASK);
 104F 62DAFD            mov REG[0xda],-3
 1052                   .dbline -2
 1052           L358:
 1052 18                pop A
 1053 60D0              mov REG[208],A
 1055 18                pop A
 1056                   .dbline 0 ; func end
 1056 7E                reti
 1057                   .dbend
 1057                   .dbfunc e CHILD_2_TIMEOUT_ISR _CHILD_2_TIMEOUT_ISR fV
 1057           _CHILD_2_TIMEOUT_ISR::
 1057                   .dbline -1
 1057 71C0              or F,-64
 1059 08                push A
 105A 5DD0              mov A,REG[0xd0]
 105C 08                push A
 105D                   .dbline 1345
 105D           ; }
 105D           ; 
 105D           ; void CHILD_2_TIMEOUT_ISR(void)
 105D           ; {
 105D                   .dbline 1346
 105D           ;       TIMEOUT = 1;    // Set the timeout flag.
 105D 62D000            mov REG[0xd0],>_TIMEOUT
 1060 550101            mov [_TIMEOUT+1],1
 1063 550000            mov [_TIMEOUT],0
 1066                   .dbline 1347
 1066           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_2_TIMEOUT_INT_MASK);
 1066 62DAFD            mov REG[0xda],-3
 1069                   .dbline -2
 1069           L359:
 1069 18                pop A
 106A 60D0              mov REG[208],A
 106C 18                pop A
 106D                   .dbline 0 ; func end
 106D 7E                reti
 106E                   .dbend
 106E                   .dbfunc e CHILD_3_TIMEOUT_ISR _CHILD_3_TIMEOUT_ISR fV
 106E           _CHILD_3_TIMEOUT_ISR::
 106E                   .dbline -1
 106E 71C0              or F,-64
 1070 08                push A
 1071 5DD0              mov A,REG[0xd0]
 1073 08                push A
 1074                   .dbline 1351
 1074           ; }
 1074           ; 
 1074           ; void CHILD_3_TIMEOUT_ISR(void)
 1074           ; {
 1074                   .dbline 1352
 1074           ;       TIMEOUT = 1;    // Set the timeout flag.
 1074 62D000            mov REG[0xd0],>_TIMEOUT
 1077 550101            mov [_TIMEOUT+1],1
 107A 550000            mov [_TIMEOUT],0
 107D                   .dbline 1353
 107D           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_3_TIMEOUT_INT_MASK);
 107D 62DAFD            mov REG[0xda],-3
 1080                   .dbline -2
 1080           L360:
 1080 18                pop A
 1081 60D0              mov REG[208],A
 1083 18                pop A
 1084                   .dbline 0 ; func end
 1084 7E                reti
 1085                   .dbend
 1085                   .dbfunc e CHILD_4_TIMEOUT_ISR _CHILD_4_TIMEOUT_ISR fV
 1085           _CHILD_4_TIMEOUT_ISR::
 1085                   .dbline -1
 1085 71C0              or F,-64
 1087 08                push A
 1088 5DD0              mov A,REG[0xd0]
 108A 08                push A
 108B                   .dbline 1357
 108B           ; }
 108B           ; 
 108B           ; void CHILD_4_TIMEOUT_ISR(void)
 108B           ; {
 108B                   .dbline 1358
 108B           ;       TIMEOUT = 1;    // Set the timeout flag.
 108B 62D000            mov REG[0xd0],>_TIMEOUT
 108E 550101            mov [_TIMEOUT+1],1
 1091 550000            mov [_TIMEOUT],0
 1094                   .dbline 1359
 1094           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_4_TIMEOUT_INT_MASK);
 1094 62DAFD            mov REG[0xda],-3
 1097                   .dbline -2
 1097           L361:
 1097 18                pop A
 1098 60D0              mov REG[208],A
 109A 18                pop A
 109B                   .dbline 0 ; func end
 109B 7E                reti
 109C                   .dbend
 109C                   .dbfunc e INIT_TIMEOUT_ISR _INIT_TIMEOUT_ISR fV
 109C           _INIT_TIMEOUT_ISR::
 109C                   .dbline -1
 109C 71C0              or F,-64
 109E 08                push A
 109F 5DD0              mov A,REG[0xd0]
 10A1 08                push A
 10A2                   .dbline 1363
 10A2           ; }
 10A2           ; 
 10A2           ; void INIT_TIMEOUT_ISR(void)
 10A2           ; {
 10A2                   .dbline 1364
 10A2           ;       TIMEOUT = 1;    // Set the timeout flag.
 10A2 62D000            mov REG[0xd0],>_TIMEOUT
 10A5 550101            mov [_TIMEOUT+1],1
 10A8 550000            mov [_TIMEOUT],0
 10AB                   .dbline 1365
 10AB           ;       M8C_ClearIntFlag(INT_CLR0,INIT_TIMEOUT_INT_MASK);
 10AB 62DAFD            mov REG[0xda],-3
 10AE                   .dbline -2
 10AE           L362:
 10AE 18                pop A
 10AF 60D0              mov REG[208],A
 10B1 18                pop A
 10B2                   .dbline 0 ; func end
 10B2 7E                reti
 10B3                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _SERVO_ID::
 0000 00                .byte 0
 0001                   .dbsym e SERVO_ID _SERVO_ID c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_ERROR::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_ERROR _COMMAND_ERROR c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_LENGTH::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_LENGTH _COMMAND_LENGTH c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_PARAM::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_PARAM _COMMAND_PARAM c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _CONFIGURED::
 0000 0000              .byte 0,0
 0002                   .dbsym e CONFIGURED _CONFIGURED I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _ID::
 0000 00                .byte 0
 0001                   .dbsym e ID _ID c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _CHILD::
 0000 00                .byte 0
 0001                   .dbsym e CHILD _CHILD c
