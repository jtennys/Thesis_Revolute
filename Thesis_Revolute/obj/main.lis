 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 159
 0000           ; // Author: Jason Tennyson
 0000           ; // Date: 7-10-11
 0000           ; // File: main.c
 0000           ; //
 0000           ; // This is the design for the revolute modules of Jason Tennyson's Thesis.
 0000           ; // This design is made for a PSoC CY8C28433-24PVXI.
 0000           ; //
 0000           ; // Controller Packet Structure (each field is a byte)
 0000           ; // -----------------------------------------------------
 0000           ; // All Packets:
 0000           ; // START BYTE/START BYTE/SOURCE ID/DESTINATION ID/COMMAND TYPE/PARAM 1/.../PARAM N/END TRANSMIT
 0000           ; //
 0000           ; // Servo Packet Structure (each field is a byte)
 0000           ; // -----------------------------------------------------
 0000           ; // Source Packets:
 0000           ; // START BYTE/START BYTE/DESTINATION ID/LENGTH/COMMAND TYPE/PARAM 1/.../PARAM N/CHECKSUM
 0000           ; //
 0000           ; // Return Packets:
 0000           ; // START BYTE/START BYTE/SOURCE ID/LENGTH/ERROR/PARAM1/.../PARAM N/CHECKSUM
 0000           ; 
 0000           ; #include <m8c.h>              // Part-specific constants and macros.
 0000           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules.
 0000           ; #include "psocdynamic.h"      // Required for dynamically swapping configurations at run time.
 0000           ; 
 0000           ; // These are declarations of all of the timer interrupts that are used for all configurations.
 0000           ; #pragma interrupt_handler TX_01234_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_1_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_2_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_3_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_4_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler HELLO_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler INIT_TIMEOUT_ISR
 0000           ; 
 0000           ; // These defines are used as parameters of the configToggle function. Passing one of
 0000           ; // these identifiers to configToggle will put the chip in that device configuration.
 0000           ; #define               WAIT                                            (1)
 0000           ; #define               MY_RESPONSE                                     (2)
 0000           ; #define       RESPONSE_1                                      (3)
 0000           ; #define       RESPONSE_2                                      (4)
 0000           ; #define       RESPONSE_3                                      (5)
 0000           ; #define       RESPONSE_4                                      (6)
 0000           ; #define               HELLO_MODE                                      (7)
 0000           ; #define               INITIALIZE                                      (8)
 0000           ; #define               SERVO_COMM                                      (9)
 0000           ; 
 0000           ; // These defines are used as comparisons to find what port the next module connected to.
 0000           ; #define               PORT_1                                          ('1')
 0000           ; #define               PORT_2                                          ('2')
 0000           ; #define               PORT_3                                          ('3')
 0000           ; #define               PORT_4                                          ('4')
 0000           ; 
 0000           ; // Module Type
 0000           ; #define               TYPE                                            ('1')
 0000           ; 
 0000           ; // These defines are used as transmission indicators for transmissions between PSoC controllers.
 0000           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0000           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0000           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0000           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0000           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is complete.
 0000           ; #define               PING                                            (203)   // Indicates a ping message to or from the master.
 0000           ; #define               CLEAR                                           (204)   // Indicates the arm values are to be cleared.
 0000           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0000           ; #define               DEFAULT_ID                                      (251)   // The ID that all modules start with.
 0000           ; #define               BROADCAST                                       (254)   // The broadcast ID for all controllers and servos.
 0000           ; 
 0000           ; // SERVO DEFINES
 0000           ; // These numbers can all be found in the AX-12+ datasheet.
 0000           ; // These defines cover the range of IDs these servos are capable of.
 0000           ; #define               SERVO_ID_MIN                            (0)             // This is the lowest servo ID possible.
 0000           ; #define               SERVO_ID_MAX                            (253)   // This is the highest servo ID possible.
 0000           ; // These defines are servo transmission indicators.
 0000           ; #define               SERVO_START                                     (255)   // This is the start byte for a servo transmission.
 0000           ; // These defines are used to fill in the length parameter for a given command type. These are the only
 0000           ; // lengths used by this controller for servo configuration purposes. It is worth noting that any type
 0000           ; // and length of command can be issued from the master after configuration is complete.
 0000           ; #define               READ_LENGTH                                     (4)             // This is the length value for all reads.
 0000           ; #define               WRITE_LENGTH                            (4)             // This is the length value for all writes.
 0000           ; #define               PING_LENGTH                                     (2)             // This is the length value for a ping.
 0000           ; #define               RESET_LENGTH                            (2)             // This is the length value for a reset.
 0000           ; // These defines are used to fill in the servo's EEPROM address parameter for a given command type.
 0000           ; #define               ID_ADDRESS                                      (3)             // This is the address where servo ID is stored.
 0000           ; #define               STATUS_RET_ADDRESS                      (16)    // This is where the status return level is stored.
 0000           ; // These defines are used to fill in the instruction we are using on the servo.
 0000           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0000           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0000           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0000           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0000           ; // These defines cover all of the status return level possibilities.
 0000           ; #define               STATUS_RET_NEVER                        (0)             // Only respond to ping commands.
 0000           ; #define               STATUS_RET_READ                         (1)             // Only respond to read data commands (recommended).
 0000           ; #define               STATUS_RET_ALL                          (2)             // Respond to every command.
 0000           ; 
 0000           ; // This is the status return level, which is set to one of the possible status return values above.
 0000           ; // We want the status return level to be return on read commands only so that we don't have garbage
 0000           ; // return packets flying around every time we tell the servo to move.
 0000           ; #define               STATUS_RET_LEVEL                        (STATUS_RET_READ)
 0000           ; 
 0000           ; // This is the number of attempts we make to contact the servo per sweep of attempts before
 0000           ; // writing to its EEPROM in an attempt to alter settings that keep us from communicating.
 0000           ; #define               SERVO_COMM_ATTEMPTS                     (3)
 0000           ; // This is the number of times we do a loop of SERVO_COMM_ATTEMPTS. We would like this to be at least 2.
 0000           ; // This is because we do an EEPROM write after the first unsuccessful loop of SERVO_COMM_ATTEMPTS.
 0000           ; // If we don't then do at least one more loop, the EEPROM write was done for no reason.
 0000           ; #define               SERVO_COMM_LOOPS                        (2)
 0000           ; // This is the number of timeout periods to wait through while the servo boots up (2 ms per period).
 0000           ; #define               SERVO_BOOT_TIMEOUTS                     (100)
 0000           ; 
 0000           ; // This function receives a mode identifier as a parameter and toggles the system configuration.
 0000           ; void configToggle(int mode);
 0000           ; // This function unloads all configurations. This should only be needed at startup.
 0000           ; void unloadAllConfigs(void);
 0000           ; // This function unloads the configuration corresponding to the number passed to it.
 0000           ; void unloadConfig(int config_num);
 0000           ; // This function is a response to the master sending out a hello message.
 0000           ; void sayHello(void);
 0000           ; // This function looks for commands and returns 1 if a command has been read, 0 if not.
 0000           ; int commandReady(void);
 0000           ; // This function interprets the command that has just been read and performs an action accordingly.
 0000           ; void takeAction(void);
 0000           ; // This function responds to a ping.
 0000           ; void pingResponse(void);
 0000           ; // This function tells the master node that an ID assignment was completed on this module.
 0000           ; void assignedID(void);
 0000           ; // This function listens for children and registers the port that they talk to.
 0000           ; int childListen(void);
 0000           ; // This function waits for a known child's response to a command to that child from the master.
 0000           ; int childResponse(void);
 0000           ; // This function does everything it can to find the servo attached to this controller.
 0000           ; void servoFinder(void);
 0000           ; // This function carries out the passed servo instruction.
 0000           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0000           ; // This function does a simple for loop to stall and make doubly sure that the transmission finished.
 0000           ; // It is meant to be used as a definite amount of wait time after the transmission complete flag is set.
 0000           ; void xmitWait(void);
 0000           ; // This function is called to do nothing while we wait for the servo to boot up.
 0000           ; void servoBootWait(void);
 0000           ; // This function is used to wait for other controllers to find their servos while not
 0000           ; // driving any pins (which would keep a child from talking to its servo).
 0000           ; void servoConfigWait(void);
 0000           ; 
 0000           ; char CHILD;           // Keeps track of where the child is connected.
 0000           ; char ID;              // Stores the ID that the master gives this module.
 0000           ; 
 0000           ; int CONFIGURED;       // Keeps track of whether or not this module has been configured by the master.
 0000           ; int TIMEOUT;  // This flag is set if a timeout occurs.
 0000           ; int STATE;            // This stores the ID of the currently-loaded configuration.
 0000           ; 
 0000           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0000           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0000           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0000           ; char COMMAND_PARAM;                   // Stores a parameter that accompanies the command (if any).
 0000           ; char COMMAND_LENGTH;          // Stores the length parameter of a servo command.
 0000           ; char COMMAND_ERROR;                   // Stores the error code of a servo command.
 0000           ; 
 0000           ; char SERVO_ID;                                // Stores the ID of the servo inside of this module.
 0000           ; 
 0000           ; void main(void)
 0000           ; {     
 0000                   .dbline 161
 0000           ;       // Initial value assignment for variables of importance.
 0000           ;       CHILD = 0;                              // There is no child yet.
 0000 62D000            mov REG[0xd0],>_CHILD
 0003 550000            mov [_CHILD],0
 0006                   .dbline 162
 0006           ;       CONFIGURED = 0;                 // This module is not configured yet.
 0006 62D000            mov REG[0xd0],>_CONFIGURED
 0009 550100            mov [_CONFIGURED+1],0
 000C 550000            mov [_CONFIGURED],0
 000F                   .dbline 163
 000F           ;       TIMEOUT = 0;                    // Set the timeout flag low to start.
 000F 62D000            mov REG[0xd0],>_TIMEOUT
 0012 550100            mov [_TIMEOUT+1],0
 0015 550000            mov [_TIMEOUT],0
 0018                   .dbline 164
 0018           ;       COMMAND_PARAM = 0;              // There is no parameter yet.
 0018 62D000            mov REG[0xd0],>_COMMAND_PARAM
 001B 550000            mov [_COMMAND_PARAM],0
 001E                   .dbline 165
 001E           ;       STATE = 0;                              // There is no state yet.
 001E 62D000            mov REG[0xd0],>_STATE
 0021 550100            mov [_STATE+1],0
 0024 550000            mov [_STATE],0
 0027                   .dbline 166
 0027           ;       ID = DEFAULT_ID;                // Set the ID of this controller to the default to start with.
 0027 62D000            mov REG[0xd0],>_ID
 002A 5500FB            mov [_ID],-5
 002D                   .dbline 168
 002D           ; 
 002D           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); // Activate GPIO ISR
 002D 43E020            or REG[0xe0],32
 0030                   .dbline 170
 0030           ;       
 0030           ;       M8C_EnableGInt;                 // Turn on global interrupts for the transmission timeout timer.
 0030 7101                      or  F, 01h
 0032           
 0032                   .dbline 173
 0032           ;       
 0032           ;       // We have to wait for the servo to power up and get ready for communications.
 0032           ;       servoBootWait();
 0032 7C0F93            xcall _servoBootWait
 0035                   .dbline 176
 0035           ;       
 0035           ;       // Find the servo that is inside of this module.
 0035           ;       servoFinder();
 0035 7C0CDC            xcall _servoFinder
 0038 8013              xjmp L3
 003A           L2:
 003A                   .dbline 180
 003A           ;       
 003A           ;       // Loop and wait for commands.
 003A           ;       while(1)
 003A           ;       {       
 003A                   .dbline 181
 003A           ;               if(commandReady())
 003A 9283              xcall _commandReady
 003C 62D000            mov REG[0xd0],>__r0
 003F 3C0000            cmp [__r0],0
 0042 B006              jnz X1
 0044 3C0000            cmp [__r1],0
 0047 A004              jz L5
 0049           X1:
 0049                   .dbline 182
 0049           ;               {
 0049                   .dbline 184
 0049           ;                       // If the command is ready, take action.
 0049           ;                       takeAction();
 0049 7C086E            xcall _takeAction
 004C                   .dbline 185
 004C           ;               }
 004C           L5:
 004C                   .dbline 186
 004C           ;       }
 004C           L3:
 004C                   .dbline 179
 004C 8FED              xjmp L2
 004E           X0:
 004E                   .dbline -2
 004E           L1:
 004E                   .dbline 0 ; func end
 004E 8FFF              jmp .
 0050                   .dbend
 0050                   .dbfunc e sayHello _sayHello fV
 0050           _sayHello::
 0050                   .dbline -1
 0050                   .dbline 191
 0050           ; }
 0050           ; 
 0050           ; // This function transmits a response to a hello command from the master.
 0050           ; void sayHello(void)
 0050           ; {     
 0050                   .dbline 192
 0050           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 0050 5000              mov A,0
 0052 08                push A
 0053 5002              mov A,2
 0055 08                push A
 0056 905D              xcall _configToggle
 0058 38FE              add SP,-2
 005A                   .dbline 195
 005A           ;       
 005A           ;       // Transmit a hello response to the master node.
 005A           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 005A 10                push X
 005B 50FC              mov A,-4
 005D 7C0000            xcall _TX_014_PutChar
 0060 20                pop X
 0061                   .dbline 196
 0061           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 0061 10                push X
 0062 50FC              mov A,-4
 0064 7C0000            xcall _TX_014_PutChar
 0067 20                pop X
 0068                   .dbline 197
 0068           ;       TX_014_PutChar(ID);                             // My ID (source)
 0068 10                push X
 0069 62D000            mov REG[0xd0],>_ID
 006C 5100              mov A,[_ID]
 006E 7C0000            xcall _TX_014_PutChar
 0071 20                pop X
 0072                   .dbline 198
 0072           ;       TX_014_PutChar(MASTER_ID);              // Master ID (destination)
 0072 10                push X
 0073 5000              mov A,0
 0075 7C0000            xcall _TX_014_PutChar
 0078 20                pop X
 0079                   .dbline 199
 0079           ;       TX_014_PutChar(HELLO_BYTE);             // This is a hello command.
 0079 10                push X
 007A 50C8              mov A,-56
 007C 7C0000            xcall _TX_014_PutChar
 007F 20                pop X
 0080                   .dbline 200
 0080           ;       TX_014_PutChar(CHILD);                  // Sends child port value, default 0.
 0080 10                push X
 0081 62D000            mov REG[0xd0],>_CHILD
 0084 5100              mov A,[_CHILD]
 0086 7C0000            xcall _TX_014_PutChar
 0089 20                pop X
 008A                   .dbline 201
 008A           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission.
 008A 10                push X
 008B 50FD              mov A,-3
 008D 7C0000            xcall _TX_014_PutChar
 0090 20                pop X
 0091                   .dbline 202
 0091           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission.
 0091 10                push X
 0092 50FD              mov A,-3
 0094 7C0000            xcall _TX_014_PutChar
 0097 20                pop X
 0098           L8:
 0098                   .dbline 205
 0098           ;       
 0098           ;       // Wait for the transmission to finish.
 0098           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0098           L9:
 0098                   .dbline 205
 0098 10                push X
 0099 7C0000            xcall _TX_014_bReadTxStatus
 009C 62D000            mov REG[0xd0],>__r0
 009F 20                pop X
 00A0 5300              mov [__r0],A
 00A2 470020            tst [__r0],32
 00A5 AFF2              jz L8
 00A7                   .dbline 208
 00A7           ;       
 00A7           ;       // Make completely sure we're done.
 00A7           ;       xmitWait();
 00A7 7C0F74            xcall _xmitWait
 00AA                   .dbline 210
 00AA           ; 
 00AA           ;       configToggle(WAIT);                             // Switch back to wait mode.
 00AA 5000              mov A,0
 00AC 08                push A
 00AD 5001              mov A,1
 00AF 08                push A
 00B0 9003              xcall _configToggle
 00B2 38FE              add SP,-2
 00B4                   .dbline -2
 00B4           L7:
 00B4                   .dbline 0 ; func end
 00B4 7F                ret
 00B5                   .dbend
 00B5                   .dbfunc e configToggle _configToggle fV
 00B5           ;           mode -> X-5
 00B5           _configToggle::
 00B5                   .dbline -1
 00B5 10                push X
 00B6 4F                mov X,SP
 00B7                   .dbline 216
 00B7           ; }
 00B7           ; 
 00B7           ; // This function receives a mode flag and switches the microcontroller to the
 00B7           ; // desired hardware configuration.
 00B7           ; void configToggle(int mode)
 00B7           ; {     
 00B7                   .dbline 219
 00B7           ;       // Set the pins high and disconnect from the global bus.
 00B7           ;       // This helps keep false start bits from happening while we swap configs.
 00B7           ;       PRT0DR |= 0b00011111;   // Set pins P00 through P04 high.
 00B7 43001F            or REG[0],31
 00BA                   .dbline 220
 00BA           ;       PRT0GS &= 0b11100000;   // Disconnect pins P00 through P04 from the global bus.
 00BA 4102E0            and REG[0x2],-32
 00BD                   .dbline 224
 00BD           ;       
 00BD           ;       // Unload the configuration of the current state.
 00BD           ;       // If there is no state, blindly wipe all configurations.
 00BD           ;       if(STATE)
 00BD 62D000            mov REG[0xd0],>_STATE
 00C0 3C0000            cmp [_STATE],0
 00C3 B006              jnz X2
 00C5 3C0100            cmp [_STATE+1],0
 00C8 A011              jz L12
 00CA           X2:
 00CA                   .dbline 225
 00CA           ;       {
 00CA                   .dbline 226
 00CA           ;               unloadConfig(STATE);
 00CA 62D000            mov REG[0xd0],>_STATE
 00CD 5100              mov A,[_STATE]
 00CF 08                push A
 00D0 5101              mov A,[_STATE+1]
 00D2 08                push A
 00D3 7C0A74            xcall _unloadConfig
 00D6 38FE              add SP,-2
 00D8                   .dbline 227
 00D8           ;       }
 00D8 8004              xjmp L13
 00DA           L12:
 00DA                   .dbline 229
 00DA           ;       else
 00DA           ;       {
 00DA                   .dbline 230
 00DA           ;               unloadAllConfigs();
 00DA 7C0A58            xcall _unloadAllConfigs
 00DD                   .dbline 231
 00DD           ;       }
 00DD           L13:
 00DD                   .dbline 235
 00DD           ;       
 00DD           ;       // Go through the list of possible modes until we find the one that was passed in to us.
 00DD           ;       // Then, load that configuration and initialize whatever needs to be initialized.
 00DD           ;       if(mode == WAIT)
 00DD 3DFB00            cmp [X-5],0
 00E0 B022              jnz L14
 00E2 3DFC01            cmp [X-4],1
 00E5 B01D              jnz L14
 00E7           X3:
 00E7                   .dbline 236
 00E7           ;       {
 00E7                   .dbline 239
 00E7           ;               // Load the wait receiver configuration. This is the receiver configuration used after
 00E7           ;               // initialization is complete. It listens and forwards everything it hears.
 00E7           ;               LoadConfig_waiting();
 00E7 7C0000            xcall _LoadConfig_waiting
 00EA                   .dbline 242
 00EA           ;               
 00EA           ;               // Start the receivers.
 00EA           ;               WAIT_RECV_Start(WAIT_RECV_PARITY_NONE);
 00EA 10                push X
 00EB 5000              mov A,0
 00ED 7C0000            xcall _WAIT_RECV_Start
 00F0 20                pop X
 00F1                   .dbline 243
 00F1           ;               RX8_2_Start(RX8_2_PARITY_NONE);
 00F1 10                push X
 00F2 5000              mov A,0
 00F4 7C0000            xcall _RX8_2_Start
 00F7 20                pop X
 00F8                   .dbline 246
 00F8           ;               
 00F8           ;               // Set the current state.
 00F8           ;               STATE = WAIT;
 00F8 62D000            mov REG[0xd0],>_STATE
 00FB 550101            mov [_STATE+1],1
 00FE 550000            mov [_STATE],0
 0101                   .dbline 247
 0101           ;       }
 0101 81A0              xjmp L15
 0103           L14:
 0103                   .dbline 248
 0103           ;       else if(mode == MY_RESPONSE)
 0103 3DFB00            cmp [X-5],0
 0106 B04C              jnz L16
 0108 3DFC02            cmp [X-4],2
 010B B047              jnz L16
 010D           X4:
 010D                   .dbline 249
 010D           ;       {
 010D                   .dbline 251
 010D           ;               // Load the transmitter configuration. This is for transmitting messages on all ports.
 010D           ;               LoadConfig_my_response();
 010D 7C0000            xcall _LoadConfig_my_response
 0110                   .dbline 254
 0110           ;               
 0110           ;               // Clear the timeout flag.
 0110           ;               TIMEOUT = 0;
 0110 62D000            mov REG[0xd0],>_TIMEOUT
 0113 550100            mov [_TIMEOUT+1],0
 0116 550000            mov [_TIMEOUT],0
 0119                   .dbline 257
 0119           ;               
 0119           ;               // Start the transmitters.
 0119           ;               TX_014_Start(TX_014_PARITY_NONE);       // Transmits on P00, P01, and P04.
 0119 10                push X
 011A 5000              mov A,0
 011C 7C0000            xcall _TX_014_Start
 011F 20                pop X
 0120                   .dbline 258
 0120           ;               TX_23_Start(TX_23_PARITY_NONE);         // Transmits on P02 and P03.
 0120 10                push X
 0121 5000              mov A,0
 0123 7C0000            xcall _TX_23_Start
 0126                   .dbline 260
 0126           ;               
 0126           ;               TX_01234_TIMEOUT_EnableInt();           // Make sure interrupts are enabled.
 0126 7C0000            xcall _TX_01234_TIMEOUT_EnableInt
 0129                   .dbline 261
 0129           ;               TX_01234_TIMEOUT_Start();                       // Start the timer.
 0129 7C0000            xcall _TX_01234_TIMEOUT_Start
 012C 20                pop X
 012D           L18:
 012D                   .dbline 265
 012D           ;               
 012D           ;               // Do nothing while we wait for one timeout period (1 ms).
 012D           ;               // This is to allow everyone to get in the right configuration before talking.
 012D           ;               while(!TIMEOUT) { }
 012D                   .dbline 265
 012D           L19:
 012D                   .dbline 265
 012D 62D000            mov REG[0xd0],>_TIMEOUT
 0130 3C0000            cmp [_TIMEOUT],0
 0133 B006              jnz X5
 0135 3C0100            cmp [_TIMEOUT+1],0
 0138 AFF4              jz L18
 013A           X5:
 013A                   .dbline 267
 013A           ;               
 013A           ;               TX_01234_TIMEOUT_Stop();                        // Stop the timer.
 013A 10                push X
 013B 7C0000            xcall _TX_01234_TIMEOUT_Stop
 013E 20                pop X
 013F                   .dbline 268
 013F           ;               TIMEOUT = 0;                                            // Reset the timeout flag.
 013F 62D000            mov REG[0xd0],>_TIMEOUT
 0142 550100            mov [_TIMEOUT+1],0
 0145 550000            mov [_TIMEOUT],0
 0148                   .dbline 271
 0148           ;       
 0148           ;               // Set the current state.
 0148           ;               STATE = MY_RESPONSE;
 0148 62D000            mov REG[0xd0],>_STATE
 014B 550102            mov [_STATE+1],2
 014E 550000            mov [_STATE],0
 0151                   .dbline 272
 0151           ;       }
 0151 8150              xjmp L17
 0153           L16:
 0153                   .dbline 273
 0153           ;       else if(mode == RESPONSE_1)
 0153 3DFB00            cmp [X-5],0
 0156 B02A              jnz L21
 0158 3DFC03            cmp [X-4],3
 015B B025              jnz L21
 015D           X6:
 015D                   .dbline 274
 015D           ;       {
 015D                   .dbline 276
 015D           ;               // Load the response wait on port 1.
 015D           ;               LoadConfig_response1();
 015D 7C0000            xcall _LoadConfig_response1
 0160                   .dbline 279
 0160           ;               
 0160           ;               // Clear the timeout flag.
 0160           ;               TIMEOUT = 0;
 0160 62D000            mov REG[0xd0],>_TIMEOUT
 0163 550100            mov [_TIMEOUT+1],0
 0166 550000            mov [_TIMEOUT],0
 0169                   .dbline 282
 0169           ;               
 0169           ;               // Start listening for a response through child port 1.
 0169           ;               CHILD_1_Start(CHILD_1_PARITY_NONE);
 0169 10                push X
 016A 5000              mov A,0
 016C 7C0000            xcall _CHILD_1_Start
 016F                   .dbline 284
 016F           ;               
 016F           ;               CHILD_1_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 016F 7C0000            xcall _CHILD_1_TIMEOUT_EnableInt
 0172                   .dbline 285
 0172           ;               CHILD_1_TIMEOUT_Start();                        // Start the timer.
 0172 7C0000            xcall _CHILD_1_TIMEOUT_Start
 0175 20                pop X
 0176                   .dbline 288
 0176           ;               
 0176           ;               // Set the current state.
 0176           ;               STATE = RESPONSE_1;
 0176 62D000            mov REG[0xd0],>_STATE
 0179 550103            mov [_STATE+1],3
 017C 550000            mov [_STATE],0
 017F                   .dbline 289
 017F           ;       }
 017F 8122              xjmp L22
 0181           L21:
 0181                   .dbline 290
 0181           ;       else if(mode == RESPONSE_2)
 0181 3DFB00            cmp [X-5],0
 0184 B02A              jnz L23
 0186 3DFC04            cmp [X-4],4
 0189 B025              jnz L23
 018B           X7:
 018B                   .dbline 291
 018B           ;       {
 018B                   .dbline 293
 018B           ;               // Load the response wait on port 2.
 018B           ;               LoadConfig_response2();
 018B 7C0000            xcall _LoadConfig_response2
 018E                   .dbline 296
 018E           ;               
 018E           ;               // Clear the timeout flag.
 018E           ;               TIMEOUT = 0;
 018E 62D000            mov REG[0xd0],>_TIMEOUT
 0191 550100            mov [_TIMEOUT+1],0
 0194 550000            mov [_TIMEOUT],0
 0197                   .dbline 299
 0197           ;               
 0197           ;               // Start listening for a response through child port 2.
 0197           ;               CHILD_2_Start(CHILD_2_PARITY_NONE);
 0197 10                push X
 0198 5000              mov A,0
 019A 7C0000            xcall _CHILD_2_Start
 019D                   .dbline 301
 019D           ;               
 019D           ;               CHILD_2_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 019D 7C0000            xcall _CHILD_2_TIMEOUT_EnableInt
 01A0                   .dbline 302
 01A0           ;               CHILD_2_TIMEOUT_Start();                        // Start the timer.
 01A0 7C0000            xcall _CHILD_2_TIMEOUT_Start
 01A3 20                pop X
 01A4                   .dbline 305
 01A4           ;               
 01A4           ;               // Set the current state.
 01A4           ;               STATE = RESPONSE_2;
 01A4 62D000            mov REG[0xd0],>_STATE
 01A7 550104            mov [_STATE+1],4
 01AA 550000            mov [_STATE],0
 01AD                   .dbline 306
 01AD           ;       }
 01AD 80F4              xjmp L24
 01AF           L23:
 01AF                   .dbline 307
 01AF           ;       else if(mode == RESPONSE_3)
 01AF 3DFB00            cmp [X-5],0
 01B2 B02A              jnz L25
 01B4 3DFC05            cmp [X-4],5
 01B7 B025              jnz L25
 01B9           X8:
 01B9                   .dbline 308
 01B9           ;       {
 01B9                   .dbline 310
 01B9           ;               // Load the response wait on port 3.
 01B9           ;               LoadConfig_response3();
 01B9 7C0000            xcall _LoadConfig_response3
 01BC                   .dbline 313
 01BC           ;               
 01BC           ;               // Clear the timeout flag.
 01BC           ;               TIMEOUT = 0;
 01BC 62D000            mov REG[0xd0],>_TIMEOUT
 01BF 550100            mov [_TIMEOUT+1],0
 01C2 550000            mov [_TIMEOUT],0
 01C5                   .dbline 316
 01C5           ;               
 01C5           ;               // Start listening for a response through child port 3.
 01C5           ;               CHILD_3_Start(CHILD_3_PARITY_NONE);
 01C5 10                push X
 01C6 5000              mov A,0
 01C8 7C0000            xcall _CHILD_3_Start
 01CB                   .dbline 318
 01CB           ;               
 01CB           ;               CHILD_3_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 01CB 7C0000            xcall _CHILD_3_TIMEOUT_EnableInt
 01CE                   .dbline 319
 01CE           ;               CHILD_3_TIMEOUT_Start();                        // Start the timer.
 01CE 7C0000            xcall _CHILD_3_TIMEOUT_Start
 01D1 20                pop X
 01D2                   .dbline 322
 01D2           ;               
 01D2           ;               // Set the current state.
 01D2           ;               STATE = RESPONSE_3;
 01D2 62D000            mov REG[0xd0],>_STATE
 01D5 550105            mov [_STATE+1],5
 01D8 550000            mov [_STATE],0
 01DB                   .dbline 323
 01DB           ;       }
 01DB 80C6              xjmp L26
 01DD           L25:
 01DD                   .dbline 324
 01DD           ;       else if(mode == RESPONSE_4)
 01DD 3DFB00            cmp [X-5],0
 01E0 B02A              jnz L27
 01E2 3DFC06            cmp [X-4],6
 01E5 B025              jnz L27
 01E7           X9:
 01E7                   .dbline 325
 01E7           ;       {
 01E7                   .dbline 327
 01E7           ;               // Load the response wait on port 4.
 01E7           ;               LoadConfig_response4();
 01E7 7C0000            xcall _LoadConfig_response4
 01EA                   .dbline 330
 01EA           ;               
 01EA           ;               // Clear the timeout flag.
 01EA           ;               TIMEOUT = 0;
 01EA 62D000            mov REG[0xd0],>_TIMEOUT
 01ED 550100            mov [_TIMEOUT+1],0
 01F0 550000            mov [_TIMEOUT],0
 01F3                   .dbline 333
 01F3           ;               
 01F3           ;               // Start listening for a response through child port 4.
 01F3           ;               CHILD_4_Start(CHILD_4_PARITY_NONE);
 01F3 10                push X
 01F4 5000              mov A,0
 01F6 7C0000            xcall _CHILD_4_Start
 01F9                   .dbline 335
 01F9           ;               
 01F9           ;               CHILD_4_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 01F9 7C0000            xcall _CHILD_4_TIMEOUT_EnableInt
 01FC                   .dbline 336
 01FC           ;               CHILD_4_TIMEOUT_Start();                        // Start the timer.
 01FC 7C0000            xcall _CHILD_4_TIMEOUT_Start
 01FF 20                pop X
 0200                   .dbline 339
 0200           ;               
 0200           ;               // Set the current state.
 0200           ;               STATE = RESPONSE_4;
 0200 62D000            mov REG[0xd0],>_STATE
 0203 550106            mov [_STATE+1],6
 0206 550000            mov [_STATE],0
 0209                   .dbline 340
 0209           ;       }
 0209 8098              xjmp L28
 020B           L27:
 020B                   .dbline 341
 020B           ;       else if(mode == HELLO_MODE)
 020B 3DFB00            cmp [X-5],0
 020E B03F              jnz L29
 0210 3DFC07            cmp [X-4],7
 0213 B03A              jnz L29
 0215           X10:
 0215                   .dbline 342
 0215           ;       {
 0215                   .dbline 344
 0215           ;               // Load the hello wait mode. This is for listening on all ports for a hello response.
 0215           ;               LoadConfig_hello();
 0215 7C0000            xcall _LoadConfig_hello
 0218                   .dbline 347
 0218           ;               
 0218           ;               // Clear the timeout flag.
 0218           ;               TIMEOUT = 0;
 0218 62D000            mov REG[0xd0],>_TIMEOUT
 021B 550100            mov [_TIMEOUT+1],0
 021E 550000            mov [_TIMEOUT],0
 0221                   .dbline 351
 0221           ;               
 0221           ;               // The seemingly unnecessary brackets around each line are unfortunately needed.
 0221           ;       
 0221           ;               {
 0221                   .dbline 353
 0221           ;               // Start listening for a response through child port 1.
 0221           ;               HELLO_1_Start(HELLO_1_PARITY_NONE);
 0221 10                push X
 0222 5000              mov A,0
 0224 7C0000            xcall _HELLO_1_Start
 0227 20                pop X
 0228                   .dbline 354
 0228           ;               }
 0228                   .dbline 356
 0228           ;               
 0228           ;               {
 0228                   .dbline 358
 0228           ;               // Start listening for a response through child port 2.
 0228           ;               HELLO_2_Start(HELLO_2_PARITY_NONE);
 0228 10                push X
 0229 5000              mov A,0
 022B 7C0000            xcall _HELLO_2_Start
 022E 20                pop X
 022F                   .dbline 359
 022F           ;               }
 022F                   .dbline 361
 022F           ;               
 022F           ;               {
 022F                   .dbline 363
 022F           ;               // Start listening for a response through child port 3.
 022F           ;               HELLO_3_Start(HELLO_3_PARITY_NONE);
 022F 10                push X
 0230 5000              mov A,0
 0232 7C0000            xcall _HELLO_3_Start
 0235 20                pop X
 0236                   .dbline 364
 0236           ;               }
 0236                   .dbline 366
 0236           ;               
 0236           ;               {
 0236                   .dbline 368
 0236           ;               // Start listening for a response through child port 4.
 0236           ;               HELLO_4_Start(HELLO_4_PARITY_NONE);
 0236 10                push X
 0237 5000              mov A,0
 0239 7C0000            xcall _HELLO_4_Start
 023C                   .dbline 369
 023C           ;               }
 023C                   .dbline 371
 023C           ;               
 023C           ;               HELLO_TIMEOUT_EnableInt();      // Make sure interrupts are enabled.
 023C 7C0000            xcall _HELLO_TIMEOUT_EnableInt
 023F                   .dbline 372
 023F           ;               HELLO_TIMEOUT_Start();          // Start the timer.
 023F 7C0000            xcall _HELLO_TIMEOUT_Start
 0242 20                pop X
 0243                   .dbline 375
 0243           ;               
 0243           ;               // Set the current state.
 0243           ;               STATE = HELLO_MODE;
 0243 62D000            mov REG[0xd0],>_STATE
 0246 550107            mov [_STATE+1],7
 0249 550000            mov [_STATE],0
 024C                   .dbline 376
 024C           ;       }
 024C 8055              xjmp L30
 024E           L29:
 024E                   .dbline 377
 024E           ;       else if(mode == INITIALIZE)
 024E 3DFB00            cmp [X-5],0
 0251 B02A              jnz L31
 0253 3DFC08            cmp [X-4],8
 0256 B025              jnz L31
 0258           X11:
 0258                   .dbline 378
 0258           ;       {
 0258                   .dbline 380
 0258           ;               // Load the configuration for initialization. This config listens but does not forward.
 0258           ;               LoadConfig_initial();
 0258 7C0000            xcall _LoadConfig_initial
 025B                   .dbline 383
 025B           ;               
 025B           ;               // Clear the timeout flag.
 025B           ;               TIMEOUT = 0;
 025B 62D000            mov REG[0xd0],>_TIMEOUT
 025E 550100            mov [_TIMEOUT+1],0
 0261 550000            mov [_TIMEOUT],0
 0264                   .dbline 386
 0264           ;               
 0264           ;               // Start the receiver.
 0264           ;               INIT_RX_Start(INIT_RX_PARITY_NONE);
 0264 10                push X
 0265 5000              mov A,0
 0267 7C0000            xcall _INIT_RX_Start
 026A                   .dbline 388
 026A           ;               
 026A           ;               INIT_TIMEOUT_EnableInt();       // Make sure interrupts are enabled.
 026A 7C0000            xcall _INIT_TIMEOUT_EnableInt
 026D                   .dbline 389
 026D           ;               INIT_TIMEOUT_Start();           // Start the timer.
 026D 7C0000            xcall _INIT_TIMEOUT_Start
 0270 20                pop X
 0271                   .dbline 392
 0271           ;               
 0271           ;               // Set the current state.
 0271           ;               STATE = INITIALIZE;
 0271 62D000            mov REG[0xd0],>_STATE
 0274 550108            mov [_STATE+1],8
 0277 550000            mov [_STATE],0
 027A                   .dbline 393
 027A           ;       }
 027A 8027              xjmp L32
 027C           L31:
 027C                   .dbline 394
 027C           ;       else if(mode == SERVO_COMM)
 027C 3DFB00            cmp [X-5],0
 027F B022              jnz L33
 0281 3DFC09            cmp [X-4],9
 0284 B01D              jnz L33
 0286           X12:
 0286                   .dbline 395
 0286           ;       {
 0286                   .dbline 397
 0286           ;               // Load the configuration for servo communication. This config only transmits on P00.
 0286           ;               LoadConfig_servo_transmit();
 0286 7C0000            xcall _LoadConfig_servo_transmit
 0289                   .dbline 400
 0289           ;               
 0289           ;               // Clear the timeout flag.
 0289           ;               TIMEOUT = 0;
 0289 62D000            mov REG[0xd0],>_TIMEOUT
 028C 550100            mov [_TIMEOUT+1],0
 028F 550000            mov [_TIMEOUT],0
 0292                   .dbline 403
 0292           ;               
 0292           ;               // Start the transmitter.
 0292           ;               SERVO_TX_Start(SERVO_TX_PARITY_NONE);
 0292 10                push X
 0293 5000              mov A,0
 0295 7C0000            xcall _SERVO_TX_Start
 0298 20                pop X
 0299                   .dbline 406
 0299           ;       
 0299           ;               // Set the current state.
 0299           ;               STATE = SERVO_COMM;
 0299 62D000            mov REG[0xd0],>_STATE
 029C 550109            mov [_STATE+1],9
 029F 550000            mov [_STATE],0
 02A2                   .dbline 407
 02A2           ;       }
 02A2           L33:
 02A2           L32:
 02A2           L30:
 02A2           L28:
 02A2           L26:
 02A2           L24:
 02A2           L22:
 02A2           L17:
 02A2           L15:
 02A2                   .dbline 410
 02A2           ;       
 02A2           ;       // If this module is configured, talk on all pins for potential children.
 02A2           ;       if(CONFIGURED)
 02A2 62D000            mov REG[0xd0],>_CONFIGURED
 02A5 3C0000            cmp [_CONFIGURED],0
 02A8 B006              jnz X13
 02AA 3C0100            cmp [_CONFIGURED+1],0
 02AD A009              jz L35
 02AF           X13:
 02AF                   .dbline 411
 02AF           ;       {
 02AF                   .dbline 412
 02AF           ;               PRT0GS |= 0b00011111;   // Connect all pins to the global bus.
 02AF 43021F            or REG[0x2],31
 02B2                   .dbline 413
 02B2           ;               PRT2DR &= 0b11111110;   // Turn on the LED (active low).
 02B2 4108FE            and REG[0x8],-2
 02B5                   .dbline 414
 02B5           ;       }
 02B5 8007              xjmp L36
 02B7           L35:
 02B7                   .dbline 416
 02B7           ;       else
 02B7           ;       {
 02B7                   .dbline 417
 02B7           ;               PRT0GS |= 0b00000001;   // Just connect pin 0;
 02B7 430201            or REG[0x2],1
 02BA                   .dbline 418
 02BA           ;               PRT2DR |= 0b00000001;   // Turn off the LED (active low).
 02BA 430801            or REG[0x8],1
 02BD                   .dbline 419
 02BD           ;       }
 02BD           L36:
 02BD                   .dbline -2
 02BD           L11:
 02BD 20                pop X
 02BE                   .dbline 0 ; func end
 02BE 7F                ret
 02BF                   .dbsym l mode -5 I
 02BF                   .dbend
 02BF                   .dbfunc e commandReady _commandReady fI
 02BF           ;   runningTotal -> X+3
 02BF           ;              i -> X+1
 02BF           ;       tempByte -> X+0
 02BF           _commandReady::
 02BF                   .dbline -1
 02BF 10                push X
 02C0 4F                mov X,SP
 02C1 3805              add SP,5
 02C3                   .dbline 426
 02C3           ; }
 02C3           ; 
 02C3           ; // This function checks the current hardware configuration state. Once it finds this state, it
 02C3           ; // uses the receivers that are in that configuration in the way they are intended to grab the
 02C3           ; // transmission information that we require (or just let commands pass through if we don't care).
 02C3           ; int commandReady(void)
 02C3           ; {
 02C3                   .dbline 427
 02C3           ;       int i = 0;                      // This integer is used for looping through the remaining bytes of commands.
 02C3 560200            mov [X+2],0
 02C6 560100            mov [X+1],0
 02C9                   .dbline 428
 02C9           ;       char tempByte = 0;      // This byte is used to store each byte for comparison as it comes in.
 02C9 560000            mov [X+0],0
 02CC                   .dbline 430
 02CC           ;       
 02CC           ;       int runningTotal = 0;   // This is used to check for a checksum in the case of a servo transmit.
 02CC 560400            mov [X+4],0
 02CF 560300            mov [X+3],0
 02D2                   .dbline 434
 02D2           ;       
 02D2           ;       // This conditional checks which configuration is loaded and uses the proper devices to
 02D2           ;       // read a transmission and store the important information from that transmission.
 02D2           ;       if(STATE == WAIT)
 02D2 62D000            mov REG[0xd0],>_STATE
 02D5 3C0000            cmp [_STATE],0
 02D8 B0D4              jnz L38
 02DA 3C0101            cmp [_STATE+1],1
 02DD B0CF              jnz L38
 02DF           X14:
 02DF                   .dbline 435
 02DF           ;       {       
 02DF                   .dbline 438
 02DF           ;               // In wait mode, the only thing that progresses things forward is a master node transmission.
 02DF           ;               // With this being the case, we use a blocking operation to sit and wait for a byte.
 02DF           ;               tempByte = WAIT_RECV_cGetChar();
 02DF 10                push X
 02E0 7C0000            xcall _WAIT_RECV_cGetChar
 02E3 62D000            mov REG[0xd0],>__r0
 02E6 20                pop X
 02E7 5400              mov [X+0],A
 02E9                   .dbline 441
 02E9           ;               
 02E9           ;               // If a transmission has started for either a controller or a servo...
 02E9           ;               if(tempByte == START_TRANSMIT)
 02E9 3D00FC            cmp [X+0],-4
 02EC B047              jnz L40
 02EE                   .dbline 442
 02EE           ;               {
 02EE 800B              xjmp L43
 02F0           L42:
 02F0                   .dbline 445
 02F0           ;                       // While we keep reading start bytes, sit and spin.
 02F0           ;                       while(tempByte == START_TRANSMIT)
 02F0           ;                       {
 02F0                   .dbline 446
 02F0           ;                               tempByte = WAIT_RECV_cGetChar();
 02F0 10                push X
 02F1 7C0000            xcall _WAIT_RECV_cGetChar
 02F4 62D000            mov REG[0xd0],>__r0
 02F7 20                pop X
 02F8 5400              mov [X+0],A
 02FA                   .dbline 447
 02FA           ;                       }
 02FA           L43:
 02FA                   .dbline 444
 02FA 3D00FC            cmp [X+0],-4
 02FD AFF2              jz L42
 02FF                   .dbline 450
 02FF           ;                       
 02FF           ;                       // The tempByte variable contains the source ID. If the source is good, store all bytes.
 02FF           ;                       if(tempByte == MASTER_ID)
 02FF 3D0000            cmp [X+0],0
 0302 B55E              jnz L39
 0304                   .dbline 451
 0304           ;                       {
 0304                   .dbline 452
 0304           ;                               COMMAND_SOURCE = tempByte;
 0304 5200              mov A,[X+0]
 0306 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0309 5300              mov [_COMMAND_SOURCE],A
 030B                   .dbline 453
 030B           ;                               COMMAND_DESTINATION = WAIT_RECV_cGetChar();
 030B 10                push X
 030C 7C0000            xcall _WAIT_RECV_cGetChar
 030F 20                pop X
 0310 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0313 5300              mov [_COMMAND_DESTINATION],A
 0315                   .dbline 454
 0315           ;                               COMMAND_TYPE = WAIT_RECV_cGetChar();
 0315 10                push X
 0316 7C0000            xcall _WAIT_RECV_cGetChar
 0319 20                pop X
 031A 62D000            mov REG[0xd0],>_COMMAND_TYPE
 031D 5300              mov [_COMMAND_TYPE],A
 031F                   .dbline 455
 031F           ;                               COMMAND_PARAM = WAIT_RECV_cGetChar();
 031F 10                push X
 0320 7C0000            xcall _WAIT_RECV_cGetChar
 0323 20                pop X
 0324 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0327 5300              mov [_COMMAND_PARAM],A
 0329                   .dbline 457
 0329           ;                               
 0329           ;                               return 1;
 0329 62D000            mov REG[0xd0],>__r0
 032C 550001            mov [__r1],1
 032F 550000            mov [__r0],0
 0332 8537              xjmp L37
 0334           L40:
 0334                   .dbline 460
 0334           ;                       }
 0334           ;               }
 0334           ;               else if(tempByte == SERVO_START)
 0334 3D00FF            cmp [X+0],-1
 0337 B529              jnz L39
 0339                   .dbline 461
 0339           ;               {
 0339 800B              xjmp L50
 033B           L49:
 033B                   .dbline 464
 033B           ;                       // While we keep reading start bytes, sit and spin.
 033B           ;                       while(tempByte == SERVO_START)
 033B           ;                       {
 033B                   .dbline 465
 033B           ;                               tempByte = WAIT_RECV_cGetChar();
 033B 10                push X
 033C 7C0000            xcall _WAIT_RECV_cGetChar
 033F 62D000            mov REG[0xd0],>__r0
 0342 20                pop X
 0343 5400              mov [X+0],A
 0345                   .dbline 466
 0345           ;                       }
 0345           L50:
 0345                   .dbline 463
 0345 3D00FF            cmp [X+0],-1
 0348 AFF2              jz L49
 034A                   .dbline 469
 034A           ;                       
 034A           ;                       // We assume (and hopefully rightly so) that this is a command from master.
 034A           ;                       COMMAND_SOURCE = MASTER_ID;
 034A 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 034D 550000            mov [_COMMAND_SOURCE],0
 0350                   .dbline 471
 0350           ;                       // The first parameter after the servo start is the destination.
 0350           ;                       COMMAND_DESTINATION = tempByte;
 0350 5200              mov A,[X+0]
 0352 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0355 5300              mov [_COMMAND_DESTINATION],A
 0357                   .dbline 476
 0357           ;                       // The second parameter after the servo start is the command length.
 0357           ;                       // We don't need it to wait for the transmission to go through since the
 0357           ;                       // transmission goes through the chip with a delay of approximately 100 ns
 0357           ;                       // (it is already in and out by the time you read this byte).
 0357           ;                       tempByte = WAIT_RECV_cGetChar();
 0357 10                push X
 0358 7C0000            xcall _WAIT_RECV_cGetChar
 035B 62D000            mov REG[0xd0],>__r0
 035E 20                pop X
 035F 5400              mov [X+0],A
 0361                   .dbline 479
 0361           ;                       // Now we store the command type. Depending on what the status return level
 0361           ;                       // is, we have special duties.
 0361           ;                       COMMAND_TYPE = WAIT_RECV_cGetChar();
 0361 10                push X
 0362 7C0000            xcall _WAIT_RECV_cGetChar
 0365 20                pop X
 0366 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0369 5300              mov [_COMMAND_TYPE],A
 036B                   .dbline 483
 036B           ;                       
 036B           ;                       // This basically clears the rest of the command from the buffer
 036B           ;                       // and serves the dual purpose of allowing everybody time to hear it.
 036B           ;                       for(i = 0; i < (tempByte - 1); i++)
 036B 560200            mov [X+2],0
 036E 560100            mov [X+1],0
 0371 800E              xjmp L55
 0373           L52:
 0373                   .dbline 484
 0373           ;                       {
 0373                   .dbline 485
 0373           ;                               WAIT_RECV_cGetChar();
 0373 10                push X
 0374 7C0000            xcall _WAIT_RECV_cGetChar
 0377 62D000            mov REG[0xd0],>__r0
 037A 20                pop X
 037B                   .dbline 486
 037B           ;                       }
 037B           L53:
 037B                   .dbline 483
 037B 7702              inc [X+2]
 037D 0F0100            adc [X+1],0
 0380           L55:
 0380                   .dbline 483
 0380 62D000            mov REG[0xd0],>__r0
 0383 5200              mov A,[X+0]
 0385 5300              mov [__r1],A
 0387 550000            mov [__r0],0
 038A 160001            sub [__r1],1
 038D 1E0000            sbb [__r0],0
 0390 5202              mov A,[X+2]
 0392 1200              sub A,[__r1]
 0394 5100              mov A,[__r0]
 0396 3180              xor A,-128
 0398 5300              mov [__rX],A
 039A 5201              mov A,[X+1]
 039C 3180              xor A,-128
 039E 1A00              sbb A,[__rX]
 03A0 CFD2              jc L52
 03A2           X15:
 03A2                   .dbline 488
 03A2           ;                               
 03A2           ;                       return 1;
 03A2 62D000            mov REG[0xd0],>__r0
 03A5 550001            mov [__r1],1
 03A8 550000            mov [__r0],0
 03AB 84BE              xjmp L37
 03AD           L38:
 03AD                   .dbline 491
 03AD           ;               }
 03AD           ;       }
 03AD           ;       else if(STATE == HELLO_MODE)
 03AD 62D000            mov REG[0xd0],>_STATE
 03B0 3C0000            cmp [_STATE],0
 03B3 B0E2              jnz L56
 03B5 3C0107            cmp [_STATE+1],7
 03B8 B0DD              jnz L56
 03BA           X16:
 03BA                   .dbline 492
 03BA           ;       {
 03BA                   .dbline 495
 03BA           ;               // Check all of the ports for a start byte. Only one port will produce one.
 03BA           ;               // Only non-blocking commands are used to avoid getting stuck listening downstream.
 03BA           ;               if(HELLO_1_cReadChar() == START_TRANSMIT)
 03BA 10                push X
 03BB 7C0000            xcall _HELLO_1_cReadChar
 03BE 62D000            mov REG[0xd0],>__r0
 03C1 20                pop X
 03C2 39FC              cmp A,-4
 03C4 B02C              jnz L58
 03C6                   .dbline 496
 03C6           ;               {
 03C6 801B              xjmp L61
 03C8           L60:
 03C8                   .dbline 498
 03C8           ;                       while(!TIMEOUT)
 03C8           ;                       {
 03C8                   .dbline 499
 03C8           ;                               if(HELLO_1_cReadChar() == END_TRANSMIT)
 03C8 10                push X
 03C9 7C0000            xcall _HELLO_1_cReadChar
 03CC 20                pop X
 03CD 39FD              cmp A,-3
 03CF B012              jnz L63
 03D1                   .dbline 500
 03D1           ;                               {
 03D1                   .dbline 501
 03D1           ;                                       CHILD = PORT_1;
 03D1 62D000            mov REG[0xd0],>_CHILD
 03D4 550031            mov [_CHILD],49
 03D7                   .dbline 503
 03D7           ;                               
 03D7           ;                                       return 1;
 03D7 62D000            mov REG[0xd0],>__r0
 03DA 550001            mov [__r1],1
 03DD 550000            mov [__r0],0
 03E0 8489              xjmp L37
 03E2           L63:
 03E2                   .dbline 505
 03E2           ;                               }
 03E2           ;                       }
 03E2           L61:
 03E2                   .dbline 497
 03E2 62D000            mov REG[0xd0],>_TIMEOUT
 03E5 3C0000            cmp [_TIMEOUT],0
 03E8 B006              jnz X17
 03EA 3C0100            cmp [_TIMEOUT+1],0
 03ED AFDA              jz L60
 03EF           X17:
 03EF                   .dbline 506
 03EF           ;               }
 03EF 8471              xjmp L57
 03F1           L58:
 03F1                   .dbline 507
 03F1           ;               else if(HELLO_2_cReadChar() == START_TRANSMIT)
 03F1 10                push X
 03F2 7C0000            xcall _HELLO_2_cReadChar
 03F5 62D000            mov REG[0xd0],>__r0
 03F8 20                pop X
 03F9 39FC              cmp A,-4
 03FB B02C              jnz L65
 03FD                   .dbline 508
 03FD           ;               {
 03FD 801B              xjmp L68
 03FF           L67:
 03FF                   .dbline 510
 03FF           ;                       while(!TIMEOUT)
 03FF           ;                       {
 03FF                   .dbline 511
 03FF           ;                               if(HELLO_2_cReadChar() == END_TRANSMIT)
 03FF 10                push X
 0400 7C0000            xcall _HELLO_2_cReadChar
 0403 20                pop X
 0404 39FD              cmp A,-3
 0406 B012              jnz L70
 0408                   .dbline 512
 0408           ;                               {
 0408                   .dbline 513
 0408           ;                                       CHILD = PORT_2;
 0408 62D000            mov REG[0xd0],>_CHILD
 040B 550032            mov [_CHILD],50
 040E                   .dbline 515
 040E           ;                               
 040E           ;                                       return 1;
 040E 62D000            mov REG[0xd0],>__r0
 0411 550001            mov [__r1],1
 0414 550000            mov [__r0],0
 0417 8452              xjmp L37
 0419           L70:
 0419                   .dbline 517
 0419           ;                               }
 0419           ;                       }
 0419           L68:
 0419                   .dbline 509
 0419 62D000            mov REG[0xd0],>_TIMEOUT
 041C 3C0000            cmp [_TIMEOUT],0
 041F B006              jnz X18
 0421 3C0100            cmp [_TIMEOUT+1],0
 0424 AFDA              jz L67
 0426           X18:
 0426                   .dbline 518
 0426           ;               }
 0426 843A              xjmp L57
 0428           L65:
 0428                   .dbline 519
 0428           ;               else if(HELLO_3_cReadChar() == START_TRANSMIT)
 0428 10                push X
 0429 7C0000            xcall _HELLO_3_cReadChar
 042C 62D000            mov REG[0xd0],>__r0
 042F 20                pop X
 0430 39FC              cmp A,-4
 0432 B02C              jnz L72
 0434                   .dbline 520
 0434           ;               {
 0434 801B              xjmp L75
 0436           L74:
 0436                   .dbline 522
 0436           ;                       while(!TIMEOUT)
 0436           ;                       {
 0436                   .dbline 523
 0436           ;                               if(HELLO_3_cReadChar() == END_TRANSMIT)
 0436 10                push X
 0437 7C0000            xcall _HELLO_3_cReadChar
 043A 20                pop X
 043B 39FD              cmp A,-3
 043D B012              jnz L77
 043F                   .dbline 524
 043F           ;                               {
 043F                   .dbline 525
 043F           ;                                       CHILD = PORT_3;
 043F 62D000            mov REG[0xd0],>_CHILD
 0442 550033            mov [_CHILD],51
 0445                   .dbline 527
 0445           ;                               
 0445           ;                                       return 1;
 0445 62D000            mov REG[0xd0],>__r0
 0448 550001            mov [__r1],1
 044B 550000            mov [__r0],0
 044E 841B              xjmp L37
 0450           L77:
 0450                   .dbline 529
 0450           ;                               }
 0450           ;                       }
 0450           L75:
 0450                   .dbline 521
 0450 62D000            mov REG[0xd0],>_TIMEOUT
 0453 3C0000            cmp [_TIMEOUT],0
 0456 B006              jnz X19
 0458 3C0100            cmp [_TIMEOUT+1],0
 045B AFDA              jz L74
 045D           X19:
 045D                   .dbline 530
 045D           ;               }
 045D 8403              xjmp L57
 045F           L72:
 045F                   .dbline 531
 045F           ;               else if(HELLO_4_cReadChar() == START_TRANSMIT)
 045F 10                push X
 0460 7C0000            xcall _HELLO_4_cReadChar
 0463 62D000            mov REG[0xd0],>__r0
 0466 20                pop X
 0467 39FC              cmp A,-4
 0469 B3F7              jnz L57
 046B                   .dbline 532
 046B           ;               {
 046B 801B              xjmp L82
 046D           L81:
 046D                   .dbline 534
 046D           ;                       while(!TIMEOUT)
 046D           ;                       {
 046D                   .dbline 535
 046D           ;                               if(HELLO_4_cReadChar() == END_TRANSMIT)
 046D 10                push X
 046E 7C0000            xcall _HELLO_4_cReadChar
 0471 20                pop X
 0472 39FD              cmp A,-3
 0474 B012              jnz L84
 0476                   .dbline 536
 0476           ;                               {
 0476                   .dbline 537
 0476           ;                                       CHILD = PORT_4;
 0476 62D000            mov REG[0xd0],>_CHILD
 0479 550034            mov [_CHILD],52
 047C                   .dbline 539
 047C           ;                               
 047C           ;                                       return 1;
 047C 62D000            mov REG[0xd0],>__r0
 047F 550001            mov [__r1],1
 0482 550000            mov [__r0],0
 0485 83E4              xjmp L37
 0487           L84:
 0487                   .dbline 541
 0487           ;                               }
 0487           ;                       }
 0487           L82:
 0487                   .dbline 533
 0487 62D000            mov REG[0xd0],>_TIMEOUT
 048A 3C0000            cmp [_TIMEOUT],0
 048D B006              jnz X20
 048F 3C0100            cmp [_TIMEOUT+1],0
 0492 AFDA              jz L81
 0494           X20:
 0494                   .dbline 542
 0494           ;               }
 0494                   .dbline 543
 0494           ;       }
 0494 83CC              xjmp L57
 0496           L56:
 0496                   .dbline 544
 0496           ;       else if(STATE == RESPONSE_1)
 0496 62D000            mov REG[0xd0],>_STATE
 0499 3C0000            cmp [_STATE],0
 049C B0D2              jnz L86
 049E 3C0103            cmp [_STATE+1],3
 04A1 B0CD              jnz L86
 04A3           X21:
 04A3                   .dbline 545
 04A3           ;       {
 04A3                   .dbline 546
 04A3           ;               if(tempByte = CHILD_1_cReadChar())      // If we have a nonzero byte...
 04A3 10                push X
 04A4 7C0000            xcall _CHILD_1_cReadChar
 04A7 62D000            mov REG[0xd0],>__r0
 04AA 20                pop X
 04AB 5400              mov [X+0],A
 04AD 3900              cmp A,0
 04AF A3B1              jz L87
 04B1                   .dbline 547
 04B1           ;               {
 04B1                   .dbline 548
 04B1           ;                       if(tempByte == SERVO_START)             // We have a servo response coming.
 04B1 3D00FF            cmp [X+0],-1
 04B4 B090              jnz L90
 04B6                   .dbline 549
 04B6           ;                       {
 04B6 807F              xjmp L93
 04B8           L92:
 04B8                   .dbline 552
 04B8           ;                               // While we have not timed out, try to let all of the bytes through.
 04B8           ;                               while(!TIMEOUT)
 04B8           ;                               {
 04B8                   .dbline 554
 04B8           ;                                       // Eat the remaining servo start bytes.
 04B8           ;                                       if(tempByte = CHILD_1_cReadChar())
 04B8 10                push X
 04B9 7C0000            xcall _CHILD_1_cReadChar
 04BC 62D000            mov REG[0xd0],>__r0
 04BF 20                pop X
 04C0 5400              mov [X+0],A
 04C2 3900              cmp A,0
 04C4 A071              jz L95
 04C6                   .dbline 555
 04C6           ;                                       {
 04C6                   .dbline 558
 04C6           ;                                               // Once we get past the start bytes, we can start adding the
 04C6           ;                                               // bytes to our running total and searching for a checksum.
 04C6           ;                                               if(tempByte != SERVO_START)
 04C6 3D00FF            cmp [X+0],-1
 04C9 A06C              jz L97
 04CB                   .dbline 559
 04CB           ;                                               {
 04CB                   .dbline 561
 04CB           ;                                                       // Add to the running total.
 04CB           ;                                                       runningTotal += tempByte;
 04CB 5200              mov A,[X+0]
 04CD 0504              add [X+4],A
 04CF 0F0300            adc [X+3],0
 04D2 8056              xjmp L100
 04D4           L99:
 04D4                   .dbline 565
 04D4           ;                                                       
 04D4           ;                                                       // Either find a checksum or time out. Either way we're not stuck.
 04D4           ;                                                       while(!TIMEOUT)
 04D4           ;                                                       {
 04D4                   .dbline 567
 04D4           ;                                                               // If a nonzero byte has arrived...
 04D4           ;                                                               if(tempByte = CHILD_1_cReadChar())
 04D4 10                push X
 04D5 7C0000            xcall _CHILD_1_cReadChar
 04D8 62D000            mov REG[0xd0],>__r0
 04DB 20                pop X
 04DC 5400              mov [X+0],A
 04DE 3900              cmp A,0
 04E0 A048              jz L102
 04E2                   .dbline 568
 04E2           ;                                                               {
 04E2                   .dbline 570
 04E2           ;                                                                       // Check to see if it is a checksum.
 04E2           ;                                                                       if((runningTotal%256) == (255-tempByte))
 04E2 5200              mov A,[X+0]
 04E4 5300              mov [__r1],A
 04E6 550000            mov [__r0],0
 04E9 50FF              mov A,-1
 04EB 1200              sub A,[__r1]
 04ED 5300              mov [__r1],A
 04EF 5000              mov A,0
 04F1 1A00              sbb A,[__r0]
 04F3 5300              mov [__r0],A
 04F5 5001              mov A,1
 04F7 08                push A
 04F8 5000              mov A,0
 04FA 08                push A
 04FB 5203              mov A,[X+3]
 04FD 08                push A
 04FE 5204              mov A,[X+4]
 0500 08                push A
 0501 7C0000            xcall __divmod_16X16_16
 0504 38FE              add SP,-2
 0506 18                pop A
 0507 5300              mov [__r3],A
 0509 18                pop A
 050A 3A00              cmp A,[__r0]
 050C B012              jnz L104
 050E 5100              mov A,[__r3]
 0510 3A00              cmp A,[__r1]
 0512 B00C              jnz L104
 0514           X22:
 0514                   .dbline 571
 0514           ;                                                                       {
 0514                   .dbline 572
 0514           ;                                                                               return 1;
 0514 62D000            mov REG[0xd0],>__r0
 0517 550001            mov [__r1],1
 051A 550000            mov [__r0],0
 051D 834C              xjmp L37
 051F           L104:
 051F                   .dbline 575
 051F           ;                                                                       }
 051F           ;                                                                       else
 051F           ;                                                                       {
 051F                   .dbline 576
 051F           ;                                                                               runningTotal += tempByte;
 051F 62D000            mov REG[0xd0],>__r0
 0522 5200              mov A,[X+0]
 0524 0504              add [X+4],A
 0526 0F0300            adc [X+3],0
 0529                   .dbline 577
 0529           ;                                                                       }
 0529                   .dbline 578
 0529           ;                                                               }
 0529           L102:
 0529                   .dbline 579
 0529           ;                                                       }
 0529           L100:
 0529                   .dbline 564
 0529 62D000            mov REG[0xd0],>_TIMEOUT
 052C 3C0000            cmp [_TIMEOUT],0
 052F B006              jnz X23
 0531 3C0100            cmp [_TIMEOUT+1],0
 0534 AF9F              jz L99
 0536           X23:
 0536                   .dbline 580
 0536           ;                                               }
 0536           L97:
 0536                   .dbline 581
 0536           ;                                       }
 0536           L95:
 0536                   .dbline 582
 0536           ;                               }
 0536           L93:
 0536                   .dbline 551
 0536 62D000            mov REG[0xd0],>_TIMEOUT
 0539 3C0000            cmp [_TIMEOUT],0
 053C B006              jnz X24
 053E 3C0100            cmp [_TIMEOUT+1],0
 0541 AF76              jz L92
 0543           X24:
 0543                   .dbline 583
 0543           ;                       }
 0543 831D              xjmp L87
 0545           L90:
 0545                   .dbline 584
 0545           ;                       else if(tempByte == START_TRANSMIT)     // We have a controller response coming.
 0545 3D00FC            cmp [X+0],-4
 0548 B318              jnz L87
 054A                   .dbline 585
 054A           ;                       {
 054A 8015              xjmp L109
 054C           L108:
 054C                   .dbline 588
 054C           ;                               // We simply wait for the end transmit indicator.
 054C           ;                               while(!TIMEOUT)
 054C           ;                               {
 054C                   .dbline 589
 054C           ;                                       if(CHILD_1_cReadChar() == END_TRANSMIT)
 054C 10                push X
 054D 7C0000            xcall _CHILD_1_cReadChar
 0550 62D000            mov REG[0xd0],>__r0
 0553 20                pop X
 0554 39FD              cmp A,-3
 0556 B009              jnz L111
 0558                   .dbline 590
 0558           ;                                       {
 0558                   .dbline 591
 0558           ;                                               return 1;
 0558 550001            mov [__r1],1
 055B 550000            mov [__r0],0
 055E 830B              xjmp L37
 0560           L111:
 0560                   .dbline 593
 0560           ;                                       }
 0560           ;                               }
 0560           L109:
 0560                   .dbline 587
 0560 62D000            mov REG[0xd0],>_TIMEOUT
 0563 3C0000            cmp [_TIMEOUT],0
 0566 B006              jnz X25
 0568 3C0100            cmp [_TIMEOUT+1],0
 056B AFE0              jz L108
 056D           X25:
 056D                   .dbline 594
 056D           ;                       }
 056D                   .dbline 595
 056D           ;               }
 056D                   .dbline 596
 056D           ;       }
 056D 82F3              xjmp L87
 056F           L86:
 056F                   .dbline 597
 056F           ;       else if(STATE == RESPONSE_2)
 056F 62D000            mov REG[0xd0],>_STATE
 0572 3C0000            cmp [_STATE],0
 0575 B0D2              jnz L113
 0577 3C0104            cmp [_STATE+1],4
 057A B0CD              jnz L113
 057C           X26:
 057C                   .dbline 598
 057C           ;       {
 057C                   .dbline 599
 057C           ;               if(tempByte = CHILD_2_cReadChar())
 057C 10                push X
 057D 7C0000            xcall _CHILD_2_cReadChar
 0580 62D000            mov REG[0xd0],>__r0
 0583 20                pop X
 0584 5400              mov [X+0],A
 0586 3900              cmp A,0
 0588 A2D8              jz L114
 058A                   .dbline 600
 058A           ;               {
 058A                   .dbline 601
 058A           ;                       if(tempByte == SERVO_START)             // We have a servo response coming.
 058A 3D00FF            cmp [X+0],-1
 058D B090              jnz L117
 058F                   .dbline 602
 058F           ;                       {
 058F 807F              xjmp L120
 0591           L119:
 0591                   .dbline 605
 0591           ;                               // While we have not timed out, try to let all of the bytes through.
 0591           ;                               while(!TIMEOUT)
 0591           ;                               {
 0591                   .dbline 607
 0591           ;                                       // Eat the remaining servo start bytes.
 0591           ;                                       if(tempByte = CHILD_2_cReadChar())
 0591 10                push X
 0592 7C0000            xcall _CHILD_2_cReadChar
 0595 62D000            mov REG[0xd0],>__r0
 0598 20                pop X
 0599 5400              mov [X+0],A
 059B 3900              cmp A,0
 059D A071              jz L122
 059F                   .dbline 608
 059F           ;                                       {
 059F                   .dbline 611
 059F           ;                                               // Once we get past the start bytes, we can start adding the
 059F           ;                                               // bytes to our running total and searching for a checksum.
 059F           ;                                               if(tempByte != SERVO_START)
 059F 3D00FF            cmp [X+0],-1
 05A2 A06C              jz L124
 05A4                   .dbline 612
 05A4           ;                                               {
 05A4                   .dbline 614
 05A4           ;                                                       // Add to the running total.
 05A4           ;                                                       runningTotal += tempByte;
 05A4 5200              mov A,[X+0]
 05A6 0504              add [X+4],A
 05A8 0F0300            adc [X+3],0
 05AB 8056              xjmp L127
 05AD           L126:
 05AD                   .dbline 618
 05AD           ;                                                       
 05AD           ;                                                       // Either find a checksum or time out. Either way we're not stuck.
 05AD           ;                                                       while(!TIMEOUT)
 05AD           ;                                                       {
 05AD                   .dbline 620
 05AD           ;                                                               // If a nonzero byte has arrived...
 05AD           ;                                                               if(tempByte = CHILD_2_cReadChar())
 05AD 10                push X
 05AE 7C0000            xcall _CHILD_2_cReadChar
 05B1 62D000            mov REG[0xd0],>__r0
 05B4 20                pop X
 05B5 5400              mov [X+0],A
 05B7 3900              cmp A,0
 05B9 A048              jz L129
 05BB                   .dbline 621
 05BB           ;                                                               {
 05BB                   .dbline 623
 05BB           ;                                                                       // Check to see if it is a checksum.
 05BB           ;                                                                       if((runningTotal%256) == (255-tempByte))
 05BB 5200              mov A,[X+0]
 05BD 5300              mov [__r1],A
 05BF 550000            mov [__r0],0
 05C2 50FF              mov A,-1
 05C4 1200              sub A,[__r1]
 05C6 5300              mov [__r1],A
 05C8 5000              mov A,0
 05CA 1A00              sbb A,[__r0]
 05CC 5300              mov [__r0],A
 05CE 5001              mov A,1
 05D0 08                push A
 05D1 5000              mov A,0
 05D3 08                push A
 05D4 5203              mov A,[X+3]
 05D6 08                push A
 05D7 5204              mov A,[X+4]
 05D9 08                push A
 05DA 7C0000            xcall __divmod_16X16_16
 05DD 38FE              add SP,-2
 05DF 18                pop A
 05E0 5300              mov [__r3],A
 05E2 18                pop A
 05E3 3A00              cmp A,[__r0]
 05E5 B012              jnz L131
 05E7 5100              mov A,[__r3]
 05E9 3A00              cmp A,[__r1]
 05EB B00C              jnz L131
 05ED           X27:
 05ED                   .dbline 624
 05ED           ;                                                                       {
 05ED                   .dbline 625
 05ED           ;                                                                               return 1;
 05ED 62D000            mov REG[0xd0],>__r0
 05F0 550001            mov [__r1],1
 05F3 550000            mov [__r0],0
 05F6 8273              xjmp L37
 05F8           L131:
 05F8                   .dbline 628
 05F8           ;                                                                       }
 05F8           ;                                                                       else
 05F8           ;                                                                       {
 05F8                   .dbline 629
 05F8           ;                                                                               runningTotal += tempByte;
 05F8 62D000            mov REG[0xd0],>__r0
 05FB 5200              mov A,[X+0]
 05FD 0504              add [X+4],A
 05FF 0F0300            adc [X+3],0
 0602                   .dbline 630
 0602           ;                                                                       }
 0602                   .dbline 631
 0602           ;                                                               }
 0602           L129:
 0602                   .dbline 632
 0602           ;                                                       }
 0602           L127:
 0602                   .dbline 617
 0602 62D000            mov REG[0xd0],>_TIMEOUT
 0605 3C0000            cmp [_TIMEOUT],0
 0608 B006              jnz X28
 060A 3C0100            cmp [_TIMEOUT+1],0
 060D AF9F              jz L126
 060F           X28:
 060F                   .dbline 633
 060F           ;                                               }
 060F           L124:
 060F                   .dbline 634
 060F           ;                                       }
 060F           L122:
 060F                   .dbline 635
 060F           ;                               }
 060F           L120:
 060F                   .dbline 604
 060F 62D000            mov REG[0xd0],>_TIMEOUT
 0612 3C0000            cmp [_TIMEOUT],0
 0615 B006              jnz X29
 0617 3C0100            cmp [_TIMEOUT+1],0
 061A AF76              jz L119
 061C           X29:
 061C                   .dbline 636
 061C           ;                       }
 061C 8244              xjmp L114
 061E           L117:
 061E                   .dbline 637
 061E           ;                       else if(tempByte == START_TRANSMIT)     // We have a controller response coming.
 061E 3D00FC            cmp [X+0],-4
 0621 B23F              jnz L114
 0623                   .dbline 638
 0623           ;                       {
 0623 8015              xjmp L136
 0625           L135:
 0625                   .dbline 641
 0625           ;                               // We simply wait for the end transmit indicator.
 0625           ;                               while(!TIMEOUT)
 0625           ;                               {
 0625                   .dbline 642
 0625           ;                                       if(CHILD_2_cReadChar() == END_TRANSMIT)
 0625 10                push X
 0626 7C0000            xcall _CHILD_2_cReadChar
 0629 62D000            mov REG[0xd0],>__r0
 062C 20                pop X
 062D 39FD              cmp A,-3
 062F B009              jnz L138
 0631                   .dbline 643
 0631           ;                                       {
 0631                   .dbline 644
 0631           ;                                               return 1;
 0631 550001            mov [__r1],1
 0634 550000            mov [__r0],0
 0637 8232              xjmp L37
 0639           L138:
 0639                   .dbline 646
 0639           ;                                       }
 0639           ;                               }
 0639           L136:
 0639                   .dbline 640
 0639 62D000            mov REG[0xd0],>_TIMEOUT
 063C 3C0000            cmp [_TIMEOUT],0
 063F B006              jnz X30
 0641 3C0100            cmp [_TIMEOUT+1],0
 0644 AFE0              jz L135
 0646           X30:
 0646                   .dbline 647
 0646           ;                       }
 0646                   .dbline 648
 0646           ;               }
 0646                   .dbline 649
 0646           ;       }
 0646 821A              xjmp L114
 0648           L113:
 0648                   .dbline 650
 0648           ;       else if(STATE == RESPONSE_3)
 0648 62D000            mov REG[0xd0],>_STATE
 064B 3C0000            cmp [_STATE],0
 064E B0D2              jnz L140
 0650 3C0105            cmp [_STATE+1],5
 0653 B0CD              jnz L140
 0655           X31:
 0655                   .dbline 651
 0655           ;       {
 0655                   .dbline 652
 0655           ;               if(tempByte = CHILD_3_cReadChar())
 0655 10                push X
 0656 7C0000            xcall _CHILD_3_cReadChar
 0659 62D000            mov REG[0xd0],>__r0
 065C 20                pop X
 065D 5400              mov [X+0],A
 065F 3900              cmp A,0
 0661 A1FF              jz L141
 0663                   .dbline 653
 0663           ;               {
 0663                   .dbline 654
 0663           ;                       if(tempByte == SERVO_START)             // We have a servo response coming.
 0663 3D00FF            cmp [X+0],-1
 0666 B090              jnz L144
 0668                   .dbline 655
 0668           ;                       {
 0668 807F              xjmp L147
 066A           L146:
 066A                   .dbline 658
 066A           ;                               // While we have not timed out, try to let all of the bytes through.
 066A           ;                               while(!TIMEOUT)
 066A           ;                               {
 066A                   .dbline 660
 066A           ;                                       // Eat the remaining servo start bytes.
 066A           ;                                       if(tempByte = CHILD_3_cReadChar())
 066A 10                push X
 066B 7C0000            xcall _CHILD_3_cReadChar
 066E 62D000            mov REG[0xd0],>__r0
 0671 20                pop X
 0672 5400              mov [X+0],A
 0674 3900              cmp A,0
 0676 A071              jz L149
 0678                   .dbline 661
 0678           ;                                       {
 0678                   .dbline 664
 0678           ;                                               // Once we get past the start bytes, we can start adding the
 0678           ;                                               // bytes to our running total and searching for a checksum.
 0678           ;                                               if(tempByte != SERVO_START)
 0678 3D00FF            cmp [X+0],-1
 067B A06C              jz L151
 067D                   .dbline 665
 067D           ;                                               {
 067D                   .dbline 667
 067D           ;                                                       // Add to the running total.
 067D           ;                                                       runningTotal += tempByte;
 067D 5200              mov A,[X+0]
 067F 0504              add [X+4],A
 0681 0F0300            adc [X+3],0
 0684 8056              xjmp L154
 0686           L153:
 0686                   .dbline 671
 0686           ;                                                       
 0686           ;                                                       // Either find a checksum or time out. Either way we're not stuck.
 0686           ;                                                       while(!TIMEOUT)
 0686           ;                                                       {
 0686                   .dbline 673
 0686           ;                                                               // If a nonzero byte has arrived...
 0686           ;                                                               if(tempByte = CHILD_3_cReadChar())
 0686 10                push X
 0687 7C0000            xcall _CHILD_3_cReadChar
 068A 62D000            mov REG[0xd0],>__r0
 068D 20                pop X
 068E 5400              mov [X+0],A
 0690 3900              cmp A,0
 0692 A048              jz L156
 0694                   .dbline 674
 0694           ;                                                               {
 0694                   .dbline 676
 0694           ;                                                                       // Check to see if it is a checksum.
 0694           ;                                                                       if((runningTotal%256) == (255-tempByte))
 0694 5200              mov A,[X+0]
 0696 5300              mov [__r1],A
 0698 550000            mov [__r0],0
 069B 50FF              mov A,-1
 069D 1200              sub A,[__r1]
 069F 5300              mov [__r1],A
 06A1 5000              mov A,0
 06A3 1A00              sbb A,[__r0]
 06A5 5300              mov [__r0],A
 06A7 5001              mov A,1
 06A9 08                push A
 06AA 5000              mov A,0
 06AC 08                push A
 06AD 5203              mov A,[X+3]
 06AF 08                push A
 06B0 5204              mov A,[X+4]
 06B2 08                push A
 06B3 7C0000            xcall __divmod_16X16_16
 06B6 38FE              add SP,-2
 06B8 18                pop A
 06B9 5300              mov [__r3],A
 06BB 18                pop A
 06BC 3A00              cmp A,[__r0]
 06BE B012              jnz L158
 06C0 5100              mov A,[__r3]
 06C2 3A00              cmp A,[__r1]
 06C4 B00C              jnz L158
 06C6           X32:
 06C6                   .dbline 677
 06C6           ;                                                                       {
 06C6                   .dbline 678
 06C6           ;                                                                               return 1;
 06C6 62D000            mov REG[0xd0],>__r0
 06C9 550001            mov [__r1],1
 06CC 550000            mov [__r0],0
 06CF 819A              xjmp L37
 06D1           L158:
 06D1                   .dbline 681
 06D1           ;                                                                       }
 06D1           ;                                                                       else
 06D1           ;                                                                       {
 06D1                   .dbline 682
 06D1           ;                                                                               runningTotal += tempByte;
 06D1 62D000            mov REG[0xd0],>__r0
 06D4 5200              mov A,[X+0]
 06D6 0504              add [X+4],A
 06D8 0F0300            adc [X+3],0
 06DB                   .dbline 683
 06DB           ;                                                                       }
 06DB                   .dbline 684
 06DB           ;                                                               }
 06DB           L156:
 06DB                   .dbline 685
 06DB           ;                                                       }
 06DB           L154:
 06DB                   .dbline 670
 06DB 62D000            mov REG[0xd0],>_TIMEOUT
 06DE 3C0000            cmp [_TIMEOUT],0
 06E1 B006              jnz X33
 06E3 3C0100            cmp [_TIMEOUT+1],0
 06E6 AF9F              jz L153
 06E8           X33:
 06E8                   .dbline 686
 06E8           ;                                               }
 06E8           L151:
 06E8                   .dbline 687
 06E8           ;                                       }
 06E8           L149:
 06E8                   .dbline 688
 06E8           ;                               }
 06E8           L147:
 06E8                   .dbline 657
 06E8 62D000            mov REG[0xd0],>_TIMEOUT
 06EB 3C0000            cmp [_TIMEOUT],0
 06EE B006              jnz X34
 06F0 3C0100            cmp [_TIMEOUT+1],0
 06F3 AF76              jz L146
 06F5           X34:
 06F5                   .dbline 689
 06F5           ;                       }
 06F5 816B              xjmp L141
 06F7           L144:
 06F7                   .dbline 690
 06F7           ;                       else if(tempByte == START_TRANSMIT)     // We have a controller response coming.
 06F7 3D00FC            cmp [X+0],-4
 06FA B166              jnz L141
 06FC                   .dbline 691
 06FC           ;                       {
 06FC 8015              xjmp L163
 06FE           L162:
 06FE                   .dbline 694
 06FE           ;                               // We simply wait for the end transmit indicator.
 06FE           ;                               while(!TIMEOUT)
 06FE           ;                               {
 06FE                   .dbline 695
 06FE           ;                                       if(CHILD_3_cReadChar() == END_TRANSMIT)
 06FE 10                push X
 06FF 7C0000            xcall _CHILD_3_cReadChar
 0702 62D000            mov REG[0xd0],>__r0
 0705 20                pop X
 0706 39FD              cmp A,-3
 0708 B009              jnz L165
 070A                   .dbline 696
 070A           ;                                       {
 070A                   .dbline 697
 070A           ;                                               return 1;
 070A 550001            mov [__r1],1
 070D 550000            mov [__r0],0
 0710 8159              xjmp L37
 0712           L165:
 0712                   .dbline 699
 0712           ;                                       }
 0712           ;                               }
 0712           L163:
 0712                   .dbline 693
 0712 62D000            mov REG[0xd0],>_TIMEOUT
 0715 3C0000            cmp [_TIMEOUT],0
 0718 B006              jnz X35
 071A 3C0100            cmp [_TIMEOUT+1],0
 071D AFE0              jz L162
 071F           X35:
 071F                   .dbline 700
 071F           ;                       }
 071F                   .dbline 701
 071F           ;               }
 071F                   .dbline 702
 071F           ;       }
 071F 8141              xjmp L141
 0721           L140:
 0721                   .dbline 703
 0721           ;       else if(STATE == RESPONSE_4)
 0721 62D000            mov REG[0xd0],>_STATE
 0724 3C0000            cmp [_STATE],0
 0727 B0D2              jnz L167
 0729 3C0106            cmp [_STATE+1],6
 072C B0CD              jnz L167
 072E           X36:
 072E                   .dbline 704
 072E           ;       {
 072E                   .dbline 705
 072E           ;               if(tempByte = CHILD_4_cReadChar())
 072E 10                push X
 072F 7C0000            xcall _CHILD_4_cReadChar
 0732 62D000            mov REG[0xd0],>__r0
 0735 20                pop X
 0736 5400              mov [X+0],A
 0738 3900              cmp A,0
 073A A126              jz L168
 073C                   .dbline 706
 073C           ;               {
 073C                   .dbline 707
 073C           ;                       if(tempByte == SERVO_START)             // We have a servo response coming.
 073C 3D00FF            cmp [X+0],-1
 073F B090              jnz L171
 0741                   .dbline 708
 0741           ;                       {
 0741 807F              xjmp L174
 0743           L173:
 0743                   .dbline 711
 0743           ;                               // While we have not timed out, try to let all of the bytes through.
 0743           ;                               while(!TIMEOUT)
 0743           ;                               {
 0743                   .dbline 713
 0743           ;                                       // Eat the remaining servo start bytes.
 0743           ;                                       if(tempByte = CHILD_4_cReadChar())
 0743 10                push X
 0744 7C0000            xcall _CHILD_4_cReadChar
 0747 62D000            mov REG[0xd0],>__r0
 074A 20                pop X
 074B 5400              mov [X+0],A
 074D 3900              cmp A,0
 074F A071              jz L176
 0751                   .dbline 714
 0751           ;                                       {
 0751                   .dbline 717
 0751           ;                                               // Once we get past the start bytes, we can start adding the
 0751           ;                                               // bytes to our running total and searching for a checksum.
 0751           ;                                               if(tempByte != SERVO_START)
 0751 3D00FF            cmp [X+0],-1
 0754 A06C              jz L178
 0756                   .dbline 718
 0756           ;                                               {
 0756                   .dbline 720
 0756           ;                                                       // Add to the running total.
 0756           ;                                                       runningTotal += tempByte;
 0756 5200              mov A,[X+0]
 0758 0504              add [X+4],A
 075A 0F0300            adc [X+3],0
 075D 8056              xjmp L181
 075F           L180:
 075F                   .dbline 724
 075F           ;                                                       
 075F           ;                                                       // Either find a checksum or time out. Either way we're not stuck.
 075F           ;                                                       while(!TIMEOUT)
 075F           ;                                                       {
 075F                   .dbline 726
 075F           ;                                                               // If a nonzero byte has arrived...
 075F           ;                                                               if(tempByte = CHILD_4_cReadChar())
 075F 10                push X
 0760 7C0000            xcall _CHILD_4_cReadChar
 0763 62D000            mov REG[0xd0],>__r0
 0766 20                pop X
 0767 5400              mov [X+0],A
 0769 3900              cmp A,0
 076B A048              jz L183
 076D                   .dbline 727
 076D           ;                                                               {
 076D                   .dbline 729
 076D           ;                                                                       // Check to see if it is a checksum.
 076D           ;                                                                       if((runningTotal%256) == (255-tempByte))
 076D 5200              mov A,[X+0]
 076F 5300              mov [__r1],A
 0771 550000            mov [__r0],0
 0774 50FF              mov A,-1
 0776 1200              sub A,[__r1]
 0778 5300              mov [__r1],A
 077A 5000              mov A,0
 077C 1A00              sbb A,[__r0]
 077E 5300              mov [__r0],A
 0780 5001              mov A,1
 0782 08                push A
 0783 5000              mov A,0
 0785 08                push A
 0786 5203              mov A,[X+3]
 0788 08                push A
 0789 5204              mov A,[X+4]
 078B 08                push A
 078C 7C0000            xcall __divmod_16X16_16
 078F 38FE              add SP,-2
 0791 18                pop A
 0792 5300              mov [__r3],A
 0794 18                pop A
 0795 3A00              cmp A,[__r0]
 0797 B012              jnz L185
 0799 5100              mov A,[__r3]
 079B 3A00              cmp A,[__r1]
 079D B00C              jnz L185
 079F           X37:
 079F                   .dbline 730
 079F           ;                                                                       {
 079F                   .dbline 731
 079F           ;                                                                               return 1;
 079F 62D000            mov REG[0xd0],>__r0
 07A2 550001            mov [__r1],1
 07A5 550000            mov [__r0],0
 07A8 80C1              xjmp L37
 07AA           L185:
 07AA                   .dbline 734
 07AA           ;                                                                       }
 07AA           ;                                                                       else
 07AA           ;                                                                       {
 07AA                   .dbline 735
 07AA           ;                                                                               runningTotal += tempByte;
 07AA 62D000            mov REG[0xd0],>__r0
 07AD 5200              mov A,[X+0]
 07AF 0504              add [X+4],A
 07B1 0F0300            adc [X+3],0
 07B4                   .dbline 736
 07B4           ;                                                                       }
 07B4                   .dbline 737
 07B4           ;                                                               }
 07B4           L183:
 07B4                   .dbline 738
 07B4           ;                                                       }
 07B4           L181:
 07B4                   .dbline 723
 07B4 62D000            mov REG[0xd0],>_TIMEOUT
 07B7 3C0000            cmp [_TIMEOUT],0
 07BA B006              jnz X38
 07BC 3C0100            cmp [_TIMEOUT+1],0
 07BF AF9F              jz L180
 07C1           X38:
 07C1                   .dbline 739
 07C1           ;                                               }
 07C1           L178:
 07C1                   .dbline 740
 07C1           ;                                       }
 07C1           L176:
 07C1                   .dbline 741
 07C1           ;                               }
 07C1           L174:
 07C1                   .dbline 710
 07C1 62D000            mov REG[0xd0],>_TIMEOUT
 07C4 3C0000            cmp [_TIMEOUT],0
 07C7 B006              jnz X39
 07C9 3C0100            cmp [_TIMEOUT+1],0
 07CC AF76              jz L173
 07CE           X39:
 07CE                   .dbline 742
 07CE           ;                       }
 07CE 8092              xjmp L168
 07D0           L171:
 07D0                   .dbline 743
 07D0           ;                       else if(tempByte == START_TRANSMIT)     // We have a controller response coming.
 07D0 3D00FC            cmp [X+0],-4
 07D3 B08D              jnz L168
 07D5                   .dbline 744
 07D5           ;                       {
 07D5 8015              xjmp L190
 07D7           L189:
 07D7                   .dbline 747
 07D7           ;                               // We simply wait for the end transmit indicator.
 07D7           ;                               while(!TIMEOUT)
 07D7           ;                               {
 07D7                   .dbline 748
 07D7           ;                                       if(CHILD_4_cReadChar() == END_TRANSMIT)
 07D7 10                push X
 07D8 7C0000            xcall _CHILD_4_cReadChar
 07DB 62D000            mov REG[0xd0],>__r0
 07DE 20                pop X
 07DF 39FD              cmp A,-3
 07E1 B009              jnz L192
 07E3                   .dbline 749
 07E3           ;                                       {
 07E3                   .dbline 750
 07E3           ;                                               return 1;
 07E3 550001            mov [__r1],1
 07E6 550000            mov [__r0],0
 07E9 8080              xjmp L37
 07EB           L192:
 07EB                   .dbline 752
 07EB           ;                                       }
 07EB           ;                               }
 07EB           L190:
 07EB                   .dbline 746
 07EB 62D000            mov REG[0xd0],>_TIMEOUT
 07EE 3C0000            cmp [_TIMEOUT],0
 07F1 B006              jnz X40
 07F3 3C0100            cmp [_TIMEOUT+1],0
 07F6 AFE0              jz L189
 07F8           X40:
 07F8                   .dbline 753
 07F8           ;                       }
 07F8                   .dbline 754
 07F8           ;               }
 07F8                   .dbline 755
 07F8           ;       }
 07F8 8068              xjmp L168
 07FA           L167:
 07FA                   .dbline 756
 07FA           ;       else if(STATE == INITIALIZE)
 07FA 62D000            mov REG[0xd0],>_STATE
 07FD 3C0000            cmp [_STATE],0
 0800 B060              jnz L194
 0802 3C0108            cmp [_STATE+1],8
 0805 B05B              jnz L194
 0807           X41:
 0807                   .dbline 757
 0807           ;       {
 0807                   .dbline 758
 0807           ;               if(INIT_RX_cReadChar() == SERVO_START)
 0807 10                push X
 0808 7C0000            xcall _INIT_RX_cReadChar
 080B 62D000            mov REG[0xd0],>__r0
 080E 20                pop X
 080F 39FF              cmp A,-1
 0811 B04F              jnz L196
 0813                   .dbline 759
 0813           ;               {
 0813 8040              xjmp L199
 0815           L198:
 0815                   .dbline 761
 0815           ;                       while(!TIMEOUT)
 0815           ;                       {
 0815                   .dbline 763
 0815           ;                               // We officially have a transmission.
 0815           ;                               if(INIT_RX_cReadChar() == SERVO_START)
 0815 10                push X
 0816 7C0000            xcall _INIT_RX_cReadChar
 0819 62D000            mov REG[0xd0],>__r0
 081C 20                pop X
 081D 39FF              cmp A,-1
 081F B034              jnz L201
 0821                   .dbline 764
 0821           ;                               {
 0821                   .dbline 767
 0821           ;                                       // If we definitely have a transmission starting, grab all bytes from the rx buffer
 0821           ;                                       // and store them in the proper variables for actions to be taken later.
 0821           ;                                       COMMAND_SOURCE = INIT_RX_cGetChar();
 0821 10                push X
 0822 7C0000            xcall _INIT_RX_cGetChar
 0825 20                pop X
 0826 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0829 5300              mov [_COMMAND_SOURCE],A
 082B                   .dbline 768
 082B           ;                                       COMMAND_LENGTH = INIT_RX_cGetChar();
 082B 10                push X
 082C 7C0000            xcall _INIT_RX_cGetChar
 082F 20                pop X
 0830 62D000            mov REG[0xd0],>_COMMAND_LENGTH
 0833 5300              mov [_COMMAND_LENGTH],A
 0835                   .dbline 769
 0835           ;                                       COMMAND_ERROR = INIT_RX_cGetChar();
 0835 10                push X
 0836 7C0000            xcall _INIT_RX_cGetChar
 0839 20                pop X
 083A 62D000            mov REG[0xd0],>_COMMAND_ERROR
 083D 5300              mov [_COMMAND_ERROR],A
 083F                   .dbline 770
 083F           ;                                       COMMAND_PARAM = INIT_RX_cGetChar();
 083F 10                push X
 0840 7C0000            xcall _INIT_RX_cGetChar
 0843 20                pop X
 0844 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0847 5300              mov [_COMMAND_PARAM],A
 0849                   .dbline 772
 0849           ;                                       
 0849           ;                                       return 1;
 0849 62D000            mov REG[0xd0],>__r0
 084C 550001            mov [__r1],1
 084F 550000            mov [__r0],0
 0852 8017              xjmp L37
 0854           L201:
 0854                   .dbline 774
 0854           ;                               }
 0854           ;                       }
 0854           L199:
 0854                   .dbline 760
 0854 62D000            mov REG[0xd0],>_TIMEOUT
 0857 3C0000            cmp [_TIMEOUT],0
 085A B006              jnz X42
 085C 3C0100            cmp [_TIMEOUT+1],0
 085F AFB5              jz L198
 0861           X42:
 0861                   .dbline 775
 0861           ;               }
 0861           L196:
 0861                   .dbline 776
 0861           ;       }
 0861           L194:
 0861           L168:
 0861           L141:
 0861           L114:
 0861           L87:
 0861           L57:
 0861           L39:
 0861                   .dbline 778
 0861           ;       
 0861           ;       return 0;
 0861 62D000            mov REG[0xd0],>__r0
 0864 550000            mov [__r1],0
 0867 550000            mov [__r0],0
 086A                   .dbline -2
 086A           L37:
 086A 38FB              add SP,-5
 086C 20                pop X
 086D                   .dbline 0 ; func end
 086D 7F                ret
 086E                   .dbsym l runningTotal 3 I
 086E                   .dbsym l i 1 I
 086E                   .dbsym l tempByte 0 c
 086E                   .dbend
 086E                   .dbfunc e takeAction _takeAction fV
 086E           ;   runningTotal -> X+3
 086E           ;       tempByte -> X+2
 086E           ;              i -> X+0
 086E           _takeAction::
 086E                   .dbline -1
 086E 10                push X
 086F 4F                mov X,SP
 0870 3805              add SP,5
 0872                   .dbline 784
 0872           ; }
 0872           ; 
 0872           ; // This function interprets what has been read by the command ready function
 0872           ; // and performs the appropriate action.
 0872           ; void takeAction(void)
 0872           ; {
 0872                   .dbline 785
 0872           ;       int i = 0;                                                      // An index variable for looping.
 0872 560100            mov [X+1],0
 0875 560000            mov [X+0],0
 0878                   .dbline 786
 0878           ;       char tempByte = 0;                                      // A temporary byte storage variable.
 0878 560200            mov [X+2],0
 087B                   .dbline 787
 087B           ;       int runningTotal = 0;                           // A running total of bytes to check against a checksum.
 087B 560400            mov [X+4],0
 087E 560300            mov [X+3],0
 0881                   .dbline 789
 0881           ;       
 0881           ;       if(COMMAND_TYPE == CLEAR)                               // The master wants to clear the arm.
 0881 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0884 3C00CC            cmp [_COMMAND_TYPE],-52
 0887 B01A              jnz L204
 0889                   .dbline 790
 0889           ;       {
 0889                   .dbline 792
 0889           ;               // Reset the discovered parameters.
 0889           ;               ID = DEFAULT_ID;
 0889 62D000            mov REG[0xd0],>_ID
 088C 5500FB            mov [_ID],-5
 088F                   .dbline 793
 088F           ;               CONFIGURED = 0;
 088F 62D000            mov REG[0xd0],>_CONFIGURED
 0892 550100            mov [_CONFIGURED+1],0
 0895 550000            mov [_CONFIGURED],0
 0898                   .dbline 794
 0898           ;               CHILD = 0;
 0898 62D000            mov REG[0xd0],>_CHILD
 089B 550000            mov [_CHILD],0
 089E                   .dbline 797
 089E           ;               
 089E           ;               // Find the servo again.
 089E           ;               servoFinder();
 089E 943C              xcall _servoFinder
 08A0                   .dbline 798
 08A0           ;       }
 08A0 80F2              xjmp L205
 08A2           L204:
 08A2                   .dbline 799
 08A2           ;       else if(COMMAND_TYPE == HELLO_BYTE)             // The master is probing for new modules.
 08A2 62D000            mov REG[0xd0],>_COMMAND_TYPE
 08A5 3C00C8            cmp [_COMMAND_TYPE],-56
 08A8 B03B              jnz L206
 08AA                   .dbline 800
 08AA           ;       {
 08AA                   .dbline 801
 08AA           ;               if(!CONFIGURED)
 08AA 62D000            mov REG[0xd0],>_CONFIGURED
 08AD 3C0000            cmp [_CONFIGURED],0
 08B0 B00B              jnz L208
 08B2 3C0100            cmp [_CONFIGURED+1],0
 08B5 B006              jnz L208
 08B7           X43:
 08B7                   .dbline 802
 08B7           ;               {
 08B7                   .dbline 804
 08B7           ;                       // Announce this module's presence if not configured.
 08B7           ;                       sayHello();
 08B7 7C0050            xcall _sayHello
 08BA                   .dbline 805
 08BA           ;               }
 08BA 80D8              xjmp L207
 08BC           L208:
 08BC                   .dbline 806
 08BC           ;               else if(!CHILD)
 08BC 62D000            mov REG[0xd0],>_CHILD
 08BF 3C0000            cmp [_CHILD],0
 08C2 B015              jnz L210
 08C4                   .dbline 807
 08C4           ;               {
 08C4                   .dbline 809
 08C4           ;                       // Listen for children if we have none.
 08C4           ;                       if(childListen())
 08C4 92D6              xcall _childListen
 08C6 62D000            mov REG[0xd0],>__r0
 08C9 3C0000            cmp [__r0],0
 08CC B006              jnz X44
 08CE 3C0000            cmp [__r1],0
 08D1 A0C1              jz L207
 08D3           X44:
 08D3                   .dbline 810
 08D3           ;                       {
 08D3                   .dbline 812
 08D3           ;                               // If a child was heard saying hello, forward the command with the port number added.
 08D3           ;                               sayHello();
 08D3 7C0050            xcall _sayHello
 08D6                   .dbline 813
 08D6           ;                       }
 08D6                   .dbline 814
 08D6           ;               }
 08D6 80BC              xjmp L207
 08D8           L210:
 08D8                   .dbline 815
 08D8           ;               else if(CHILD)
 08D8 62D000            mov REG[0xd0],>_CHILD
 08DB 3C0000            cmp [_CHILD],0
 08DE A0B4              jz L207
 08E0                   .dbline 816
 08E0           ;               {
 08E0                   .dbline 818
 08E0           ;                       // If you have a child established, listen to that child.
 08E0           ;                       childResponse();
 08E0 9312              xcall _childResponse
 08E2                   .dbline 819
 08E2           ;               }
 08E2                   .dbline 820
 08E2           ;       }
 08E2 80B0              xjmp L207
 08E4           L206:
 08E4                   .dbline 821
 08E4           ;       else if(COMMAND_TYPE == PING)           // The master is trying to find a module that is configured.
 08E4 62D000            mov REG[0xd0],>_COMMAND_TYPE
 08E7 3C00CB            cmp [_COMMAND_TYPE],-53
 08EA B021              jnz L216
 08EC                   .dbline 822
 08EC           ;       {
 08EC                   .dbline 824
 08EC           ;               // If this is to me, act accordingly.
 08EC           ;               if(COMMAND_DESTINATION == ID)
 08EC 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 08EF 5100              mov A,[_COMMAND_DESTINATION]
 08F1 62D000            mov REG[0xd0],>_ID
 08F4 3A00              cmp A,[_ID]
 08F6 B005              jnz L218
 08F8                   .dbline 825
 08F8           ;               {
 08F8                   .dbline 827
 08F8           ;                       // Ping back to the master.
 08F8           ;                       pingResponse();
 08F8 909D              xcall _pingResponse
 08FA                   .dbline 828
 08FA           ;               }
 08FA 8098              xjmp L217
 08FC           L218:
 08FC                   .dbline 829
 08FC           ;               else if(COMMAND_DESTINATION > ID)
 08FC 62D000            mov REG[0xd0],>_ID
 08FF 5100              mov A,[_ID]
 0901 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0904 3A00              cmp A,[_COMMAND_DESTINATION]
 0906 D08C              jnc L217
 0908           X45:
 0908                   .dbline 830
 0908           ;               {
 0908                   .dbline 832
 0908           ;                       // If you have a child established, listen to that child.
 0908           ;                       childResponse();
 0908 92EA              xcall _childResponse
 090A                   .dbline 833
 090A           ;               }
 090A                   .dbline 834
 090A           ;       }
 090A 8088              xjmp L217
 090C           L216:
 090C                   .dbline 835
 090C           ;       else if(COMMAND_TYPE == ID_ASSIGNMENT)  // The master is assigning an ID to someone.
 090C 62D000            mov REG[0xd0],>_COMMAND_TYPE
 090F 3C00C9            cmp [_COMMAND_TYPE],-55
 0912 B065              jnz L222
 0914                   .dbline 836
 0914           ;       {
 0914                   .dbline 838
 0914           ;               // If this is meant for me, change my ID.
 0914           ;               if(COMMAND_DESTINATION == ID)
 0914 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0917 5100              mov A,[_COMMAND_DESTINATION]
 0919 62D000            mov REG[0xd0],>_ID
 091C 3A00              cmp A,[_ID]
 091E B049              jnz L224
 0920                   .dbline 839
 0920           ;               {
 0920                   .dbline 840
 0920           ;                       if((COMMAND_PARAM > MASTER_ID) && (COMMAND_PARAM < DEFAULT_ID))
 0920 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0923 5000              mov A,0
 0925 3A00              cmp A,[_COMMAND_PARAM]
 0927 D06B              jnc L223
 0929           X46:
 0929 62D000            mov REG[0xd0],>_COMMAND_PARAM
 092C 3C00FB            cmp [_COMMAND_PARAM],-5
 092F D063              jnc L223
 0931           X47:
 0931                   .dbline 841
 0931           ;                       {
 0931                   .dbline 843
 0931           ;                               // Assign this module the ID that has been passed by the master.
 0931           ;                               ID = COMMAND_PARAM;
 0931 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0934 5100              mov A,[_COMMAND_PARAM]
 0936 62D000            mov REG[0xd0],>_ID
 0939 5300              mov [_ID],A
 093B                   .dbline 846
 093B           ;                               
 093B           ;                               // This module is now configured.
 093B           ;                               CONFIGURED = 1;
 093B 62D000            mov REG[0xd0],>_CONFIGURED
 093E 550101            mov [_CONFIGURED+1],1
 0941 550000            mov [_CONFIGURED],0
 0944                   .dbline 849
 0944           ;                       
 0944           ;                               // Let the master node know that you got the ID assignment.
 0944           ;                               assignedID();
 0944 91B7              xcall _assignedID
 0946                   .dbline 852
 0946           ;                               
 0946           ;                               // Send a request to change the servo ID to match the controller ID.
 0946           ;                               servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, ID_ADDRESS, ID);
 0946 62D000            mov REG[0xd0],>_ID
 0949 5100              mov A,[_ID]
 094B 08                push A
 094C 5003              mov A,3
 094E 08                push A
 094F 08                push A
 0950 5004              mov A,4
 0952 08                push A
 0953 62D000            mov REG[0xd0],>_SERVO_ID
 0956 5100              mov A,[_SERVO_ID]
 0958 08                push A
 0959 953B              xcall _servoInstruction
 095B                   .dbline 855
 095B           ;                               
 095B           ;                               // Get back into wait mode.
 095B           ;                               configToggle(WAIT);
 095B 5000              mov A,0
 095D 08                push A
 095E 5001              mov A,1
 0960 08                push A
 0961 7C00B5            xcall _configToggle
 0964 38F9              add SP,-7
 0966                   .dbline 856
 0966           ;                       }
 0966                   .dbline 857
 0966           ;               }
 0966 802C              xjmp L223
 0968           L224:
 0968                   .dbline 858
 0968           ;               else if(COMMAND_DESTINATION > ID)
 0968 62D000            mov REG[0xd0],>_ID
 096B 5100              mov A,[_ID]
 096D 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0970 3A00              cmp A,[_COMMAND_DESTINATION]
 0972 D020              jnc L223
 0974           X48:
 0974                   .dbline 859
 0974           ;               {
 0974                   .dbline 861
 0974           ;                       // Switch to listen to your child.
 0974           ;                       childResponse();
 0974 927E              xcall _childResponse
 0976                   .dbline 862
 0976           ;               }
 0976                   .dbline 863
 0976           ;       }
 0976 801C              xjmp L223
 0978           L222:
 0978                   .dbline 864
 0978           ;       else if((COMMAND_TYPE == PING_SERVO) || (COMMAND_TYPE == READ_SERVO))
 0978 62D000            mov REG[0xd0],>_COMMAND_TYPE
 097B 3C0001            cmp [_COMMAND_TYPE],1
 097E A006              jz L232
 0980 3C0002            cmp [_COMMAND_TYPE],2
 0983 B00F              jnz L230
 0985           L232:
 0985                   .dbline 865
 0985           ;       {
 0985                   .dbline 866
 0985           ;               if(COMMAND_DESTINATION > ID)
 0985 62D000            mov REG[0xd0],>_ID
 0988 5100              mov A,[_ID]
 098A 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 098D 3A00              cmp A,[_COMMAND_DESTINATION]
 098F D003              jnc L233
 0991           X49:
 0991                   .dbline 867
 0991           ;               {
 0991                   .dbline 869
 0991           ;                       // Allow the child response through.
 0991           ;                       childResponse();
 0991 9261              xcall _childResponse
 0993                   .dbline 870
 0993           ;               }
 0993           L233:
 0993                   .dbline 871
 0993           ;       }
 0993           L230:
 0993           L223:
 0993           L217:
 0993           L207:
 0993           L205:
 0993                   .dbline -2
 0993           L203:
 0993 38FB              add SP,-5
 0995 20                pop X
 0996                   .dbline 0 ; func end
 0996 7F                ret
 0997                   .dbsym l runningTotal 3 I
 0997                   .dbsym l tempByte 2 c
 0997                   .dbsym l i 0 I
 0997                   .dbend
 0997                   .dbfunc e pingResponse _pingResponse fV
 0997           _pingResponse::
 0997                   .dbline -1
 0997                   .dbline 876
 0997           ; }
 0997           ; 
 0997           ; // This function sends out a ping response for everyone to hear.
 0997           ; void pingResponse(void)
 0997           ; {
 0997                   .dbline 877
 0997           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 0997 5000              mov A,0
 0999 08                push A
 099A 5002              mov A,2
 099C 08                push A
 099D 7C00B5            xcall _configToggle
 09A0 38FE              add SP,-2
 09A2                   .dbline 880
 09A2           ;       
 09A2           ;       // Transmit a ping to everyone.
 09A2           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 09A2 10                push X
 09A3 50FC              mov A,-4
 09A5 7C0000            xcall _TX_014_PutChar
 09A8 20                pop X
 09A9                   .dbline 881
 09A9           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 09A9 10                push X
 09AA 50FC              mov A,-4
 09AC 7C0000            xcall _TX_23_PutChar
 09AF 20                pop X
 09B0                   .dbline 882
 09B0           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 09B0 10                push X
 09B1 50FC              mov A,-4
 09B3 7C0000            xcall _TX_014_PutChar
 09B6 20                pop X
 09B7                   .dbline 883
 09B7           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 09B7 10                push X
 09B8 50FC              mov A,-4
 09BA 7C0000            xcall _TX_23_PutChar
 09BD 20                pop X
 09BE                   .dbline 884
 09BE           ;       TX_014_PutChar(ID);                             // My ID
 09BE 10                push X
 09BF 62D000            mov REG[0xd0],>_ID
 09C2 5100              mov A,[_ID]
 09C4 7C0000            xcall _TX_014_PutChar
 09C7 20                pop X
 09C8                   .dbline 885
 09C8           ;       TX_23_PutChar(ID);                              // My ID
 09C8 10                push X
 09C9 62D000            mov REG[0xd0],>_ID
 09CC 5100              mov A,[_ID]
 09CE 7C0000            xcall _TX_23_PutChar
 09D1 20                pop X
 09D2                   .dbline 886
 09D2           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 09D2 10                push X
 09D3 5000              mov A,0
 09D5 7C0000            xcall _TX_014_PutChar
 09D8 20                pop X
 09D9                   .dbline 887
 09D9           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 09D9 10                push X
 09DA 5000              mov A,0
 09DC 7C0000            xcall _TX_23_PutChar
 09DF 20                pop X
 09E0                   .dbline 888
 09E0           ;       TX_014_PutChar(PING);                   // This is a ping response
 09E0 10                push X
 09E1 50CB              mov A,-53
 09E3 7C0000            xcall _TX_014_PutChar
 09E6 20                pop X
 09E7                   .dbline 889
 09E7           ;       TX_23_PutChar(PING);                    // This is a ping response
 09E7 10                push X
 09E8 50CB              mov A,-53
 09EA 7C0000            xcall _TX_23_PutChar
 09ED 20                pop X
 09EE                   .dbline 890
 09EE           ;       TX_014_PutChar(TYPE);                   // This is the module type
 09EE 10                push X
 09EF 5031              mov A,49
 09F1 7C0000            xcall _TX_014_PutChar
 09F4 20                pop X
 09F5                   .dbline 891
 09F5           ;       TX_23_PutChar(TYPE);                    // This is the module type
 09F5 10                push X
 09F6 5031              mov A,49
 09F8 7C0000            xcall _TX_23_PutChar
 09FB 20                pop X
 09FC                   .dbline 892
 09FC           ;       TX_014_PutChar(CHILD);                  // This is the child-connected port
 09FC 10                push X
 09FD 62D000            mov REG[0xd0],>_CHILD
 0A00 5100              mov A,[_CHILD]
 0A02 7C0000            xcall _TX_014_PutChar
 0A05 20                pop X
 0A06                   .dbline 893
 0A06           ;       TX_23_PutChar(CHILD);                   // This is the child-connected port
 0A06 10                push X
 0A07 62D000            mov REG[0xd0],>_CHILD
 0A0A 5100              mov A,[_CHILD]
 0A0C 7C0000            xcall _TX_23_PutChar
 0A0F 20                pop X
 0A10                   .dbline 894
 0A10           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0A10 10                push X
 0A11 50FD              mov A,-3
 0A13 7C0000            xcall _TX_014_PutChar
 0A16 20                pop X
 0A17                   .dbline 895
 0A17           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0A17 10                push X
 0A18 50FD              mov A,-3
 0A1A 7C0000            xcall _TX_23_PutChar
 0A1D 20                pop X
 0A1E                   .dbline 896
 0A1E           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0A1E 10                push X
 0A1F 50FD              mov A,-3
 0A21 7C0000            xcall _TX_014_PutChar
 0A24 20                pop X
 0A25                   .dbline 897
 0A25           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0A25 10                push X
 0A26 50FD              mov A,-3
 0A28 7C0000            xcall _TX_23_PutChar
 0A2B 20                pop X
 0A2C           L236:
 0A2C                   .dbline 900
 0A2C           ;       
 0A2C           ;       // Wait for the transmission to finish.
 0A2C           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0A2C           L237:
 0A2C                   .dbline 900
 0A2C 10                push X
 0A2D 7C0000            xcall _TX_014_bReadTxStatus
 0A30 62D000            mov REG[0xd0],>__r0
 0A33 20                pop X
 0A34 5300              mov [__r0],A
 0A36 470020            tst [__r0],32
 0A39 AFF2              jz L236
 0A3B           L239:
 0A3B                   .dbline 901
 0A3B           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 0A3B           L240:
 0A3B                   .dbline 901
 0A3B 10                push X
 0A3C 7C0000            xcall _TX_23_bReadTxStatus
 0A3F 62D000            mov REG[0xd0],>__r0
 0A42 20                pop X
 0A43 5300              mov [__r0],A
 0A45 470020            tst [__r0],32
 0A48 AFF2              jz L239
 0A4A                   .dbline 904
 0A4A           ;       
 0A4A           ;       // Make completely sure we're done.
 0A4A           ;       xmitWait();
 0A4A 9528              xcall _xmitWait
 0A4C                   .dbline 906
 0A4C           ;       
 0A4C           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0A4C 5000              mov A,0
 0A4E 08                push A
 0A4F 5001              mov A,1
 0A51 08                push A
 0A52 7C00B5            xcall _configToggle
 0A55 38FE              add SP,-2
 0A57                   .dbline -2
 0A57           L235:
 0A57                   .dbline 0 ; func end
 0A57 7F                ret
 0A58                   .dbend
 0A58                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0A58           _unloadAllConfigs::
 0A58                   .dbline -1
 0A58                   .dbline 912
 0A58           ; }
 0A58           ; 
 0A58           ; // This function blindly unloads all user configurations. This will be called once,
 0A58           ; // when the system initially has no known state.
 0A58           ; void unloadAllConfigs(void)
 0A58           ; {
 0A58                   .dbline 913
 0A58           ;       UnloadConfig_waiting();
 0A58 7C0000            xcall _UnloadConfig_waiting
 0A5B                   .dbline 914
 0A5B           ;       UnloadConfig_hello();
 0A5B 7C0000            xcall _UnloadConfig_hello
 0A5E                   .dbline 915
 0A5E           ;       UnloadConfig_my_response();
 0A5E 7C0000            xcall _UnloadConfig_my_response
 0A61                   .dbline 916
 0A61           ;       UnloadConfig_response1();
 0A61 7C0000            xcall _UnloadConfig_response1
 0A64                   .dbline 917
 0A64           ;       UnloadConfig_response2();
 0A64 7C0000            xcall _UnloadConfig_response2
 0A67                   .dbline 918
 0A67           ;       UnloadConfig_response3();
 0A67 7C0000            xcall _UnloadConfig_response3
 0A6A                   .dbline 919
 0A6A           ;       UnloadConfig_response4();
 0A6A 7C0000            xcall _UnloadConfig_response4
 0A6D                   .dbline 920
 0A6D           ;       UnloadConfig_initial();
 0A6D 7C0000            xcall _UnloadConfig_initial
 0A70                   .dbline 921
 0A70           ;       UnloadConfig_servo_transmit();
 0A70 7C0000            xcall _UnloadConfig_servo_transmit
 0A73                   .dbline -2
 0A73           L242:
 0A73                   .dbline 0 ; func end
 0A73 7F                ret
 0A74                   .dbend
 0A74                   .dbfunc e unloadConfig _unloadConfig fV
 0A74           ;     config_num -> X-5
 0A74           _unloadConfig::
 0A74                   .dbline -1
 0A74 10                push X
 0A75 4F                mov X,SP
 0A76                   .dbline 927
 0A76           ; }
 0A76           ; 
 0A76           ; // This function unloads the configuration corresponding to the config number passed to it.
 0A76           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0A76           ; void unloadConfig(int config_num)
 0A76           ; {
 0A76                   .dbline 928
 0A76           ;       if(config_num == WAIT)
 0A76 3DFB00            cmp [X-5],0
 0A79 B00B              jnz L244
 0A7B 3DFC01            cmp [X-4],1
 0A7E B006              jnz L244
 0A80           X50:
 0A80                   .dbline 929
 0A80           ;       {
 0A80                   .dbline 930
 0A80           ;               UnloadConfig_waiting();
 0A80 7C0000            xcall _UnloadConfig_waiting
 0A83                   .dbline 931
 0A83           ;       }
 0A83 8077              xjmp L245
 0A85           L244:
 0A85                   .dbline 932
 0A85           ;       else if(config_num == HELLO_MODE)
 0A85 3DFB00            cmp [X-5],0
 0A88 B00B              jnz L246
 0A8A 3DFC07            cmp [X-4],7
 0A8D B006              jnz L246
 0A8F           X51:
 0A8F                   .dbline 933
 0A8F           ;       {
 0A8F                   .dbline 934
 0A8F           ;               UnloadConfig_hello();
 0A8F 7C0000            xcall _UnloadConfig_hello
 0A92                   .dbline 935
 0A92           ;       }
 0A92 8068              xjmp L247
 0A94           L246:
 0A94                   .dbline 936
 0A94           ;       else if(config_num == MY_RESPONSE)
 0A94 3DFB00            cmp [X-5],0
 0A97 B00B              jnz L248
 0A99 3DFC02            cmp [X-4],2
 0A9C B006              jnz L248
 0A9E           X52:
 0A9E                   .dbline 937
 0A9E           ;       {
 0A9E                   .dbline 938
 0A9E           ;               UnloadConfig_my_response();
 0A9E 7C0000            xcall _UnloadConfig_my_response
 0AA1                   .dbline 939
 0AA1           ;       }
 0AA1 8059              xjmp L249
 0AA3           L248:
 0AA3                   .dbline 940
 0AA3           ;       else if(config_num == RESPONSE_1)
 0AA3 3DFB00            cmp [X-5],0
 0AA6 B00B              jnz L250
 0AA8 3DFC03            cmp [X-4],3
 0AAB B006              jnz L250
 0AAD           X53:
 0AAD                   .dbline 941
 0AAD           ;       {
 0AAD                   .dbline 942
 0AAD           ;               UnloadConfig_response1();
 0AAD 7C0000            xcall _UnloadConfig_response1
 0AB0                   .dbline 943
 0AB0           ;       }
 0AB0 804A              xjmp L251
 0AB2           L250:
 0AB2                   .dbline 944
 0AB2           ;       else if(config_num == RESPONSE_2)
 0AB2 3DFB00            cmp [X-5],0
 0AB5 B00B              jnz L252
 0AB7 3DFC04            cmp [X-4],4
 0ABA B006              jnz L252
 0ABC           X54:
 0ABC                   .dbline 945
 0ABC           ;       {
 0ABC                   .dbline 946
 0ABC           ;               UnloadConfig_response2();
 0ABC 7C0000            xcall _UnloadConfig_response2
 0ABF                   .dbline 947
 0ABF           ;       }
 0ABF 803B              xjmp L253
 0AC1           L252:
 0AC1                   .dbline 948
 0AC1           ;       else if(config_num == RESPONSE_3)
 0AC1 3DFB00            cmp [X-5],0
 0AC4 B00B              jnz L254
 0AC6 3DFC05            cmp [X-4],5
 0AC9 B006              jnz L254
 0ACB           X55:
 0ACB                   .dbline 949
 0ACB           ;       {
 0ACB                   .dbline 950
 0ACB           ;               UnloadConfig_response3();
 0ACB 7C0000            xcall _UnloadConfig_response3
 0ACE                   .dbline 951
 0ACE           ;       }
 0ACE 802C              xjmp L255
 0AD0           L254:
 0AD0                   .dbline 952
 0AD0           ;       else if(config_num == RESPONSE_4)
 0AD0 3DFB00            cmp [X-5],0
 0AD3 B00B              jnz L256
 0AD5 3DFC06            cmp [X-4],6
 0AD8 B006              jnz L256
 0ADA           X56:
 0ADA                   .dbline 953
 0ADA           ;       {
 0ADA                   .dbline 954
 0ADA           ;               UnloadConfig_response4();
 0ADA 7C0000            xcall _UnloadConfig_response4
 0ADD                   .dbline 955
 0ADD           ;       }
 0ADD 801D              xjmp L257
 0ADF           L256:
 0ADF                   .dbline 956
 0ADF           ;       else if(config_num == INITIALIZE)
 0ADF 3DFB00            cmp [X-5],0
 0AE2 B00B              jnz L258
 0AE4 3DFC08            cmp [X-4],8
 0AE7 B006              jnz L258
 0AE9           X57:
 0AE9                   .dbline 957
 0AE9           ;       {
 0AE9                   .dbline 958
 0AE9           ;               UnloadConfig_initial();
 0AE9 7C0000            xcall _UnloadConfig_initial
 0AEC                   .dbline 959
 0AEC           ;       }
 0AEC 800E              xjmp L259
 0AEE           L258:
 0AEE                   .dbline 960
 0AEE           ;       else if(config_num == SERVO_COMM)
 0AEE 3DFB00            cmp [X-5],0
 0AF1 B009              jnz L260
 0AF3 3DFC09            cmp [X-4],9
 0AF6 B004              jnz L260
 0AF8           X58:
 0AF8                   .dbline 961
 0AF8           ;       {
 0AF8                   .dbline 962
 0AF8           ;               UnloadConfig_servo_transmit();
 0AF8 7C0000            xcall _UnloadConfig_servo_transmit
 0AFB                   .dbline 963
 0AFB           ;       }
 0AFB           L260:
 0AFB           L259:
 0AFB           L257:
 0AFB           L255:
 0AFB           L253:
 0AFB           L251:
 0AFB           L249:
 0AFB           L247:
 0AFB           L245:
 0AFB                   .dbline -2
 0AFB           L243:
 0AFB 20                pop X
 0AFC                   .dbline 0 ; func end
 0AFC 7F                ret
 0AFD                   .dbsym l config_num -5 I
 0AFD                   .dbend
 0AFD                   .dbfunc e assignedID _assignedID fV
 0AFD           _assignedID::
 0AFD                   .dbline -1
 0AFD                   .dbline 968
 0AFD           ; }
 0AFD           ; 
 0AFD           ; // This function responds that an ID has been assigned to it.
 0AFD           ; void assignedID(void)
 0AFD           ; {
 0AFD                   .dbline 969
 0AFD           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 0AFD 5000              mov A,0
 0AFF 08                push A
 0B00 5002              mov A,2
 0B02 08                push A
 0B03 7C00B5            xcall _configToggle
 0B06 38FE              add SP,-2
 0B08                   .dbline 972
 0B08           ;       
 0B08           ;       // Transmit a ping to everyone.
 0B08           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 0B08 10                push X
 0B09 50FC              mov A,-4
 0B0B 7C0000            xcall _TX_014_PutChar
 0B0E 20                pop X
 0B0F                   .dbline 973
 0B0F           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 0B0F 10                push X
 0B10 50FC              mov A,-4
 0B12 7C0000            xcall _TX_23_PutChar
 0B15 20                pop X
 0B16                   .dbline 974
 0B16           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 0B16 10                push X
 0B17 50FC              mov A,-4
 0B19 7C0000            xcall _TX_014_PutChar
 0B1C 20                pop X
 0B1D                   .dbline 975
 0B1D           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 0B1D 10                push X
 0B1E 50FC              mov A,-4
 0B20 7C0000            xcall _TX_23_PutChar
 0B23 20                pop X
 0B24                   .dbline 976
 0B24           ;       TX_014_PutChar(ID);                             // My ID
 0B24 10                push X
 0B25 62D000            mov REG[0xd0],>_ID
 0B28 5100              mov A,[_ID]
 0B2A 7C0000            xcall _TX_014_PutChar
 0B2D 20                pop X
 0B2E                   .dbline 977
 0B2E           ;       TX_23_PutChar(ID);                              // My ID
 0B2E 10                push X
 0B2F 62D000            mov REG[0xd0],>_ID
 0B32 5100              mov A,[_ID]
 0B34 7C0000            xcall _TX_23_PutChar
 0B37 20                pop X
 0B38                   .dbline 978
 0B38           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 0B38 10                push X
 0B39 5000              mov A,0
 0B3B 7C0000            xcall _TX_014_PutChar
 0B3E 20                pop X
 0B3F                   .dbline 979
 0B3F           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 0B3F 10                push X
 0B40 5000              mov A,0
 0B42 7C0000            xcall _TX_23_PutChar
 0B45 20                pop X
 0B46                   .dbline 980
 0B46           ;       TX_014_PutChar(ID_ASSIGN_OK);   // This is an assignment ack response
 0B46 10                push X
 0B47 50CA              mov A,-54
 0B49 7C0000            xcall _TX_014_PutChar
 0B4C 20                pop X
 0B4D                   .dbline 981
 0B4D           ;       TX_23_PutChar(ID_ASSIGN_OK);    // This is an assignment ack response
 0B4D 10                push X
 0B4E 50CA              mov A,-54
 0B50 7C0000            xcall _TX_23_PutChar
 0B53 20                pop X
 0B54                   .dbline 982
 0B54           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0B54 10                push X
 0B55 50FD              mov A,-3
 0B57 7C0000            xcall _TX_014_PutChar
 0B5A 20                pop X
 0B5B                   .dbline 983
 0B5B           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0B5B 10                push X
 0B5C 50FD              mov A,-3
 0B5E 7C0000            xcall _TX_23_PutChar
 0B61 20                pop X
 0B62                   .dbline 984
 0B62           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0B62 10                push X
 0B63 50FD              mov A,-3
 0B65 7C0000            xcall _TX_014_PutChar
 0B68 20                pop X
 0B69                   .dbline 985
 0B69           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0B69 10                push X
 0B6A 50FD              mov A,-3
 0B6C 7C0000            xcall _TX_23_PutChar
 0B6F 20                pop X
 0B70           L263:
 0B70                   .dbline 988
 0B70           ;       
 0B70           ;       // Wait for the transmission to finish.
 0B70           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0B70           L264:
 0B70                   .dbline 988
 0B70 10                push X
 0B71 7C0000            xcall _TX_014_bReadTxStatus
 0B74 62D000            mov REG[0xd0],>__r0
 0B77 20                pop X
 0B78 5300              mov [__r0],A
 0B7A 470020            tst [__r0],32
 0B7D AFF2              jz L263
 0B7F           L266:
 0B7F                   .dbline 989
 0B7F           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 0B7F           L267:
 0B7F                   .dbline 989
 0B7F 10                push X
 0B80 7C0000            xcall _TX_23_bReadTxStatus
 0B83 62D000            mov REG[0xd0],>__r0
 0B86 20                pop X
 0B87 5300              mov [__r0],A
 0B89 470020            tst [__r0],32
 0B8C AFF2              jz L266
 0B8E                   .dbline 992
 0B8E           ;       
 0B8E           ;       // Make completely sure we're done.
 0B8E           ;       xmitWait();
 0B8E 93E4              xcall _xmitWait
 0B90                   .dbline 994
 0B90           ;       
 0B90           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0B90 5000              mov A,0
 0B92 08                push A
 0B93 5001              mov A,1
 0B95 08                push A
 0B96 7C00B5            xcall _configToggle
 0B99 38FE              add SP,-2
 0B9B                   .dbline -2
 0B9B           L262:
 0B9B                   .dbline 0 ; func end
 0B9B 7F                ret
 0B9C                   .dbend
 0B9C                   .dbfunc e childListen _childListen fI
 0B9C           _childListen::
 0B9C                   .dbline -1
 0B9C                   .dbline 999
 0B9C           ; }
 0B9C           ; 
 0B9C           ; // This function listens for children and registers the port that they talk to.
 0B9C           ; int childListen(void)
 0B9C           ; {
 0B9C                   .dbline 1000
 0B9C           ;       configToggle(HELLO_MODE);       // Switch to listen for hellos on every port.
 0B9C 5000              mov A,0
 0B9E 08                push A
 0B9F 5007              mov A,7
 0BA1 08                push A
 0BA2 7C00B5            xcall _configToggle
 0BA5 38FE              add SP,-2
 0BA7 801C              xjmp L271
 0BA9           L270:
 0BA9                   .dbline 1004
 0BA9           ;       
 0BA9           ;       // Wait to either hear a child or time out.
 0BA9           ;       while(!TIMEOUT)
 0BA9           ;       {               
 0BA9                   .dbline 1005
 0BA9           ;               if(commandReady())
 0BA9 7C02BF            xcall _commandReady
 0BAC 62D000            mov REG[0xd0],>__r0
 0BAF 3C0000            cmp [__r0],0
 0BB2 B006              jnz X59
 0BB4 3C0000            cmp [__r1],0
 0BB7 A00C              jz L273
 0BB9           X59:
 0BB9                   .dbline 1006
 0BB9           ;               {
 0BB9                   .dbline 1007
 0BB9           ;                       return 1;
 0BB9 62D000            mov REG[0xd0],>__r0
 0BBC 550001            mov [__r1],1
 0BBF 550000            mov [__r0],0
 0BC2 8030              xjmp L269
 0BC4           L273:
 0BC4                   .dbline 1009
 0BC4           ;               }
 0BC4           ;       }
 0BC4           L271:
 0BC4                   .dbline 1003
 0BC4 62D000            mov REG[0xd0],>_TIMEOUT
 0BC7 3C0000            cmp [_TIMEOUT],0
 0BCA B006              jnz X60
 0BCC 3C0100            cmp [_TIMEOUT+1],0
 0BCF AFD9              jz L270
 0BD1           X60:
 0BD1                   .dbline 1011
 0BD1           ;       
 0BD1           ;       HELLO_TIMEOUT_Stop();           // Stop the timer.
 0BD1 10                push X
 0BD2 7C0000            xcall _HELLO_TIMEOUT_Stop
 0BD5 20                pop X
 0BD6                   .dbline 1012
 0BD6           ;       TIMEOUT = 0;                            // Clear the timeout flag.
 0BD6 62D000            mov REG[0xd0],>_TIMEOUT
 0BD9 550100            mov [_TIMEOUT+1],0
 0BDC 550000            mov [_TIMEOUT],0
 0BDF                   .dbline 1014
 0BDF           ;       
 0BDF           ;       configToggle(WAIT);                     // Switch back to wait for a master response.
 0BDF 5000              mov A,0
 0BE1 08                push A
 0BE2 5001              mov A,1
 0BE4 08                push A
 0BE5 7C00B5            xcall _configToggle
 0BE8 38FE              add SP,-2
 0BEA                   .dbline 1016
 0BEA           ;       
 0BEA           ;       return 0;                                       // Return the result of our listening session.
 0BEA 62D000            mov REG[0xd0],>__r0
 0BED 550000            mov [__r1],0
 0BF0 550000            mov [__r0],0
 0BF3                   .dbline -2
 0BF3           L269:
 0BF3                   .dbline 0 ; func end
 0BF3 7F                ret
 0BF4                   .dbend
 0BF4                   .dbfunc e childResponse _childResponse fI
 0BF4           ; child_responded -> X+0
 0BF4           _childResponse::
 0BF4                   .dbline -1
 0BF4 10                push X
 0BF5 4F                mov X,SP
 0BF6 3802              add SP,2
 0BF8                   .dbline 1021
 0BF8           ; }
 0BF8           ; 
 0BF8           ; // This function waits for a known child's response.
 0BF8           ; int childResponse(void)
 0BF8           ; {
 0BF8                   .dbline 1022
 0BF8           ;       int child_responded = 0;
 0BF8 560100            mov [X+1],0
 0BFB 560000            mov [X+0],0
 0BFE                   .dbline 1025
 0BFE           ;       
 0BFE           ;       // Switch to the right port.
 0BFE           ;       if(CHILD == PORT_1)
 0BFE 62D000            mov REG[0xd0],>_CHILD
 0C01 3C0031            cmp [_CHILD],49
 0C04 B00E              jnz L276
 0C06                   .dbline 1026
 0C06           ;       {
 0C06                   .dbline 1027
 0C06           ;               configToggle(RESPONSE_1);
 0C06 5000              mov A,0
 0C08 08                push A
 0C09 5003              mov A,3
 0C0B 08                push A
 0C0C 7C00B5            xcall _configToggle
 0C0F 38FE              add SP,-2
 0C11                   .dbline 1028
 0C11           ;       }
 0C11 8056              xjmp L285
 0C13           L276:
 0C13                   .dbline 1029
 0C13           ;       else if(CHILD == PORT_2)
 0C13 62D000            mov REG[0xd0],>_CHILD
 0C16 3C0032            cmp [_CHILD],50
 0C19 B00E              jnz L278
 0C1B                   .dbline 1030
 0C1B           ;       {
 0C1B                   .dbline 1031
 0C1B           ;               configToggle(RESPONSE_2);
 0C1B 5000              mov A,0
 0C1D 08                push A
 0C1E 5004              mov A,4
 0C20 08                push A
 0C21 7C00B5            xcall _configToggle
 0C24 38FE              add SP,-2
 0C26                   .dbline 1032
 0C26           ;       }
 0C26 8041              xjmp L285
 0C28           L278:
 0C28                   .dbline 1033
 0C28           ;       else if(CHILD == PORT_3)
 0C28 62D000            mov REG[0xd0],>_CHILD
 0C2B 3C0033            cmp [_CHILD],51
 0C2E B00E              jnz L280
 0C30                   .dbline 1034
 0C30           ;       {
 0C30                   .dbline 1035
 0C30           ;               configToggle(RESPONSE_3);
 0C30 5000              mov A,0
 0C32 08                push A
 0C33 5005              mov A,5
 0C35 08                push A
 0C36 7C00B5            xcall _configToggle
 0C39 38FE              add SP,-2
 0C3B                   .dbline 1036
 0C3B           ;       }
 0C3B 802C              xjmp L285
 0C3D           L280:
 0C3D                   .dbline 1037
 0C3D           ;       else if(CHILD == PORT_4)
 0C3D 62D000            mov REG[0xd0],>_CHILD
 0C40 3C0034            cmp [_CHILD],52
 0C43 B024              jnz L285
 0C45                   .dbline 1038
 0C45           ;       {
 0C45                   .dbline 1039
 0C45           ;               configToggle(RESPONSE_4);
 0C45 5000              mov A,0
 0C47 08                push A
 0C48 5006              mov A,6
 0C4A 08                push A
 0C4B 7C00B5            xcall _configToggle
 0C4E 38FE              add SP,-2
 0C50                   .dbline 1040
 0C50           ;       }
 0C50 8017              xjmp L285
 0C52           L284:
 0C52                   .dbline 1044
 0C52           ;       
 0C52           ;       // Wait for a response or a timeout.
 0C52           ;       while((!child_responded) && (!TIMEOUT))
 0C52           ;       {
 0C52                   .dbline 1045
 0C52           ;               if(commandReady())
 0C52 7C02BF            xcall _commandReady
 0C55 62D000            mov REG[0xd0],>__r0
 0C58 3C0000            cmp [__r0],0
 0C5B B006              jnz X61
 0C5D 3C0000            cmp [__r1],0
 0C60 A007              jz L287
 0C62           X61:
 0C62                   .dbline 1046
 0C62           ;               {
 0C62                   .dbline 1047
 0C62           ;                       child_responded = 1;
 0C62 560101            mov [X+1],1
 0C65 560000            mov [X+0],0
 0C68                   .dbline 1048
 0C68           ;               }
 0C68           L287:
 0C68                   .dbline 1049
 0C68           ;       }
 0C68           L285:
 0C68                   .dbline 1043
 0C68 3D0000            cmp [X+0],0
 0C6B B013              jnz L289
 0C6D 3D0100            cmp [X+1],0
 0C70 B00E              jnz L289
 0C72           X62:
 0C72 62D000            mov REG[0xd0],>_TIMEOUT
 0C75 3C0000            cmp [_TIMEOUT],0
 0C78 B006              jnz X63
 0C7A 3C0100            cmp [_TIMEOUT+1],0
 0C7D AFD4              jz L284
 0C7F           X63:
 0C7F           L289:
 0C7F                   .dbline 1052
 0C7F           ;       
 0C7F           ;       // Stop the right timer.
 0C7F           ;       if(CHILD == PORT_1)
 0C7F 62D000            mov REG[0xd0],>_CHILD
 0C82 3C0031            cmp [_CHILD],49
 0C85 B008              jnz L290
 0C87                   .dbline 1053
 0C87           ;       {
 0C87                   .dbline 1054
 0C87           ;               CHILD_1_TIMEOUT_Stop();
 0C87 10                push X
 0C88 7C0000            xcall _CHILD_1_TIMEOUT_Stop
 0C8B 20                pop X
 0C8C                   .dbline 1055
 0C8C           ;       }
 0C8C 802C              xjmp L291
 0C8E           L290:
 0C8E                   .dbline 1056
 0C8E           ;       else if(CHILD == PORT_2)
 0C8E 62D000            mov REG[0xd0],>_CHILD
 0C91 3C0032            cmp [_CHILD],50
 0C94 B008              jnz L292
 0C96                   .dbline 1057
 0C96           ;       {
 0C96                   .dbline 1058
 0C96           ;               CHILD_2_TIMEOUT_Stop();
 0C96 10                push X
 0C97 7C0000            xcall _CHILD_2_TIMEOUT_Stop
 0C9A 20                pop X
 0C9B                   .dbline 1059
 0C9B           ;       }
 0C9B 801D              xjmp L293
 0C9D           L292:
 0C9D                   .dbline 1060
 0C9D           ;       else if(CHILD == PORT_3)
 0C9D 62D000            mov REG[0xd0],>_CHILD
 0CA0 3C0033            cmp [_CHILD],51
 0CA3 B008              jnz L294
 0CA5                   .dbline 1061
 0CA5           ;       {
 0CA5                   .dbline 1062
 0CA5           ;               CHILD_3_TIMEOUT_Stop();
 0CA5 10                push X
 0CA6 7C0000            xcall _CHILD_3_TIMEOUT_Stop
 0CA9 20                pop X
 0CAA                   .dbline 1063
 0CAA           ;       }
 0CAA 800E              xjmp L295
 0CAC           L294:
 0CAC                   .dbline 1064
 0CAC           ;       else if(CHILD == PORT_4)
 0CAC 62D000            mov REG[0xd0],>_CHILD
 0CAF 3C0034            cmp [_CHILD],52
 0CB2 B006              jnz L296
 0CB4                   .dbline 1065
 0CB4           ;       {
 0CB4                   .dbline 1066
 0CB4           ;               CHILD_4_TIMEOUT_Stop();
 0CB4 10                push X
 0CB5 7C0000            xcall _CHILD_4_TIMEOUT_Stop
 0CB8 20                pop X
 0CB9                   .dbline 1067
 0CB9           ;       }
 0CB9           L296:
 0CB9           L295:
 0CB9           L293:
 0CB9           L291:
 0CB9                   .dbline 1069
 0CB9           ;       
 0CB9           ;       TIMEOUT = 0;                                    // Reset the timeout flag.
 0CB9 62D000            mov REG[0xd0],>_TIMEOUT
 0CBC 550100            mov [_TIMEOUT+1],0
 0CBF 550000            mov [_TIMEOUT],0
 0CC2                   .dbline 1071
 0CC2           ;       
 0CC2           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0CC2 5000              mov A,0
 0CC4 08                push A
 0CC5 5001              mov A,1
 0CC7 08                push A
 0CC8 7C00B5            xcall _configToggle
 0CCB 38FE              add SP,-2
 0CCD                   .dbline 1073
 0CCD           ;       
 0CCD           ;       return child_responded;
 0CCD 62D000            mov REG[0xd0],>__r0
 0CD0 5201              mov A,[X+1]
 0CD2 5300              mov [__r1],A
 0CD4 5200              mov A,[X+0]
 0CD6 5300              mov [__r0],A
 0CD8                   .dbline -2
 0CD8           L275:
 0CD8 38FE              add SP,-2
 0CDA 20                pop X
 0CDB                   .dbline 0 ; func end
 0CDB 7F                ret
 0CDC                   .dbsym l child_responded 0 I
 0CDC                   .dbend
 0CDC                   .dbfunc e servoFinder _servoFinder fV
 0CDC           ;     flashWrite -> X+5
 0CDC           ; status_return_level -> X+4
 0CDC           ;              j -> X+2
 0CDC           ;              i -> X+0
 0CDC           _servoFinder::
 0CDC                   .dbline -1
 0CDC 10                push X
 0CDD 4F                mov X,SP
 0CDE 3807              add SP,7
 0CE0                   .dbline 1080
 0CE0           ; }
 0CE0           ; 
 0CE0           ; // This function is used to find the servo that is directly connected to this module's controller.
 0CE0           ; // After the servo ID is found, the status return level is changed so that packets are only
 0CE0           ; // returned for the desired status return level defined at the top of this file.
 0CE0           ; void servoFinder(void)
 0CE0           ; {                             
 0CE0                   .dbline 1082
 0CE0           ;       // Index variables for incrementing and checking against the maximum servo comm attempts.
 0CE0           ;       int i = 0;
 0CE0 560100            mov [X+1],0
 0CE3 560000            mov [X+0],0
 0CE6                   .dbline 1083
 0CE6           ;       int j = 0;
 0CE6 560300            mov [X+3],0
 0CE9 560200            mov [X+2],0
 0CEC                   .dbline 1086
 0CEC           ;       
 0CEC           ;       // Integer used as a flag so that EEPROM writes aren't done more than once.
 0CEC           ;       int flashWrite = 0;
 0CEC 560600            mov [X+6],0
 0CEF 560500            mov [X+5],0
 0CF2                   .dbline 1089
 0CF2           ;       
 0CF2           ;       // Create a status return level variable and set it to an out of range value initially.
 0CF2           ;       char status_return_level = 3;
 0CF2 560403            mov [X+4],3
 0CF5                   .dbline 1092
 0CF5           ;       
 0CF5           ;       // Start with a servo ID of 255 (out of valid range).
 0CF5           ;       SERVO_ID = SERVO_START;
 0CF5 62D000            mov REG[0xd0],>_SERVO_ID
 0CF8 5500FF            mov [_SERVO_ID],-1
 0CFB                   .dbline 1101
 0CFB           ; 
 0CFB           ;       // This for loop will loop SERVO_COMM_LOOPS number of times and ping the servo SERVO_COMM_ATTEMPTS
 0CFB           ;       // number of times in each loop (unless stopped short due to early success). If this fails for the
 0CFB           ;       // first round of pings, a broadcast reset will be performed to reset the servo. This is done
 0CFB           ;       // because we assume that the baud rate is matching up, but the servo's return delay time is too
 0CFB           ;       // fast for the controller to switch into receive mode to read the response. The default return
 0CFB           ;       // delay time is 500 microseconds. If we loop for SERVO_COMM_LOOPS number of times and still don't
 0CFB           ;       // see anything, we assume that there is something is too wrong for us to fix.
 0CFB           ;       for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0CFB 560300            mov [X+3],0
 0CFE 560200            mov [X+2],0
 0D01           L299:
 0D01                   .dbline 1102
 0D01           ;       {       
 0D01                   .dbline 1104
 0D01           ;               // Ping SERVO_COMM_ATTEMPTS times to try and extract the servo ID.
 0D01           ;               for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0D01 560100            mov [X+1],0
 0D04 560000            mov [X+0],0
 0D07           L303:
 0D07                   .dbline 1105
 0D07           ;               {
 0D07                   .dbline 1107
 0D07           ;                       // Send a ping out for any servo connected to me (will only be one).
 0D07           ;                       servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
 0D07 5000              mov A,0
 0D09 08                push A
 0D0A 08                push A
 0D0B 5001              mov A,1
 0D0D 08                push A
 0D0E 5002              mov A,2
 0D10 08                push A
 0D11 50FE              mov A,-2
 0D13 08                push A
 0D14 9180              xcall _servoInstruction
 0D16 38FB              add SP,-5
 0D18 804C              xjmp L308
 0D1A           L307:
 0D1A                   .dbline 1111
 0D1A           ;                       
 0D1A           ;                       // Wait for either a timeout or a valid servo ID (which will trigger a timeout).
 0D1A           ;                       while(!TIMEOUT)
 0D1A           ;                       {       
 0D1A                   .dbline 1112
 0D1A           ;                               if(commandReady())
 0D1A 7C02BF            xcall _commandReady
 0D1D 62D000            mov REG[0xd0],>__r0
 0D20 3C0000            cmp [__r0],0
 0D23 B006              jnz X64
 0D25 3C0000            cmp [__r1],0
 0D28 A03C              jz L310
 0D2A           X64:
 0D2A                   .dbline 1113
 0D2A           ;                               {
 0D2A                   .dbline 1115
 0D2A           ;                                       // If we read a source ID within the range, exit the loop.
 0D2A           ;                                       if((COMMAND_SOURCE >= SERVO_ID_MIN) && (COMMAND_SOURCE <= SERVO_ID_MAX))
 0D2A 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0D2D 3C0000            cmp [_COMMAND_SOURCE],0
 0D30 C02B              jc L312
 0D32           X65:
 0D32 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0D35 50FD              mov A,-3
 0D37 3A00              cmp A,[_COMMAND_SOURCE]
 0D39 C022              jc L312
 0D3B           X66:
 0D3B                   .dbline 1116
 0D3B           ;                                       {       
 0D3B                   .dbline 1118
 0D3B           ;                                               // Exit this while loop by setting the timeout flag.
 0D3B           ;                                               TIMEOUT = 1;
 0D3B 62D000            mov REG[0xd0],>_TIMEOUT
 0D3E 550101            mov [_TIMEOUT+1],1
 0D41 550000            mov [_TIMEOUT],0
 0D44                   .dbline 1120
 0D44           ;                                               // Set the servo ID variable to where the ping came from.
 0D44           ;                                               SERVO_ID = COMMAND_SOURCE;
 0D44 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0D47 5100              mov A,[_COMMAND_SOURCE]
 0D49 62D000            mov REG[0xd0],>_SERVO_ID
 0D4C 5300              mov [_SERVO_ID],A
 0D4E                   .dbline 1122
 0D4E           ;                                               // Set the index variable such that the for loop exits.
 0D4E           ;                                               i = SERVO_COMM_ATTEMPTS;
 0D4E 560103            mov [X+1],3
 0D51 560000            mov [X+0],0
 0D54                   .dbline 1124
 0D54           ;                                               // Set the outer index variable to 2 to not attempt again for no reason.
 0D54           ;                                               j = SERVO_COMM_LOOPS;
 0D54 560302            mov [X+3],2
 0D57 560200            mov [X+2],0
 0D5A                   .dbline 1125
 0D5A           ;                                       }
 0D5A 800A              xjmp L313
 0D5C           L312:
 0D5C                   .dbline 1127
 0D5C           ;                                       else
 0D5C           ;                                       {
 0D5C                   .dbline 1129
 0D5C           ;                                               // Exit this while loop and try to ping again.
 0D5C           ;                                               TIMEOUT = 1;
 0D5C 62D000            mov REG[0xd0],>_TIMEOUT
 0D5F 550101            mov [_TIMEOUT+1],1
 0D62 550000            mov [_TIMEOUT],0
 0D65                   .dbline 1130
 0D65           ;                                       }
 0D65           L313:
 0D65                   .dbline 1131
 0D65           ;                               }
 0D65           L310:
 0D65                   .dbline 1132
 0D65           ;                       }
 0D65           L308:
 0D65                   .dbline 1110
 0D65 62D000            mov REG[0xd0],>_TIMEOUT
 0D68 3C0000            cmp [_TIMEOUT],0
 0D6B B006              jnz X67
 0D6D 3C0100            cmp [_TIMEOUT+1],0
 0D70 AFA9              jz L307
 0D72           X67:
 0D72                   .dbline 1133
 0D72           ;               }
 0D72           L304:
 0D72                   .dbline 1104
 0D72 7701              inc [X+1]
 0D74 0F0000            adc [X+0],0
 0D77                   .dbline 1104
 0D77 5201              mov A,[X+1]
 0D79 1103              sub A,3
 0D7B 5200              mov A,[X+0]
 0D7D 3180              xor A,-128
 0D7F 1980              sbb A,(0 ^ 0x80)
 0D81 CF85              jc L303
 0D83           X68:
 0D83                   .dbline 1137
 0D83           ;               
 0D83           ;               // If we didn't get a response and haven't written to the flash of the
 0D83           ;               // servo (first time through), send out a broadcast reset.
 0D83           ;               if((SERVO_ID == SERVO_START) && (!flashWrite))
 0D83 62D000            mov REG[0xd0],>_SERVO_ID
 0D86 3C00FF            cmp [_SERVO_ID],-1
 0D89 B022              jnz L314
 0D8B 3D0500            cmp [X+5],0
 0D8E B01D              jnz L314
 0D90 3D0600            cmp [X+6],0
 0D93 B018              jnz L314
 0D95           X69:
 0D95                   .dbline 1138
 0D95           ;               {
 0D95                   .dbline 1140
 0D95           ;                       // Set the flash write flag so that we only do this once per power cycle.
 0D95           ;                       flashWrite = 1;
 0D95 560601            mov [X+6],1
 0D98 560500            mov [X+5],0
 0D9B                   .dbline 1144
 0D9B           ;                       
 0D9B           ;                       // Send out a broadcast reset so that we know that the response time interval
 0D9B           ;                       // is large enough (default delay time for a servo is 500 microseconds).
 0D9B           ;                       servoInstruction(BROADCAST, RESET_LENGTH, RESET_SERVO, 0, 0);
 0D9B 5000              mov A,0
 0D9D 08                push A
 0D9E 08                push A
 0D9F 5006              mov A,6
 0DA1 08                push A
 0DA2 5002              mov A,2
 0DA4 08                push A
 0DA5 50FE              mov A,-2
 0DA7 08                push A
 0DA8 90EC              xcall _servoInstruction
 0DAA 38FB              add SP,-5
 0DAC                   .dbline 1145
 0DAC           ;               }
 0DAC           L314:
 0DAC                   .dbline 1146
 0DAC           ;       }
 0DAC           L300:
 0DAC                   .dbline 1101
 0DAC 7703              inc [X+3]
 0DAE 0F0200            adc [X+2],0
 0DB1                   .dbline 1101
 0DB1 5203              mov A,[X+3]
 0DB3 1102              sub A,2
 0DB5 5202              mov A,[X+2]
 0DB7 3180              xor A,-128
 0DB9 1980              sbb A,(0 ^ 0x80)
 0DBB CF45              jc L299
 0DBD           X70:
 0DBD                   .dbline 1149
 0DBD           ; 
 0DBD           ;       // Reset flash write flag.
 0DBD           ;       flashWrite = 0;
 0DBD 560600            mov [X+6],0
 0DC0 560500            mov [X+5],0
 0DC3                   .dbline 1153
 0DC3           ;       
 0DC3           ;       // If we have a valid servo ID, set the status return level. If we don't, just skip this
 0DC3           ;       // because all hope is lost.
 0DC3           ;       if(SERVO_ID < BROADCAST)
 0DC3 62D000            mov REG[0xd0],>_SERVO_ID
 0DC6 3C00FE            cmp [_SERVO_ID],-2
 0DC9 D0C6              jnc L316
 0DCB           X71:
 0DCB                   .dbline 1154
 0DCB           ;       {
 0DCB                   .dbline 1159
 0DCB           ;               // This for loop will loop SERVO_COMM_LOOPS number of times and poll for the servo's status
 0DCB           ;               // return level SERVO_COMM_ATTEMPTS number of times in each loop (unless stopped short due
 0DCB           ;               // to early success). If this fails for the first iteration, or we read a status return level
 0DCB           ;               // other than what we want, we will attempt to write the desired status return level onto the servo.
 0DCB           ;               for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0DCB 560300            mov [X+3],0
 0DCE 560200            mov [X+2],0
 0DD1           L318:
 0DD1                   .dbline 1160
 0DD1           ;               {
 0DD1                   .dbline 1162
 0DD1           ;                       // Attempt to read the status return level for the defined number of attempts.
 0DD1           ;                       for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0DD1 560100            mov [X+1],0
 0DD4 560000            mov [X+0],0
 0DD7           L322:
 0DD7                   .dbline 1163
 0DD7           ;                       {
 0DD7                   .dbline 1165
 0DD7           ;                               // Send a request for the servo's status return level.
 0DD7           ;                               servoInstruction(SERVO_ID, READ_LENGTH, READ_SERVO, STATUS_RET_ADDRESS, 1);
 0DD7 5001              mov A,1
 0DD9 08                push A
 0DDA 5010              mov A,16
 0DDC 08                push A
 0DDD 5002              mov A,2
 0DDF 08                push A
 0DE0 5004              mov A,4
 0DE2 08                push A
 0DE3 62D000            mov REG[0xd0],>_SERVO_ID
 0DE6 5100              mov A,[_SERVO_ID]
 0DE8 08                push A
 0DE9 90AB              xcall _servoInstruction
 0DEB 38FB              add SP,-5
 0DED 8048              xjmp L327
 0DEF           L326:
 0DEF                   .dbline 1169
 0DEF           ;                               
 0DEF           ;                               // Wait for either a timeout or an indication that we want to exit the loop.
 0DEF           ;                               while(!TIMEOUT)
 0DEF           ;                               {
 0DEF                   .dbline 1171
 0DEF           ;                                       // If a valid command is ready, interpret it.
 0DEF           ;                                       if(commandReady())
 0DEF 7C02BF            xcall _commandReady
 0DF2 62D000            mov REG[0xd0],>__r0
 0DF5 3C0000            cmp [__r0],0
 0DF8 B006              jnz X72
 0DFA 3C0000            cmp [__r1],0
 0DFD A038              jz L329
 0DFF           X72:
 0DFF                   .dbline 1172
 0DFF           ;                                       {
 0DFF                   .dbline 1173
 0DFF           ;                                               if(!COMMAND_ERROR)
 0DFF 62D000            mov REG[0xd0],>_COMMAND_ERROR
 0E02 3C0000            cmp [_COMMAND_ERROR],0
 0E05 B030              jnz L331
 0E07                   .dbline 1174
 0E07           ;                                               {
 0E07                   .dbline 1176
 0E07           ;                                                       // If the return level is equal to what is desired, store it.
 0E07           ;                                                       if(COMMAND_PARAM == STATUS_RET_LEVEL)
 0E07 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0E0A 3C0001            cmp [_COMMAND_PARAM],1
 0E0D B01F              jnz L333
 0E0F                   .dbline 1177
 0E0F           ;                                                       {
 0E0F                   .dbline 1179
 0E0F           ;                                                               // Set the timeout flag to exit the loop.
 0E0F           ;                                                               TIMEOUT = 1;
 0E0F 62D000            mov REG[0xd0],>_TIMEOUT
 0E12 550101            mov [_TIMEOUT+1],1
 0E15 550000            mov [_TIMEOUT],0
 0E18                   .dbline 1181
 0E18           ;                                                               // Store the status return level.
 0E18           ;                                                               status_return_level = COMMAND_PARAM;
 0E18 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0E1B 5100              mov A,[_COMMAND_PARAM]
 0E1D 5404              mov [X+4],A
 0E1F                   .dbline 1183
 0E1F           ;                                                               // Set i so that we exit the for loop.
 0E1F           ;                                                               i = SERVO_COMM_ATTEMPTS;
 0E1F 560103            mov [X+1],3
 0E22 560000            mov [X+0],0
 0E25                   .dbline 1185
 0E25           ;                                                               // Set the outer loop's variable so that we don't loop again.
 0E25           ;                                                               j = SERVO_COMM_LOOPS;
 0E25 560302            mov [X+3],2
 0E28 560200            mov [X+2],0
 0E2B                   .dbline 1186
 0E2B           ;                                                       }
 0E2B 800A              xjmp L334
 0E2D           L333:
 0E2D                   .dbline 1188
 0E2D           ;                                                       else
 0E2D           ;                                                       {       
 0E2D                   .dbline 1190
 0E2D           ;                                                               // Set the timeout flag to exit the loop.
 0E2D           ;                                                               TIMEOUT = 1;
 0E2D 62D000            mov REG[0xd0],>_TIMEOUT
 0E30 550101            mov [_TIMEOUT+1],1
 0E33 550000            mov [_TIMEOUT],0
 0E36                   .dbline 1191
 0E36           ;                                                       }
 0E36           L334:
 0E36                   .dbline 1192
 0E36           ;                                               }
 0E36           L331:
 0E36                   .dbline 1193
 0E36           ;                                       }
 0E36           L329:
 0E36                   .dbline 1194
 0E36           ;                               }
 0E36           L327:
 0E36                   .dbline 1168
 0E36 62D000            mov REG[0xd0],>_TIMEOUT
 0E39 3C0000            cmp [_TIMEOUT],0
 0E3C B006              jnz X73
 0E3E 3C0100            cmp [_TIMEOUT+1],0
 0E41 AFAD              jz L326
 0E43           X73:
 0E43                   .dbline 1195
 0E43           ;                       }
 0E43           L323:
 0E43                   .dbline 1162
 0E43 7701              inc [X+1]
 0E45 0F0000            adc [X+0],0
 0E48                   .dbline 1162
 0E48 5201              mov A,[X+1]
 0E4A 1103              sub A,3
 0E4C 5200              mov A,[X+0]
 0E4E 3180              xor A,-128
 0E50 1980              sbb A,(0 ^ 0x80)
 0E52 CF84              jc L322
 0E54           X74:
 0E54                   .dbline 1199
 0E54           ;               
 0E54           ;                       // If we didn't get a good response and haven't written to the flash of the servo,
 0E54           ;                       // force a change in the status return level with an EEPROM write.
 0E54           ;                       if((status_return_level != STATUS_RET_LEVEL) && (!flashWrite))
 0E54 3D0401            cmp [X+4],1
 0E57 A027              jz L335
 0E59 3D0500            cmp [X+5],0
 0E5C B022              jnz L335
 0E5E 3D0600            cmp [X+6],0
 0E61 B01D              jnz L335
 0E63           X75:
 0E63                   .dbline 1200
 0E63           ;                       {       
 0E63                   .dbline 1201
 0E63           ;                               flashWrite = 1;
 0E63 560601            mov [X+6],1
 0E66 560500            mov [X+5],0
 0E69                   .dbline 1204
 0E69           ;                               
 0E69           ;                               // Try to force the return status to what we want.
 0E69           ;                               servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, STATUS_RET_ADDRESS, STATUS_RET_LEVEL);
 0E69 5001              mov A,1
 0E6B 08                push A
 0E6C 5010              mov A,16
 0E6E 08                push A
 0E6F 5003              mov A,3
 0E71 08                push A
 0E72 5004              mov A,4
 0E74 08                push A
 0E75 62D000            mov REG[0xd0],>_SERVO_ID
 0E78 5100              mov A,[_SERVO_ID]
 0E7A 08                push A
 0E7B 9019              xcall _servoInstruction
 0E7D 38FB              add SP,-5
 0E7F                   .dbline 1205
 0E7F           ;                       }
 0E7F           L335:
 0E7F                   .dbline 1206
 0E7F           ;               }
 0E7F           L319:
 0E7F                   .dbline 1159
 0E7F 7703              inc [X+3]
 0E81 0F0200            adc [X+2],0
 0E84                   .dbline 1159
 0E84 5203              mov A,[X+3]
 0E86 1102              sub A,2
 0E88 5202              mov A,[X+2]
 0E8A 3180              xor A,-128
 0E8C 1980              sbb A,(0 ^ 0x80)
 0E8E CF42              jc L318
 0E90           X76:
 0E90                   .dbline 1207
 0E90           ;       }
 0E90           L316:
 0E90                   .dbline 1210
 0E90           ;       
 0E90           ;       // Wait for the other controllers to find their servos.
 0E90           ;       servoConfigWait();
 0E90 9155              xcall _servoConfigWait
 0E92                   .dbline -2
 0E92           L298:
 0E92 38F9              add SP,-7
 0E94 20                pop X
 0E95                   .dbline 0 ; func end
 0E95 7F                ret
 0E96                   .dbsym l flashWrite 5 I
 0E96                   .dbsym l status_return_level 4 c
 0E96                   .dbsym l j 2 I
 0E96                   .dbsym l i 0 I
 0E96                   .dbend
 0E96                   .dbfunc e servoInstruction _servoInstruction fV
 0E96           ;       checksum -> X+0
 0E96           ;          value -> X-8
 0E96           ;        address -> X-7
 0E96           ;    instruction -> X-6
 0E96           ;         length -> X-5
 0E96           ;             id -> X-4
 0E96           _servoInstruction::
 0E96                   .dbline -1
 0E96 10                push X
 0E97 4F                mov X,SP
 0E98 3801              add SP,1
 0E9A                   .dbline 1216
 0E9A           ; }
 0E9A           ; 
 0E9A           ; // This function receives a destination, command length, instruction type, address, and value.
 0E9A           ; // With these parameters, the function sends a packet to the communication bus.
 0E9A           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 0E9A           ; {
 0E9A                   .dbline 1220
 0E9A           ;       char checksum;
 0E9A           ;       
 0E9A           ;       // Toggle into transmit mode.
 0E9A           ;       configToggle(SERVO_COMM);
 0E9A 5000              mov A,0
 0E9C 08                push A
 0E9D 5009              mov A,9
 0E9F 08                push A
 0EA0 7C00B5            xcall _configToggle
 0EA3 38FE              add SP,-2
 0EA5                   .dbline 1223
 0EA5           ;       
 0EA5           ;       // Calculate the checksum value for our servo communication.
 0EA5           ;       checksum = 255-((id + length + instruction + address + value)%256);
 0EA5 62D000            mov REG[0xd0],>__r0
 0EA8 52FB              mov A,[X-5]
 0EAA 5300              mov [__r1],A
 0EAC 550000            mov [__r0],0
 0EAF 52FC              mov A,[X-4]
 0EB1 0200              add A,[__r1]
 0EB3 5300              mov [__r1],A
 0EB5 5000              mov A,0
 0EB7 0A00              adc A,[__r0]
 0EB9 5300              mov [__r0],A
 0EBB 52FA              mov A,[X-6]
 0EBD 0400              add [__r1],A
 0EBF 0E0000            adc [__r0],0
 0EC2 52F9              mov A,[X-7]
 0EC4 0400              add [__r1],A
 0EC6 0E0000            adc [__r0],0
 0EC9 52F8              mov A,[X-8]
 0ECB 0400              add [__r1],A
 0ECD 0E0000            adc [__r0],0
 0ED0 5001              mov A,1
 0ED2 08                push A
 0ED3 5000              mov A,0
 0ED5 08                push A
 0ED6 5100              mov A,[__r0]
 0ED8 08                push A
 0ED9 5100              mov A,[__r1]
 0EDB 08                push A
 0EDC 7C0000            xcall __divmod_16X16_16
 0EDF 38FE              add SP,-2
 0EE1 18                pop A
 0EE2 5300              mov [__r1],A
 0EE4 18                pop A
 0EE5 50FF              mov A,-1
 0EE7 1200              sub A,[__r1]
 0EE9 5400              mov [X+0],A
 0EEB                   .dbline 1226
 0EEB           ;       
 0EEB           ;       // Talk to the servo.
 0EEB           ;       if(instruction == PING_SERVO)
 0EEB 3DFA01            cmp [X-6],1
 0EEE B02D              jnz L338
 0EF0                   .dbline 1227
 0EF0           ;       {
 0EF0                   .dbline 1228
 0EF0           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte one
 0EF0 10                push X
 0EF1 50FF              mov A,-1
 0EF3 7C0000            xcall _SERVO_TX_PutChar
 0EF6 20                pop X
 0EF7                   .dbline 1229
 0EF7           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte two
 0EF7 10                push X
 0EF8 50FF              mov A,-1
 0EFA 7C0000            xcall _SERVO_TX_PutChar
 0EFD 20                pop X
 0EFE                   .dbline 1230
 0EFE           ;               SERVO_TX_PutChar(id);                   // Servo ID
 0EFE 10                push X
 0EFF 52FC              mov A,[X-4]
 0F01 7C0000            xcall _SERVO_TX_PutChar
 0F04 20                pop X
 0F05                   .dbline 1231
 0F05           ;               SERVO_TX_PutChar(length);               // The instruction length.
 0F05 10                push X
 0F06 52FB              mov A,[X-5]
 0F08 7C0000            xcall _SERVO_TX_PutChar
 0F0B 20                pop X
 0F0C                   .dbline 1232
 0F0C           ;               SERVO_TX_PutChar(instruction);  // The instruction to carry out.
 0F0C 10                push X
 0F0D 52FA              mov A,[X-6]
 0F0F 7C0000            xcall _SERVO_TX_PutChar
 0F12 20                pop X
 0F13                   .dbline 1233
 0F13           ;               SERVO_TX_PutChar(checksum);             // This is the checksum.
 0F13 10                push X
 0F14 5200              mov A,[X+0]
 0F16 7C0000            xcall _SERVO_TX_PutChar
 0F19 20                pop X
 0F1A                   .dbline 1234
 0F1A           ;       }
 0F1A 8039              xjmp L341
 0F1C           L338:
 0F1C                   .dbline 1236
 0F1C           ;       else
 0F1C           ;       {
 0F1C                   .dbline 1237
 0F1C           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte one
 0F1C 10                push X
 0F1D 50FF              mov A,-1
 0F1F 7C0000            xcall _SERVO_TX_PutChar
 0F22 20                pop X
 0F23                   .dbline 1238
 0F23           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte two
 0F23 10                push X
 0F24 50FF              mov A,-1
 0F26 7C0000            xcall _SERVO_TX_PutChar
 0F29 20                pop X
 0F2A                   .dbline 1239
 0F2A           ;               SERVO_TX_PutChar(id);                   // Servo ID
 0F2A 10                push X
 0F2B 52FC              mov A,[X-4]
 0F2D 7C0000            xcall _SERVO_TX_PutChar
 0F30 20                pop X
 0F31                   .dbline 1240
 0F31           ;               SERVO_TX_PutChar(length);               // The instruction length.
 0F31 10                push X
 0F32 52FB              mov A,[X-5]
 0F34 7C0000            xcall _SERVO_TX_PutChar
 0F37 20                pop X
 0F38                   .dbline 1241
 0F38           ;               SERVO_TX_PutChar(instruction);  // The instruction to carry out.
 0F38 10                push X
 0F39 52FA              mov A,[X-6]
 0F3B 7C0000            xcall _SERVO_TX_PutChar
 0F3E 20                pop X
 0F3F                   .dbline 1242
 0F3F           ;               SERVO_TX_PutChar(address);              // The address to read/write from/to.
 0F3F 10                push X
 0F40 52F9              mov A,[X-7]
 0F42 7C0000            xcall _SERVO_TX_PutChar
 0F45 20                pop X
 0F46                   .dbline 1243
 0F46           ;               SERVO_TX_PutChar(value);                // The value to write or number of bytes to read.
 0F46 10                push X
 0F47 52F8              mov A,[X-8]
 0F49 7C0000            xcall _SERVO_TX_PutChar
 0F4C 20                pop X
 0F4D                   .dbline 1244
 0F4D           ;               SERVO_TX_PutChar(checksum);             // This is the checksum.
 0F4D 10                push X
 0F4E 5200              mov A,[X+0]
 0F50 7C0000            xcall _SERVO_TX_PutChar
 0F53 20                pop X
 0F54                   .dbline 1245
 0F54           ;       }
 0F54           L340:
 0F54                   .dbline 1248
 0F54           ;       
 0F54           ;       // Wait for the transmission to finish.
 0F54           ;       while(!(SERVO_TX_bReadTxStatus() & SERVO_TX_TX_COMPLETE));
 0F54           L341:
 0F54                   .dbline 1248
 0F54 10                push X
 0F55 7C0000            xcall _SERVO_TX_bReadTxStatus
 0F58 62D000            mov REG[0xd0],>__r0
 0F5B 20                pop X
 0F5C 5300              mov [__r0],A
 0F5E 470020            tst [__r0],32
 0F61 AFF2              jz L340
 0F63                   .dbline 1251
 0F63           ;       
 0F63           ;       // Make completely sure we're done.
 0F63           ;       xmitWait();
 0F63 900F              xcall _xmitWait
 0F65                   .dbline 1254
 0F65           ;       
 0F65           ;       // Switch back to wait for a servo response.
 0F65           ;       configToggle(INITIALIZE);
 0F65 5000              mov A,0
 0F67 08                push A
 0F68 5008              mov A,8
 0F6A 08                push A
 0F6B 7C00B5            xcall _configToggle
 0F6E 38FE              add SP,-2
 0F70                   .dbline -2
 0F70           L337:
 0F70 38FF              add SP,-1
 0F72 20                pop X
 0F73                   .dbline 0 ; func end
 0F73 7F                ret
 0F74                   .dbsym l checksum 0 c
 0F74                   .dbsym l value -8 c
 0F74                   .dbsym l address -7 c
 0F74                   .dbsym l instruction -6 c
 0F74                   .dbsym l length -5 c
 0F74                   .dbsym l id -4 c
 0F74                   .dbend
 0F74                   .dbfunc e xmitWait _xmitWait fV
 0F74           ;              i -> X+0
 0F74           _xmitWait::
 0F74                   .dbline -1
 0F74 10                push X
 0F75 4F                mov X,SP
 0F76 3802              add SP,2
 0F78                   .dbline 1260
 0F78           ; }
 0F78           ; 
 0F78           ; // This function is used in various ways to create a period of nothingness. Mostly,
 0F78           ; // it is used to allow the controller enough time to transmit bytes (as its name suggests).
 0F78           ; void xmitWait(void)
 0F78           ; {
 0F78                   .dbline 1263
 0F78           ;       int i;
 0F78           ;       
 0F78           ;       for(i = 0; i < 25; i++)
 0F78 560100            mov [X+1],0
 0F7B 560000            mov [X+0],0
 0F7E           L344:
 0F7E                   .dbline 1264
 0F7E           ;       {
 0F7E                   .dbline 1266
 0F7E           ;               // Does nothing and wastes approximately 50 microseconds.
 0F7E           ;       }
 0F7E           L345:
 0F7E                   .dbline 1263
 0F7E 7701              inc [X+1]
 0F80 0F0000            adc [X+0],0
 0F83                   .dbline 1263
 0F83 5201              mov A,[X+1]
 0F85 1119              sub A,25
 0F87 5200              mov A,[X+0]
 0F89 3180              xor A,-128
 0F8B 1980              sbb A,(0 ^ 0x80)
 0F8D CFF0              jc L344
 0F8F           X77:
 0F8F                   .dbline -2
 0F8F           L343:
 0F8F 38FE              add SP,-2
 0F91 20                pop X
 0F92                   .dbline 0 ; func end
 0F92 7F                ret
 0F93                   .dbsym l i 0 I
 0F93                   .dbend
 0F93                   .dbfunc e servoBootWait _servoBootWait fV
 0F93           ;              i -> X+0
 0F93           _servoBootWait::
 0F93                   .dbline -1
 0F93 10                push X
 0F94 4F                mov X,SP
 0F95 3802              add SP,2
 0F97                   .dbline 1274
 0F97           ; }
 0F97           ; 
 0F97           ; // This function wastes time while the servo that is attached to this controller boots up.
 0F97           ; // Once that happens, communications should happen quickly and reliably. The estimated boot
 0F97           ; // time in testing was approximately 120 ms. This means that the define SERVO_BOOT_TIMEOUTS
 0F97           ; // at the top must be a minimum of 60 since timeout periods are in 2 ms intervals.
 0F97           ; void servoBootWait(void)
 0F97           ; {
 0F97                   .dbline 1275
 0F97           ;       int i = 0;                                      // Index integer used for looping.
 0F97 560100            mov [X+1],0
 0F9A 560000            mov [X+0],0
 0F9D                   .dbline 1277
 0F9D           ; 
 0F9D           ;       configToggle(INITIALIZE);       // Switch to initialize mode to do this timeout routine.
 0F9D 5000              mov A,0
 0F9F 08                push A
 0FA0 5008              mov A,8
 0FA2 08                push A
 0FA3 7C00B5            xcall _configToggle
 0FA6 38FE              add SP,-2
 0FA8                   .dbline 1280
 0FA8           ;       
 0FA8           ;       // Loop and wait for enough timeouts to happen before we talk to the servo.
 0FA8           ;       for(i = 0; i < SERVO_BOOT_TIMEOUTS; i++)
 0FA8 560100            mov [X+1],0
 0FAB 560000            mov [X+0],0
 0FAE                   .dbline 1281
 0FAE           ;       {
 0FAE           L353:
 0FAE                   .dbline 1282
 0FAE           ;               while(!TIMEOUT) { }             // Do nothing while we wait for one timeout period.
 0FAE                   .dbline 1282
 0FAE           L354:
 0FAE                   .dbline 1282
 0FAE 62D000            mov REG[0xd0],>_TIMEOUT
 0FB1 3C0000            cmp [_TIMEOUT],0
 0FB4 B006              jnz X78
 0FB6 3C0100            cmp [_TIMEOUT+1],0
 0FB9 AFF4              jz L353
 0FBB           X78:
 0FBB                   .dbline 1283
 0FBB           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 0FBB 62D000            mov REG[0xd0],>_TIMEOUT
 0FBE 550100            mov [_TIMEOUT+1],0
 0FC1 550000            mov [_TIMEOUT],0
 0FC4                   .dbline 1284
 0FC4           ;       }
 0FC4           L350:
 0FC4                   .dbline 1280
 0FC4 7701              inc [X+1]
 0FC6 0F0000            adc [X+0],0
 0FC9                   .dbline 1280
 0FC9 5201              mov A,[X+1]
 0FCB 1164              sub A,100
 0FCD 5200              mov A,[X+0]
 0FCF 3180              xor A,-128
 0FD1 1980              sbb A,(0 ^ 0x80)
 0FD3 CFDA              jc L354
 0FD5           X79:
 0FD5                   .dbline 1286
 0FD5           ;       
 0FD5           ;       INIT_TIMEOUT_Stop();            // Stop the timeout timer.
 0FD5 10                push X
 0FD6 7C0000            xcall _INIT_TIMEOUT_Stop
 0FD9 20                pop X
 0FDA                   .dbline 1287
 0FDA           ;       TIMEOUT = 0;                            // Clear the timeout flag.
 0FDA 62D000            mov REG[0xd0],>_TIMEOUT
 0FDD 550100            mov [_TIMEOUT+1],0
 0FE0 550000            mov [_TIMEOUT],0
 0FE3                   .dbline -2
 0FE3           L348:
 0FE3 38FE              add SP,-2
 0FE5 20                pop X
 0FE6                   .dbline 0 ; func end
 0FE6 7F                ret
 0FE7                   .dbsym l i 0 I
 0FE7                   .dbend
 0FE7                   .dbfunc e servoConfigWait _servoConfigWait fV
 0FE7           ;              i -> X+0
 0FE7           _servoConfigWait::
 0FE7                   .dbline -1
 0FE7 10                push X
 0FE8 4F                mov X,SP
 0FE9 3802              add SP,2
 0FEB                   .dbline 1293
 0FEB           ; }
 0FEB           ; 
 0FEB           ; // Sits and spins for the amount of time it takes for a worst case scenario for setup time
 0FEB           ; // to take place. This allows all other modules to initialize.
 0FEB           ; void servoConfigWait(void)
 0FEB           ; {
 0FEB                   .dbline 1294
 0FEB           ;       int i = 0;                                      // Index integer for looping purposes.
 0FEB 560100            mov [X+1],0
 0FEE 560000            mov [X+0],0
 0FF1                   .dbline 1296
 0FF1           ;       
 0FF1           ;       configToggle(INITIALIZE);       // Switch to initialize mode to do this timeout routine.
 0FF1 5000              mov A,0
 0FF3 08                push A
 0FF4 5008              mov A,8
 0FF6 08                push A
 0FF7 7C00B5            xcall _configToggle
 0FFA 38FE              add SP,-2
 0FFC                   .dbline 1301
 0FFC           ;       
 0FFC           ;       // For SERVO_COMM_ATTEMPTS*SERVO_COMM_LOOPS cycles, let the other controllers find
 0FFC           ;       // their servos. The reason we loop this many times is to allow for a possible worst
 0FFC           ;       // case scenario of setup time to complete.
 0FFC           ;       for(i = 0; i < (SERVO_COMM_ATTEMPTS*SERVO_COMM_LOOPS); i++)
 0FFC 560100            mov [X+1],0
 0FFF 560000            mov [X+0],0
 1002                   .dbline 1302
 1002           ;       {
 1002           L361:
 1002                   .dbline 1303
 1002           ;               while(!TIMEOUT) { }             // Do nothing while we wait for one timeout period.
 1002                   .dbline 1303
 1002           L362:
 1002                   .dbline 1303
 1002 62D000            mov REG[0xd0],>_TIMEOUT
 1005 3C0000            cmp [_TIMEOUT],0
 1008 B006              jnz X80
 100A 3C0100            cmp [_TIMEOUT+1],0
 100D AFF4              jz L361
 100F           X80:
 100F                   .dbline 1304
 100F           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 100F 62D000            mov REG[0xd0],>_TIMEOUT
 1012 550100            mov [_TIMEOUT+1],0
 1015 550000            mov [_TIMEOUT],0
 1018                   .dbline 1305
 1018           ;       }
 1018           L358:
 1018                   .dbline 1301
 1018 7701              inc [X+1]
 101A 0F0000            adc [X+0],0
 101D                   .dbline 1301
 101D 5201              mov A,[X+1]
 101F 1106              sub A,6
 1021 5200              mov A,[X+0]
 1023 3180              xor A,-128
 1025 1980              sbb A,(0 ^ 0x80)
 1027 CFDA              jc L362
 1029           X81:
 1029                   .dbline 1307
 1029           ;       
 1029           ;       INIT_TIMEOUT_Stop();            // Stop the timer.
 1029 10                push X
 102A 7C0000            xcall _INIT_TIMEOUT_Stop
 102D 20                pop X
 102E                   .dbline 1308
 102E           ;       TIMEOUT = 0;                            // Reset the timeout flag.
 102E 62D000            mov REG[0xd0],>_TIMEOUT
 1031 550100            mov [_TIMEOUT+1],0
 1034 550000            mov [_TIMEOUT],0
 1037                   .dbline 1310
 1037           ; 
 1037           ;       configToggle(WAIT);                     // Switch to wait for the master node to speak to you.
 1037 5000              mov A,0
 1039 08                push A
 103A 5001              mov A,1
 103C 08                push A
 103D 7C00B5            xcall _configToggle
 1040 38FE              add SP,-2
 1042                   .dbline -2
 1042           L356:
 1042 38FE              add SP,-2
 1044 20                pop X
 1045                   .dbline 0 ; func end
 1045 7F                ret
 1046                   .dbsym l i 0 I
 1046                   .dbend
 1046                   .dbfunc e TX_01234_TIMEOUT_ISR _TX_01234_TIMEOUT_ISR fV
 1046           _TX_01234_TIMEOUT_ISR::
 1046                   .dbline -1
 1046 71C0              or F,-64
 1048 08                push A
 1049 5DD0              mov A,REG[0xd0]
 104B 08                push A
 104C                   .dbline 1318
 104C           ; }
 104C           ; 
 104C           ; // This timeout ISR is for waiting before a transmission is made from this module.
 104C           ; // This is to give all the other modules a chance to set up and clear their buffers.
 104C           ; // It is currently set so that there is 1 ms of down time between the last transmission
 104C           ; // and this module's transmission.
 104C           ; void TX_01234_TIMEOUT_ISR(void)
 104C           ; {
 104C                   .dbline 1319
 104C           ;       TIMEOUT = 1;    // Set the timeout flag.
 104C 62D000            mov REG[0xd0],>_TIMEOUT
 104F 550101            mov [_TIMEOUT+1],1
 1052 550000            mov [_TIMEOUT],0
 1055                   .dbline 1320
 1055           ;       M8C_ClearIntFlag(INT_CLR0,TX_01234_TIMEOUT_INT_MASK);
 1055 62DAFD            mov REG[0xda],-3
 1058                   .dbline -2
 1058           L364:
 1058 18                pop A
 1059 60D0              mov REG[208],A
 105B 18                pop A
 105C                   .dbline 0 ; func end
 105C 7E                reti
 105D                   .dbend
 105D                   .dbfunc e HELLO_TIMEOUT_ISR _HELLO_TIMEOUT_ISR fV
 105D           _HELLO_TIMEOUT_ISR::
 105D                   .dbline -1
 105D 71C0              or F,-64
 105F 08                push A
 1060 5DD0              mov A,REG[0xd0]
 1062 08                push A
 1063                   .dbline 1325
 1063           ; }
 1063           ; 
 1063           ; // This is the ISR for a hello response timeout.
 1063           ; void HELLO_TIMEOUT_ISR(void)
 1063           ; {
 1063                   .dbline 1326
 1063           ;       TIMEOUT = 1;    // Set the timeout flag.
 1063 62D000            mov REG[0xd0],>_TIMEOUT
 1066 550101            mov [_TIMEOUT+1],1
 1069 550000            mov [_TIMEOUT],0
 106C                   .dbline 1327
 106C           ;       M8C_ClearIntFlag(INT_CLR0,HELLO_TIMEOUT_INT_MASK);
 106C 62DAFD            mov REG[0xda],-3
 106F                   .dbline -2
 106F           L365:
 106F 18                pop A
 1070 60D0              mov REG[208],A
 1072 18                pop A
 1073                   .dbline 0 ; func end
 1073 7E                reti
 1074                   .dbend
 1074                   .dbfunc e CHILD_1_TIMEOUT_ISR _CHILD_1_TIMEOUT_ISR fV
 1074           _CHILD_1_TIMEOUT_ISR::
 1074                   .dbline -1
 1074 71C0              or F,-64
 1076 08                push A
 1077 5DD0              mov A,REG[0xd0]
 1079 08                push A
 107A                   .dbline 1332
 107A           ; }
 107A           ; 
 107A           ; // These remaining ISRs are for all the child timeout scenarios.
 107A           ; void CHILD_1_TIMEOUT_ISR(void)
 107A           ; {
 107A                   .dbline 1333
 107A           ;       TIMEOUT = 1;    // Set the timeout flag.
 107A 62D000            mov REG[0xd0],>_TIMEOUT
 107D 550101            mov [_TIMEOUT+1],1
 1080 550000            mov [_TIMEOUT],0
 1083                   .dbline 1334
 1083           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_1_TIMEOUT_INT_MASK);
 1083 62DAFD            mov REG[0xda],-3
 1086                   .dbline -2
 1086           L366:
 1086 18                pop A
 1087 60D0              mov REG[208],A
 1089 18                pop A
 108A                   .dbline 0 ; func end
 108A 7E                reti
 108B                   .dbend
 108B                   .dbfunc e CHILD_2_TIMEOUT_ISR _CHILD_2_TIMEOUT_ISR fV
 108B           _CHILD_2_TIMEOUT_ISR::
 108B                   .dbline -1
 108B 71C0              or F,-64
 108D 08                push A
 108E 5DD0              mov A,REG[0xd0]
 1090 08                push A
 1091                   .dbline 1338
 1091           ; }
 1091           ; 
 1091           ; void CHILD_2_TIMEOUT_ISR(void)
 1091           ; {
 1091                   .dbline 1339
 1091           ;       TIMEOUT = 1;    // Set the timeout flag.
 1091 62D000            mov REG[0xd0],>_TIMEOUT
 1094 550101            mov [_TIMEOUT+1],1
 1097 550000            mov [_TIMEOUT],0
 109A                   .dbline 1340
 109A           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_2_TIMEOUT_INT_MASK);
 109A 62DAFD            mov REG[0xda],-3
 109D                   .dbline -2
 109D           L367:
 109D 18                pop A
 109E 60D0              mov REG[208],A
 10A0 18                pop A
 10A1                   .dbline 0 ; func end
 10A1 7E                reti
 10A2                   .dbend
 10A2                   .dbfunc e CHILD_3_TIMEOUT_ISR _CHILD_3_TIMEOUT_ISR fV
 10A2           _CHILD_3_TIMEOUT_ISR::
 10A2                   .dbline -1
 10A2 71C0              or F,-64
 10A4 08                push A
 10A5 5DD0              mov A,REG[0xd0]
 10A7 08                push A
 10A8                   .dbline 1344
 10A8           ; }
 10A8           ; 
 10A8           ; void CHILD_3_TIMEOUT_ISR(void)
 10A8           ; {
 10A8                   .dbline 1345
 10A8           ;       TIMEOUT = 1;    // Set the timeout flag.
 10A8 62D000            mov REG[0xd0],>_TIMEOUT
 10AB 550101            mov [_TIMEOUT+1],1
 10AE 550000            mov [_TIMEOUT],0
 10B1                   .dbline 1346
 10B1           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_3_TIMEOUT_INT_MASK);
 10B1 62DAFD            mov REG[0xda],-3
 10B4                   .dbline -2
 10B4           L368:
 10B4 18                pop A
 10B5 60D0              mov REG[208],A
 10B7 18                pop A
 10B8                   .dbline 0 ; func end
 10B8 7E                reti
 10B9                   .dbend
 10B9                   .dbfunc e CHILD_4_TIMEOUT_ISR _CHILD_4_TIMEOUT_ISR fV
 10B9           _CHILD_4_TIMEOUT_ISR::
 10B9                   .dbline -1
 10B9 71C0              or F,-64
 10BB 08                push A
 10BC 5DD0              mov A,REG[0xd0]
 10BE 08                push A
 10BF                   .dbline 1350
 10BF           ; }
 10BF           ; 
 10BF           ; void CHILD_4_TIMEOUT_ISR(void)
 10BF           ; {
 10BF                   .dbline 1351
 10BF           ;       TIMEOUT = 1;    // Set the timeout flag.
 10BF 62D000            mov REG[0xd0],>_TIMEOUT
 10C2 550101            mov [_TIMEOUT+1],1
 10C5 550000            mov [_TIMEOUT],0
 10C8                   .dbline 1352
 10C8           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_4_TIMEOUT_INT_MASK);
 10C8 62DAFD            mov REG[0xda],-3
 10CB                   .dbline -2
 10CB           L369:
 10CB 18                pop A
 10CC 60D0              mov REG[208],A
 10CE 18                pop A
 10CF                   .dbline 0 ; func end
 10CF 7E                reti
 10D0                   .dbend
 10D0                   .dbfunc e INIT_TIMEOUT_ISR _INIT_TIMEOUT_ISR fV
 10D0           _INIT_TIMEOUT_ISR::
 10D0                   .dbline -1
 10D0 71C0              or F,-64
 10D2 08                push A
 10D3 5DD0              mov A,REG[0xd0]
 10D5 08                push A
 10D6                   .dbline 1356
 10D6           ; }
 10D6           ; 
 10D6           ; void INIT_TIMEOUT_ISR(void)
 10D6           ; {
 10D6                   .dbline 1357
 10D6           ;       TIMEOUT = 1;    // Set the timeout flag.
 10D6 62D000            mov REG[0xd0],>_TIMEOUT
 10D9 550101            mov [_TIMEOUT+1],1
 10DC 550000            mov [_TIMEOUT],0
 10DF                   .dbline 1358
 10DF           ;       M8C_ClearIntFlag(INT_CLR0,INIT_TIMEOUT_INT_MASK);
 10DF 62DAFD            mov REG[0xda],-3
 10E2                   .dbline -2
 10E2           L370:
 10E2 18                pop A
 10E3 60D0              mov REG[208],A
 10E5 18                pop A
 10E6                   .dbline 0 ; func end
 10E6 7E                reti
 10E7                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _SERVO_ID::
 0000 00                .byte 0
 0001                   .dbsym e SERVO_ID _SERVO_ID c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_ERROR::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_ERROR _COMMAND_ERROR c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_LENGTH::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_LENGTH _COMMAND_LENGTH c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_PARAM::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_PARAM _COMMAND_PARAM c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _CONFIGURED::
 0000 0000              .byte 0,0
 0002                   .dbsym e CONFIGURED _CONFIGURED I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _ID::
 0000 00                .byte 0
 0001                   .dbsym e ID _ID c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _CHILD::
 0000 00                .byte 0
 0001                   .dbsym e CHILD _CHILD c
