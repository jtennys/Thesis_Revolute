 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 157
 0000           ; // Author: Jason Tennyson
 0000           ; // Date: 3-17-11
 0000           ; // File: main.c
 0000           ; //
 0000           ; // This is the design for the revolute modules for Jason Tennyson's Thesis.
 0000           ; // This design is made for a PSoC CY8C28433-24PVXI.
 0000           ; //
 0000           ; // Packet Structure
 0000           ; // ----------------
 0000           ; // START BYTE/START BYTE/SOURCE ID BYTE/DESTINATION ID BYTE/COMMAND TYPE/PARAM 1/.../PARAM N/END TRANSMIT
 0000           ; 
 0000           ; #include <m8c.h>              // Part-specific constants and macros.
 0000           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules.
 0000           ; #include "psocdynamic.h"      // Required for dynamically swapping configurations at run time.
 0000           ; 
 0000           ; // These are declarations of all of the timer interrupts that are used for all configurations.
 0000           ; #pragma interrupt_handler TX_01234_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_1_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_2_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_3_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler CHILD_4_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler HELLO_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler INIT_TIMEOUT_ISR
 0000           ; 
 0000           ; // These defines are used as parameters of the configToggle function.  Passing one of
 0000           ; // these identifiers to configToggle will put the chip in that device configuration.
 0000           ; #define               WAIT                                            (1)
 0000           ; #define               MY_RESPONSE                                     (2)
 0000           ; #define       RESPONSE_1                                      (3)
 0000           ; #define       RESPONSE_2                                      (4)
 0000           ; #define       RESPONSE_3                                      (5)
 0000           ; #define       RESPONSE_4                                      (6)
 0000           ; #define               HELLO_MODE                                      (7)
 0000           ; #define               INITIALIZE                                      (8)
 0000           ; #define               SERVO_COMM                                      (9)
 0000           ; 
 0000           ; // These defines are used as comparisons to find what port the next module connected to.
 0000           ; #define               PORT_1                                          ('1')
 0000           ; #define               PORT_2                                          ('2')
 0000           ; #define               PORT_3                                          ('3')
 0000           ; #define               PORT_4                                          ('4')
 0000           ; 
 0000           ; // Module Type
 0000           ; #define               TYPE                                            (1)
 0000           ; 
 0000           ; // These defines are used as transmission indicators for transmissions between PSoC controllers.
 0000           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0000           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0000           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0000           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0000           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is complete.
 0000           ; #define               PING                                            (203)   // Indicates a ping message to or from the master.
 0000           ; #define               CLEAR_CONFIG                            (204)   // Indicates that the master is asking for a config clear.
 0000           ; #define               CONFIG_CLEARED                          (205)   // Indicates that a module has cleared its own config.
 0000           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0000           ; #define               DEFAULT_ID                                      (251)   // The ID that all modules start with.
 0000           ; #define               BROADCAST                                       (254)   // The broadcast ID for all controllers and servos.
 0000           ; 
 0000           ; // SERVO DEFINES
 0000           ; // These numbers can all be found in the AX-12+ datasheet.
 0000           ; // These defines cover the range of IDs these servos are capable of.
 0000           ; #define               SERVO_ID_MIN                            (0)             // This is the lowest servo ID possible.
 0000           ; #define               SERVO_ID_MAX                            (253)   // This is the highest servo ID possible.
 0000           ; // These defines are servo transmission indicators.
 0000           ; #define               SERVO_START                                     (255)   // This is the start byte for a servo transmission.
 0000           ; // These defines are used to fill in the length parameter for a given command type.  These are the only
 0000           ; // lengths used by this controller for servo configuration purposes.  It is worth noting that any type
 0000           ; // and length of command can be issued from the master after configuration is complete.
 0000           ; #define               READ_LENGTH                                     (4)             // This is the length value for all reads.
 0000           ; #define               WRITE_LENGTH                            (4)             // This is the length value for all writes.
 0000           ; #define               PING_LENGTH                                     (2)             // This is the length value for a ping.
 0000           ; #define               RESET_LENGTH                            (2)             // This is the length value for a reset.
 0000           ; // These defines are used to fill in the servo's EEPROM address parameter for a given command type.
 0000           ; #define               ID_ADDRESS                                      (3)             // This is the address where servo ID is stored.
 0000           ; #define               STATUS_RET_ADDRESS                      (16)    // This is where the status return level is stored.
 0000           ; // These defines are used to fill in the instruction we are using on the servo.
 0000           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0000           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0000           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0000           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0000           ; // These defines cover all of the status return level possibilities.
 0000           ; #define               STATUS_RET_NEVER                        (0)             // Only respond to ping commands.
 0000           ; #define               STATUS_RET_READ                         (1)             // Only respond to read data commands (recommended).
 0000           ; #define               STATUS_RET_ALL                          (2)             // Respond to every command.
 0000           ; 
 0000           ; // This is the number of attempts we make to contact the servo per sweep of attempts before
 0000           ; // writing to its EEPROM in an attempt to alter settings that keep us from communicating.
 0000           ; #define               SERVO_COMM_ATTEMPTS                     (10)
 0000           ; // This is the number of times we do a loop of SERVO_COMM_ATTEMPTS.  We would like this to be at least 2.
 0000           ; // This is because we do an EEPROM write after the first unsuccessful loop of SERVO_COMM_ATTEMPTS.
 0000           ; // If we don't then do at least one more loop, the EEPROM write was done for no reason.
 0000           ; #define               SERVO_COMM_LOOPS                        (2)
 0000           ; // This is the number of timeout periods to wait through while the servo boots up (2 ms per period).
 0000           ; #define               SERVO_BOOT_TIMEOUTS                     (75)
 0000           ; 
 0000           ; // This is the number of iterations we loop waiting for bytes to reset the timeout on a child response.
 0000           ; // This will be the amount of iterations we do after the last byte has been received as well.
 0000           ; #define               RESPONSE_ITERATIONS                     (10)
 0000           ; 
 0000           ; // This is the status return level, which is set to one of the possible status return values above.
 0000           ; // We want the status return level to be return on read commands only so that we don't have garbage
 0000           ; // return packets flying around every time we tell the servo to move.
 0000           ; #define               STATUS_RET_LEVEL                        (STATUS_RET_READ)
 0000           ; 
 0000           ; // This function receives a mode identifier as a parameter and toggles the system configuration.
 0000           ; void configToggle(int mode);
 0000           ; // This function unloads all configurations.  This should only be needed at startup.
 0000           ; void unloadAllConfigs(void);
 0000           ; // This function unloads the configuration corresponding to the number passed to it.
 0000           ; void unloadConfig(int config_num);
 0000           ; // This function is a response to the master sending out a hello message.
 0000           ; void sayHello(void);
 0000           ; // This function looks for commands and returns 1 if a command has been read, 0 if not.
 0000           ; int commandReady(void);
 0000           ; // This function interprets the command that has just been read and performs an action accordingly.
 0000           ; void takeAction(void);
 0000           ; // This function responds to a ping.
 0000           ; void pingResponse(void);
 0000           ; // This function tells the master node that an ID assignment was completed on this module.
 0000           ; void assignedID(void);
 0000           ; // This function sends out an acknowledgement of a configuration reset.
 0000           ; void configCleared(void);
 0000           ; // This function listens for children and registers the port that they talk to.
 0000           ; int childListen(void);
 0000           ; // This function waits for a known child's response to a command to that child from the master.
 0000           ; int childResponse(void);
 0000           ; // This function does everything it can to find the servo attached to this controller.
 0000           ; void servoFinder(void);
 0000           ; // This function carries out the passed servo instruction.
 0000           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0000           ; // This function does a simple for loop to stall and make doubly sure that the transmission finished.
 0000           ; // It is meant to be used as a definite amount of wait time after the transmission complete flag is set.
 0000           ; void xmitWait(void);
 0000           ; // This function is called to do nothing while we wait for the servo to boot up.
 0000           ; void servoBootWait(void);
 0000           ; // This function is used to wait for other controllers to find their servos while not
 0000           ; // driving any pins (which would keep a child from talking to its servo).
 0000           ; void servoConfigWait(void);
 0000           ; 
 0000           ; char CHILD;           // Keeps track of where the child is connected.
 0000           ; char ID;              // Stores the ID that the master gives this module.
 0000           ; 
 0000           ; int CONFIGURED;       // Keeps track of whether or not this module has been configured by the master.
 0000           ; int TIMEOUT;  // This flag is set if a timeout occurs.
 0000           ; int STATE;            // This stores the ID of the currently-loaded configuration.
 0000           ; 
 0000           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0000           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0000           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0000           ; char COMMAND_PARAM;                   // Stores a parameter that accompanies the command (if any).
 0000           ; char COMMAND_LENGTH;          // Stores the length parameter of a servo command.
 0000           ; char COMMAND_ERROR;                   // Stores the error code of a servo command.
 0000           ; 
 0000           ; char SERVO_ID;                                // Stores the ID of the servo inside of this module.
 0000           ; 
 0000           ; void main()
 0000           ; {     
 0000                   .dbline 159
 0000           ;       // Initial value assignment for variables of importance.
 0000           ;       CHILD = 0;                              // There is no child yet.
 0000 62D000            mov REG[0xd0],>_CHILD
 0003 550000            mov [_CHILD],0
 0006                   .dbline 160
 0006           ;       CONFIGURED = 0;                 // This module is not configured yet.
 0006 62D000            mov REG[0xd0],>_CONFIGURED
 0009 550100            mov [_CONFIGURED+1],0
 000C 550000            mov [_CONFIGURED],0
 000F                   .dbline 161
 000F           ;       TIMEOUT = 0;                    // Set the timeout flag low to start.
 000F 62D000            mov REG[0xd0],>_TIMEOUT
 0012 550100            mov [_TIMEOUT+1],0
 0015 550000            mov [_TIMEOUT],0
 0018                   .dbline 162
 0018           ;       COMMAND_PARAM = 0;              // There is no parameter yet.
 0018 62D000            mov REG[0xd0],>_COMMAND_PARAM
 001B 550000            mov [_COMMAND_PARAM],0
 001E                   .dbline 163
 001E           ;       STATE = 0;                              // There is no state yet.
 001E 62D000            mov REG[0xd0],>_STATE
 0021 550100            mov [_STATE+1],0
 0024 550000            mov [_STATE],0
 0027                   .dbline 164
 0027           ;       ID = DEFAULT_ID;                // Set the ID of this controller to the default to start with.
 0027 62D000            mov REG[0xd0],>_ID
 002A 5500FB            mov [_ID],-5
 002D                   .dbline 166
 002D           ; 
 002D           ;       M8C_EnableGInt;                 // Turn on global interrupts for the transmission timeout timer.
 002D 7101                      or  F, 01h
 002F           
 002F                   .dbline 168
 002F           ;       
 002F           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); // Activate GPIO ISR
 002F 43E020            or REG[0xe0],32
 0032                   .dbline 171
 0032           ;       
 0032           ;       // We have to wait for the servo to power up and get ready for communications.
 0032           ;       servoBootWait();
 0032 7C0F82            xcall _servoBootWait
 0035                   .dbline 174
 0035           ;       
 0035           ;       // Find the servo that is inside of this module.
 0035           ;       servoFinder();
 0035 7C0CB7            xcall _servoFinder
 0038 8012              xjmp L3
 003A           L2:
 003A                   .dbline 178
 003A           ;       
 003A           ;       // Loop and wait for commands.
 003A           ;       while(1)
 003A           ;       {       
 003A                   .dbline 179
 003A           ;               if(commandReady())
 003A 9282              xcall _commandReady
 003C 62D000            mov REG[0xd0],>__r0
 003F 3C0000            cmp [__r0],0
 0042 B006              jnz X1
 0044 3C0000            cmp [__r1],0
 0047 A003              jz L5
 0049           X1:
 0049                   .dbline 180
 0049           ;               {
 0049                   .dbline 182
 0049           ;                       // If the command is ready, take action.
 0049           ;                       takeAction();
 0049 9655              xcall _takeAction
 004B                   .dbline 183
 004B           ;               }
 004B           L5:
 004B                   .dbline 184
 004B           ;       }
 004B           L3:
 004B                   .dbline 177
 004B 8FEE              xjmp L2
 004D           X0:
 004D                   .dbline -2
 004D           L1:
 004D                   .dbline 0 ; func end
 004D 8FFF              jmp .
 004F                   .dbend
 004F                   .dbfunc e sayHello _sayHello fV
 004F           _sayHello::
 004F                   .dbline -1
 004F                   .dbline 189
 004F           ; }
 004F           ; 
 004F           ; // This function transmits a response to a hello command from the master.
 004F           ; void sayHello(void)
 004F           ; {     
 004F                   .dbline 190
 004F           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 004F 5000              mov A,0
 0051 08                push A
 0052 5002              mov A,2
 0054 08                push A
 0055 905D              xcall _configToggle
 0057 38FE              add SP,-2
 0059                   .dbline 193
 0059           ;       
 0059           ;       // Transmit a hello response to the master node.
 0059           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 0059 10                push X
 005A 50FC              mov A,-4
 005C 7C0000            xcall _TX_014_PutChar
 005F 20                pop X
 0060                   .dbline 194
 0060           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 0060 10                push X
 0061 50FC              mov A,-4
 0063 7C0000            xcall _TX_014_PutChar
 0066 20                pop X
 0067                   .dbline 195
 0067           ;       TX_014_PutChar(ID);                             // My ID (source)
 0067 10                push X
 0068 62D000            mov REG[0xd0],>_ID
 006B 5100              mov A,[_ID]
 006D 7C0000            xcall _TX_014_PutChar
 0070 20                pop X
 0071                   .dbline 196
 0071           ;       TX_014_PutChar(MASTER_ID);              // Master ID (destination)
 0071 10                push X
 0072 5000              mov A,0
 0074 7C0000            xcall _TX_014_PutChar
 0077 20                pop X
 0078                   .dbline 197
 0078           ;       TX_014_PutChar(HELLO_BYTE);             // This is a hello command.
 0078 10                push X
 0079 50C8              mov A,-56
 007B 7C0000            xcall _TX_014_PutChar
 007E 20                pop X
 007F                   .dbline 198
 007F           ;       TX_014_PutChar(CHILD);                  // Sends child port value, default 0.
 007F 10                push X
 0080 62D000            mov REG[0xd0],>_CHILD
 0083 5100              mov A,[_CHILD]
 0085 7C0000            xcall _TX_014_PutChar
 0088 20                pop X
 0089                   .dbline 199
 0089           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission.
 0089 10                push X
 008A 50FD              mov A,-3
 008C 7C0000            xcall _TX_014_PutChar
 008F 20                pop X
 0090                   .dbline 200
 0090           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission.
 0090 10                push X
 0091 50FD              mov A,-3
 0093 7C0000            xcall _TX_014_PutChar
 0096 20                pop X
 0097           L8:
 0097                   .dbline 203
 0097           ;       
 0097           ;       // Wait for the transmission to finish.
 0097           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0097           L9:
 0097                   .dbline 203
 0097 10                push X
 0098 7C0000            xcall _TX_014_bReadTxStatus
 009B 62D000            mov REG[0xd0],>__r0
 009E 20                pop X
 009F 5300              mov [__r0],A
 00A1 470020            tst [__r0],32
 00A4 AFF2              jz L8
 00A6                   .dbline 206
 00A6           ;       
 00A6           ;       // Make completely sure we're done.
 00A6           ;       xmitWait();
 00A6 7C0F63            xcall _xmitWait
 00A9                   .dbline 208
 00A9           ; 
 00A9           ;       configToggle(WAIT);                             // Switch back to wait mode.
 00A9 5000              mov A,0
 00AB 08                push A
 00AC 5001              mov A,1
 00AE 08                push A
 00AF 9003              xcall _configToggle
 00B1 38FE              add SP,-2
 00B3                   .dbline -2
 00B3           L7:
 00B3                   .dbline 0 ; func end
 00B3 7F                ret
 00B4                   .dbend
 00B4                   .dbfunc e configToggle _configToggle fV
 00B4           ;           mode -> X-5
 00B4           _configToggle::
 00B4                   .dbline -1
 00B4 10                push X
 00B5 4F                mov X,SP
 00B6                   .dbline 214
 00B6           ; }
 00B6           ; 
 00B6           ; // This function receives a mode flag and switches the microcontroller to the
 00B6           ; // desired hardware configuration.
 00B6           ; void configToggle(int mode)
 00B6           ; {     
 00B6                   .dbline 217
 00B6           ;       // Set the pins high and disconnect from the global bus.
 00B6           ;       // This keeps false start bits from happening while we swap configs.
 00B6           ;       PRT0DR |= 0b00011111;   // Set pins P00 through P04 high.
 00B6 43001F            or REG[0],31
 00B9                   .dbline 218
 00B9           ;       PRT0GS &= 0b11100000;   // Disconnect pins P00 through P04 from the global bus.
 00B9 4102E0            and REG[0x2],-32
 00BC                   .dbline 222
 00BC           ;       
 00BC           ;       // Unload the configuration of the current state.
 00BC           ;       // If there is no state, blindly wipe all configurations.
 00BC           ;       if(STATE)
 00BC 62D000            mov REG[0xd0],>_STATE
 00BF 3C0000            cmp [_STATE],0
 00C2 B006              jnz X2
 00C4 3C0100            cmp [_STATE+1],0
 00C7 A011              jz L12
 00C9           X2:
 00C9                   .dbline 223
 00C9           ;       {
 00C9                   .dbline 224
 00C9           ;               unloadConfig(STATE);
 00C9 62D000            mov REG[0xd0],>_STATE
 00CC 5100              mov A,[_STATE]
 00CE 08                push A
 00CF 5101              mov A,[_STATE+1]
 00D1 08                push A
 00D2 7C0A4F            xcall _unloadConfig
 00D5 38FE              add SP,-2
 00D7                   .dbline 225
 00D7           ;       }
 00D7 8004              xjmp L13
 00D9           L12:
 00D9                   .dbline 227
 00D9           ;       else
 00D9           ;       {
 00D9                   .dbline 228
 00D9           ;               unloadAllConfigs();
 00D9 7C0A33            xcall _unloadAllConfigs
 00DC                   .dbline 229
 00DC           ;       }
 00DC           L13:
 00DC                   .dbline 233
 00DC           ;       
 00DC           ;       // Go through the list of possible modes until we find the one that was passed in to us.
 00DC           ;       // Then, load that configuration and initialize whatever needs to be initialized.
 00DC           ;       if(mode == WAIT)
 00DC 3DFB00            cmp [X-5],0
 00DF B022              jnz L14
 00E1 3DFC01            cmp [X-4],1
 00E4 B01D              jnz L14
 00E6           X3:
 00E6                   .dbline 234
 00E6           ;       {
 00E6                   .dbline 237
 00E6           ;               // Load the wait receiver configuration.  This is the receiver configuration used after
 00E6           ;               // initialization is complete.  It listens and forwards everything it hears.
 00E6           ;               LoadConfig_waiting();
 00E6 7C0000            xcall _LoadConfig_waiting
 00E9                   .dbline 240
 00E9           ;               
 00E9           ;               // Start the receivers.
 00E9           ;               WAIT_RECV_Start(WAIT_RECV_PARITY_NONE);
 00E9 10                push X
 00EA 5000              mov A,0
 00EC 7C0000            xcall _WAIT_RECV_Start
 00EF 20                pop X
 00F0                   .dbline 241
 00F0           ;               RX8_2_Start(RX8_2_PARITY_NONE);
 00F0 10                push X
 00F1 5000              mov A,0
 00F3 7C0000            xcall _RX8_2_Start
 00F6 20                pop X
 00F7                   .dbline 244
 00F7           ;               
 00F7           ;               // Set the current state.
 00F7           ;               STATE = WAIT;
 00F7 62D000            mov REG[0xd0],>_STATE
 00FA 550101            mov [_STATE+1],1
 00FD 550000            mov [_STATE],0
 0100                   .dbline 245
 0100           ;       }
 0100 81A0              xjmp L15
 0102           L14:
 0102                   .dbline 246
 0102           ;       else if(mode == MY_RESPONSE)
 0102 3DFB00            cmp [X-5],0
 0105 B04C              jnz L16
 0107 3DFC02            cmp [X-4],2
 010A B047              jnz L16
 010C           X4:
 010C                   .dbline 247
 010C           ;       {
 010C                   .dbline 249
 010C           ;               // Load the transmitter configuration.  This is for transmitting messages on all ports.
 010C           ;               LoadConfig_my_response();
 010C 7C0000            xcall _LoadConfig_my_response
 010F                   .dbline 252
 010F           ;               
 010F           ;               // Clear the timeout flag.
 010F           ;               TIMEOUT = 0;
 010F 62D000            mov REG[0xd0],>_TIMEOUT
 0112 550100            mov [_TIMEOUT+1],0
 0115 550000            mov [_TIMEOUT],0
 0118                   .dbline 255
 0118           ;               
 0118           ;               // Start the transmitters.
 0118           ;               TX_014_Start(TX_014_PARITY_NONE);       // Transmits on P00, P01, and P04.
 0118 10                push X
 0119 5000              mov A,0
 011B 7C0000            xcall _TX_014_Start
 011E 20                pop X
 011F                   .dbline 256
 011F           ;               TX_23_Start(TX_23_PARITY_NONE);         // Transmits on P02 and P03.
 011F 10                push X
 0120 5000              mov A,0
 0122 7C0000            xcall _TX_23_Start
 0125                   .dbline 258
 0125           ;               
 0125           ;               TX_01234_TIMEOUT_EnableInt();           // Make sure interrupts are enabled.
 0125 7C0000            xcall _TX_01234_TIMEOUT_EnableInt
 0128                   .dbline 259
 0128           ;               TX_01234_TIMEOUT_Start();                       // Start the timer.
 0128 7C0000            xcall _TX_01234_TIMEOUT_Start
 012B 20                pop X
 012C           L18:
 012C                   .dbline 263
 012C           ;               
 012C           ;               // Do nothing while we wait for one timeout period (1 ms).
 012C           ;               // This is to allow everyone to get in the right configuration before talking.
 012C           ;               while(!TIMEOUT) { }
 012C                   .dbline 263
 012C           L19:
 012C                   .dbline 263
 012C 62D000            mov REG[0xd0],>_TIMEOUT
 012F 3C0000            cmp [_TIMEOUT],0
 0132 B006              jnz X5
 0134 3C0100            cmp [_TIMEOUT+1],0
 0137 AFF4              jz L18
 0139           X5:
 0139                   .dbline 265
 0139           ;               
 0139           ;               TX_01234_TIMEOUT_Stop();                        // Stop the timer.
 0139 10                push X
 013A 7C0000            xcall _TX_01234_TIMEOUT_Stop
 013D 20                pop X
 013E                   .dbline 266
 013E           ;               TIMEOUT = 0;                                            // Reset the timeout flag.
 013E 62D000            mov REG[0xd0],>_TIMEOUT
 0141 550100            mov [_TIMEOUT+1],0
 0144 550000            mov [_TIMEOUT],0
 0147                   .dbline 269
 0147           ;       
 0147           ;               // Set the current state.
 0147           ;               STATE = MY_RESPONSE;
 0147 62D000            mov REG[0xd0],>_STATE
 014A 550102            mov [_STATE+1],2
 014D 550000            mov [_STATE],0
 0150                   .dbline 270
 0150           ;       }
 0150 8150              xjmp L17
 0152           L16:
 0152                   .dbline 271
 0152           ;       else if(mode == RESPONSE_1)
 0152 3DFB00            cmp [X-5],0
 0155 B02A              jnz L21
 0157 3DFC03            cmp [X-4],3
 015A B025              jnz L21
 015C           X6:
 015C                   .dbline 272
 015C           ;       {
 015C                   .dbline 274
 015C           ;               // Load the response wait on port 1.
 015C           ;               LoadConfig_response1();
 015C 7C0000            xcall _LoadConfig_response1
 015F                   .dbline 277
 015F           ;               
 015F           ;               // Clear the timeout flag.
 015F           ;               TIMEOUT = 0;
 015F 62D000            mov REG[0xd0],>_TIMEOUT
 0162 550100            mov [_TIMEOUT+1],0
 0165 550000            mov [_TIMEOUT],0
 0168                   .dbline 280
 0168           ;               
 0168           ;               // Start listening for a response through child port 1.
 0168           ;               CHILD_1_Start(CHILD_1_PARITY_NONE);
 0168 10                push X
 0169 5000              mov A,0
 016B 7C0000            xcall _CHILD_1_Start
 016E                   .dbline 282
 016E           ;               
 016E           ;               CHILD_1_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 016E 7C0000            xcall _CHILD_1_TIMEOUT_EnableInt
 0171                   .dbline 283
 0171           ;               CHILD_1_TIMEOUT_Start();                        // Start the timer.
 0171 7C0000            xcall _CHILD_1_TIMEOUT_Start
 0174 20                pop X
 0175                   .dbline 286
 0175           ;               
 0175           ;               // Set the current state.
 0175           ;               STATE = RESPONSE_1;
 0175 62D000            mov REG[0xd0],>_STATE
 0178 550103            mov [_STATE+1],3
 017B 550000            mov [_STATE],0
 017E                   .dbline 287
 017E           ;       }
 017E 8122              xjmp L22
 0180           L21:
 0180                   .dbline 288
 0180           ;       else if(mode == RESPONSE_2)
 0180 3DFB00            cmp [X-5],0
 0183 B02A              jnz L23
 0185 3DFC04            cmp [X-4],4
 0188 B025              jnz L23
 018A           X7:
 018A                   .dbline 289
 018A           ;       {
 018A                   .dbline 291
 018A           ;               // Load the response wait on port 2.
 018A           ;               LoadConfig_response2();
 018A 7C0000            xcall _LoadConfig_response2
 018D                   .dbline 294
 018D           ;               
 018D           ;               // Clear the timeout flag.
 018D           ;               TIMEOUT = 0;
 018D 62D000            mov REG[0xd0],>_TIMEOUT
 0190 550100            mov [_TIMEOUT+1],0
 0193 550000            mov [_TIMEOUT],0
 0196                   .dbline 297
 0196           ;               
 0196           ;               // Start listening for a response through child port 2.
 0196           ;               CHILD_2_Start(CHILD_2_PARITY_NONE);
 0196 10                push X
 0197 5000              mov A,0
 0199 7C0000            xcall _CHILD_2_Start
 019C                   .dbline 299
 019C           ;               
 019C           ;               CHILD_2_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 019C 7C0000            xcall _CHILD_2_TIMEOUT_EnableInt
 019F                   .dbline 300
 019F           ;               CHILD_2_TIMEOUT_Start();                        // Start the timer.
 019F 7C0000            xcall _CHILD_2_TIMEOUT_Start
 01A2 20                pop X
 01A3                   .dbline 303
 01A3           ;               
 01A3           ;               // Set the current state.
 01A3           ;               STATE = RESPONSE_2;
 01A3 62D000            mov REG[0xd0],>_STATE
 01A6 550104            mov [_STATE+1],4
 01A9 550000            mov [_STATE],0
 01AC                   .dbline 304
 01AC           ;       }
 01AC 80F4              xjmp L24
 01AE           L23:
 01AE                   .dbline 305
 01AE           ;       else if(mode == RESPONSE_3)
 01AE 3DFB00            cmp [X-5],0
 01B1 B02A              jnz L25
 01B3 3DFC05            cmp [X-4],5
 01B6 B025              jnz L25
 01B8           X8:
 01B8                   .dbline 306
 01B8           ;       {
 01B8                   .dbline 308
 01B8           ;               // Load the response wait on port 3.
 01B8           ;               LoadConfig_response3();
 01B8 7C0000            xcall _LoadConfig_response3
 01BB                   .dbline 311
 01BB           ;               
 01BB           ;               // Clear the timeout flag.
 01BB           ;               TIMEOUT = 0;
 01BB 62D000            mov REG[0xd0],>_TIMEOUT
 01BE 550100            mov [_TIMEOUT+1],0
 01C1 550000            mov [_TIMEOUT],0
 01C4                   .dbline 314
 01C4           ;               
 01C4           ;               // Start listening for a response through child port 3.
 01C4           ;               CHILD_3_Start(CHILD_3_PARITY_NONE);
 01C4 10                push X
 01C5 5000              mov A,0
 01C7 7C0000            xcall _CHILD_3_Start
 01CA                   .dbline 316
 01CA           ;               
 01CA           ;               CHILD_3_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 01CA 7C0000            xcall _CHILD_3_TIMEOUT_EnableInt
 01CD                   .dbline 317
 01CD           ;               CHILD_3_TIMEOUT_Start();                        // Start the timer.
 01CD 7C0000            xcall _CHILD_3_TIMEOUT_Start
 01D0 20                pop X
 01D1                   .dbline 320
 01D1           ;               
 01D1           ;               // Set the current state.
 01D1           ;               STATE = RESPONSE_3;
 01D1 62D000            mov REG[0xd0],>_STATE
 01D4 550105            mov [_STATE+1],5
 01D7 550000            mov [_STATE],0
 01DA                   .dbline 321
 01DA           ;       }
 01DA 80C6              xjmp L26
 01DC           L25:
 01DC                   .dbline 322
 01DC           ;       else if(mode == RESPONSE_4)
 01DC 3DFB00            cmp [X-5],0
 01DF B02A              jnz L27
 01E1 3DFC06            cmp [X-4],6
 01E4 B025              jnz L27
 01E6           X9:
 01E6                   .dbline 323
 01E6           ;       {
 01E6                   .dbline 325
 01E6           ;               // Load the response wait on port 4.
 01E6           ;               LoadConfig_response4();
 01E6 7C0000            xcall _LoadConfig_response4
 01E9                   .dbline 328
 01E9           ;               
 01E9           ;               // Clear the timeout flag.
 01E9           ;               TIMEOUT = 0;
 01E9 62D000            mov REG[0xd0],>_TIMEOUT
 01EC 550100            mov [_TIMEOUT+1],0
 01EF 550000            mov [_TIMEOUT],0
 01F2                   .dbline 331
 01F2           ;               
 01F2           ;               // Start listening for a response through child port 4.
 01F2           ;               CHILD_4_Start(CHILD_4_PARITY_NONE);
 01F2 10                push X
 01F3 5000              mov A,0
 01F5 7C0000            xcall _CHILD_4_Start
 01F8                   .dbline 333
 01F8           ;               
 01F8           ;               CHILD_4_TIMEOUT_EnableInt();            // Make sure interrupts are enabled.
 01F8 7C0000            xcall _CHILD_4_TIMEOUT_EnableInt
 01FB                   .dbline 334
 01FB           ;               CHILD_4_TIMEOUT_Start();                        // Start the timer.
 01FB 7C0000            xcall _CHILD_4_TIMEOUT_Start
 01FE 20                pop X
 01FF                   .dbline 337
 01FF           ;               
 01FF           ;               // Set the current state.
 01FF           ;               STATE = RESPONSE_4;
 01FF 62D000            mov REG[0xd0],>_STATE
 0202 550106            mov [_STATE+1],6
 0205 550000            mov [_STATE],0
 0208                   .dbline 338
 0208           ;       }
 0208 8098              xjmp L28
 020A           L27:
 020A                   .dbline 339
 020A           ;       else if(mode == HELLO_MODE)
 020A 3DFB00            cmp [X-5],0
 020D B03F              jnz L29
 020F 3DFC07            cmp [X-4],7
 0212 B03A              jnz L29
 0214           X10:
 0214                   .dbline 340
 0214           ;       {
 0214                   .dbline 342
 0214           ;               // Load the hello wait mode.  This is for listening on all ports for a hello response.
 0214           ;               LoadConfig_hello();
 0214 7C0000            xcall _LoadConfig_hello
 0217                   .dbline 345
 0217           ;               
 0217           ;               // Clear the timeout flag.
 0217           ;               TIMEOUT = 0;
 0217 62D000            mov REG[0xd0],>_TIMEOUT
 021A 550100            mov [_TIMEOUT+1],0
 021D 550000            mov [_TIMEOUT],0
 0220                   .dbline 349
 0220           ;               
 0220           ;               // The seemingly unnecessary brackets around each line are unfortunately needed.
 0220           ;       
 0220           ;               {
 0220                   .dbline 351
 0220           ;               // Start listening for a response through child port 1.
 0220           ;               HELLO_1_Start(HELLO_1_PARITY_NONE);
 0220 10                push X
 0221 5000              mov A,0
 0223 7C0000            xcall _HELLO_1_Start
 0226 20                pop X
 0227                   .dbline 352
 0227           ;               }
 0227                   .dbline 354
 0227           ;               
 0227           ;               {
 0227                   .dbline 356
 0227           ;               // Start listening for a response through child port 2.
 0227           ;               HELLO_2_Start(HELLO_2_PARITY_NONE);
 0227 10                push X
 0228 5000              mov A,0
 022A 7C0000            xcall _HELLO_2_Start
 022D 20                pop X
 022E                   .dbline 357
 022E           ;               }
 022E                   .dbline 359
 022E           ;               
 022E           ;               {
 022E                   .dbline 361
 022E           ;               // Start listening for a response through child port 3.
 022E           ;               HELLO_3_Start(HELLO_3_PARITY_NONE);
 022E 10                push X
 022F 5000              mov A,0
 0231 7C0000            xcall _HELLO_3_Start
 0234 20                pop X
 0235                   .dbline 362
 0235           ;               }
 0235                   .dbline 364
 0235           ;               
 0235           ;               {
 0235                   .dbline 366
 0235           ;               // Start listening for a response through child port 4.
 0235           ;               HELLO_4_Start(HELLO_4_PARITY_NONE);
 0235 10                push X
 0236 5000              mov A,0
 0238 7C0000            xcall _HELLO_4_Start
 023B                   .dbline 367
 023B           ;               }
 023B                   .dbline 369
 023B           ;               
 023B           ;               HELLO_TIMEOUT_EnableInt();      // Make sure interrupts are enabled.
 023B 7C0000            xcall _HELLO_TIMEOUT_EnableInt
 023E                   .dbline 370
 023E           ;               HELLO_TIMEOUT_Start();          // Start the timer.
 023E 7C0000            xcall _HELLO_TIMEOUT_Start
 0241 20                pop X
 0242                   .dbline 373
 0242           ;               
 0242           ;               // Set the current state.
 0242           ;               STATE = HELLO_MODE;
 0242 62D000            mov REG[0xd0],>_STATE
 0245 550107            mov [_STATE+1],7
 0248 550000            mov [_STATE],0
 024B                   .dbline 374
 024B           ;       }
 024B 8055              xjmp L30
 024D           L29:
 024D                   .dbline 375
 024D           ;       else if(mode == INITIALIZE)
 024D 3DFB00            cmp [X-5],0
 0250 B02A              jnz L31
 0252 3DFC08            cmp [X-4],8
 0255 B025              jnz L31
 0257           X11:
 0257                   .dbline 376
 0257           ;       {
 0257                   .dbline 378
 0257           ;               // Load the configuration for initialization.  This config listens but does not forward.
 0257           ;               LoadConfig_initial();
 0257 7C0000            xcall _LoadConfig_initial
 025A                   .dbline 381
 025A           ;               
 025A           ;               // Clear the timeout flag.
 025A           ;               TIMEOUT = 0;
 025A 62D000            mov REG[0xd0],>_TIMEOUT
 025D 550100            mov [_TIMEOUT+1],0
 0260 550000            mov [_TIMEOUT],0
 0263                   .dbline 384
 0263           ;               
 0263           ;               // Start the receiver.
 0263           ;               INIT_RX_Start(INIT_RX_PARITY_NONE);
 0263 10                push X
 0264 5000              mov A,0
 0266 7C0000            xcall _INIT_RX_Start
 0269                   .dbline 386
 0269           ;               
 0269           ;               INIT_TIMEOUT_EnableInt();       // Make sure interrupts are enabled.
 0269 7C0000            xcall _INIT_TIMEOUT_EnableInt
 026C                   .dbline 387
 026C           ;               INIT_TIMEOUT_Start();           // Start the timer.
 026C 7C0000            xcall _INIT_TIMEOUT_Start
 026F 20                pop X
 0270                   .dbline 390
 0270           ;               
 0270           ;               // Set the current state.
 0270           ;               STATE = INITIALIZE;
 0270 62D000            mov REG[0xd0],>_STATE
 0273 550108            mov [_STATE+1],8
 0276 550000            mov [_STATE],0
 0279                   .dbline 391
 0279           ;       }
 0279 8027              xjmp L32
 027B           L31:
 027B                   .dbline 392
 027B           ;       else if(mode == SERVO_COMM)
 027B 3DFB00            cmp [X-5],0
 027E B022              jnz L33
 0280 3DFC09            cmp [X-4],9
 0283 B01D              jnz L33
 0285           X12:
 0285                   .dbline 393
 0285           ;       {
 0285                   .dbline 395
 0285           ;               // Load the configuration for servo communication.  This config only transmits on P00.
 0285           ;               LoadConfig_servo_transmit();
 0285 7C0000            xcall _LoadConfig_servo_transmit
 0288                   .dbline 398
 0288           ;               
 0288           ;               // Clear the timeout flag.
 0288           ;               TIMEOUT = 0;
 0288 62D000            mov REG[0xd0],>_TIMEOUT
 028B 550100            mov [_TIMEOUT+1],0
 028E 550000            mov [_TIMEOUT],0
 0291                   .dbline 401
 0291           ;               
 0291           ;               // Start the transmitter.
 0291           ;               SERVO_TX_Start(SERVO_TX_PARITY_NONE);
 0291 10                push X
 0292 5000              mov A,0
 0294 7C0000            xcall _SERVO_TX_Start
 0297 20                pop X
 0298                   .dbline 404
 0298           ;       
 0298           ;               // Set the current state.
 0298           ;               STATE = SERVO_COMM;
 0298 62D000            mov REG[0xd0],>_STATE
 029B 550109            mov [_STATE+1],9
 029E 550000            mov [_STATE],0
 02A1                   .dbline 405
 02A1           ;       }
 02A1           L33:
 02A1           L32:
 02A1           L30:
 02A1           L28:
 02A1           L26:
 02A1           L24:
 02A1           L22:
 02A1           L17:
 02A1           L15:
 02A1                   .dbline 408
 02A1           ;       
 02A1           ;       // If this module is configured, talk on all pins for potential children.
 02A1           ;       if(CONFIGURED)
 02A1 62D000            mov REG[0xd0],>_CONFIGURED
 02A4 3C0000            cmp [_CONFIGURED],0
 02A7 B006              jnz X13
 02A9 3C0100            cmp [_CONFIGURED+1],0
 02AC A009              jz L35
 02AE           X13:
 02AE                   .dbline 409
 02AE           ;       {
 02AE                   .dbline 410
 02AE           ;               PRT0GS |= 0b00011111;   // Connect all pins to the global bus.
 02AE 43021F            or REG[0x2],31
 02B1                   .dbline 411
 02B1           ;               PRT2DR &= 0b11111110;   // Turn on the LED (active low).
 02B1 4108FE            and REG[0x8],-2
 02B4                   .dbline 412
 02B4           ;       }
 02B4 8007              xjmp L36
 02B6           L35:
 02B6                   .dbline 414
 02B6           ;       else
 02B6           ;       {
 02B6                   .dbline 415
 02B6           ;               PRT0GS |= 0b00000001;   // Just connect pin 0;
 02B6 430201            or REG[0x2],1
 02B9                   .dbline 416
 02B9           ;               PRT2DR |= 0b00000001;   // Turn off the LED (active low).
 02B9 430801            or REG[0x8],1
 02BC                   .dbline 417
 02BC           ;       }
 02BC           L36:
 02BC                   .dbline -2
 02BC           L11:
 02BC 20                pop X
 02BD                   .dbline 0 ; func end
 02BD 7F                ret
 02BE                   .dbsym l mode -5 I
 02BE                   .dbend
 02BE                   .dbfunc e commandReady _commandReady fI
 02BE           ;              i -> X+1
 02BE           ;       tempByte -> X+0
 02BE           _commandReady::
 02BE                   .dbline -1
 02BE 10                push X
 02BF 4F                mov X,SP
 02C0 3803              add SP,3
 02C2                   .dbline 424
 02C2           ; }
 02C2           ; 
 02C2           ; // This function tries to peek and see if a start byte has been written to the bus.
 02C2           ; // If there is no start byte, the function exits.  If a start byte is detected, the function
 02C2           ; // blocks and waits for the transmission to finish.
 02C2           ; int commandReady(void)
 02C2           ; {
 02C2                   .dbline 425
 02C2           ;       int i = 0;                      // This integer is used for looping through the remaining bytes of commands.
 02C2 560200            mov [X+2],0
 02C5 560100            mov [X+1],0
 02C8                   .dbline 426
 02C8           ;       char tempByte = 0;      // This byte is used to store each byte for comparison as it comes in.
 02C8 560000            mov [X+0],0
 02CB                   .dbline 430
 02CB           ;       
 02CB           ;       // This conditional checks which configuration is loaded and uses the proper devices to
 02CB           ;       // read a transmission and store the important information from that transmission.
 02CB           ;       if(STATE == WAIT)
 02CB 62D000            mov REG[0xd0],>_STATE
 02CE 3C0000            cmp [_STATE],0
 02D1 B0D4              jnz L38
 02D3 3C0101            cmp [_STATE+1],1
 02D6 B0CF              jnz L38
 02D8           X14:
 02D8                   .dbline 431
 02D8           ;       {       
 02D8                   .dbline 434
 02D8           ;               // In wait mode, the only thing that progresses things forward is a master node transmission.
 02D8           ;               // With this being the case, we use a blocking operation to sit and wait for a byte.
 02D8           ;               tempByte = WAIT_RECV_cGetChar();
 02D8 10                push X
 02D9 7C0000            xcall _WAIT_RECV_cGetChar
 02DC 62D000            mov REG[0xd0],>__r0
 02DF 20                pop X
 02E0 5400              mov [X+0],A
 02E2                   .dbline 437
 02E2           ;               
 02E2           ;               // If a transmission has started for either a controller or a servo...
 02E2           ;               if(tempByte == START_TRANSMIT)
 02E2 3D00FC            cmp [X+0],-4
 02E5 B047              jnz L40
 02E7                   .dbline 438
 02E7           ;               {
 02E7 800B              xjmp L43
 02E9           L42:
 02E9                   .dbline 441
 02E9           ;                       // While we keep reading start bytes, sit and spin.
 02E9           ;                       while(tempByte == START_TRANSMIT)
 02E9           ;                       {
 02E9                   .dbline 442
 02E9           ;                               tempByte = WAIT_RECV_cGetChar();
 02E9 10                push X
 02EA 7C0000            xcall _WAIT_RECV_cGetChar
 02ED 62D000            mov REG[0xd0],>__r0
 02F0 20                pop X
 02F1 5400              mov [X+0],A
 02F3                   .dbline 443
 02F3           ;                       }
 02F3           L43:
 02F3                   .dbline 440
 02F3 3D00FC            cmp [X+0],-4
 02F6 AFF2              jz L42
 02F8                   .dbline 446
 02F8           ;                       
 02F8           ;                       // The tempByte variable contains the source ID.  If the source is good, store all bytes.
 02F8           ;                       if(tempByte == MASTER_ID)
 02F8 3D0000            cmp [X+0],0
 02FB B397              jnz L39
 02FD                   .dbline 447
 02FD           ;                       {
 02FD                   .dbline 448
 02FD           ;                               COMMAND_SOURCE = tempByte;
 02FD 5200              mov A,[X+0]
 02FF 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0302 5300              mov [_COMMAND_SOURCE],A
 0304                   .dbline 449
 0304           ;                               COMMAND_DESTINATION = WAIT_RECV_cGetChar();
 0304 10                push X
 0305 7C0000            xcall _WAIT_RECV_cGetChar
 0308 20                pop X
 0309 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 030C 5300              mov [_COMMAND_DESTINATION],A
 030E                   .dbline 450
 030E           ;                               COMMAND_TYPE = WAIT_RECV_cGetChar();
 030E 10                push X
 030F 7C0000            xcall _WAIT_RECV_cGetChar
 0312 20                pop X
 0313 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0316 5300              mov [_COMMAND_TYPE],A
 0318                   .dbline 451
 0318           ;                               COMMAND_PARAM = WAIT_RECV_cGetChar();
 0318 10                push X
 0319 7C0000            xcall _WAIT_RECV_cGetChar
 031C 20                pop X
 031D 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0320 5300              mov [_COMMAND_PARAM],A
 0322                   .dbline 453
 0322           ;                               
 0322           ;                               return 1;
 0322 62D000            mov REG[0xd0],>__r0
 0325 550001            mov [__r1],1
 0328 550000            mov [__r0],0
 032B 8370              xjmp L37
 032D           L40:
 032D                   .dbline 456
 032D           ;                       }
 032D           ;               }
 032D           ;               else if(tempByte == SERVO_START)
 032D 3D00FF            cmp [X+0],-1
 0330 B362              jnz L39
 0332                   .dbline 457
 0332           ;               {
 0332 800B              xjmp L50
 0334           L49:
 0334                   .dbline 460
 0334           ;                       // While we keep reading start bytes, sit and spin.
 0334           ;                       while(tempByte == SERVO_START)
 0334           ;                       {
 0334                   .dbline 461
 0334           ;                               tempByte = WAIT_RECV_cGetChar();
 0334 10                push X
 0335 7C0000            xcall _WAIT_RECV_cGetChar
 0338 62D000            mov REG[0xd0],>__r0
 033B 20                pop X
 033C 5400              mov [X+0],A
 033E                   .dbline 462
 033E           ;                       }
 033E           L50:
 033E                   .dbline 459
 033E 3D00FF            cmp [X+0],-1
 0341 AFF2              jz L49
 0343                   .dbline 465
 0343           ;                       
 0343           ;                       // We assume (and hopefully rightly so) that this is a command from master.
 0343           ;                       COMMAND_SOURCE = MASTER_ID;
 0343 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0346 550000            mov [_COMMAND_SOURCE],0
 0349                   .dbline 467
 0349           ;                       // The first parameter after the servo start is the destination.
 0349           ;                       COMMAND_DESTINATION = tempByte;
 0349 5200              mov A,[X+0]
 034B 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 034E 5300              mov [_COMMAND_DESTINATION],A
 0350                   .dbline 472
 0350           ;                       // The second parameter after the servo start is the command length.
 0350           ;                       // We don't need it to wait for the transmission to go through since the
 0350           ;                       // transmission goes through the chip with a delay of approximately 100 ns
 0350           ;                       // (it is already in and out by the time you read this byte).
 0350           ;                       tempByte = WAIT_RECV_cGetChar();
 0350 10                push X
 0351 7C0000            xcall _WAIT_RECV_cGetChar
 0354 62D000            mov REG[0xd0],>__r0
 0357 20                pop X
 0358 5400              mov [X+0],A
 035A                   .dbline 475
 035A           ;                       // Now we store the command type.  Depending on what the status return level
 035A           ;                       // is, we have special duties.
 035A           ;                       COMMAND_TYPE = WAIT_RECV_cGetChar();
 035A 10                push X
 035B 7C0000            xcall _WAIT_RECV_cGetChar
 035E 20                pop X
 035F 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0362 5300              mov [_COMMAND_TYPE],A
 0364                   .dbline 478
 0364           ;                       
 0364           ;                       // This basically waits for the rest of the command to pass through.
 0364           ;                       for(i = 0; i < (tempByte - 1); i++)
 0364 560200            mov [X+2],0
 0367 560100            mov [X+1],0
 036A 800E              xjmp L55
 036C           L52:
 036C                   .dbline 479
 036C           ;                       {
 036C                   .dbline 480
 036C           ;                               WAIT_RECV_cGetChar();
 036C 10                push X
 036D 7C0000            xcall _WAIT_RECV_cGetChar
 0370 62D000            mov REG[0xd0],>__r0
 0373 20                pop X
 0374                   .dbline 481
 0374           ;                       }
 0374           L53:
 0374                   .dbline 478
 0374 7702              inc [X+2]
 0376 0F0100            adc [X+1],0
 0379           L55:
 0379                   .dbline 478
 0379 62D000            mov REG[0xd0],>__r0
 037C 5200              mov A,[X+0]
 037E 5300              mov [__r1],A
 0380 550000            mov [__r0],0
 0383 160001            sub [__r1],1
 0386 1E0000            sbb [__r0],0
 0389 5202              mov A,[X+2]
 038B 1200              sub A,[__r1]
 038D 5100              mov A,[__r0]
 038F 3180              xor A,-128
 0391 5300              mov [__rX],A
 0393 5201              mov A,[X+1]
 0395 3180              xor A,-128
 0397 1A00              sbb A,[__rX]
 0399 CFD2              jc L52
 039B           X15:
 039B                   .dbline 483
 039B           ;                               
 039B           ;                       return 1;
 039B 62D000            mov REG[0xd0],>__r0
 039E 550001            mov [__r1],1
 03A1 550000            mov [__r0],0
 03A4 82F7              xjmp L37
 03A6           L38:
 03A6                   .dbline 486
 03A6           ;               }
 03A6           ;       }
 03A6           ;       else if(STATE == HELLO_MODE)
 03A6 62D000            mov REG[0xd0],>_STATE
 03A9 3C0000            cmp [_STATE],0
 03AC B06E              jnz L56
 03AE 3C0107            cmp [_STATE+1],7
 03B1 B069              jnz L56
 03B3           X16:
 03B3                   .dbline 487
 03B3           ;       {
 03B3                   .dbline 489
 03B3           ;               // Check all of the ports for a start byte.  Only one port will produce one.
 03B3           ;               if(HELLO_1_cReadChar() == START_TRANSMIT)
 03B3 10                push X
 03B4 7C0000            xcall _HELLO_1_cReadChar
 03B7 20                pop X
 03B8 39FC              cmp A,-4
 03BA B012              jnz L58
 03BC                   .dbline 490
 03BC           ;               {               
 03BC                   .dbline 491
 03BC           ;                       CHILD = PORT_1;
 03BC 62D000            mov REG[0xd0],>_CHILD
 03BF 550031            mov [_CHILD],49
 03C2                   .dbline 493
 03C2           ;                       
 03C2           ;                       return 1;
 03C2 62D000            mov REG[0xd0],>__r0
 03C5 550001            mov [__r1],1
 03C8 550000            mov [__r0],0
 03CB 82D0              xjmp L37
 03CD           L58:
 03CD                   .dbline 495
 03CD           ;               }
 03CD           ;               else if(HELLO_2_cReadChar() == START_TRANSMIT)
 03CD 10                push X
 03CE 7C0000            xcall _HELLO_2_cReadChar
 03D1 20                pop X
 03D2 39FC              cmp A,-4
 03D4 B012              jnz L60
 03D6                   .dbline 496
 03D6           ;               {               
 03D6                   .dbline 497
 03D6           ;                       CHILD = PORT_2;
 03D6 62D000            mov REG[0xd0],>_CHILD
 03D9 550032            mov [_CHILD],50
 03DC                   .dbline 499
 03DC           ;                       
 03DC           ;                       return 1;
 03DC 62D000            mov REG[0xd0],>__r0
 03DF 550001            mov [__r1],1
 03E2 550000            mov [__r0],0
 03E5 82B6              xjmp L37
 03E7           L60:
 03E7                   .dbline 501
 03E7           ;               }
 03E7           ;               else if(HELLO_3_cReadChar() == START_TRANSMIT)
 03E7 10                push X
 03E8 7C0000            xcall _HELLO_3_cReadChar
 03EB 20                pop X
 03EC 39FC              cmp A,-4
 03EE B012              jnz L62
 03F0                   .dbline 502
 03F0           ;               {
 03F0                   .dbline 503
 03F0           ;                       CHILD = PORT_3;
 03F0 62D000            mov REG[0xd0],>_CHILD
 03F3 550033            mov [_CHILD],51
 03F6                   .dbline 505
 03F6           ;                       
 03F6           ;                       return 1;
 03F6 62D000            mov REG[0xd0],>__r0
 03F9 550001            mov [__r1],1
 03FC 550000            mov [__r0],0
 03FF 829C              xjmp L37
 0401           L62:
 0401                   .dbline 507
 0401           ;               }
 0401           ;               else if(HELLO_4_cReadChar() == START_TRANSMIT)
 0401 10                push X
 0402 7C0000            xcall _HELLO_4_cReadChar
 0405 20                pop X
 0406 39FC              cmp A,-4
 0408 B28A              jnz L57
 040A                   .dbline 508
 040A           ;               {
 040A                   .dbline 509
 040A           ;                       CHILD = PORT_4;
 040A 62D000            mov REG[0xd0],>_CHILD
 040D 550034            mov [_CHILD],52
 0410                   .dbline 511
 0410           ;                       
 0410           ;                       return 1;
 0410 62D000            mov REG[0xd0],>__r0
 0413 550001            mov [__r1],1
 0416 550000            mov [__r0],0
 0419 8282              xjmp L37
 041B           L56:
 041B                   .dbline 514
 041B           ;               }
 041B           ;       }
 041B           ;       else if(STATE == RESPONSE_1)
 041B 62D000            mov REG[0xd0],>_STATE
 041E 3C0000            cmp [_STATE],0
 0421 B081              jnz L66
 0423 3C0103            cmp [_STATE+1],3
 0426 B07C              jnz L66
 0428           X17:
 0428                   .dbline 515
 0428           ;       {
 0428                   .dbline 516
 0428           ;               if(tempByte = CHILD_1_cReadChar())
 0428 10                push X
 0429 7C0000            xcall _CHILD_1_cReadChar
 042C 62D000            mov REG[0xd0],>__r0
 042F 20                pop X
 0430 5400              mov [X+0],A
 0432 3900              cmp A,0
 0434 A25E              jz L67
 0436                   .dbline 517
 0436           ;               {
 0436                   .dbline 518
 0436           ;                       if(tempByte == SERVO_START)                             // We have a servo response coming.
 0436 3D00FF            cmp [X+0],-1
 0439 B050              jnz L70
 043B                   .dbline 519
 043B           ;                       {
 043B           L72:
 043B                   .dbline 521
 043B           ;                               // Burn through the rest of the start bytes and the servo length.
 043B           ;                               while(CHILD_1_cGetChar() == SERVO_START) { }
 043B                   .dbline 521
 043B           L73:
 043B                   .dbline 521
 043B 10                push X
 043C 7C0000            xcall _CHILD_1_cGetChar
 043F 62D000            mov REG[0xd0],>__r0
 0442 20                pop X
 0443 39FF              cmp A,-1
 0445 AFF5              jz L72
 0447                   .dbline 524
 0447           ;                               
 0447           ;                               // We store the length, since it is the next byte from the servo.
 0447           ;                               tempByte = CHILD_1_cGetChar();
 0447 10                push X
 0448 7C0000            xcall _CHILD_1_cGetChar
 044B 62D000            mov REG[0xd0],>__r0
 044E 20                pop X
 044F 5400              mov [X+0],A
 0451                   .dbline 527
 0451           ;                               
 0451           ;                               // This basically waits for the rest of the command to pass through.
 0451           ;                               for(i = 0; i < tempByte; i++)
 0451 560200            mov [X+2],0
 0454 560100            mov [X+1],0
 0457 800E              xjmp L78
 0459           L75:
 0459                   .dbline 528
 0459           ;                               {
 0459                   .dbline 529
 0459           ;                                       CHILD_1_cGetChar();
 0459 10                push X
 045A 7C0000            xcall _CHILD_1_cGetChar
 045D 62D000            mov REG[0xd0],>__r0
 0460 20                pop X
 0461                   .dbline 530
 0461           ;                               }
 0461           L76:
 0461                   .dbline 527
 0461 7702              inc [X+2]
 0463 0F0100            adc [X+1],0
 0466           L78:
 0466                   .dbline 527
 0466 62D000            mov REG[0xd0],>__r0
 0469 5200              mov A,[X+0]
 046B 5300              mov [__r1],A
 046D 5202              mov A,[X+2]
 046F 1200              sub A,[__r1]
 0471 5000              mov A,0
 0473 3180              xor A,-128
 0475 5300              mov [__rX],A
 0477 5201              mov A,[X+1]
 0479 3180              xor A,-128
 047B 1A00              sbb A,[__rX]
 047D CFDB              jc L75
 047F           X18:
 047F                   .dbline 532
 047F           ;                               
 047F           ;                               return 1;
 047F 62D000            mov REG[0xd0],>__r0
 0482 550001            mov [__r1],1
 0485 550000            mov [__r0],0
 0488 8213              xjmp L37
 048A           L70:
 048A                   .dbline 534
 048A           ;                       }
 048A           ;                       else if (tempByte == START_TRANSMIT)    // We have a controller response coming.
 048A 3D00FC            cmp [X+0],-4
 048D B205              jnz L67
 048F                   .dbline 535
 048F           ;                       {
 048F           L81:
 048F                   .dbline 537
 048F           ;                               // We simply wait for the end transmit indicator.
 048F           ;                               while(CHILD_1_cGetChar() != END_TRANSMIT) { }
 048F                   .dbline 537
 048F           L82:
 048F                   .dbline 537
 048F 10                push X
 0490 7C0000            xcall _CHILD_1_cGetChar
 0493 62D000            mov REG[0xd0],>__r0
 0496 20                pop X
 0497 39FD              cmp A,-3
 0499 BFF5              jnz L81
 049B                   .dbline 539
 049B           ;                               
 049B           ;                               return 1;
 049B 550001            mov [__r1],1
 049E 550000            mov [__r0],0
 04A1 81FA              xjmp L37
 04A3           L66:
 04A3                   .dbline 543
 04A3           ;                       }
 04A3           ;               }
 04A3           ;       }
 04A3           ;       else if(STATE == RESPONSE_2)
 04A3 62D000            mov REG[0xd0],>_STATE
 04A6 3C0000            cmp [_STATE],0
 04A9 B081              jnz L84
 04AB 3C0104            cmp [_STATE+1],4
 04AE B07C              jnz L84
 04B0           X19:
 04B0                   .dbline 544
 04B0           ;       {
 04B0                   .dbline 545
 04B0           ;               if(tempByte = CHILD_2_cReadChar())
 04B0 10                push X
 04B1 7C0000            xcall _CHILD_2_cReadChar
 04B4 62D000            mov REG[0xd0],>__r0
 04B7 20                pop X
 04B8 5400              mov [X+0],A
 04BA 3900              cmp A,0
 04BC A1D6              jz L85
 04BE                   .dbline 546
 04BE           ;               {
 04BE                   .dbline 547
 04BE           ;                       if(tempByte == SERVO_START)                             // We have a servo response coming.
 04BE 3D00FF            cmp [X+0],-1
 04C1 B050              jnz L88
 04C3                   .dbline 548
 04C3           ;                       {
 04C3           L90:
 04C3                   .dbline 550
 04C3           ;                               // Burn through the rest of the start bytes and the servo length.
 04C3           ;                               while(CHILD_2_cGetChar() == SERVO_START) { }
 04C3                   .dbline 550
 04C3           L91:
 04C3                   .dbline 550
 04C3 10                push X
 04C4 7C0000            xcall _CHILD_2_cGetChar
 04C7 62D000            mov REG[0xd0],>__r0
 04CA 20                pop X
 04CB 39FF              cmp A,-1
 04CD AFF5              jz L90
 04CF                   .dbline 553
 04CF           ;                               
 04CF           ;                               // We store the length, since it is the next byte from the servo.
 04CF           ;                               tempByte = CHILD_2_cGetChar();
 04CF 10                push X
 04D0 7C0000            xcall _CHILD_2_cGetChar
 04D3 62D000            mov REG[0xd0],>__r0
 04D6 20                pop X
 04D7 5400              mov [X+0],A
 04D9                   .dbline 556
 04D9           ;                               
 04D9           ;                               // This basically waits for the rest of the command to pass through.
 04D9           ;                               for(i = 0; i < tempByte; i++)
 04D9 560200            mov [X+2],0
 04DC 560100            mov [X+1],0
 04DF 800E              xjmp L96
 04E1           L93:
 04E1                   .dbline 557
 04E1           ;                               {
 04E1                   .dbline 558
 04E1           ;                                       CHILD_2_cGetChar();
 04E1 10                push X
 04E2 7C0000            xcall _CHILD_2_cGetChar
 04E5 62D000            mov REG[0xd0],>__r0
 04E8 20                pop X
 04E9                   .dbline 559
 04E9           ;                               }
 04E9           L94:
 04E9                   .dbline 556
 04E9 7702              inc [X+2]
 04EB 0F0100            adc [X+1],0
 04EE           L96:
 04EE                   .dbline 556
 04EE 62D000            mov REG[0xd0],>__r0
 04F1 5200              mov A,[X+0]
 04F3 5300              mov [__r1],A
 04F5 5202              mov A,[X+2]
 04F7 1200              sub A,[__r1]
 04F9 5000              mov A,0
 04FB 3180              xor A,-128
 04FD 5300              mov [__rX],A
 04FF 5201              mov A,[X+1]
 0501 3180              xor A,-128
 0503 1A00              sbb A,[__rX]
 0505 CFDB              jc L93
 0507           X20:
 0507                   .dbline 561
 0507           ;                               
 0507           ;                               return 1;
 0507 62D000            mov REG[0xd0],>__r0
 050A 550001            mov [__r1],1
 050D 550000            mov [__r0],0
 0510 818B              xjmp L37
 0512           L88:
 0512                   .dbline 563
 0512           ;                       }
 0512           ;                       else if (tempByte == START_TRANSMIT)    // We have a controller response coming.
 0512 3D00FC            cmp [X+0],-4
 0515 B17D              jnz L85
 0517                   .dbline 564
 0517           ;                       {
 0517           L99:
 0517                   .dbline 566
 0517           ;                               // We simply wait for the end transmit indicator.
 0517           ;                               while(CHILD_2_cGetChar() != END_TRANSMIT) { }
 0517                   .dbline 566
 0517           L100:
 0517                   .dbline 566
 0517 10                push X
 0518 7C0000            xcall _CHILD_2_cGetChar
 051B 62D000            mov REG[0xd0],>__r0
 051E 20                pop X
 051F 39FD              cmp A,-3
 0521 BFF5              jnz L99
 0523                   .dbline 568
 0523           ;                               
 0523           ;                               return 1;
 0523 550001            mov [__r1],1
 0526 550000            mov [__r0],0
 0529 8172              xjmp L37
 052B           L84:
 052B                   .dbline 572
 052B           ;                       }
 052B           ;               }
 052B           ;       }
 052B           ;       else if(STATE == RESPONSE_3)
 052B 62D000            mov REG[0xd0],>_STATE
 052E 3C0000            cmp [_STATE],0
 0531 B081              jnz L102
 0533 3C0105            cmp [_STATE+1],5
 0536 B07C              jnz L102
 0538           X21:
 0538                   .dbline 573
 0538           ;       {
 0538                   .dbline 574
 0538           ;               if(tempByte = CHILD_3_cReadChar())
 0538 10                push X
 0539 7C0000            xcall _CHILD_3_cReadChar
 053C 62D000            mov REG[0xd0],>__r0
 053F 20                pop X
 0540 5400              mov [X+0],A
 0542 3900              cmp A,0
 0544 A14E              jz L103
 0546                   .dbline 575
 0546           ;               {
 0546                   .dbline 576
 0546           ;                       if(tempByte == SERVO_START)                             // We have a servo response coming.
 0546 3D00FF            cmp [X+0],-1
 0549 B050              jnz L106
 054B                   .dbline 577
 054B           ;                       {
 054B           L108:
 054B                   .dbline 579
 054B           ;                               // Burn through the rest of the start bytes and the servo length.
 054B           ;                               while(CHILD_3_cGetChar() == SERVO_START) { }
 054B                   .dbline 579
 054B           L109:
 054B                   .dbline 579
 054B 10                push X
 054C 7C0000            xcall _CHILD_3_cGetChar
 054F 62D000            mov REG[0xd0],>__r0
 0552 20                pop X
 0553 39FF              cmp A,-1
 0555 AFF5              jz L108
 0557                   .dbline 582
 0557           ;                               
 0557           ;                               // We store the length, since it is the next byte from the servo.
 0557           ;                               tempByte = CHILD_3_cGetChar();
 0557 10                push X
 0558 7C0000            xcall _CHILD_3_cGetChar
 055B 62D000            mov REG[0xd0],>__r0
 055E 20                pop X
 055F 5400              mov [X+0],A
 0561                   .dbline 585
 0561           ;                               
 0561           ;                               // This basically waits for the rest of the command to pass through.
 0561           ;                               for(i = 0; i < tempByte; i++)
 0561 560200            mov [X+2],0
 0564 560100            mov [X+1],0
 0567 800E              xjmp L114
 0569           L111:
 0569                   .dbline 586
 0569           ;                               {
 0569                   .dbline 587
 0569           ;                                       CHILD_3_cGetChar();
 0569 10                push X
 056A 7C0000            xcall _CHILD_3_cGetChar
 056D 62D000            mov REG[0xd0],>__r0
 0570 20                pop X
 0571                   .dbline 588
 0571           ;                               }
 0571           L112:
 0571                   .dbline 585
 0571 7702              inc [X+2]
 0573 0F0100            adc [X+1],0
 0576           L114:
 0576                   .dbline 585
 0576 62D000            mov REG[0xd0],>__r0
 0579 5200              mov A,[X+0]
 057B 5300              mov [__r1],A
 057D 5202              mov A,[X+2]
 057F 1200              sub A,[__r1]
 0581 5000              mov A,0
 0583 3180              xor A,-128
 0585 5300              mov [__rX],A
 0587 5201              mov A,[X+1]
 0589 3180              xor A,-128
 058B 1A00              sbb A,[__rX]
 058D CFDB              jc L111
 058F           X22:
 058F                   .dbline 590
 058F           ;                               
 058F           ;                               return 1;
 058F 62D000            mov REG[0xd0],>__r0
 0592 550001            mov [__r1],1
 0595 550000            mov [__r0],0
 0598 8103              xjmp L37
 059A           L106:
 059A                   .dbline 592
 059A           ;                       }
 059A           ;                       else if (tempByte == START_TRANSMIT)    // We have a controller response coming.
 059A 3D00FC            cmp [X+0],-4
 059D B0F5              jnz L103
 059F                   .dbline 593
 059F           ;                       {
 059F           L117:
 059F                   .dbline 595
 059F           ;                               // We simply wait for the end transmit indicator.
 059F           ;                               while(CHILD_3_cGetChar() != END_TRANSMIT) { }
 059F                   .dbline 595
 059F           L118:
 059F                   .dbline 595
 059F 10                push X
 05A0 7C0000            xcall _CHILD_3_cGetChar
 05A3 62D000            mov REG[0xd0],>__r0
 05A6 20                pop X
 05A7 39FD              cmp A,-3
 05A9 BFF5              jnz L117
 05AB                   .dbline 597
 05AB           ;                               
 05AB           ;                               return 1;
 05AB 550001            mov [__r1],1
 05AE 550000            mov [__r0],0
 05B1 80EA              xjmp L37
 05B3           L102:
 05B3                   .dbline 601
 05B3           ;                       }
 05B3           ;               }
 05B3           ;       }
 05B3           ;       else if(STATE == RESPONSE_4)
 05B3 62D000            mov REG[0xd0],>_STATE
 05B6 3C0000            cmp [_STATE],0
 05B9 B081              jnz L120
 05BB 3C0106            cmp [_STATE+1],6
 05BE B07C              jnz L120
 05C0           X23:
 05C0                   .dbline 602
 05C0           ;       {
 05C0                   .dbline 603
 05C0           ;               if(tempByte = CHILD_4_cReadChar())
 05C0 10                push X
 05C1 7C0000            xcall _CHILD_4_cReadChar
 05C4 62D000            mov REG[0xd0],>__r0
 05C7 20                pop X
 05C8 5400              mov [X+0],A
 05CA 3900              cmp A,0
 05CC A0C6              jz L121
 05CE                   .dbline 604
 05CE           ;               {
 05CE                   .dbline 605
 05CE           ;                       if(tempByte == SERVO_START)                             // We have a servo response coming.
 05CE 3D00FF            cmp [X+0],-1
 05D1 B050              jnz L124
 05D3                   .dbline 606
 05D3           ;                       {
 05D3           L126:
 05D3                   .dbline 608
 05D3           ;                               // Burn through the rest of the start bytes and the servo length.
 05D3           ;                               while(CHILD_4_cGetChar() == SERVO_START) { }
 05D3                   .dbline 608
 05D3           L127:
 05D3                   .dbline 608
 05D3 10                push X
 05D4 7C0000            xcall _CHILD_4_cGetChar
 05D7 62D000            mov REG[0xd0],>__r0
 05DA 20                pop X
 05DB 39FF              cmp A,-1
 05DD AFF5              jz L126
 05DF                   .dbline 611
 05DF           ;                               
 05DF           ;                               // We store the length, since it is the next byte from the servo.
 05DF           ;                               tempByte = CHILD_4_cGetChar();
 05DF 10                push X
 05E0 7C0000            xcall _CHILD_4_cGetChar
 05E3 62D000            mov REG[0xd0],>__r0
 05E6 20                pop X
 05E7 5400              mov [X+0],A
 05E9                   .dbline 614
 05E9           ;                               
 05E9           ;                               // This basically waits for the rest of the command to pass through.
 05E9           ;                               for(i = 0; i < tempByte; i++)
 05E9 560200            mov [X+2],0
 05EC 560100            mov [X+1],0
 05EF 800E              xjmp L132
 05F1           L129:
 05F1                   .dbline 615
 05F1           ;                               {
 05F1                   .dbline 616
 05F1           ;                                       CHILD_4_cGetChar();
 05F1 10                push X
 05F2 7C0000            xcall _CHILD_4_cGetChar
 05F5 62D000            mov REG[0xd0],>__r0
 05F8 20                pop X
 05F9                   .dbline 617
 05F9           ;                               }
 05F9           L130:
 05F9                   .dbline 614
 05F9 7702              inc [X+2]
 05FB 0F0100            adc [X+1],0
 05FE           L132:
 05FE                   .dbline 614
 05FE 62D000            mov REG[0xd0],>__r0
 0601 5200              mov A,[X+0]
 0603 5300              mov [__r1],A
 0605 5202              mov A,[X+2]
 0607 1200              sub A,[__r1]
 0609 5000              mov A,0
 060B 3180              xor A,-128
 060D 5300              mov [__rX],A
 060F 5201              mov A,[X+1]
 0611 3180              xor A,-128
 0613 1A00              sbb A,[__rX]
 0615 CFDB              jc L129
 0617           X24:
 0617                   .dbline 619
 0617           ;                               
 0617           ;                               return 1;
 0617 62D000            mov REG[0xd0],>__r0
 061A 550001            mov [__r1],1
 061D 550000            mov [__r0],0
 0620 807B              xjmp L37
 0622           L124:
 0622                   .dbline 621
 0622           ;                       }
 0622           ;                       else if (tempByte == START_TRANSMIT)    // We have a controller response coming.
 0622 3D00FC            cmp [X+0],-4
 0625 B06D              jnz L121
 0627                   .dbline 622
 0627           ;                       {
 0627           L135:
 0627                   .dbline 624
 0627           ;                               // We simply wait for the end transmit indicator.
 0627           ;                               while(CHILD_4_cGetChar() != END_TRANSMIT) { }
 0627                   .dbline 624
 0627           L136:
 0627                   .dbline 624
 0627 10                push X
 0628 7C0000            xcall _CHILD_4_cGetChar
 062B 62D000            mov REG[0xd0],>__r0
 062E 20                pop X
 062F 39FD              cmp A,-3
 0631 BFF5              jnz L135
 0633                   .dbline 626
 0633           ;                               
 0633           ;                               return 1;
 0633 550001            mov [__r1],1
 0636 550000            mov [__r0],0
 0639 8062              xjmp L37
 063B           L120:
 063B                   .dbline 630
 063B           ;                       }
 063B           ;               }
 063B           ;       }
 063B           ;       else if(STATE == INITIALIZE)
 063B 62D000            mov REG[0xd0],>_STATE
 063E 3C0000            cmp [_STATE],0
 0641 B051              jnz L138
 0643 3C0108            cmp [_STATE+1],8
 0646 B04C              jnz L138
 0648           X25:
 0648                   .dbline 631
 0648           ;       {
 0648                   .dbline 632
 0648           ;               if(INIT_RX_cReadChar() == SERVO_START)
 0648 10                push X
 0649 7C0000            xcall _INIT_RX_cReadChar
 064C 62D000            mov REG[0xd0],>__r0
 064F 20                pop X
 0650 39FF              cmp A,-1
 0652 B040              jnz L140
 0654                   .dbline 633
 0654           ;               {
 0654                   .dbline 635
 0654           ;                       // We officially have a transmission.
 0654           ;                       if(INIT_RX_cGetChar() == SERVO_START)
 0654 10                push X
 0655 7C0000            xcall _INIT_RX_cGetChar
 0658 62D000            mov REG[0xd0],>__r0
 065B 20                pop X
 065C 39FF              cmp A,-1
 065E B034              jnz L142
 0660                   .dbline 636
 0660           ;                       {
 0660                   .dbline 639
 0660           ;                               // If we definitely have a transmission starting, grab all bytes from the rx buffer
 0660           ;                               // and store them in the proper variables for actions to be taken later.
 0660           ;                               COMMAND_SOURCE = INIT_RX_cGetChar();
 0660 10                push X
 0661 7C0000            xcall _INIT_RX_cGetChar
 0664 20                pop X
 0665 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0668 5300              mov [_COMMAND_SOURCE],A
 066A                   .dbline 640
 066A           ;                               COMMAND_LENGTH = INIT_RX_cGetChar();
 066A 10                push X
 066B 7C0000            xcall _INIT_RX_cGetChar
 066E 20                pop X
 066F 62D000            mov REG[0xd0],>_COMMAND_LENGTH
 0672 5300              mov [_COMMAND_LENGTH],A
 0674                   .dbline 641
 0674           ;                               COMMAND_ERROR = INIT_RX_cGetChar();
 0674 10                push X
 0675 7C0000            xcall _INIT_RX_cGetChar
 0678 20                pop X
 0679 62D000            mov REG[0xd0],>_COMMAND_ERROR
 067C 5300              mov [_COMMAND_ERROR],A
 067E                   .dbline 642
 067E           ;                               COMMAND_PARAM = INIT_RX_cGetChar();
 067E 10                push X
 067F 7C0000            xcall _INIT_RX_cGetChar
 0682 20                pop X
 0683 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0686 5300              mov [_COMMAND_PARAM],A
 0688                   .dbline 644
 0688           ;                               
 0688           ;                               return 1;
 0688 62D000            mov REG[0xd0],>__r0
 068B 550001            mov [__r1],1
 068E 550000            mov [__r0],0
 0691 800A              xjmp L37
 0693           L142:
 0693                   .dbline 646
 0693           ;                       }
 0693           ;               }
 0693           L140:
 0693                   .dbline 647
 0693           ;       }
 0693           L138:
 0693           L121:
 0693           L103:
 0693           L85:
 0693           L67:
 0693           L57:
 0693           L39:
 0693                   .dbline 649
 0693           ;       
 0693           ;       return 0;
 0693 62D000            mov REG[0xd0],>__r0
 0696 550000            mov [__r1],0
 0699 550000            mov [__r0],0
 069C                   .dbline -2
 069C           L37:
 069C 38FD              add SP,-3
 069E 20                pop X
 069F                   .dbline 0 ; func end
 069F 7F                ret
 06A0                   .dbsym l i 1 I
 06A0                   .dbsym l tempByte 0 c
 06A0                   .dbend
 06A0                   .dbfunc e takeAction _takeAction fV
 06A0           ;              j -> X+4
 06A0           ;              i -> X+2
 06A0           ;              i -> X+0
 06A0           _takeAction::
 06A0                   .dbline -1
 06A0 10                push X
 06A1 4F                mov X,SP
 06A2 3806              add SP,6
 06A4                   .dbline 655
 06A4           ; }
 06A4           ; 
 06A4           ; // This function interprets what has been read by the command ready function
 06A4           ; // and performs the appropriate action.
 06A4           ; void takeAction(void)
 06A4           ; {
 06A4                   .dbline 656
 06A4           ;       int i = 0;                                                      // An index variable for looping.
 06A4 560100            mov [X+1],0
 06A7 560000            mov [X+0],0
 06AA                   .dbline 658
 06AA           ;       
 06AA           ;       if(COMMAND_TYPE == HELLO_BYTE)          // The master is probing for new modules.
 06AA 62D000            mov REG[0xd0],>_COMMAND_TYPE
 06AD 3C00C8            cmp [_COMMAND_TYPE],-56
 06B0 B039              jnz L145
 06B2                   .dbline 659
 06B2           ;       {
 06B2                   .dbline 660
 06B2           ;               if(!CONFIGURED)
 06B2 62D000            mov REG[0xd0],>_CONFIGURED
 06B5 3C0000            cmp [_CONFIGURED],0
 06B8 B00A              jnz L147
 06BA 3C0100            cmp [_CONFIGURED+1],0
 06BD B005              jnz L147
 06BF           X26:
 06BF                   .dbline 661
 06BF           ;               {
 06BF                   .dbline 663
 06BF           ;                       // Announce this module's presence if not configured.
 06BF           ;                       sayHello();
 06BF 998E              xcall _sayHello
 06C1                   .dbline 664
 06C1           ;               }
 06C1 820D              xjmp L146
 06C3           L147:
 06C3                   .dbline 665
 06C3           ;               else if(!CHILD)
 06C3 62D000            mov REG[0xd0],>_CHILD
 06C6 3C0000            cmp [_CHILD],0
 06C9 B014              jnz L149
 06CB                   .dbline 666
 06CB           ;               {
 06CB                   .dbline 668
 06CB           ;                       // Listen for children if we have none.
 06CB           ;                       if(childListen())
 06CB 94AA              xcall _childListen
 06CD 62D000            mov REG[0xd0],>__r0
 06D0 3C0000            cmp [__r0],0
 06D3 B006              jnz X27
 06D5 3C0000            cmp [__r1],0
 06D8 A1F6              jz L146
 06DA           X27:
 06DA                   .dbline 669
 06DA           ;                       {
 06DA                   .dbline 671
 06DA           ;                               // If a child was heard saying hello, forward the command with the port number added.
 06DA           ;                               sayHello();
 06DA 9973              xcall _sayHello
 06DC                   .dbline 672
 06DC           ;                       }
 06DC                   .dbline 673
 06DC           ;               }
 06DC 81F2              xjmp L146
 06DE           L149:
 06DE                   .dbline 674
 06DE           ;               else if(CHILD)
 06DE 62D000            mov REG[0xd0],>_CHILD
 06E1 3C0000            cmp [_CHILD],0
 06E4 A1EA              jz L146
 06E6                   .dbline 675
 06E6           ;               {
 06E6                   .dbline 677
 06E6           ;                       // If you have a child established, listen to that child.
 06E6           ;                       childResponse();
 06E6 94E7              xcall _childResponse
 06E8                   .dbline 678
 06E8           ;               }
 06E8                   .dbline 679
 06E8           ;       }
 06E8 81E6              xjmp L146
 06EA           L145:
 06EA                   .dbline 680
 06EA           ;       else if(COMMAND_TYPE == PING)           // The master is trying to find a module that is configured.
 06EA 62D000            mov REG[0xd0],>_COMMAND_TYPE
 06ED 3C00CB            cmp [_COMMAND_TYPE],-53
 06F0 B021              jnz L155
 06F2                   .dbline 681
 06F2           ;       {
 06F2                   .dbline 683
 06F2           ;               // If this is to me, act accordingly.
 06F2           ;               if(COMMAND_DESTINATION == ID)
 06F2 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 06F5 5100              mov A,[_COMMAND_DESTINATION]
 06F7 62D000            mov REG[0xd0],>_ID
 06FA 3A00              cmp A,[_ID]
 06FC B005              jnz L157
 06FE                   .dbline 684
 06FE           ;               {
 06FE                   .dbline 686
 06FE           ;                       // Ping back to the master.
 06FE           ;                       pingResponse();
 06FE 9272              xcall _pingResponse
 0700                   .dbline 687
 0700           ;               }
 0700 81CE              xjmp L156
 0702           L157:
 0702                   .dbline 688
 0702           ;               else if(COMMAND_DESTINATION > ID)
 0702 62D000            mov REG[0xd0],>_ID
 0705 5100              mov A,[_ID]
 0707 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 070A 3A00              cmp A,[_COMMAND_DESTINATION]
 070C D1C2              jnc L156
 070E           X28:
 070E                   .dbline 689
 070E           ;               {
 070E                   .dbline 691
 070E           ;                       // If you have a child established, listen to that child.
 070E           ;                       childResponse();
 070E 94BF              xcall _childResponse
 0710                   .dbline 692
 0710           ;               }
 0710                   .dbline 693
 0710           ;       }
 0710 81BE              xjmp L156
 0712           L155:
 0712                   .dbline 694
 0712           ;       else if(COMMAND_TYPE == ID_ASSIGNMENT)  // The master is assigning an ID to someone.
 0712 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0715 3C00C9            cmp [_COMMAND_TYPE],-55
 0718 B110              jnz L161
 071A                   .dbline 695
 071A           ;       {
 071A                   .dbline 697
 071A           ;               // If this is meant for me, change my ID.
 071A           ;               if(COMMAND_DESTINATION == ID)
 071A 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 071D 5100              mov A,[_COMMAND_DESTINATION]
 071F 62D000            mov REG[0xd0],>_ID
 0722 3A00              cmp A,[_ID]
 0724 B0F4              jnz L163
 0726                   .dbline 698
 0726           ;               {
 0726                   .dbline 699
 0726           ;                       if((COMMAND_PARAM > MASTER_ID) && (COMMAND_PARAM < DEFAULT_ID))
 0726 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0729 5000              mov A,0
 072B 3A00              cmp A,[_COMMAND_PARAM]
 072D D1A1              jnc L162
 072F           X29:
 072F 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0732 3C00FB            cmp [_COMMAND_PARAM],-5
 0735 D199              jnc L162
 0737           X30:
 0737                   .dbline 700
 0737           ;                       {
 0737                   .dbline 702
 0737           ;                               // Assign this module the ID that has been passed by the master.
 0737           ;                               ID = COMMAND_PARAM;
 0737 62D000            mov REG[0xd0],>_COMMAND_PARAM
 073A 5100              mov A,[_COMMAND_PARAM]
 073C 62D000            mov REG[0xd0],>_ID
 073F 5300              mov [_ID],A
 0741                   .dbline 705
 0741           ;                               
 0741           ;                               // This module is now configured.
 0741           ;                               CONFIGURED = 1;
 0741 62D000            mov REG[0xd0],>_CONFIGURED
 0744 550101            mov [_CONFIGURED+1],1
 0747 550000            mov [_CONFIGURED],0
 074A                   .dbline 708
 074A           ;                               
 074A           ;                               // If the servo ID doesn't match what we want, change it to match.
 074A           ;                               if(ID != SERVO_ID)
 074A 62D000            mov REG[0xd0],>_ID
 074D 5100              mov A,[_ID]
 074F 62D000            mov REG[0xd0],>_SERVO_ID
 0752 3A00              cmp A,[_SERVO_ID]
 0754 A0A8              jz L167
 0756                   .dbline 709
 0756           ;                               {
 0756                   .dbline 716
 0756           ;                                       // These are our index variables for communication attempt timeouts.
 0756           ;                                       int i;
 0756           ;                                       int j;
 0756           ;                                       
 0756           ;                                       //while(ID != SERVO_ID)
 0756           ;                                       
 0756           ;                                       for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0756 560500            mov [X+5],0
 0759 560400            mov [X+4],0
 075C           L169:
 075C                   .dbline 717
 075C           ;                                       {       
 075C                   .dbline 719
 075C           ;                                               // Send a request to change the servo ID to match the controller ID.
 075C           ;                                               servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, ID_ADDRESS, ID);
 075C 62D000            mov REG[0xd0],>_ID
 075F 5100              mov A,[_ID]
 0761 08                push A
 0762 5003              mov A,3
 0764 08                push A
 0765 08                push A
 0766 5004              mov A,4
 0768 08                push A
 0769 62D000            mov REG[0xd0],>_SERVO_ID
 076C 5100              mov A,[_SERVO_ID]
 076E 08                push A
 076F 9714              xcall _servoInstruction
 0771 38FB              add SP,-5
 0773                   .dbline 722
 0773           ;                                       
 0773           ;                                               // Try to read the servo's ID several times.
 0773           ;                                               for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0773 560300            mov [X+3],0
 0776 560200            mov [X+2],0
 0779           L173:
 0779                   .dbline 723
 0779           ;                                               {
 0779                   .dbline 725
 0779           ;                                                       // Send a request for the servo ID, which is presumably now equal to ID.
 0779           ;                                                       servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
 0779 5000              mov A,0
 077B 08                push A
 077C 08                push A
 077D 5001              mov A,1
 077F 08                push A
 0780 5002              mov A,2
 0782 08                push A
 0783 50FE              mov A,-2
 0785 08                push A
 0786 96FD              xcall _servoInstruction
 0788 38FB              add SP,-5
 078A 8043              xjmp L178
 078C           L177:
 078C                   .dbline 729
 078C           ;                                                       
 078C           ;                                                       // Wait for either a timeout or an indication that we want to exit the loop.
 078C           ;                                                       while(!TIMEOUT)
 078C           ;                                                       {
 078C                   .dbline 731
 078C           ;                                                               // If we have a command to interpret, read it.
 078C           ;                                                               if(commandReady())
 078C 9B30              xcall _commandReady
 078E 62D000            mov REG[0xd0],>__r0
 0791 3C0000            cmp [__r0],0
 0794 B006              jnz X31
 0796 3C0000            cmp [__r1],0
 0799 A034              jz L180
 079B           X31:
 079B                   .dbline 732
 079B           ;                                                               {
 079B                   .dbline 733
 079B           ;                                                                       if(!COMMAND_ERROR)
 079B 62D000            mov REG[0xd0],>_COMMAND_ERROR
 079E 3C0000            cmp [_COMMAND_ERROR],0
 07A1 B02C              jnz L182
 07A3                   .dbline 734
 07A3           ;                                                                       {
 07A3                   .dbline 736
 07A3           ;                                                                               // If we have a valid servo ID, exit the loop.
 07A3           ;                                                                               if(COMMAND_SOURCE == ID)
 07A3 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 07A6 5100              mov A,[_COMMAND_SOURCE]
 07A8 62D000            mov REG[0xd0],>_ID
 07AB 3A00              cmp A,[_ID]
 07AD B020              jnz L184
 07AF                   .dbline 737
 07AF           ;                                                                               {
 07AF                   .dbline 739
 07AF           ;                                                                                       // Set the timeout flag to exit the while loop.
 07AF           ;                                                                                       TIMEOUT = 1;
 07AF 62D000            mov REG[0xd0],>_TIMEOUT
 07B2 550101            mov [_TIMEOUT+1],1
 07B5 550000            mov [_TIMEOUT],0
 07B8                   .dbline 741
 07B8           ;                                                                                       // Set i such that the for loop is exited.
 07B8           ;                                                                                       i = SERVO_COMM_ATTEMPTS;
 07B8 56030A            mov [X+3],10
 07BB 560200            mov [X+2],0
 07BE                   .dbline 743
 07BE           ;                                                                                       // Set j such that we exit the outer loop as well.
 07BE           ;                                                                                       j = SERVO_COMM_LOOPS;
 07BE 560502            mov [X+5],2
 07C1 560400            mov [X+4],0
 07C4                   .dbline 745
 07C4           ;                                                                                       // Store the ID value.
 07C4           ;                                                                                       SERVO_ID = ID;
 07C4 62D000            mov REG[0xd0],>_ID
 07C7 5100              mov A,[_ID]
 07C9 62D000            mov REG[0xd0],>_SERVO_ID
 07CC 5300              mov [_SERVO_ID],A
 07CE                   .dbline 746
 07CE           ;                                                                               }
 07CE           L184:
 07CE                   .dbline 747
 07CE           ;                                                                       }
 07CE           L182:
 07CE                   .dbline 748
 07CE           ;                                                               }
 07CE           L180:
 07CE                   .dbline 749
 07CE           ;                                                       }
 07CE           L178:
 07CE                   .dbline 728
 07CE 62D000            mov REG[0xd0],>_TIMEOUT
 07D1 3C0000            cmp [_TIMEOUT],0
 07D4 B006              jnz X32
 07D6 3C0100            cmp [_TIMEOUT+1],0
 07D9 AFB2              jz L177
 07DB           X32:
 07DB                   .dbline 750
 07DB           ;                                               }
 07DB           L174:
 07DB                   .dbline 722
 07DB 7703              inc [X+3]
 07DD 0F0200            adc [X+2],0
 07E0                   .dbline 722
 07E0 5203              mov A,[X+3]
 07E2 110A              sub A,10
 07E4 5202              mov A,[X+2]
 07E6 3180              xor A,-128
 07E8 1980              sbb A,(0 ^ 0x80)
 07EA CF8E              jc L173
 07EC           X33:
 07EC                   .dbline 751
 07EC           ;                                       }       
 07EC           L170:
 07EC                   .dbline 716
 07EC 7705              inc [X+5]
 07EE 0F0400            adc [X+4],0
 07F1                   .dbline 716
 07F1 5205              mov A,[X+5]
 07F3 1102              sub A,2
 07F5 5204              mov A,[X+4]
 07F7 3180              xor A,-128
 07F9 1980              sbb A,(0 ^ 0x80)
 07FB CF60              jc L169
 07FD           X34:
 07FD                   .dbline 752
 07FD           ;                               }
 07FD           L167:
 07FD                   .dbline 754
 07FD           ;                               
 07FD           ;                               if(ID != SERVO_ID)
 07FD 62D000            mov REG[0xd0],>_ID
 0800 5100              mov A,[_ID]
 0802 62D000            mov REG[0xd0],>_SERVO_ID
 0805 3A00              cmp A,[_SERVO_ID]
 0807 A00D              jz L186
 0809                   .dbline 755
 0809           ;                               {
 0809                   .dbline 757
 0809           ;                                       // Toggle back to normal wait mode.
 0809           ;                                       configToggle(WAIT);
 0809 5000              mov A,0
 080B 08                push A
 080C 5001              mov A,1
 080E 08                push A
 080F 98A3              xcall _configToggle
 0811 38FE              add SP,-2
 0813                   .dbline 758
 0813           ;                               }
 0813 80BB              xjmp L162
 0815           L186:
 0815                   .dbline 760
 0815           ;                               else
 0815           ;                               {
 0815                   .dbline 762
 0815           ;                                       // Let the master node know that you got the ID assignment.
 0815           ;                                       assignedID();
 0815 92C1              xcall _assignedID
 0817                   .dbline 763
 0817           ;                               }
 0817                   .dbline 764
 0817           ;                       }
 0817                   .dbline 765
 0817           ;               }
 0817 80B7              xjmp L162
 0819           L163:
 0819                   .dbline 766
 0819           ;               else if(COMMAND_DESTINATION > ID)
 0819 62D000            mov REG[0xd0],>_ID
 081C 5100              mov A,[_ID]
 081E 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0821 3A00              cmp A,[_COMMAND_DESTINATION]
 0823 D0AB              jnc L162
 0825           X35:
 0825                   .dbline 767
 0825           ;               {
 0825                   .dbline 769
 0825           ;                       // Switch to listen to your child.
 0825           ;                       childResponse();
 0825 93A8              xcall _childResponse
 0827                   .dbline 770
 0827           ;               }
 0827                   .dbline 771
 0827           ;       }
 0827 80A7              xjmp L162
 0829           L161:
 0829                   .dbline 772
 0829           ;       else if(COMMAND_TYPE == CLEAR_CONFIG)   // The master wants to clear one or all configurations.
 0829 62D000            mov REG[0xd0],>_COMMAND_TYPE
 082C 3C00CC            cmp [_COMMAND_TYPE],-52
 082F B03D              jnz L190
 0831                   .dbline 773
 0831           ;       {
 0831                   .dbline 775
 0831           ;               // Only respond if this is directly to me and not a mass config clear.
 0831           ;               if(COMMAND_DESTINATION == ID)
 0831 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0834 5100              mov A,[_COMMAND_DESTINATION]
 0836 62D000            mov REG[0xd0],>_ID
 0839 3A00              cmp A,[_ID]
 083B B003              jnz L192
 083D                   .dbline 776
 083D           ;               {
 083D                   .dbline 777
 083D           ;                       configCleared();        // Notify the master that I am clearing my config.
 083D 9094              xcall _configCleared
 083F                   .dbline 778
 083F           ;               }
 083F           L192:
 083F                   .dbline 783
 083F           ;               
 083F           ;               // If this is meant for me, deconfigure.  Also, if a module ahead of you is
 083F           ;               // getting deconfigured, you have no choice but to deconfigure as well to
 083F           ;               // avoid errors on reconfiguration.
 083F           ;               if((COMMAND_DESTINATION <= ID) || (COMMAND_DESTINATION == BROADCAST))
 083F 62D000            mov REG[0xd0],>_ID
 0842 5100              mov A,[_ID]
 0844 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0847 3A00              cmp A,[_COMMAND_DESTINATION]
 0849 D009              jnc L196
 084B           X36:
 084B 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 084E 3C00FE            cmp [_COMMAND_DESTINATION],-2
 0851 B016              jnz L194
 0853           L196:
 0853                   .dbline 784
 0853           ;               {
 0853                   .dbline 785
 0853           ;                       ID = DEFAULT_ID;        // Reset my ID to the default.
 0853 62D000            mov REG[0xd0],>_ID
 0856 5500FB            mov [_ID],-5
 0859                   .dbline 786
 0859           ;                       CONFIGURED = 0;         // I am no longer configured.
 0859 62D000            mov REG[0xd0],>_CONFIGURED
 085C 550100            mov [_CONFIGURED+1],0
 085F 550000            mov [_CONFIGURED],0
 0862                   .dbline 787
 0862           ;                       CHILD = 0;                      // No one can depend on you anymore.
 0862 62D000            mov REG[0xd0],>_CHILD
 0865 550000            mov [_CHILD],0
 0868                   .dbline 788
 0868           ;               }
 0868           L194:
 0868                   .dbline 799
 0868           ; //            else if(COMMAND_DESTINATION > ID)
 0868           ; //            {
 0868           ; //                    // Switch to listen to your child.
 0868           ; //                    childResponse();
 0868           ; //                    // Switch back to wait for a master response.
 0868           ; //                    configToggle(WAIT);
 0868           ; //            }
 0868           ; //            Going to also have to take into account of this is my child.
 0868           ;               
 0868           ;               // Turn off the LED.
 0868           ;               PRT2DR |= 0b00000001;
 0868 430801            or REG[0x8],1
 086B                   .dbline 800
 086B           ;       }
 086B 8063              xjmp L191
 086D           L190:
 086D                   .dbline 801
 086D           ;       else if((COMMAND_TYPE == PING_SERVO) || (COMMAND_TYPE == READ_SERVO))
 086D 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0870 3C0001            cmp [_COMMAND_TYPE],1
 0873 A006              jz L199
 0875 3C0002            cmp [_COMMAND_TYPE],2
 0878 B056              jnz L197
 087A           L199:
 087A                   .dbline 802
 087A           ;       {
 087A                   .dbline 803
 087A           ;               if(COMMAND_DESTINATION > ID)
 087A 62D000            mov REG[0xd0],>_ID
 087D 5100              mov A,[_ID]
 087F 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0882 3A00              cmp A,[_COMMAND_DESTINATION]
 0884 D005              jnc L200
 0886           X37:
 0886                   .dbline 804
 0886           ;               {
 0886                   .dbline 806
 0886           ;                       // Allow the child response through.
 0886           ;                       childResponse();
 0886 9347              xcall _childResponse
 0888                   .dbline 807
 0888           ;               }
 0888 8046              xjmp L201
 088A           L200:
 088A                   .dbline 808
 088A           ;               else if(COMMAND_DESTINATION <= ID)
 088A 62D000            mov REG[0xd0],>_ID
 088D 5100              mov A,[_ID]
 088F 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0892 3A00              cmp A,[_COMMAND_DESTINATION]
 0894 C03A              jc L202
 0896           X38:
 0896                   .dbline 809
 0896           ;               {
 0896           L204:
 0896                   .dbline 811
 0896           ;                       // Sit and spin while we wait for the transmission to start.
 0896           ;                       while(WAIT_RECV_cReadChar() != SERVO_START) { }
 0896                   .dbline 811
 0896           L205:
 0896                   .dbline 811
 0896 10                push X
 0897 7C0000            xcall _WAIT_RECV_cReadChar
 089A 62D000            mov REG[0xd0],>__r0
 089D 20                pop X
 089E 39FF              cmp A,-1
 08A0 BFF5              jnz L204
 08A2                   .dbline 814
 08A2           ;                       
 08A2           ;                       // Reset the index variable.
 08A2           ;                       i = 0;
 08A2 560100            mov [X+1],0
 08A5 560000            mov [X+0],0
 08A8 801A              xjmp L208
 08AA           L207:
 08AA                   .dbline 819
 08AA           ;                       
 08AA           ;                       // Wait for the transmission to go through.
 08AA           ;                       // If no chars are read for RESPONSE_ITERATIONS iterations, move on.
 08AA           ;                       while(i < RESPONSE_ITERATIONS)
 08AA           ;                       {
 08AA                   .dbline 820
 08AA           ;                               if(WAIT_RECV_cReadChar())
 08AA 10                push X
 08AB 7C0000            xcall _WAIT_RECV_cReadChar
 08AE 62D000            mov REG[0xd0],>__r0
 08B1 20                pop X
 08B2 3900              cmp A,0
 08B4 A009              jz L210
 08B6                   .dbline 821
 08B6           ;                               {
 08B6                   .dbline 822
 08B6           ;                                       i = 0;
 08B6 560100            mov [X+1],0
 08B9 560000            mov [X+0],0
 08BC                   .dbline 823
 08BC           ;                               }
 08BC 8006              xjmp L211
 08BE           L210:
 08BE                   .dbline 825
 08BE           ;                               else
 08BE           ;                               {
 08BE                   .dbline 826
 08BE           ;                                       i++;
 08BE 7701              inc [X+1]
 08C0 0F0000            adc [X+0],0
 08C3                   .dbline 827
 08C3           ;                               }
 08C3           L211:
 08C3                   .dbline 828
 08C3           ;                       }
 08C3           L208:
 08C3                   .dbline 818
 08C3 5201              mov A,[X+1]
 08C5 110A              sub A,10
 08C7 5200              mov A,[X+0]
 08C9 3180              xor A,-128
 08CB 1980              sbb A,(0 ^ 0x80)
 08CD CFDC              jc L207
 08CF           X39:
 08CF                   .dbline 829
 08CF           ;               }
 08CF           L202:
 08CF           L201:
 08CF                   .dbline 830
 08CF           ;       }
 08CF           L197:
 08CF           L191:
 08CF           L162:
 08CF           L156:
 08CF           L146:
 08CF                   .dbline -2
 08CF           L144:
 08CF 38FA              add SP,-6
 08D1 20                pop X
 08D2                   .dbline 0 ; func end
 08D2 7F                ret
 08D3                   .dbsym l j 4 I
 08D3                   .dbsym l i 2 I
 08D3                   .dbsym l i 0 I
 08D3                   .dbend
 08D3                   .dbfunc e configCleared _configCleared fV
 08D3           _configCleared::
 08D3                   .dbline -1
 08D3                   .dbline 835
 08D3           ; }
 08D3           ; 
 08D3           ; // This function sends out an acknowledgement of a configuration reset.
 08D3           ; void configCleared(void)
 08D3           ; {
 08D3                   .dbline 836
 08D3           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 08D3 5000              mov A,0
 08D5 08                push A
 08D6 5002              mov A,2
 08D8 08                push A
 08D9 7C00B4            xcall _configToggle
 08DC 38FE              add SP,-2
 08DE                   .dbline 839
 08DE           ;       
 08DE           ;       // Transmit a ping to everyone.
 08DE           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 08DE 10                push X
 08DF 50FC              mov A,-4
 08E1 7C0000            xcall _TX_014_PutChar
 08E4 20                pop X
 08E5                   .dbline 840
 08E5           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 08E5 10                push X
 08E6 50FC              mov A,-4
 08E8 7C0000            xcall _TX_23_PutChar
 08EB 20                pop X
 08EC                   .dbline 841
 08EC           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 08EC 10                push X
 08ED 50FC              mov A,-4
 08EF 7C0000            xcall _TX_014_PutChar
 08F2 20                pop X
 08F3                   .dbline 842
 08F3           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 08F3 10                push X
 08F4 50FC              mov A,-4
 08F6 7C0000            xcall _TX_23_PutChar
 08F9 20                pop X
 08FA                   .dbline 843
 08FA           ;       TX_014_PutChar(ID);                             // My ID
 08FA 10                push X
 08FB 62D000            mov REG[0xd0],>_ID
 08FE 5100              mov A,[_ID]
 0900 7C0000            xcall _TX_014_PutChar
 0903 20                pop X
 0904                   .dbline 844
 0904           ;       TX_23_PutChar(ID);                              // My ID
 0904 10                push X
 0905 62D000            mov REG[0xd0],>_ID
 0908 5100              mov A,[_ID]
 090A 7C0000            xcall _TX_23_PutChar
 090D 20                pop X
 090E                   .dbline 845
 090E           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 090E 10                push X
 090F 5000              mov A,0
 0911 7C0000            xcall _TX_014_PutChar
 0914 20                pop X
 0915                   .dbline 846
 0915           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 0915 10                push X
 0916 5000              mov A,0
 0918 7C0000            xcall _TX_23_PutChar
 091B 20                pop X
 091C                   .dbline 847
 091C           ;       TX_014_PutChar(CONFIG_CLEARED); // This is a ping response
 091C 10                push X
 091D 50CD              mov A,-51
 091F 7C0000            xcall _TX_014_PutChar
 0922 20                pop X
 0923                   .dbline 848
 0923           ;       TX_23_PutChar(CONFIG_CLEARED);  // This is a ping response
 0923 10                push X
 0924 50CD              mov A,-51
 0926 7C0000            xcall _TX_23_PutChar
 0929 20                pop X
 092A                   .dbline 849
 092A           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 092A 10                push X
 092B 50FD              mov A,-3
 092D 7C0000            xcall _TX_014_PutChar
 0930 20                pop X
 0931                   .dbline 850
 0931           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0931 10                push X
 0932 50FD              mov A,-3
 0934 7C0000            xcall _TX_23_PutChar
 0937 20                pop X
 0938                   .dbline 851
 0938           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0938 10                push X
 0939 50FD              mov A,-3
 093B 7C0000            xcall _TX_014_PutChar
 093E 20                pop X
 093F                   .dbline 852
 093F           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 093F 10                push X
 0940 50FD              mov A,-3
 0942 7C0000            xcall _TX_23_PutChar
 0945 20                pop X
 0946           L213:
 0946                   .dbline 855
 0946           ;       
 0946           ;       // Wait for the transmission to finish.
 0946           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0946           L214:
 0946                   .dbline 855
 0946 10                push X
 0947 7C0000            xcall _TX_014_bReadTxStatus
 094A 62D000            mov REG[0xd0],>__r0
 094D 20                pop X
 094E 5300              mov [__r0],A
 0950 470020            tst [__r0],32
 0953 AFF2              jz L213
 0955           L216:
 0955                   .dbline 856
 0955           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 0955           L217:
 0955                   .dbline 856
 0955 10                push X
 0956 7C0000            xcall _TX_23_bReadTxStatus
 0959 62D000            mov REG[0xd0],>__r0
 095C 20                pop X
 095D 5300              mov [__r0],A
 095F 470020            tst [__r0],32
 0962 AFF2              jz L216
 0964                   .dbline 859
 0964           ;       
 0964           ;       // Make completely sure we're done.
 0964           ;       xmitWait();
 0964 95FD              xcall _xmitWait
 0966                   .dbline 861
 0966           ;       
 0966           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0966 5000              mov A,0
 0968 08                push A
 0969 5001              mov A,1
 096B 08                push A
 096C 7C00B4            xcall _configToggle
 096F 38FE              add SP,-2
 0971                   .dbline -2
 0971           L212:
 0971                   .dbline 0 ; func end
 0971 7F                ret
 0972                   .dbend
 0972                   .dbfunc e pingResponse _pingResponse fV
 0972           _pingResponse::
 0972                   .dbline -1
 0972                   .dbline 866
 0972           ; }
 0972           ; 
 0972           ; // This function sends out a ping response for everyone to hear.
 0972           ; void pingResponse(void)
 0972           ; {
 0972                   .dbline 867
 0972           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 0972 5000              mov A,0
 0974 08                push A
 0975 5002              mov A,2
 0977 08                push A
 0978 7C00B4            xcall _configToggle
 097B 38FE              add SP,-2
 097D                   .dbline 870
 097D           ;       
 097D           ;       // Transmit a ping to everyone.
 097D           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 097D 10                push X
 097E 50FC              mov A,-4
 0980 7C0000            xcall _TX_014_PutChar
 0983 20                pop X
 0984                   .dbline 871
 0984           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 0984 10                push X
 0985 50FC              mov A,-4
 0987 7C0000            xcall _TX_23_PutChar
 098A 20                pop X
 098B                   .dbline 872
 098B           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 098B 10                push X
 098C 50FC              mov A,-4
 098E 7C0000            xcall _TX_014_PutChar
 0991 20                pop X
 0992                   .dbline 873
 0992           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 0992 10                push X
 0993 50FC              mov A,-4
 0995 7C0000            xcall _TX_23_PutChar
 0998 20                pop X
 0999                   .dbline 874
 0999           ;       TX_014_PutChar(ID);                             // My ID
 0999 10                push X
 099A 62D000            mov REG[0xd0],>_ID
 099D 5100              mov A,[_ID]
 099F 7C0000            xcall _TX_014_PutChar
 09A2 20                pop X
 09A3                   .dbline 875
 09A3           ;       TX_23_PutChar(ID);                              // My ID
 09A3 10                push X
 09A4 62D000            mov REG[0xd0],>_ID
 09A7 5100              mov A,[_ID]
 09A9 7C0000            xcall _TX_23_PutChar
 09AC 20                pop X
 09AD                   .dbline 876
 09AD           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 09AD 10                push X
 09AE 5000              mov A,0
 09B0 7C0000            xcall _TX_014_PutChar
 09B3 20                pop X
 09B4                   .dbline 877
 09B4           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 09B4 10                push X
 09B5 5000              mov A,0
 09B7 7C0000            xcall _TX_23_PutChar
 09BA 20                pop X
 09BB                   .dbline 878
 09BB           ;       TX_014_PutChar(PING);                   // This is a ping response
 09BB 10                push X
 09BC 50CB              mov A,-53
 09BE 7C0000            xcall _TX_014_PutChar
 09C1 20                pop X
 09C2                   .dbline 879
 09C2           ;       TX_23_PutChar(PING);                    // This is a ping response
 09C2 10                push X
 09C3 50CB              mov A,-53
 09C5 7C0000            xcall _TX_23_PutChar
 09C8 20                pop X
 09C9                   .dbline 880
 09C9           ;       TX_014_PutChar(TYPE);                   // This is the module type
 09C9 10                push X
 09CA 5001              mov A,1
 09CC 7C0000            xcall _TX_014_PutChar
 09CF 20                pop X
 09D0                   .dbline 881
 09D0           ;       TX_23_PutChar(TYPE);                    // This is the module type
 09D0 10                push X
 09D1 5001              mov A,1
 09D3 7C0000            xcall _TX_23_PutChar
 09D6 20                pop X
 09D7                   .dbline 882
 09D7           ;       TX_014_PutChar(CHILD);                  // This is the child-connected port
 09D7 10                push X
 09D8 62D000            mov REG[0xd0],>_CHILD
 09DB 5100              mov A,[_CHILD]
 09DD 7C0000            xcall _TX_014_PutChar
 09E0 20                pop X
 09E1                   .dbline 883
 09E1           ;       TX_23_PutChar(CHILD);                   // This is the child-connected port
 09E1 10                push X
 09E2 62D000            mov REG[0xd0],>_CHILD
 09E5 5100              mov A,[_CHILD]
 09E7 7C0000            xcall _TX_23_PutChar
 09EA 20                pop X
 09EB                   .dbline 884
 09EB           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 09EB 10                push X
 09EC 50FD              mov A,-3
 09EE 7C0000            xcall _TX_014_PutChar
 09F1 20                pop X
 09F2                   .dbline 885
 09F2           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 09F2 10                push X
 09F3 50FD              mov A,-3
 09F5 7C0000            xcall _TX_23_PutChar
 09F8 20                pop X
 09F9                   .dbline 886
 09F9           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 09F9 10                push X
 09FA 50FD              mov A,-3
 09FC 7C0000            xcall _TX_014_PutChar
 09FF 20                pop X
 0A00                   .dbline 887
 0A00           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0A00 10                push X
 0A01 50FD              mov A,-3
 0A03 7C0000            xcall _TX_23_PutChar
 0A06 20                pop X
 0A07           L220:
 0A07                   .dbline 890
 0A07           ;       
 0A07           ;       // Wait for the transmission to finish.
 0A07           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0A07           L221:
 0A07                   .dbline 890
 0A07 10                push X
 0A08 7C0000            xcall _TX_014_bReadTxStatus
 0A0B 62D000            mov REG[0xd0],>__r0
 0A0E 20                pop X
 0A0F 5300              mov [__r0],A
 0A11 470020            tst [__r0],32
 0A14 AFF2              jz L220
 0A16           L223:
 0A16                   .dbline 891
 0A16           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 0A16           L224:
 0A16                   .dbline 891
 0A16 10                push X
 0A17 7C0000            xcall _TX_23_bReadTxStatus
 0A1A 62D000            mov REG[0xd0],>__r0
 0A1D 20                pop X
 0A1E 5300              mov [__r0],A
 0A20 470020            tst [__r0],32
 0A23 AFF2              jz L223
 0A25                   .dbline 894
 0A25           ;       
 0A25           ;       // Make completely sure we're done.
 0A25           ;       xmitWait();
 0A25 953C              xcall _xmitWait
 0A27                   .dbline 896
 0A27           ;       
 0A27           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0A27 5000              mov A,0
 0A29 08                push A
 0A2A 5001              mov A,1
 0A2C 08                push A
 0A2D 7C00B4            xcall _configToggle
 0A30 38FE              add SP,-2
 0A32                   .dbline -2
 0A32           L219:
 0A32                   .dbline 0 ; func end
 0A32 7F                ret
 0A33                   .dbend
 0A33                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0A33           _unloadAllConfigs::
 0A33                   .dbline -1
 0A33                   .dbline 902
 0A33           ; }
 0A33           ; 
 0A33           ; // This function blindly unloads all user configurations. This will be called once,
 0A33           ; // when the system initially has no known state.
 0A33           ; void unloadAllConfigs(void)
 0A33           ; {
 0A33                   .dbline 903
 0A33           ;       UnloadConfig_waiting();
 0A33 7C0000            xcall _UnloadConfig_waiting
 0A36                   .dbline 904
 0A36           ;       UnloadConfig_hello();
 0A36 7C0000            xcall _UnloadConfig_hello
 0A39                   .dbline 905
 0A39           ;       UnloadConfig_my_response();
 0A39 7C0000            xcall _UnloadConfig_my_response
 0A3C                   .dbline 906
 0A3C           ;       UnloadConfig_response1();
 0A3C 7C0000            xcall _UnloadConfig_response1
 0A3F                   .dbline 907
 0A3F           ;       UnloadConfig_response2();
 0A3F 7C0000            xcall _UnloadConfig_response2
 0A42                   .dbline 908
 0A42           ;       UnloadConfig_response3();
 0A42 7C0000            xcall _UnloadConfig_response3
 0A45                   .dbline 909
 0A45           ;       UnloadConfig_response4();
 0A45 7C0000            xcall _UnloadConfig_response4
 0A48                   .dbline 910
 0A48           ;       UnloadConfig_initial();
 0A48 7C0000            xcall _UnloadConfig_initial
 0A4B                   .dbline 911
 0A4B           ;       UnloadConfig_servo_transmit();
 0A4B 7C0000            xcall _UnloadConfig_servo_transmit
 0A4E                   .dbline -2
 0A4E           L226:
 0A4E                   .dbline 0 ; func end
 0A4E 7F                ret
 0A4F                   .dbend
 0A4F                   .dbfunc e unloadConfig _unloadConfig fV
 0A4F           ;     config_num -> X-5
 0A4F           _unloadConfig::
 0A4F                   .dbline -1
 0A4F 10                push X
 0A50 4F                mov X,SP
 0A51                   .dbline 917
 0A51           ; }
 0A51           ; 
 0A51           ; // This function unloads the configuration corresponding to the config number passed to it.
 0A51           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0A51           ; void unloadConfig(int config_num)
 0A51           ; {
 0A51                   .dbline 918
 0A51           ;       if(config_num == WAIT)
 0A51 3DFB00            cmp [X-5],0
 0A54 B00B              jnz L228
 0A56 3DFC01            cmp [X-4],1
 0A59 B006              jnz L228
 0A5B           X40:
 0A5B                   .dbline 919
 0A5B           ;       {
 0A5B                   .dbline 920
 0A5B           ;               UnloadConfig_waiting();
 0A5B 7C0000            xcall _UnloadConfig_waiting
 0A5E                   .dbline 921
 0A5E           ;       }
 0A5E 8077              xjmp L229
 0A60           L228:
 0A60                   .dbline 922
 0A60           ;       else if(config_num == HELLO_MODE)
 0A60 3DFB00            cmp [X-5],0
 0A63 B00B              jnz L230
 0A65 3DFC07            cmp [X-4],7
 0A68 B006              jnz L230
 0A6A           X41:
 0A6A                   .dbline 923
 0A6A           ;       {
 0A6A                   .dbline 924
 0A6A           ;               UnloadConfig_hello();
 0A6A 7C0000            xcall _UnloadConfig_hello
 0A6D                   .dbline 925
 0A6D           ;       }
 0A6D 8068              xjmp L231
 0A6F           L230:
 0A6F                   .dbline 926
 0A6F           ;       else if(config_num == MY_RESPONSE)
 0A6F 3DFB00            cmp [X-5],0
 0A72 B00B              jnz L232
 0A74 3DFC02            cmp [X-4],2
 0A77 B006              jnz L232
 0A79           X42:
 0A79                   .dbline 927
 0A79           ;       {
 0A79                   .dbline 928
 0A79           ;               UnloadConfig_my_response();
 0A79 7C0000            xcall _UnloadConfig_my_response
 0A7C                   .dbline 929
 0A7C           ;       }
 0A7C 8059              xjmp L233
 0A7E           L232:
 0A7E                   .dbline 930
 0A7E           ;       else if(config_num == RESPONSE_1)
 0A7E 3DFB00            cmp [X-5],0
 0A81 B00B              jnz L234
 0A83 3DFC03            cmp [X-4],3
 0A86 B006              jnz L234
 0A88           X43:
 0A88                   .dbline 931
 0A88           ;       {
 0A88                   .dbline 932
 0A88           ;               UnloadConfig_response1();
 0A88 7C0000            xcall _UnloadConfig_response1
 0A8B                   .dbline 933
 0A8B           ;       }
 0A8B 804A              xjmp L235
 0A8D           L234:
 0A8D                   .dbline 934
 0A8D           ;       else if(config_num == RESPONSE_2)
 0A8D 3DFB00            cmp [X-5],0
 0A90 B00B              jnz L236
 0A92 3DFC04            cmp [X-4],4
 0A95 B006              jnz L236
 0A97           X44:
 0A97                   .dbline 935
 0A97           ;       {
 0A97                   .dbline 936
 0A97           ;               UnloadConfig_response2();
 0A97 7C0000            xcall _UnloadConfig_response2
 0A9A                   .dbline 937
 0A9A           ;       }
 0A9A 803B              xjmp L237
 0A9C           L236:
 0A9C                   .dbline 938
 0A9C           ;       else if(config_num == RESPONSE_3)
 0A9C 3DFB00            cmp [X-5],0
 0A9F B00B              jnz L238
 0AA1 3DFC05            cmp [X-4],5
 0AA4 B006              jnz L238
 0AA6           X45:
 0AA6                   .dbline 939
 0AA6           ;       {
 0AA6                   .dbline 940
 0AA6           ;               UnloadConfig_response3();
 0AA6 7C0000            xcall _UnloadConfig_response3
 0AA9                   .dbline 941
 0AA9           ;       }
 0AA9 802C              xjmp L239
 0AAB           L238:
 0AAB                   .dbline 942
 0AAB           ;       else if(config_num == RESPONSE_4)
 0AAB 3DFB00            cmp [X-5],0
 0AAE B00B              jnz L240
 0AB0 3DFC06            cmp [X-4],6
 0AB3 B006              jnz L240
 0AB5           X46:
 0AB5                   .dbline 943
 0AB5           ;       {
 0AB5                   .dbline 944
 0AB5           ;               UnloadConfig_response4();
 0AB5 7C0000            xcall _UnloadConfig_response4
 0AB8                   .dbline 945
 0AB8           ;       }
 0AB8 801D              xjmp L241
 0ABA           L240:
 0ABA                   .dbline 946
 0ABA           ;       else if(config_num == INITIALIZE)
 0ABA 3DFB00            cmp [X-5],0
 0ABD B00B              jnz L242
 0ABF 3DFC08            cmp [X-4],8
 0AC2 B006              jnz L242
 0AC4           X47:
 0AC4                   .dbline 947
 0AC4           ;       {
 0AC4                   .dbline 948
 0AC4           ;               UnloadConfig_initial();
 0AC4 7C0000            xcall _UnloadConfig_initial
 0AC7                   .dbline 949
 0AC7           ;       }
 0AC7 800E              xjmp L243
 0AC9           L242:
 0AC9                   .dbline 950
 0AC9           ;       else if(config_num == SERVO_COMM)
 0AC9 3DFB00            cmp [X-5],0
 0ACC B009              jnz L244
 0ACE 3DFC09            cmp [X-4],9
 0AD1 B004              jnz L244
 0AD3           X48:
 0AD3                   .dbline 951
 0AD3           ;       {
 0AD3                   .dbline 952
 0AD3           ;               UnloadConfig_servo_transmit();
 0AD3 7C0000            xcall _UnloadConfig_servo_transmit
 0AD6                   .dbline 953
 0AD6           ;       }
 0AD6           L244:
 0AD6           L243:
 0AD6           L241:
 0AD6           L239:
 0AD6           L237:
 0AD6           L235:
 0AD6           L233:
 0AD6           L231:
 0AD6           L229:
 0AD6                   .dbline -2
 0AD6           L227:
 0AD6 20                pop X
 0AD7                   .dbline 0 ; func end
 0AD7 7F                ret
 0AD8                   .dbsym l config_num -5 I
 0AD8                   .dbend
 0AD8                   .dbfunc e assignedID _assignedID fV
 0AD8           _assignedID::
 0AD8                   .dbline -1
 0AD8                   .dbline 958
 0AD8           ; }
 0AD8           ; 
 0AD8           ; // This function responds that an ID has been assigned to it.
 0AD8           ; void assignedID(void)
 0AD8           ; {
 0AD8                   .dbline 959
 0AD8           ;       configToggle(MY_RESPONSE);              // Switch to response mode.
 0AD8 5000              mov A,0
 0ADA 08                push A
 0ADB 5002              mov A,2
 0ADD 08                push A
 0ADE 7C00B4            xcall _configToggle
 0AE1 38FE              add SP,-2
 0AE3                   .dbline 962
 0AE3           ;       
 0AE3           ;       // Transmit a ping to everyone.
 0AE3           ;       TX_014_PutChar(START_TRANSMIT); // Start byte one
 0AE3 10                push X
 0AE4 50FC              mov A,-4
 0AE6 7C0000            xcall _TX_014_PutChar
 0AE9 20                pop X
 0AEA                   .dbline 963
 0AEA           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte one
 0AEA 10                push X
 0AEB 50FC              mov A,-4
 0AED 7C0000            xcall _TX_23_PutChar
 0AF0 20                pop X
 0AF1                   .dbline 964
 0AF1           ;       TX_014_PutChar(START_TRANSMIT); // Start byte two
 0AF1 10                push X
 0AF2 50FC              mov A,-4
 0AF4 7C0000            xcall _TX_014_PutChar
 0AF7 20                pop X
 0AF8                   .dbline 965
 0AF8           ;       TX_23_PutChar(START_TRANSMIT);  // Start byte two
 0AF8 10                push X
 0AF9 50FC              mov A,-4
 0AFB 7C0000            xcall _TX_23_PutChar
 0AFE 20                pop X
 0AFF                   .dbline 966
 0AFF           ;       TX_014_PutChar(ID);                             // My ID
 0AFF 10                push X
 0B00 62D000            mov REG[0xd0],>_ID
 0B03 5100              mov A,[_ID]
 0B05 7C0000            xcall _TX_014_PutChar
 0B08 20                pop X
 0B09                   .dbline 967
 0B09           ;       TX_23_PutChar(ID);                              // My ID
 0B09 10                push X
 0B0A 62D000            mov REG[0xd0],>_ID
 0B0D 5100              mov A,[_ID]
 0B0F 7C0000            xcall _TX_23_PutChar
 0B12 20                pop X
 0B13                   .dbline 968
 0B13           ;       TX_014_PutChar(MASTER_ID);              // Destination ID (master)
 0B13 10                push X
 0B14 5000              mov A,0
 0B16 7C0000            xcall _TX_014_PutChar
 0B19 20                pop X
 0B1A                   .dbline 969
 0B1A           ;       TX_23_PutChar(MASTER_ID);               // Destination ID (master)
 0B1A 10                push X
 0B1B 5000              mov A,0
 0B1D 7C0000            xcall _TX_23_PutChar
 0B20 20                pop X
 0B21                   .dbline 970
 0B21           ;       TX_014_PutChar(ID_ASSIGN_OK);   // This is an assignment ack response
 0B21 10                push X
 0B22 50CA              mov A,-54
 0B24 7C0000            xcall _TX_014_PutChar
 0B27 20                pop X
 0B28                   .dbline 971
 0B28           ;       TX_23_PutChar(ID_ASSIGN_OK);    // This is an assignment ack response
 0B28 10                push X
 0B29 50CA              mov A,-54
 0B2B 7C0000            xcall _TX_23_PutChar
 0B2E 20                pop X
 0B2F                   .dbline 972
 0B2F           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0B2F 10                push X
 0B30 50FD              mov A,-3
 0B32 7C0000            xcall _TX_014_PutChar
 0B35 20                pop X
 0B36                   .dbline 973
 0B36           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0B36 10                push X
 0B37 50FD              mov A,-3
 0B39 7C0000            xcall _TX_23_PutChar
 0B3C 20                pop X
 0B3D                   .dbline 974
 0B3D           ;       TX_014_PutChar(END_TRANSMIT);   // This is the end of this transmission
 0B3D 10                push X
 0B3E 50FD              mov A,-3
 0B40 7C0000            xcall _TX_014_PutChar
 0B43 20                pop X
 0B44                   .dbline 975
 0B44           ;       TX_23_PutChar(END_TRANSMIT);    // This is the end of this transmission
 0B44 10                push X
 0B45 50FD              mov A,-3
 0B47 7C0000            xcall _TX_23_PutChar
 0B4A 20                pop X
 0B4B           L247:
 0B4B                   .dbline 978
 0B4B           ;       
 0B4B           ;       // Wait for the transmission to finish.
 0B4B           ;       while(!(TX_014_bReadTxStatus() & TX_014_TX_COMPLETE));
 0B4B           L248:
 0B4B                   .dbline 978
 0B4B 10                push X
 0B4C 7C0000            xcall _TX_014_bReadTxStatus
 0B4F 62D000            mov REG[0xd0],>__r0
 0B52 20                pop X
 0B53 5300              mov [__r0],A
 0B55 470020            tst [__r0],32
 0B58 AFF2              jz L247
 0B5A           L250:
 0B5A                   .dbline 979
 0B5A           ;       while(!(TX_23_bReadTxStatus() & TX_23_TX_COMPLETE));
 0B5A           L251:
 0B5A                   .dbline 979
 0B5A 10                push X
 0B5B 7C0000            xcall _TX_23_bReadTxStatus
 0B5E 62D000            mov REG[0xd0],>__r0
 0B61 20                pop X
 0B62 5300              mov [__r0],A
 0B64 470020            tst [__r0],32
 0B67 AFF2              jz L250
 0B69                   .dbline 982
 0B69           ;       
 0B69           ;       // Make completely sure we're done.
 0B69           ;       xmitWait();
 0B69 93F8              xcall _xmitWait
 0B6B                   .dbline 984
 0B6B           ;       
 0B6B           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0B6B 5000              mov A,0
 0B6D 08                push A
 0B6E 5001              mov A,1
 0B70 08                push A
 0B71 7C00B4            xcall _configToggle
 0B74 38FE              add SP,-2
 0B76                   .dbline -2
 0B76           L246:
 0B76                   .dbline 0 ; func end
 0B76 7F                ret
 0B77                   .dbend
 0B77                   .dbfunc e childListen _childListen fI
 0B77           _childListen::
 0B77                   .dbline -1
 0B77                   .dbline 989
 0B77           ; }
 0B77           ; 
 0B77           ; // This function listens for children and registers the port that they talk to.
 0B77           ; int childListen(void)
 0B77           ; {
 0B77                   .dbline 990
 0B77           ;       configToggle(HELLO_MODE);       // Switch to listen for hellos on every port.
 0B77 5000              mov A,0
 0B79 08                push A
 0B7A 5007              mov A,7
 0B7C 08                push A
 0B7D 7C00B4            xcall _configToggle
 0B80 38FE              add SP,-2
 0B82 801C              xjmp L255
 0B84           L254:
 0B84                   .dbline 994
 0B84           ;       
 0B84           ;       // Wait to either hear a child or time out.
 0B84           ;       while(!TIMEOUT)
 0B84           ;       {               
 0B84                   .dbline 995
 0B84           ;               if(commandReady())
 0B84 7C02BE            xcall _commandReady
 0B87 62D000            mov REG[0xd0],>__r0
 0B8A 3C0000            cmp [__r0],0
 0B8D B006              jnz X49
 0B8F 3C0000            cmp [__r1],0
 0B92 A00C              jz L257
 0B94           X49:
 0B94                   .dbline 996
 0B94           ;               {
 0B94                   .dbline 997
 0B94           ;                       return 1;
 0B94 62D000            mov REG[0xd0],>__r0
 0B97 550001            mov [__r1],1
 0B9A 550000            mov [__r0],0
 0B9D 8030              xjmp L253
 0B9F           L257:
 0B9F                   .dbline 999
 0B9F           ;               }
 0B9F           ;       }
 0B9F           L255:
 0B9F                   .dbline 993
 0B9F 62D000            mov REG[0xd0],>_TIMEOUT
 0BA2 3C0000            cmp [_TIMEOUT],0
 0BA5 B006              jnz X50
 0BA7 3C0100            cmp [_TIMEOUT+1],0
 0BAA AFD9              jz L254
 0BAC           X50:
 0BAC                   .dbline 1001
 0BAC           ;       
 0BAC           ;       HELLO_TIMEOUT_Stop();           // Stop the timer.
 0BAC 10                push X
 0BAD 7C0000            xcall _HELLO_TIMEOUT_Stop
 0BB0 20                pop X
 0BB1                   .dbline 1002
 0BB1           ;       TIMEOUT = 0;                            // Clear the timeout flag.
 0BB1 62D000            mov REG[0xd0],>_TIMEOUT
 0BB4 550100            mov [_TIMEOUT+1],0
 0BB7 550000            mov [_TIMEOUT],0
 0BBA                   .dbline 1004
 0BBA           ;       
 0BBA           ;       configToggle(WAIT);                     // Switch back to wait for a master response.
 0BBA 5000              mov A,0
 0BBC 08                push A
 0BBD 5001              mov A,1
 0BBF 08                push A
 0BC0 7C00B4            xcall _configToggle
 0BC3 38FE              add SP,-2
 0BC5                   .dbline 1006
 0BC5           ;       
 0BC5           ;       return 0;                                       // Return the result of our listening session.
 0BC5 62D000            mov REG[0xd0],>__r0
 0BC8 550000            mov [__r1],0
 0BCB 550000            mov [__r0],0
 0BCE                   .dbline -2
 0BCE           L253:
 0BCE                   .dbline 0 ; func end
 0BCE 7F                ret
 0BCF                   .dbend
 0BCF                   .dbfunc e childResponse _childResponse fI
 0BCF           ; child_responded -> X+0
 0BCF           _childResponse::
 0BCF                   .dbline -1
 0BCF 10                push X
 0BD0 4F                mov X,SP
 0BD1 3802              add SP,2
 0BD3                   .dbline 1011
 0BD3           ; }
 0BD3           ; 
 0BD3           ; // This function waits for a child response.
 0BD3           ; int childResponse(void)
 0BD3           ; {
 0BD3                   .dbline 1012
 0BD3           ;       int child_responded = 0;
 0BD3 560100            mov [X+1],0
 0BD6 560000            mov [X+0],0
 0BD9                   .dbline 1015
 0BD9           ;       
 0BD9           ;       // Switch to the right port.
 0BD9           ;       if(CHILD == PORT_1)
 0BD9 62D000            mov REG[0xd0],>_CHILD
 0BDC 3C0031            cmp [_CHILD],49
 0BDF B00E              jnz L260
 0BE1                   .dbline 1016
 0BE1           ;       {
 0BE1                   .dbline 1017
 0BE1           ;               configToggle(RESPONSE_1);
 0BE1 5000              mov A,0
 0BE3 08                push A
 0BE4 5003              mov A,3
 0BE6 08                push A
 0BE7 7C00B4            xcall _configToggle
 0BEA 38FE              add SP,-2
 0BEC                   .dbline 1018
 0BEC           ;       }
 0BEC 8056              xjmp L269
 0BEE           L260:
 0BEE                   .dbline 1019
 0BEE           ;       else if(CHILD == PORT_2)
 0BEE 62D000            mov REG[0xd0],>_CHILD
 0BF1 3C0032            cmp [_CHILD],50
 0BF4 B00E              jnz L262
 0BF6                   .dbline 1020
 0BF6           ;       {
 0BF6                   .dbline 1021
 0BF6           ;               configToggle(RESPONSE_2);
 0BF6 5000              mov A,0
 0BF8 08                push A
 0BF9 5004              mov A,4
 0BFB 08                push A
 0BFC 7C00B4            xcall _configToggle
 0BFF 38FE              add SP,-2
 0C01                   .dbline 1022
 0C01           ;       }
 0C01 8041              xjmp L269
 0C03           L262:
 0C03                   .dbline 1023
 0C03           ;       else if(CHILD == PORT_3)
 0C03 62D000            mov REG[0xd0],>_CHILD
 0C06 3C0033            cmp [_CHILD],51
 0C09 B00E              jnz L264
 0C0B                   .dbline 1024
 0C0B           ;       {
 0C0B                   .dbline 1025
 0C0B           ;               configToggle(RESPONSE_3);
 0C0B 5000              mov A,0
 0C0D 08                push A
 0C0E 5005              mov A,5
 0C10 08                push A
 0C11 7C00B4            xcall _configToggle
 0C14 38FE              add SP,-2
 0C16                   .dbline 1026
 0C16           ;       }
 0C16 802C              xjmp L269
 0C18           L264:
 0C18                   .dbline 1027
 0C18           ;       else if(CHILD == PORT_4)
 0C18 62D000            mov REG[0xd0],>_CHILD
 0C1B 3C0034            cmp [_CHILD],52
 0C1E B024              jnz L269
 0C20                   .dbline 1028
 0C20           ;       {
 0C20                   .dbline 1029
 0C20           ;               configToggle(RESPONSE_4);
 0C20 5000              mov A,0
 0C22 08                push A
 0C23 5006              mov A,6
 0C25 08                push A
 0C26 7C00B4            xcall _configToggle
 0C29 38FE              add SP,-2
 0C2B                   .dbline 1030
 0C2B           ;       }
 0C2B 8017              xjmp L269
 0C2D           L268:
 0C2D                   .dbline 1034
 0C2D           ;       
 0C2D           ;       // Wait for a response or a timeout.
 0C2D           ;       while((!child_responded) && (!TIMEOUT))
 0C2D           ;       {
 0C2D                   .dbline 1035
 0C2D           ;               if(commandReady())
 0C2D 7C02BE            xcall _commandReady
 0C30 62D000            mov REG[0xd0],>__r0
 0C33 3C0000            cmp [__r0],0
 0C36 B006              jnz X51
 0C38 3C0000            cmp [__r1],0
 0C3B A007              jz L271
 0C3D           X51:
 0C3D                   .dbline 1036
 0C3D           ;               {
 0C3D                   .dbline 1037
 0C3D           ;                       child_responded = 1;
 0C3D 560101            mov [X+1],1
 0C40 560000            mov [X+0],0
 0C43                   .dbline 1038
 0C43           ;               }
 0C43           L271:
 0C43                   .dbline 1039
 0C43           ;       }
 0C43           L269:
 0C43                   .dbline 1033
 0C43 3D0000            cmp [X+0],0
 0C46 B013              jnz L273
 0C48 3D0100            cmp [X+1],0
 0C4B B00E              jnz L273
 0C4D           X52:
 0C4D 62D000            mov REG[0xd0],>_TIMEOUT
 0C50 3C0000            cmp [_TIMEOUT],0
 0C53 B006              jnz X53
 0C55 3C0100            cmp [_TIMEOUT+1],0
 0C58 AFD4              jz L268
 0C5A           X53:
 0C5A           L273:
 0C5A                   .dbline 1042
 0C5A           ;       
 0C5A           ;       // Stop the right timer.
 0C5A           ;       if(CHILD == PORT_1)
 0C5A 62D000            mov REG[0xd0],>_CHILD
 0C5D 3C0031            cmp [_CHILD],49
 0C60 B008              jnz L274
 0C62                   .dbline 1043
 0C62           ;       {
 0C62                   .dbline 1044
 0C62           ;               CHILD_1_TIMEOUT_Stop();
 0C62 10                push X
 0C63 7C0000            xcall _CHILD_1_TIMEOUT_Stop
 0C66 20                pop X
 0C67                   .dbline 1045
 0C67           ;       }
 0C67 802C              xjmp L275
 0C69           L274:
 0C69                   .dbline 1046
 0C69           ;       else if(CHILD == PORT_2)
 0C69 62D000            mov REG[0xd0],>_CHILD
 0C6C 3C0032            cmp [_CHILD],50
 0C6F B008              jnz L276
 0C71                   .dbline 1047
 0C71           ;       {
 0C71                   .dbline 1048
 0C71           ;               CHILD_2_TIMEOUT_Stop();
 0C71 10                push X
 0C72 7C0000            xcall _CHILD_2_TIMEOUT_Stop
 0C75 20                pop X
 0C76                   .dbline 1049
 0C76           ;       }
 0C76 801D              xjmp L277
 0C78           L276:
 0C78                   .dbline 1050
 0C78           ;       else if(CHILD == PORT_3)
 0C78 62D000            mov REG[0xd0],>_CHILD
 0C7B 3C0033            cmp [_CHILD],51
 0C7E B008              jnz L278
 0C80                   .dbline 1051
 0C80           ;       {
 0C80                   .dbline 1052
 0C80           ;               CHILD_3_TIMEOUT_Stop();
 0C80 10                push X
 0C81 7C0000            xcall _CHILD_3_TIMEOUT_Stop
 0C84 20                pop X
 0C85                   .dbline 1053
 0C85           ;       }
 0C85 800E              xjmp L279
 0C87           L278:
 0C87                   .dbline 1054
 0C87           ;       else if(CHILD == PORT_4)
 0C87 62D000            mov REG[0xd0],>_CHILD
 0C8A 3C0034            cmp [_CHILD],52
 0C8D B006              jnz L280
 0C8F                   .dbline 1055
 0C8F           ;       {
 0C8F                   .dbline 1056
 0C8F           ;               CHILD_4_TIMEOUT_Stop();
 0C8F 10                push X
 0C90 7C0000            xcall _CHILD_4_TIMEOUT_Stop
 0C93 20                pop X
 0C94                   .dbline 1057
 0C94           ;       }
 0C94           L280:
 0C94           L279:
 0C94           L277:
 0C94           L275:
 0C94                   .dbline 1059
 0C94           ;       
 0C94           ;       TIMEOUT = 0;                                    // Reset the timeout flag.
 0C94 62D000            mov REG[0xd0],>_TIMEOUT
 0C97 550100            mov [_TIMEOUT+1],0
 0C9A 550000            mov [_TIMEOUT],0
 0C9D                   .dbline 1061
 0C9D           ;       
 0C9D           ;       configToggle(WAIT);                             // Switch back to wait for a master response.
 0C9D 5000              mov A,0
 0C9F 08                push A
 0CA0 5001              mov A,1
 0CA2 08                push A
 0CA3 7C00B4            xcall _configToggle
 0CA6 38FE              add SP,-2
 0CA8                   .dbline 1063
 0CA8           ;       
 0CA8           ;       return child_responded;
 0CA8 62D000            mov REG[0xd0],>__r0
 0CAB 5201              mov A,[X+1]
 0CAD 5300              mov [__r1],A
 0CAF 5200              mov A,[X+0]
 0CB1 5300              mov [__r0],A
 0CB3                   .dbline -2
 0CB3           L259:
 0CB3 38FE              add SP,-2
 0CB5 20                pop X
 0CB6                   .dbline 0 ; func end
 0CB6 7F                ret
 0CB7                   .dbsym l child_responded 0 I
 0CB7                   .dbend
 0CB7                   .dbfunc e servoFinder _servoFinder fV
 0CB7           ;     flashWrite -> X+7
 0CB7           ; status_return_level -> X+6
 0CB7           ; total_attempts -> X+4
 0CB7           ;              j -> X+2
 0CB7           ;              i -> X+0
 0CB7           _servoFinder::
 0CB7                   .dbline -1
 0CB7 10                push X
 0CB8 4F                mov X,SP
 0CB9 3809              add SP,9
 0CBB                   .dbline 1070
 0CBB           ; }
 0CBB           ; 
 0CBB           ; // This function is used to find the servo that is directly connected to this module's controller.
 0CBB           ; // After the servo ID is found, the status return level is changed so that packets are only
 0CBB           ; // returned for the desired status return level defined at the top of this file.
 0CBB           ; void servoFinder(void)
 0CBB           ; {                             
 0CBB                   .dbline 1072
 0CBB           ;       // Index variables for incrementing and checking against the maximum servo comm attempts.
 0CBB           ;       int i = 0;
 0CBB 560100            mov [X+1],0
 0CBE 560000            mov [X+0],0
 0CC1                   .dbline 1073
 0CC1           ;       int j = 0;
 0CC1 560300            mov [X+3],0
 0CC4 560200            mov [X+2],0
 0CC7                   .dbline 1075
 0CC7           ;       
 0CC7           ;       int total_attempts = 0;
 0CC7 560500            mov [X+5],0
 0CCA 560400            mov [X+4],0
 0CCD                   .dbline 1078
 0CCD           ;       
 0CCD           ;       // Integer used as a flag so that EEPROM writes aren't done more than once.
 0CCD           ;       int flashWrite = 0;
 0CCD 560800            mov [X+8],0
 0CD0 560700            mov [X+7],0
 0CD3                   .dbline 1081
 0CD3           ;       
 0CD3           ;       // Create a status return level variable and set it to an out of range value initially.
 0CD3           ;       char status_return_level = 3;
 0CD3 560603            mov [X+6],3
 0CD6                   .dbline 1084
 0CD6           ;       
 0CD6           ;       // Start with a servo ID of 255 (out of valid range).
 0CD6           ;       SERVO_ID = SERVO_START;
 0CD6 62D000            mov REG[0xd0],>_SERVO_ID
 0CD9 5500FF            mov [_SERVO_ID],-1
 0CDC                   .dbline 1093
 0CDC           ; 
 0CDC           ;       // This for loop will loop SERVO_COMM_LOOPS number of times and ping the servo SERVO_COMM_ATTEMPTS
 0CDC           ;       // number of times in each loop (unless stopped short due to early success).  If this fails for the
 0CDC           ;       // first round of pings, a broadcast reset will be performed to reset the servo.  This is done
 0CDC           ;       // because we assume that the baud rate is matching up, but the servo's return delay time is too
 0CDC           ;       // fast for the controller to switch into receive mode to read the response.  The default return
 0CDC           ;       // delay time is 500 microseconds. If we loop for SERVO_COMM_LOOPS number of times and still don't
 0CDC           ;       // see anything, we assume that there is something is too wrong for us to fix.
 0CDC           ;       for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0CDC 560300            mov [X+3],0
 0CDF 560200            mov [X+2],0
 0CE2           L283:
 0CE2                   .dbline 1094
 0CE2           ;       {       
 0CE2                   .dbline 1096
 0CE2           ;               // Ping SERVO_COMM_ATTEMPTS times to try and extract the servo ID.
 0CE2           ;               for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0CE2 560100            mov [X+1],0
 0CE5 560000            mov [X+0],0
 0CE8           L287:
 0CE8                   .dbline 1097
 0CE8           ;               {
 0CE8                   .dbline 1099
 0CE8           ;                       // Send a ping out for any servo connected to me (will only be one).
 0CE8           ;                       servoInstruction(BROADCAST, PING_LENGTH, PING_SERVO, 0, 0);
 0CE8 5000              mov A,0
 0CEA 08                push A
 0CEB 08                push A
 0CEC 5001              mov A,1
 0CEE 08                push A
 0CEF 5002              mov A,2
 0CF1 08                push A
 0CF2 50FE              mov A,-2
 0CF4 08                push A
 0CF5 918E              xcall _servoInstruction
 0CF7 38FB              add SP,-5
 0CF9                   .dbline 1101
 0CF9           ;                       
 0CF9           ;                       total_attempts++;
 0CF9 7705              inc [X+5]
 0CFB 0F0400            adc [X+4],0
 0CFE 804C              xjmp L292
 0D00           L291:
 0D00                   .dbline 1105
 0D00           ;                       
 0D00           ;                       // Wait for either a timeout or a valid servo ID (which will trigger a timeout).
 0D00           ;                       while(!TIMEOUT)
 0D00           ;                       {       
 0D00                   .dbline 1106
 0D00           ;                               if(commandReady())
 0D00 7C02BE            xcall _commandReady
 0D03 62D000            mov REG[0xd0],>__r0
 0D06 3C0000            cmp [__r0],0
 0D09 B006              jnz X54
 0D0B 3C0000            cmp [__r1],0
 0D0E A03C              jz L294
 0D10           X54:
 0D10                   .dbline 1107
 0D10           ;                               {
 0D10                   .dbline 1109
 0D10           ;                                       // If we read a source ID within the range, exit the loop.
 0D10           ;                                       if((COMMAND_SOURCE >= SERVO_ID_MIN) && (COMMAND_SOURCE <= SERVO_ID_MAX))
 0D10 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0D13 3C0000            cmp [_COMMAND_SOURCE],0
 0D16 C02B              jc L296
 0D18           X55:
 0D18 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0D1B 50FD              mov A,-3
 0D1D 3A00              cmp A,[_COMMAND_SOURCE]
 0D1F C022              jc L296
 0D21           X56:
 0D21                   .dbline 1110
 0D21           ;                                       {       
 0D21                   .dbline 1112
 0D21           ;                                               // Exit this while loop by setting the timeout flag.
 0D21           ;                                               TIMEOUT = 1;
 0D21 62D000            mov REG[0xd0],>_TIMEOUT
 0D24 550101            mov [_TIMEOUT+1],1
 0D27 550000            mov [_TIMEOUT],0
 0D2A                   .dbline 1114
 0D2A           ;                                               // Set the servo ID variable to where the ping came from.
 0D2A           ;                                               SERVO_ID = COMMAND_SOURCE;
 0D2A 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0D2D 5100              mov A,[_COMMAND_SOURCE]
 0D2F 62D000            mov REG[0xd0],>_SERVO_ID
 0D32 5300              mov [_SERVO_ID],A
 0D34                   .dbline 1116
 0D34           ;                                               // Set the index variable such that the for loop exits.
 0D34           ;                                               i = SERVO_COMM_ATTEMPTS;
 0D34 56010A            mov [X+1],10
 0D37 560000            mov [X+0],0
 0D3A                   .dbline 1118
 0D3A           ;                                               // Set the outer index variable to 2 to not attempt again for no reason.
 0D3A           ;                                               j = SERVO_COMM_LOOPS;
 0D3A 560302            mov [X+3],2
 0D3D 560200            mov [X+2],0
 0D40                   .dbline 1119
 0D40           ;                                       }
 0D40 800A              xjmp L297
 0D42           L296:
 0D42                   .dbline 1121
 0D42           ;                                       else
 0D42           ;                                       {
 0D42                   .dbline 1123
 0D42           ;                                               // Exit this while loop and try to ping again.
 0D42           ;                                               TIMEOUT = 1;
 0D42 62D000            mov REG[0xd0],>_TIMEOUT
 0D45 550101            mov [_TIMEOUT+1],1
 0D48 550000            mov [_TIMEOUT],0
 0D4B                   .dbline 1124
 0D4B           ;                                       }
 0D4B           L297:
 0D4B                   .dbline 1125
 0D4B           ;                               }
 0D4B           L294:
 0D4B                   .dbline 1126
 0D4B           ;                       }
 0D4B           L292:
 0D4B                   .dbline 1104
 0D4B 62D000            mov REG[0xd0],>_TIMEOUT
 0D4E 3C0000            cmp [_TIMEOUT],0
 0D51 B006              jnz X57
 0D53 3C0100            cmp [_TIMEOUT+1],0
 0D56 AFA9              jz L291
 0D58           X57:
 0D58                   .dbline 1127
 0D58           ;               }
 0D58           L288:
 0D58                   .dbline 1096
 0D58 7701              inc [X+1]
 0D5A 0F0000            adc [X+0],0
 0D5D                   .dbline 1096
 0D5D 5201              mov A,[X+1]
 0D5F 110A              sub A,10
 0D61 5200              mov A,[X+0]
 0D63 3180              xor A,-128
 0D65 1980              sbb A,(0 ^ 0x80)
 0D67 CF80              jc L287
 0D69           X58:
 0D69                   .dbline 1131
 0D69           ;               
 0D69           ;               // If we didn't get a response and haven't written to the flash of the
 0D69           ;               // servo (first time through), send out a broadcast reset.
 0D69           ;               if((SERVO_ID == SERVO_START) && (!flashWrite))
 0D69 62D000            mov REG[0xd0],>_SERVO_ID
 0D6C 3C00FF            cmp [_SERVO_ID],-1
 0D6F B022              jnz L298
 0D71 3D0700            cmp [X+7],0
 0D74 B01D              jnz L298
 0D76 3D0800            cmp [X+8],0
 0D79 B018              jnz L298
 0D7B           X59:
 0D7B                   .dbline 1132
 0D7B           ;               {
 0D7B                   .dbline 1134
 0D7B           ;                       // Set the flash write flag so that we only do this once per power cycle.
 0D7B           ;                       flashWrite = 1;
 0D7B 560801            mov [X+8],1
 0D7E 560700            mov [X+7],0
 0D81                   .dbline 1138
 0D81           ;                       
 0D81           ;                       // Send out a broadcast reset so that we know that the response time interval
 0D81           ;                       // is large enough (default delay time for a servo is 500 microseconds).
 0D81           ;                       servoInstruction(BROADCAST, RESET_LENGTH, RESET_SERVO, 0, 0);
 0D81 5000              mov A,0
 0D83 08                push A
 0D84 08                push A
 0D85 5006              mov A,6
 0D87 08                push A
 0D88 5002              mov A,2
 0D8A 08                push A
 0D8B 50FE              mov A,-2
 0D8D 08                push A
 0D8E 90F5              xcall _servoInstruction
 0D90 38FB              add SP,-5
 0D92                   .dbline 1139
 0D92           ;               }
 0D92           L298:
 0D92                   .dbline 1140
 0D92           ;       }
 0D92           L284:
 0D92                   .dbline 1093
 0D92 7703              inc [X+3]
 0D94 0F0200            adc [X+2],0
 0D97                   .dbline 1093
 0D97 5203              mov A,[X+3]
 0D99 1102              sub A,2
 0D9B 5202              mov A,[X+2]
 0D9D 3180              xor A,-128
 0D9F 1980              sbb A,(0 ^ 0x80)
 0DA1 CF40              jc L283
 0DA3           X60:
 0DA3                   .dbline 1143
 0DA3           ; 
 0DA3           ;       // Reset flash write flag.
 0DA3           ;       flashWrite = 0;
 0DA3 560800            mov [X+8],0
 0DA6 560700            mov [X+7],0
 0DA9                   .dbline 1147
 0DA9           ;       
 0DA9           ;       // If we have a valid servo ID, set the status return level.  If we don't, just skip this
 0DA9           ;       // because all hope is lost.
 0DA9           ;       if(SERVO_ID < BROADCAST)
 0DA9 62D000            mov REG[0xd0],>_SERVO_ID
 0DAC 3C00FE            cmp [_SERVO_ID],-2
 0DAF D0CD              jnc L327
 0DB1           X61:
 0DB1                   .dbline 1148
 0DB1           ;       {
 0DB1                   .dbline 1153
 0DB1           ;               // This for loop will loop SERVO_COMM_LOOPS number of times and poll for the servo's status
 0DB1           ;               // return level SERVO_COMM_ATTEMPTS number of times in each loop (unless stopped short due
 0DB1           ;               // to early success).  If this fails for the first iteration, or we read a status return level
 0DB1           ;               // other than what we want, we will attempt to write the desired status return level onto the servo.
 0DB1           ;               for(j = 0; j < SERVO_COMM_LOOPS; j++)
 0DB1 560300            mov [X+3],0
 0DB4 560200            mov [X+2],0
 0DB7           L302:
 0DB7                   .dbline 1154
 0DB7           ;               {
 0DB7                   .dbline 1156
 0DB7           ;                       // Attempt to read the status return level for the defined number of attempts.
 0DB7           ;                       for(i = 0; i < SERVO_COMM_ATTEMPTS; i++)
 0DB7 560100            mov [X+1],0
 0DBA 560000            mov [X+0],0
 0DBD           L306:
 0DBD                   .dbline 1157
 0DBD           ;                       {
 0DBD                   .dbline 1159
 0DBD           ;                               // Send a request for the servo's status return level.
 0DBD           ;                               servoInstruction(SERVO_ID, READ_LENGTH, READ_SERVO, STATUS_RET_ADDRESS, 1);
 0DBD 5001              mov A,1
 0DBF 08                push A
 0DC0 5010              mov A,16
 0DC2 08                push A
 0DC3 5002              mov A,2
 0DC5 08                push A
 0DC6 5004              mov A,4
 0DC8 08                push A
 0DC9 62D000            mov REG[0xd0],>_SERVO_ID
 0DCC 5100              mov A,[_SERVO_ID]
 0DCE 08                push A
 0DCF 90B4              xcall _servoInstruction
 0DD1 38FB              add SP,-5
 0DD3 8048              xjmp L311
 0DD5           L310:
 0DD5                   .dbline 1163
 0DD5           ;                               
 0DD5           ;                               // Wait for either a timeout or an indication that we want to exit the loop.
 0DD5           ;                               while(!TIMEOUT)
 0DD5           ;                               {
 0DD5                   .dbline 1165
 0DD5           ;                                       // If a valid command is ready, interpret it.
 0DD5           ;                                       if(commandReady())
 0DD5 7C02BE            xcall _commandReady
 0DD8 62D000            mov REG[0xd0],>__r0
 0DDB 3C0000            cmp [__r0],0
 0DDE B006              jnz X62
 0DE0 3C0000            cmp [__r1],0
 0DE3 A038              jz L313
 0DE5           X62:
 0DE5                   .dbline 1166
 0DE5           ;                                       {
 0DE5                   .dbline 1167
 0DE5           ;                                               if(!COMMAND_ERROR)
 0DE5 62D000            mov REG[0xd0],>_COMMAND_ERROR
 0DE8 3C0000            cmp [_COMMAND_ERROR],0
 0DEB B030              jnz L315
 0DED                   .dbline 1168
 0DED           ;                                               {
 0DED                   .dbline 1170
 0DED           ;                                                       // If the return level is equal to what is desired, store it.
 0DED           ;                                                       if(COMMAND_PARAM == STATUS_RET_LEVEL)
 0DED 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0DF0 3C0001            cmp [_COMMAND_PARAM],1
 0DF3 B01F              jnz L317
 0DF5                   .dbline 1171
 0DF5           ;                                                       {
 0DF5                   .dbline 1173
 0DF5           ;                                                               // Set the timeout flag to exit the loop.
 0DF5           ;                                                               TIMEOUT = 1;
 0DF5 62D000            mov REG[0xd0],>_TIMEOUT
 0DF8 550101            mov [_TIMEOUT+1],1
 0DFB 550000            mov [_TIMEOUT],0
 0DFE                   .dbline 1175
 0DFE           ;                                                               // Store the status return level.
 0DFE           ;                                                               status_return_level = COMMAND_PARAM;
 0DFE 62D000            mov REG[0xd0],>_COMMAND_PARAM
 0E01 5100              mov A,[_COMMAND_PARAM]
 0E03 5406              mov [X+6],A
 0E05                   .dbline 1177
 0E05           ;                                                               // Set i so that we exit the for loop.
 0E05           ;                                                               i = SERVO_COMM_ATTEMPTS;
 0E05 56010A            mov [X+1],10
 0E08 560000            mov [X+0],0
 0E0B                   .dbline 1179
 0E0B           ;                                                               // Set the outer loop's variable so that we don't loop again.
 0E0B           ;                                                               j = SERVO_COMM_LOOPS;
 0E0B 560302            mov [X+3],2
 0E0E 560200            mov [X+2],0
 0E11                   .dbline 1180
 0E11           ;                                                       }
 0E11 800A              xjmp L318
 0E13           L317:
 0E13                   .dbline 1182
 0E13           ;                                                       else
 0E13           ;                                                       {       
 0E13                   .dbline 1184
 0E13           ;                                                               // Set the timeout flag to exit the loop.
 0E13           ;                                                               TIMEOUT = 1;
 0E13 62D000            mov REG[0xd0],>_TIMEOUT
 0E16 550101            mov [_TIMEOUT+1],1
 0E19 550000            mov [_TIMEOUT],0
 0E1C                   .dbline 1185
 0E1C           ;                                                       }
 0E1C           L318:
 0E1C                   .dbline 1186
 0E1C           ;                                               }
 0E1C           L315:
 0E1C                   .dbline 1187
 0E1C           ;                                       }
 0E1C           L313:
 0E1C                   .dbline 1188
 0E1C           ;                               }
 0E1C           L311:
 0E1C                   .dbline 1162
 0E1C 62D000            mov REG[0xd0],>_TIMEOUT
 0E1F 3C0000            cmp [_TIMEOUT],0
 0E22 B006              jnz X63
 0E24 3C0100            cmp [_TIMEOUT+1],0
 0E27 AFAD              jz L310
 0E29           X63:
 0E29                   .dbline 1189
 0E29           ;                       }
 0E29           L307:
 0E29                   .dbline 1156
 0E29 7701              inc [X+1]
 0E2B 0F0000            adc [X+0],0
 0E2E                   .dbline 1156
 0E2E 5201              mov A,[X+1]
 0E30 110A              sub A,10
 0E32 5200              mov A,[X+0]
 0E34 3180              xor A,-128
 0E36 1980              sbb A,(0 ^ 0x80)
 0E38 CF84              jc L306
 0E3A           X64:
 0E3A                   .dbline 1193
 0E3A           ;               
 0E3A           ;                       // If we didn't get a good response and haven't written to the flash of the servo,
 0E3A           ;                       // force a change in the status return level with an EEPROM write.
 0E3A           ;                       if((status_return_level != STATUS_RET_LEVEL) && (!flashWrite))
 0E3A 3D0601            cmp [X+6],1
 0E3D A027              jz L319
 0E3F 3D0700            cmp [X+7],0
 0E42 B022              jnz L319
 0E44 3D0800            cmp [X+8],0
 0E47 B01D              jnz L319
 0E49           X65:
 0E49                   .dbline 1194
 0E49           ;                       {       
 0E49                   .dbline 1195
 0E49           ;                               flashWrite = 1;
 0E49 560801            mov [X+8],1
 0E4C 560700            mov [X+7],0
 0E4F                   .dbline 1198
 0E4F           ;                               
 0E4F           ;                               // Try to force the return status to what we want.
 0E4F           ;                               servoInstruction(SERVO_ID, WRITE_LENGTH, WRITE_SERVO, STATUS_RET_ADDRESS, STATUS_RET_LEVEL);
 0E4F 5001              mov A,1
 0E51 08                push A
 0E52 5010              mov A,16
 0E54 08                push A
 0E55 5003              mov A,3
 0E57 08                push A
 0E58 5004              mov A,4
 0E5A 08                push A
 0E5B 62D000            mov REG[0xd0],>_SERVO_ID
 0E5E 5100              mov A,[_SERVO_ID]
 0E60 08                push A
 0E61 9022              xcall _servoInstruction
 0E63 38FB              add SP,-5
 0E65                   .dbline 1199
 0E65           ;                       }
 0E65           L319:
 0E65                   .dbline 1200
 0E65           ;               }
 0E65           L303:
 0E65                   .dbline 1153
 0E65 7703              inc [X+3]
 0E67 0F0200            adc [X+2],0
 0E6A                   .dbline 1153
 0E6A 5203              mov A,[X+3]
 0E6C 1102              sub A,2
 0E6E 5202              mov A,[X+2]
 0E70 3180              xor A,-128
 0E72 1980              sbb A,(0 ^ 0x80)
 0E74 CF42              jc L302
 0E76           X66:
 0E76                   .dbline 1202
 0E76           ;               
 0E76           ;               if(status_return_level != STATUS_RET_LEVEL)
 0E76 3D0601            cmp [X+6],1
 0E79 A005              jz L301
 0E7B                   .dbline 1203
 0E7B           ;               {
 0E7B           L323:
 0E7B                   .dbline 1205
 0E7B           ;                       // Break on purpose to show that the status return is not correct.
 0E7B           ;                       while(1) { }
 0E7B                   .dbline 1205
 0E7B           L324:
 0E7B                   .dbline 1205
 0E7B 8FFF              xjmp L323
 0E7D           L326:
 0E7D                   .dbline 1211
 0E7D           ;               }
 0E7D           ;       }
 0E7D           ;       else
 0E7D           ;       {
 0E7D           ;               // Purposely break the module to show that we did not resolve the communication with our servo.
 0E7D           ;               while(1) { }
 0E7D                   .dbline 1211
 0E7D           L327:
 0E7D                   .dbline 1211
 0E7D 8FFF              xjmp L326
 0E7F           L301:
 0E7F                   .dbline 1215
 0E7F           ;       }
 0E7F           ;       
 0E7F           ;       // Wait for the other controllers to find their servos.
 0E7F           ;       servoConfigWait();
 0E7F 9155              xcall _servoConfigWait
 0E81                   .dbline -2
 0E81           L282:
 0E81 38F7              add SP,-9
 0E83 20                pop X
 0E84                   .dbline 0 ; func end
 0E84 7F                ret
 0E85                   .dbsym l flashWrite 7 I
 0E85                   .dbsym l status_return_level 6 c
 0E85                   .dbsym l total_attempts 4 I
 0E85                   .dbsym l j 2 I
 0E85                   .dbsym l i 0 I
 0E85                   .dbend
 0E85                   .dbfunc e servoInstruction _servoInstruction fV
 0E85           ;       checksum -> X+0
 0E85           ;          value -> X-8
 0E85           ;        address -> X-7
 0E85           ;    instruction -> X-6
 0E85           ;         length -> X-5
 0E85           ;             id -> X-4
 0E85           _servoInstruction::
 0E85                   .dbline -1
 0E85 10                push X
 0E86 4F                mov X,SP
 0E87 3801              add SP,1
 0E89                   .dbline 1221
 0E89           ; }
 0E89           ; 
 0E89           ; // This function receives a destination, command length, instruction type, address, and value.
 0E89           ; // With these parameters, the function sends a packet to the communication bus.
 0E89           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 0E89           ; {
 0E89                   .dbline 1225
 0E89           ;       char checksum;
 0E89           ;       
 0E89           ;       // Toggle into transmit mode.
 0E89           ;       configToggle(SERVO_COMM);
 0E89 5000              mov A,0
 0E8B 08                push A
 0E8C 5009              mov A,9
 0E8E 08                push A
 0E8F 7C00B4            xcall _configToggle
 0E92 38FE              add SP,-2
 0E94                   .dbline 1228
 0E94           ;       
 0E94           ;       // Calculate the checksum value for our servo communication.
 0E94           ;       checksum = 255-((id + length + instruction + address + value)%256);
 0E94 62D000            mov REG[0xd0],>__r0
 0E97 52FB              mov A,[X-5]
 0E99 5300              mov [__r1],A
 0E9B 550000            mov [__r0],0
 0E9E 52FC              mov A,[X-4]
 0EA0 0200              add A,[__r1]
 0EA2 5300              mov [__r1],A
 0EA4 5000              mov A,0
 0EA6 0A00              adc A,[__r0]
 0EA8 5300              mov [__r0],A
 0EAA 52FA              mov A,[X-6]
 0EAC 0400              add [__r1],A
 0EAE 0E0000            adc [__r0],0
 0EB1 52F9              mov A,[X-7]
 0EB3 0400              add [__r1],A
 0EB5 0E0000            adc [__r0],0
 0EB8 52F8              mov A,[X-8]
 0EBA 0400              add [__r1],A
 0EBC 0E0000            adc [__r0],0
 0EBF 5001              mov A,1
 0EC1 08                push A
 0EC2 5000              mov A,0
 0EC4 08                push A
 0EC5 5100              mov A,[__r0]
 0EC7 08                push A
 0EC8 5100              mov A,[__r1]
 0ECA 08                push A
 0ECB 7C0000            xcall __divmod_16X16_16
 0ECE 38FE              add SP,-2
 0ED0 18                pop A
 0ED1 5300              mov [__r1],A
 0ED3 18                pop A
 0ED4 50FF              mov A,-1
 0ED6 1200              sub A,[__r1]
 0ED8 5400              mov [X+0],A
 0EDA                   .dbline 1231
 0EDA           ;       
 0EDA           ;       // Talk to the servo.
 0EDA           ;       if(instruction == PING_SERVO)
 0EDA 3DFA01            cmp [X-6],1
 0EDD B02D              jnz L330
 0EDF                   .dbline 1232
 0EDF           ;       {
 0EDF                   .dbline 1233
 0EDF           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte one
 0EDF 10                push X
 0EE0 50FF              mov A,-1
 0EE2 7C0000            xcall _SERVO_TX_PutChar
 0EE5 20                pop X
 0EE6                   .dbline 1234
 0EE6           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte two
 0EE6 10                push X
 0EE7 50FF              mov A,-1
 0EE9 7C0000            xcall _SERVO_TX_PutChar
 0EEC 20                pop X
 0EED                   .dbline 1235
 0EED           ;               SERVO_TX_PutChar(id);                   // Servo ID
 0EED 10                push X
 0EEE 52FC              mov A,[X-4]
 0EF0 7C0000            xcall _SERVO_TX_PutChar
 0EF3 20                pop X
 0EF4                   .dbline 1236
 0EF4           ;               SERVO_TX_PutChar(length);               // The instruction length.
 0EF4 10                push X
 0EF5 52FB              mov A,[X-5]
 0EF7 7C0000            xcall _SERVO_TX_PutChar
 0EFA 20                pop X
 0EFB                   .dbline 1237
 0EFB           ;               SERVO_TX_PutChar(instruction);  // The instruction to carry out.
 0EFB 10                push X
 0EFC 52FA              mov A,[X-6]
 0EFE 7C0000            xcall _SERVO_TX_PutChar
 0F01 20                pop X
 0F02                   .dbline 1238
 0F02           ;               SERVO_TX_PutChar(checksum);             // This is the checksum.
 0F02 10                push X
 0F03 5200              mov A,[X+0]
 0F05 7C0000            xcall _SERVO_TX_PutChar
 0F08 20                pop X
 0F09                   .dbline 1239
 0F09           ;       }
 0F09 8039              xjmp L333
 0F0B           L330:
 0F0B                   .dbline 1241
 0F0B           ;       else
 0F0B           ;       {
 0F0B                   .dbline 1242
 0F0B           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte one
 0F0B 10                push X
 0F0C 50FF              mov A,-1
 0F0E 7C0000            xcall _SERVO_TX_PutChar
 0F11 20                pop X
 0F12                   .dbline 1243
 0F12           ;               SERVO_TX_PutChar(SERVO_START);  // Start byte two
 0F12 10                push X
 0F13 50FF              mov A,-1
 0F15 7C0000            xcall _SERVO_TX_PutChar
 0F18 20                pop X
 0F19                   .dbline 1244
 0F19           ;               SERVO_TX_PutChar(id);                   // Servo ID
 0F19 10                push X
 0F1A 52FC              mov A,[X-4]
 0F1C 7C0000            xcall _SERVO_TX_PutChar
 0F1F 20                pop X
 0F20                   .dbline 1245
 0F20           ;               SERVO_TX_PutChar(length);               // The instruction length.
 0F20 10                push X
 0F21 52FB              mov A,[X-5]
 0F23 7C0000            xcall _SERVO_TX_PutChar
 0F26 20                pop X
 0F27                   .dbline 1246
 0F27           ;               SERVO_TX_PutChar(instruction);  // The instruction to carry out.
 0F27 10                push X
 0F28 52FA              mov A,[X-6]
 0F2A 7C0000            xcall _SERVO_TX_PutChar
 0F2D 20                pop X
 0F2E                   .dbline 1247
 0F2E           ;               SERVO_TX_PutChar(address);              // The address to read/write from/to.
 0F2E 10                push X
 0F2F 52F9              mov A,[X-7]
 0F31 7C0000            xcall _SERVO_TX_PutChar
 0F34 20                pop X
 0F35                   .dbline 1248
 0F35           ;               SERVO_TX_PutChar(value);                // The value to write or number of bytes to read.
 0F35 10                push X
 0F36 52F8              mov A,[X-8]
 0F38 7C0000            xcall _SERVO_TX_PutChar
 0F3B 20                pop X
 0F3C                   .dbline 1249
 0F3C           ;               SERVO_TX_PutChar(checksum);             // This is the checksum.
 0F3C 10                push X
 0F3D 5200              mov A,[X+0]
 0F3F 7C0000            xcall _SERVO_TX_PutChar
 0F42 20                pop X
 0F43                   .dbline 1250
 0F43           ;       }
 0F43           L332:
 0F43                   .dbline 1253
 0F43           ;       
 0F43           ;       // Wait for the transmission to finish.
 0F43           ;       while(!(SERVO_TX_bReadTxStatus() & SERVO_TX_TX_COMPLETE));
 0F43           L333:
 0F43                   .dbline 1253
 0F43 10                push X
 0F44 7C0000            xcall _SERVO_TX_bReadTxStatus
 0F47 62D000            mov REG[0xd0],>__r0
 0F4A 20                pop X
 0F4B 5300              mov [__r0],A
 0F4D 470020            tst [__r0],32
 0F50 AFF2              jz L332
 0F52                   .dbline 1256
 0F52           ;       
 0F52           ;       // Make completely sure we're done.
 0F52           ;       xmitWait();
 0F52 900F              xcall _xmitWait
 0F54                   .dbline 1259
 0F54           ;       
 0F54           ;       // Switch back to wait for a servo response.
 0F54           ;       configToggle(INITIALIZE);
 0F54 5000              mov A,0
 0F56 08                push A
 0F57 5008              mov A,8
 0F59 08                push A
 0F5A 7C00B4            xcall _configToggle
 0F5D 38FE              add SP,-2
 0F5F                   .dbline -2
 0F5F           L329:
 0F5F 38FF              add SP,-1
 0F61 20                pop X
 0F62                   .dbline 0 ; func end
 0F62 7F                ret
 0F63                   .dbsym l checksum 0 c
 0F63                   .dbsym l value -8 c
 0F63                   .dbsym l address -7 c
 0F63                   .dbsym l instruction -6 c
 0F63                   .dbsym l length -5 c
 0F63                   .dbsym l id -4 c
 0F63                   .dbend
 0F63                   .dbfunc e xmitWait _xmitWait fV
 0F63           ;              i -> X+0
 0F63           _xmitWait::
 0F63                   .dbline -1
 0F63 10                push X
 0F64 4F                mov X,SP
 0F65 3802              add SP,2
 0F67                   .dbline 1263
 0F67           ; }
 0F67           ; 
 0F67           ; void xmitWait(void)
 0F67           ; {
 0F67                   .dbline 1266
 0F67           ;       int i;
 0F67           ;       
 0F67           ;       for(i = 0; i < 25; i++)
 0F67 560100            mov [X+1],0
 0F6A 560000            mov [X+0],0
 0F6D           L336:
 0F6D                   .dbline 1267
 0F6D           ;       {
 0F6D                   .dbline 1269
 0F6D           ;               // Does nothing and wastes approximately 50 microseconds.
 0F6D           ;       }
 0F6D           L337:
 0F6D                   .dbline 1266
 0F6D 7701              inc [X+1]
 0F6F 0F0000            adc [X+0],0
 0F72                   .dbline 1266
 0F72 5201              mov A,[X+1]
 0F74 1119              sub A,25
 0F76 5200              mov A,[X+0]
 0F78 3180              xor A,-128
 0F7A 1980              sbb A,(0 ^ 0x80)
 0F7C CFF0              jc L336
 0F7E           X67:
 0F7E                   .dbline -2
 0F7E           L335:
 0F7E 38FE              add SP,-2
 0F80 20                pop X
 0F81                   .dbline 0 ; func end
 0F81 7F                ret
 0F82                   .dbsym l i 0 I
 0F82                   .dbend
 0F82                   .dbfunc e servoBootWait _servoBootWait fV
 0F82           ;              i -> X+0
 0F82           _servoBootWait::
 0F82                   .dbline -1
 0F82 10                push X
 0F83 4F                mov X,SP
 0F84 3802              add SP,2
 0F86                   .dbline 1276
 0F86           ; }
 0F86           ; 
 0F86           ; // This function wastes time while the servo that is attached to this controller boots up.
 0F86           ; // Once that happens, communications should happen quickly and reliably.  The estimated boot
 0F86           ; // time in testing was approximately 120 ms.
 0F86           ; void servoBootWait(void)
 0F86           ; {
 0F86                   .dbline 1277
 0F86           ;       int i = 0;                                      // Index integer used for looping.
 0F86 560100            mov [X+1],0
 0F89 560000            mov [X+0],0
 0F8C                   .dbline 1279
 0F8C           ; 
 0F8C           ;       configToggle(INITIALIZE);       // Switch to initialize mode to do this timeout routine.
 0F8C 5000              mov A,0
 0F8E 08                push A
 0F8F 5008              mov A,8
 0F91 08                push A
 0F92 7C00B4            xcall _configToggle
 0F95 38FE              add SP,-2
 0F97                   .dbline 1282
 0F97           ;       
 0F97           ;       // Loop and wait for enough timeouts to happen before we talk to the servo.
 0F97           ;       for(i = 0; i < SERVO_BOOT_TIMEOUTS; i++)
 0F97 560100            mov [X+1],0
 0F9A 560000            mov [X+0],0
 0F9D                   .dbline 1283
 0F9D           ;       {
 0F9D           L345:
 0F9D                   .dbline 1284
 0F9D           ;               while(!TIMEOUT) { }             // Do nothing while we wait for one timeout period.
 0F9D                   .dbline 1284
 0F9D           L346:
 0F9D                   .dbline 1284
 0F9D 62D000            mov REG[0xd0],>_TIMEOUT
 0FA0 3C0000            cmp [_TIMEOUT],0
 0FA3 B006              jnz X68
 0FA5 3C0100            cmp [_TIMEOUT+1],0
 0FA8 AFF4              jz L345
 0FAA           X68:
 0FAA                   .dbline 1285
 0FAA           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 0FAA 62D000            mov REG[0xd0],>_TIMEOUT
 0FAD 550100            mov [_TIMEOUT+1],0
 0FB0 550000            mov [_TIMEOUT],0
 0FB3                   .dbline 1286
 0FB3           ;       }
 0FB3           L342:
 0FB3                   .dbline 1282
 0FB3 7701              inc [X+1]
 0FB5 0F0000            adc [X+0],0
 0FB8                   .dbline 1282
 0FB8 5201              mov A,[X+1]
 0FBA 114B              sub A,75
 0FBC 5200              mov A,[X+0]
 0FBE 3180              xor A,-128
 0FC0 1980              sbb A,(0 ^ 0x80)
 0FC2 CFDA              jc L346
 0FC4           X69:
 0FC4                   .dbline 1288
 0FC4           ;       
 0FC4           ;       INIT_TIMEOUT_Stop();            // Stop the timeout timer.
 0FC4 10                push X
 0FC5 7C0000            xcall _INIT_TIMEOUT_Stop
 0FC8 20                pop X
 0FC9                   .dbline 1289
 0FC9           ;       TIMEOUT = 0;                            // Clear the timeout flag.
 0FC9 62D000            mov REG[0xd0],>_TIMEOUT
 0FCC 550100            mov [_TIMEOUT+1],0
 0FCF 550000            mov [_TIMEOUT],0
 0FD2                   .dbline -2
 0FD2           L340:
 0FD2 38FE              add SP,-2
 0FD4 20                pop X
 0FD5                   .dbline 0 ; func end
 0FD5 7F                ret
 0FD6                   .dbsym l i 0 I
 0FD6                   .dbend
 0FD6                   .dbfunc e servoConfigWait _servoConfigWait fV
 0FD6           ;              i -> X+0
 0FD6           _servoConfigWait::
 0FD6                   .dbline -1
 0FD6 10                push X
 0FD7 4F                mov X,SP
 0FD8 3802              add SP,2
 0FDA                   .dbline 1295
 0FDA           ; }
 0FDA           ; 
 0FDA           ; // Sits and spins for the amount of time it takes for a worst case scenario for setup time
 0FDA           ; // to take place.  This allows all other modules to initialize.
 0FDA           ; void servoConfigWait(void)
 0FDA           ; {
 0FDA                   .dbline 1296
 0FDA           ;       int i = 0;                                      // Index integer for looping purposes.
 0FDA 560100            mov [X+1],0
 0FDD 560000            mov [X+0],0
 0FE0                   .dbline 1298
 0FE0           ;       
 0FE0           ;       configToggle(INITIALIZE);       // Switch to initialize mode to do this timeout routine.
 0FE0 5000              mov A,0
 0FE2 08                push A
 0FE3 5008              mov A,8
 0FE5 08                push A
 0FE6 7C00B4            xcall _configToggle
 0FE9 38FE              add SP,-2
 0FEB                   .dbline 1303
 0FEB           ;       
 0FEB           ;       // For SERVO_COMM_ATTEMPTS*SERVO_COMM_LOOPS cycles, let the other controllers find
 0FEB           ;       // their servos.  The reason we loop this many times is to allow for a possible worst
 0FEB           ;       // case scenario of setup time to complete.
 0FEB           ;       for(i = 0; i < (SERVO_COMM_ATTEMPTS*SERVO_COMM_LOOPS); i++)
 0FEB 560100            mov [X+1],0
 0FEE 560000            mov [X+0],0
 0FF1                   .dbline 1304
 0FF1           ;       {
 0FF1           L353:
 0FF1                   .dbline 1305
 0FF1           ;               while(!TIMEOUT) { }             // Do nothing while we wait for one timeout period.
 0FF1                   .dbline 1305
 0FF1           L354:
 0FF1                   .dbline 1305
 0FF1 62D000            mov REG[0xd0],>_TIMEOUT
 0FF4 3C0000            cmp [_TIMEOUT],0
 0FF7 B006              jnz X70
 0FF9 3C0100            cmp [_TIMEOUT+1],0
 0FFC AFF4              jz L353
 0FFE           X70:
 0FFE                   .dbline 1306
 0FFE           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 0FFE 62D000            mov REG[0xd0],>_TIMEOUT
 1001 550100            mov [_TIMEOUT+1],0
 1004 550000            mov [_TIMEOUT],0
 1007                   .dbline 1307
 1007           ;       }
 1007           L350:
 1007                   .dbline 1303
 1007 7701              inc [X+1]
 1009 0F0000            adc [X+0],0
 100C                   .dbline 1303
 100C 5201              mov A,[X+1]
 100E 1114              sub A,20
 1010 5200              mov A,[X+0]
 1012 3180              xor A,-128
 1014 1980              sbb A,(0 ^ 0x80)
 1016 CFDA              jc L354
 1018           X71:
 1018                   .dbline 1309
 1018           ;       
 1018           ;       INIT_TIMEOUT_Stop();            // Stop the timer.
 1018 10                push X
 1019 7C0000            xcall _INIT_TIMEOUT_Stop
 101C 20                pop X
 101D                   .dbline 1310
 101D           ;       TIMEOUT = 0;                            // Reset the timeout flag.
 101D 62D000            mov REG[0xd0],>_TIMEOUT
 1020 550100            mov [_TIMEOUT+1],0
 1023 550000            mov [_TIMEOUT],0
 1026                   .dbline 1312
 1026           ; 
 1026           ;       configToggle(WAIT);                     // Switch to wait for the master node to speak to you.
 1026 5000              mov A,0
 1028 08                push A
 1029 5001              mov A,1
 102B 08                push A
 102C 7C00B4            xcall _configToggle
 102F 38FE              add SP,-2
 1031                   .dbline -2
 1031           L348:
 1031 38FE              add SP,-2
 1033 20                pop X
 1034                   .dbline 0 ; func end
 1034 7F                ret
 1035                   .dbsym l i 0 I
 1035                   .dbend
 1035                   .dbfunc e TX_01234_TIMEOUT_ISR _TX_01234_TIMEOUT_ISR fV
 1035           _TX_01234_TIMEOUT_ISR::
 1035                   .dbline -1
 1035 71C0              or F,-64
 1037 08                push A
 1038 5DD0              mov A,REG[0xd0]
 103A 08                push A
 103B                   .dbline 1320
 103B           ; }
 103B           ; 
 103B           ; // This timeout ISR is for waiting before a transmission is made from this module.
 103B           ; // This is to give all the other modules a chance to set up and clear their buffers.
 103B           ; // It is currently set so that there is 1 ms of down time between the last transmission
 103B           ; // and this module's transmission.
 103B           ; void TX_01234_TIMEOUT_ISR(void)
 103B           ; {
 103B                   .dbline 1321
 103B           ;       TIMEOUT = 1;    // Set the timeout flag.
 103B 62D000            mov REG[0xd0],>_TIMEOUT
 103E 550101            mov [_TIMEOUT+1],1
 1041 550000            mov [_TIMEOUT],0
 1044                   .dbline 1322
 1044           ;       M8C_ClearIntFlag(INT_CLR0,TX_01234_TIMEOUT_INT_MASK);
 1044 62DAFD            mov REG[0xda],-3
 1047                   .dbline -2
 1047           L356:
 1047 18                pop A
 1048 60D0              mov REG[208],A
 104A 18                pop A
 104B                   .dbline 0 ; func end
 104B 7E                reti
 104C                   .dbend
 104C                   .dbfunc e HELLO_TIMEOUT_ISR _HELLO_TIMEOUT_ISR fV
 104C           _HELLO_TIMEOUT_ISR::
 104C                   .dbline -1
 104C 71C0              or F,-64
 104E 08                push A
 104F 5DD0              mov A,REG[0xd0]
 1051 08                push A
 1052                   .dbline 1327
 1052           ; }
 1052           ; 
 1052           ; // This is the ISR for a hello response timeout.
 1052           ; void HELLO_TIMEOUT_ISR(void)
 1052           ; {
 1052                   .dbline 1328
 1052           ;       TIMEOUT = 1;    // Set the timeout flag.
 1052 62D000            mov REG[0xd0],>_TIMEOUT
 1055 550101            mov [_TIMEOUT+1],1
 1058 550000            mov [_TIMEOUT],0
 105B                   .dbline 1329
 105B           ;       M8C_ClearIntFlag(INT_CLR0,HELLO_TIMEOUT_INT_MASK);
 105B 62DAFD            mov REG[0xda],-3
 105E                   .dbline -2
 105E           L357:
 105E 18                pop A
 105F 60D0              mov REG[208],A
 1061 18                pop A
 1062                   .dbline 0 ; func end
 1062 7E                reti
 1063                   .dbend
 1063                   .dbfunc e CHILD_1_TIMEOUT_ISR _CHILD_1_TIMEOUT_ISR fV
 1063           _CHILD_1_TIMEOUT_ISR::
 1063                   .dbline -1
 1063 71C0              or F,-64
 1065 08                push A
 1066 5DD0              mov A,REG[0xd0]
 1068 08                push A
 1069                   .dbline 1334
 1069           ; }
 1069           ; 
 1069           ; // These remaining ISRs are for all the child timeout scenarios.
 1069           ; void CHILD_1_TIMEOUT_ISR(void)
 1069           ; {
 1069                   .dbline 1335
 1069           ;       TIMEOUT = 1;    // Set the timeout flag.
 1069 62D000            mov REG[0xd0],>_TIMEOUT
 106C 550101            mov [_TIMEOUT+1],1
 106F 550000            mov [_TIMEOUT],0
 1072                   .dbline 1336
 1072           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_1_TIMEOUT_INT_MASK);
 1072 62DAFD            mov REG[0xda],-3
 1075                   .dbline -2
 1075           L358:
 1075 18                pop A
 1076 60D0              mov REG[208],A
 1078 18                pop A
 1079                   .dbline 0 ; func end
 1079 7E                reti
 107A                   .dbend
 107A                   .dbfunc e CHILD_2_TIMEOUT_ISR _CHILD_2_TIMEOUT_ISR fV
 107A           _CHILD_2_TIMEOUT_ISR::
 107A                   .dbline -1
 107A 71C0              or F,-64
 107C 08                push A
 107D 5DD0              mov A,REG[0xd0]
 107F 08                push A
 1080                   .dbline 1340
 1080           ; }
 1080           ; 
 1080           ; void CHILD_2_TIMEOUT_ISR(void)
 1080           ; {
 1080                   .dbline 1341
 1080           ;       TIMEOUT = 1;    // Set the timeout flag.
 1080 62D000            mov REG[0xd0],>_TIMEOUT
 1083 550101            mov [_TIMEOUT+1],1
 1086 550000            mov [_TIMEOUT],0
 1089                   .dbline 1342
 1089           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_2_TIMEOUT_INT_MASK);
 1089 62DAFD            mov REG[0xda],-3
 108C                   .dbline -2
 108C           L359:
 108C 18                pop A
 108D 60D0              mov REG[208],A
 108F 18                pop A
 1090                   .dbline 0 ; func end
 1090 7E                reti
 1091                   .dbend
 1091                   .dbfunc e CHILD_3_TIMEOUT_ISR _CHILD_3_TIMEOUT_ISR fV
 1091           _CHILD_3_TIMEOUT_ISR::
 1091                   .dbline -1
 1091 71C0              or F,-64
 1093 08                push A
 1094 5DD0              mov A,REG[0xd0]
 1096 08                push A
 1097                   .dbline 1346
 1097           ; }
 1097           ; 
 1097           ; void CHILD_3_TIMEOUT_ISR(void)
 1097           ; {
 1097                   .dbline 1347
 1097           ;       TIMEOUT = 1;    // Set the timeout flag.
 1097 62D000            mov REG[0xd0],>_TIMEOUT
 109A 550101            mov [_TIMEOUT+1],1
 109D 550000            mov [_TIMEOUT],0
 10A0                   .dbline 1348
 10A0           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_3_TIMEOUT_INT_MASK);
 10A0 62DAFD            mov REG[0xda],-3
 10A3                   .dbline -2
 10A3           L360:
 10A3 18                pop A
 10A4 60D0              mov REG[208],A
 10A6 18                pop A
 10A7                   .dbline 0 ; func end
 10A7 7E                reti
 10A8                   .dbend
 10A8                   .dbfunc e CHILD_4_TIMEOUT_ISR _CHILD_4_TIMEOUT_ISR fV
 10A8           _CHILD_4_TIMEOUT_ISR::
 10A8                   .dbline -1
 10A8 71C0              or F,-64
 10AA 08                push A
 10AB 5DD0              mov A,REG[0xd0]
 10AD 08                push A
 10AE                   .dbline 1352
 10AE           ; }
 10AE           ; 
 10AE           ; void CHILD_4_TIMEOUT_ISR(void)
 10AE           ; {
 10AE                   .dbline 1353
 10AE           ;       TIMEOUT = 1;    // Set the timeout flag.
 10AE 62D000            mov REG[0xd0],>_TIMEOUT
 10B1 550101            mov [_TIMEOUT+1],1
 10B4 550000            mov [_TIMEOUT],0
 10B7                   .dbline 1354
 10B7           ;       M8C_ClearIntFlag(INT_CLR0,CHILD_4_TIMEOUT_INT_MASK);
 10B7 62DAFD            mov REG[0xda],-3
 10BA                   .dbline -2
 10BA           L361:
 10BA 18                pop A
 10BB 60D0              mov REG[208],A
 10BD 18                pop A
 10BE                   .dbline 0 ; func end
 10BE 7E                reti
 10BF                   .dbend
 10BF                   .dbfunc e INIT_TIMEOUT_ISR _INIT_TIMEOUT_ISR fV
 10BF           _INIT_TIMEOUT_ISR::
 10BF                   .dbline -1
 10BF 71C0              or F,-64
 10C1 08                push A
 10C2 5DD0              mov A,REG[0xd0]
 10C4 08                push A
 10C5                   .dbline 1358
 10C5           ; }
 10C5           ; 
 10C5           ; void INIT_TIMEOUT_ISR(void)
 10C5           ; {
 10C5                   .dbline 1359
 10C5           ;       TIMEOUT = 1;    // Set the timeout flag.
 10C5 62D000            mov REG[0xd0],>_TIMEOUT
 10C8 550101            mov [_TIMEOUT+1],1
 10CB 550000            mov [_TIMEOUT],0
 10CE                   .dbline 1360
 10CE           ;       M8C_ClearIntFlag(INT_CLR0,INIT_TIMEOUT_INT_MASK);
 10CE 62DAFD            mov REG[0xda],-3
 10D1                   .dbline -2
 10D1           L362:
 10D1 18                pop A
 10D2 60D0              mov REG[208],A
 10D4 18                pop A
 10D5                   .dbline 0 ; func end
 10D5 7E                reti
 10D6                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _SERVO_ID::
 0000 00                .byte 0
 0001                   .dbsym e SERVO_ID _SERVO_ID c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_ERROR::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_ERROR _COMMAND_ERROR c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_LENGTH::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_LENGTH _COMMAND_LENGTH c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_PARAM::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_PARAM _COMMAND_PARAM c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _CONFIGURED::
 0000 0000              .byte 0,0
 0002                   .dbsym e CONFIGURED _CONFIGURED I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _ID::
 0000 00                .byte 0
 0001                   .dbsym e ID _ID c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\THESIS~2\THESIS~1\main.c
 0000           _CHILD::
 0000 00                .byte 0
 0001                   .dbsym e CHILD _CHILD c
